var entry;entry =
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpClientConfiguration": () => /* binding */ HttpClientConfiguration
/* harmony export */ });
/* harmony import */ var _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./retry-interceptor.js */ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js");

/**
 * A class for configuring HttpClients.
 */
class HttpClientConfiguration {
    constructor() {
        /**
         * The base URL to be prepended to each Request's url before sending.
         */
        this.baseUrl = '';
        /**
         * Default values to apply to init objects when creating Requests. Note that
         * defaults cannot be applied when Request objects are manually created because
         * Request provides its own defaults and discards the original init object.
         * See also https://developer.mozilla.org/en-US/docs/Web/API/Request/Request
         */
        this.defaults = {};
        /**
         * Interceptors to be added to the HttpClient.
         */
        this.interceptors = [];
        this.dispatcher = null;
    }
    /**
     * Sets the baseUrl.
     *
     * @param baseUrl - The base URL.
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    withBaseUrl(baseUrl) {
        this.baseUrl = baseUrl;
        return this;
    }
    /**
     * Sets the defaults.
     *
     * @param defaults - The defaults.
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    withDefaults(defaults) {
        this.defaults = defaults;
        return this;
    }
    /**
     * Adds an interceptor to be run on all requests or responses.
     *
     * @param interceptor - An object with request, requestError,
     * response, or responseError methods. request and requestError act as
     * resolve and reject handlers for the Request before it is sent.
     * response and responseError act as resolve and reject handlers for
     * the Response after it has been received.
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    withInterceptor(interceptor) {
        this.interceptors.push(interceptor);
        return this;
    }
    /**
     * Applies a configuration that addresses common application needs, including
     * configuring same-origin credentials, and using rejectErrorResponses.
     *
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    useStandardConfiguration() {
        const standardConfig = { credentials: 'same-origin' };
        Object.assign(this.defaults, standardConfig, this.defaults);
        return this.rejectErrorResponses();
    }
    /**
     * Causes Responses whose status codes fall outside the range 200-299 to reject.
     * The fetch API only rejects on network errors or other conditions that prevent
     * the request from completing, meaning consumers must inspect Response.ok in the
     * Promise continuation to determine if the server responded with a success code.
     * This method adds a response interceptor that causes Responses with error codes
     * to be rejected, which is common behavior in HTTP client libraries.
     *
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    rejectErrorResponses() {
        return this.withInterceptor({ response: rejectOnError });
    }
    withRetry(config) {
        const interceptor = new _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_0__.RetryInterceptor(config);
        return this.withInterceptor(interceptor);
    }
    withDispatcher(dispatcher) {
        this.dispatcher = dispatcher;
        return this;
    }
}
function rejectOnError(response) {
    if (!response.ok) {
        throw response;
    }
    return response;
}
//# sourceMappingURL=http-client-configuration.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/http-client.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/http-client.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IHttpClient": () => /* binding */ IHttpClient,
/* harmony export */   "HttpClient": () => /* binding */ HttpClient
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http-client-configuration.js */ "./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js");
/* harmony import */ var _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retry-interceptor.js */ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js");



const absoluteUrlRegexp = /^([a-z][a-z0-9+\-.]*:)?\/\//i;
const IHttpClient = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IHttpClient', x => x.singleton(HttpClient));
/**
 * An HTTP client based on the Fetch API.
 */
class HttpClient {
    /**
     * Creates an instance of HttpClient.
     */
    constructor() {
        this.dispatcher = null;
        this.activeRequestCount = 0;
        this.isRequesting = false;
        this.isConfigured = false;
        this.baseUrl = '';
        this.defaults = null;
        this.interceptors = [];
    }
    /**
     * Configure this client with default settings to be used by all requests.
     *
     * @param config - A configuration object, or a function that takes a config
     * object and configures it.
     * @returns The chainable instance of this HttpClient.
     * @chainable
     */
    configure(config) {
        let normalizedConfig;
        if (typeof config === 'object') {
            const requestInitConfiguration = { defaults: config };
            normalizedConfig = requestInitConfiguration;
        }
        else if (typeof config === 'function') {
            normalizedConfig = new _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_1__.HttpClientConfiguration();
            normalizedConfig.baseUrl = this.baseUrl;
            normalizedConfig.defaults = { ...this.defaults };
            normalizedConfig.interceptors = this.interceptors;
            normalizedConfig.dispatcher = this.dispatcher;
            const c = config(normalizedConfig);
            if (Object.prototype.isPrototypeOf.call(_http_client_configuration_js__WEBPACK_IMPORTED_MODULE_1__.HttpClientConfiguration.prototype, c)) {
                normalizedConfig = c;
            }
        }
        else {
            throw new Error('invalid config');
        }
        const defaults = normalizedConfig.defaults;
        if (defaults !== undefined && Object.prototype.isPrototypeOf.call(Headers.prototype, defaults.headers)) {
            // Headers instances are not iterable in all browsers. Require a plain
            // object here to allow default headers to be merged into request headers.
            throw new Error('Default headers must be a plain object.');
        }
        const interceptors = normalizedConfig.interceptors;
        if (interceptors !== undefined && interceptors.length) {
            // find if there is a RetryInterceptor
            if (interceptors.filter(x => Object.prototype.isPrototypeOf.call(_retry_interceptor_js__WEBPACK_IMPORTED_MODULE_2__.RetryInterceptor.prototype, x)).length > 1) {
                throw new Error('Only one RetryInterceptor is allowed.');
            }
            const retryInterceptorIndex = interceptors.findIndex(x => Object.prototype.isPrototypeOf.call(_retry_interceptor_js__WEBPACK_IMPORTED_MODULE_2__.RetryInterceptor.prototype, x));
            if (retryInterceptorIndex >= 0 && retryInterceptorIndex !== interceptors.length - 1) {
                throw new Error('The retry interceptor must be the last interceptor defined.');
            }
        }
        this.baseUrl = normalizedConfig.baseUrl;
        this.defaults = defaults;
        this.interceptors = normalizedConfig.interceptors !== undefined ? normalizedConfig.interceptors : [];
        this.dispatcher = normalizedConfig.dispatcher;
        this.isConfigured = true;
        return this;
    }
    /**
     * Starts the process of fetching a resource. Default configuration parameters
     * will be applied to the Request. The constructed Request will be passed to
     * registered request interceptors before being sent. The Response will be passed
     * to registered Response interceptors before it is returned.
     *
     * See also https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    fetch(input, init) {
        this.trackRequestStart();
        let request = this.buildRequest(input, init);
        return this.processRequest(request, this.interceptors).then(result => {
            let response;
            if (Object.prototype.isPrototypeOf.call(Response.prototype, result)) {
                response = Promise.resolve(result);
            }
            else if (Object.prototype.isPrototypeOf.call(Request.prototype, result)) {
                request = result;
                response = fetch(request);
            }
            else {
                throw new Error(`An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [${result}]`);
            }
            return this.processResponse(response, this.interceptors, request);
        })
            .then(result => {
            if (Object.prototype.isPrototypeOf.call(Request.prototype, result)) {
                return this.fetch(result);
            }
            return result;
        })
            .then(result => {
            this.trackRequestEnd();
            return result;
        }, error => {
            this.trackRequestEnd();
            throw error;
        });
    }
    buildRequest(input, init) {
        const defaults = this.defaults !== null ? this.defaults : {};
        let request;
        let body;
        let requestContentType;
        const parsedDefaultHeaders = parseHeaderValues(defaults.headers);
        if (Object.prototype.isPrototypeOf.call(Request.prototype, input)) {
            request = input;
            requestContentType = new Headers(request.headers).get('Content-Type');
        }
        else {
            if (!init) {
                init = {};
            }
            body = init.body;
            const bodyObj = body !== undefined ? { body: body } : null;
            const requestInit = { ...defaults, headers: {}, ...init, ...bodyObj };
            requestContentType = new Headers(requestInit.headers).get('Content-Type');
            request = new Request(getRequestUrl(this.baseUrl, input), requestInit);
        }
        if (!requestContentType) {
            if (new Headers(parsedDefaultHeaders).has('content-type')) {
                request.headers.set('Content-Type', new Headers(parsedDefaultHeaders).get('content-type'));
            }
            else if (body !== undefined && isJSON(body)) {
                request.headers.set('Content-Type', 'application/json');
            }
        }
        setDefaultHeaders(request.headers, parsedDefaultHeaders);
        if (body !== undefined && Object.prototype.isPrototypeOf.call(Blob.prototype, body) && body.type) {
            // work around bug in IE & Edge where the Blob type is ignored in the request
            // https://connect.microsoft.com/IE/feedback/details/2136163
            request.headers.set('Content-Type', body.type);
        }
        return request;
    }
    /**
     * Calls fetch as a GET request.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    get(input, init) {
        return this.fetch(input, init);
    }
    /**
     * Calls fetch with request method set to POST.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    post(input, body, init) {
        return this.callFetch(input, body, init, 'POST');
    }
    /**
     * Calls fetch with request method set to PUT.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    put(input, body, init) {
        return this.callFetch(input, body, init, 'PUT');
    }
    /**
     * Calls fetch with request method set to PATCH.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    patch(input, body, init) {
        return this.callFetch(input, body, init, 'PATCH');
    }
    /**
     * Calls fetch with request method set to DELETE.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    delete(input, body, init) {
        return this.callFetch(input, body, init, 'DELETE');
    }
    trackRequestStart() {
        this.isRequesting = !!(++this.activeRequestCount);
        if (this.isRequesting && this.dispatcher !== null) {
            const evt = new this.dispatcher.ownerDocument.defaultView.CustomEvent('aurelia-fetch-client-request-started', { bubbles: true, cancelable: true });
            setTimeout(() => { this.dispatcher.dispatchEvent(evt); }, 1);
        }
    }
    trackRequestEnd() {
        this.isRequesting = !!(--this.activeRequestCount);
        if (!this.isRequesting && this.dispatcher !== null) {
            const evt = new this.dispatcher.ownerDocument.defaultView.CustomEvent('aurelia-fetch-client-requests-drained', { bubbles: true, cancelable: true });
            setTimeout(() => { this.dispatcher.dispatchEvent(evt); }, 1);
        }
    }
    processRequest(request, interceptors) {
        return this.applyInterceptors(request, interceptors, 'request', 'requestError', this);
    }
    processResponse(response, interceptors, request) {
        return this.applyInterceptors(response, interceptors, 'response', 'responseError', request, this);
    }
    applyInterceptors(input, interceptors, successName, errorName, ...interceptorArgs) {
        return (interceptors !== undefined ? interceptors : [])
            .reduce((chain, interceptor) => {
            const successHandler = interceptor[successName];
            const errorHandler = interceptor[errorName];
            // TODO: Fix this, as it violates `strictBindCallApply`.
            return chain.then(successHandler ? (value => successHandler.call(interceptor, value, ...interceptorArgs)) : identity, errorHandler ? (reason => errorHandler.call(interceptor, reason, ...interceptorArgs)) : thrower);
        }, Promise.resolve(input));
    }
    callFetch(input, body, init, method) {
        if (!init) {
            init = {};
        }
        init.method = method;
        if (body) {
            init.body = body;
        }
        return this.fetch(input, init);
    }
}
function parseHeaderValues(headers) {
    const parsedHeaders = {};
    const $headers = headers !== undefined ? headers : {};
    for (const name in $headers) {
        if (Object.prototype.hasOwnProperty.call($headers, name)) {
            parsedHeaders[name] = (typeof $headers[name] === 'function')
                ? $headers[name]()
                : $headers[name];
        }
    }
    return parsedHeaders;
}
function getRequestUrl(baseUrl, url) {
    if (absoluteUrlRegexp.test(url)) {
        return url;
    }
    return (baseUrl !== undefined ? baseUrl : '') + url;
}
function setDefaultHeaders(headers, defaultHeaders) {
    const $defaultHeaders = defaultHeaders !== undefined ? defaultHeaders : {};
    for (const name in $defaultHeaders) {
        if (Object.prototype.hasOwnProperty.call($defaultHeaders, name) && !headers.has(name)) {
            headers.set(name, $defaultHeaders[name]);
        }
    }
}
function isJSON(str) {
    try {
        JSON.parse(str);
    }
    catch (err) {
        return false;
    }
    return true;
}
function identity(x) {
    return x;
}
function thrower(x) {
    throw x;
}
//# sourceMappingURL=http-client.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "json": () => /* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_0__.json,
/* harmony export */   "retryStrategy": () => /* reexport safe */ _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_1__.retryStrategy,
/* harmony export */   "RetryInterceptor": () => /* reexport safe */ _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_1__.RetryInterceptor,
/* harmony export */   "HttpClientConfiguration": () => /* reexport safe */ _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_2__.HttpClientConfiguration,
/* harmony export */   "HttpClient": () => /* reexport safe */ _http_client_js__WEBPACK_IMPORTED_MODULE_3__.HttpClient,
/* harmony export */   "IHttpClient": () => /* reexport safe */ _http_client_js__WEBPACK_IMPORTED_MODULE_3__.IHttpClient
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/@aurelia/fetch-client/dist/esm/util.js");
/* harmony import */ var _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retry-interceptor.js */ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js");
/* harmony import */ var _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http-client-configuration.js */ "./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js");
/* harmony import */ var _http_client_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./http-client.js */ "./node_modules/@aurelia/fetch-client/dist/esm/http-client.js");




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retryStrategy": () => /* binding */ retryStrategy,
/* harmony export */   "RetryInterceptor": () => /* binding */ RetryInterceptor
/* harmony export */ });
const retryStrategy = {
    fixed: 0,
    incremental: 1,
    exponential: 2,
    random: 3
};
const defaultRetryConfig = {
    maxRetries: 3,
    interval: 1000,
    strategy: retryStrategy.fixed
};
/**
 * Interceptor that retries requests on error, based on a given RetryConfiguration.
 */
class RetryInterceptor {
    /**
     * Creates an instance of RetryInterceptor.
     */
    constructor(retryConfig) {
        this.retryConfig = { ...defaultRetryConfig, ...(retryConfig !== undefined ? retryConfig : {}) };
        if (this.retryConfig.strategy === retryStrategy.exponential &&
            this.retryConfig.interval <= 1000) {
            throw new Error('An interval less than or equal to 1 second is not allowed when using the exponential retry strategy');
        }
    }
    /**
     * Called with the request before it is sent. It remembers the request so it can be retried on error.
     *
     * @param request - The request to be sent.
     * @returns The existing request, a new request or a response; or a Promise for any of these.
     */
    request(request) {
        if (!request.retryConfig) {
            request.retryConfig = { ...this.retryConfig };
            request.retryConfig.counter = 0;
        }
        // do this on every request
        request.retryConfig.requestClone = request.clone();
        return request;
    }
    /**
     * Called with the response after it is received. Clears the remembered request, as it was succesfull.
     *
     * @param response - The response.
     * @returns The response; or a Promise for one.
     */
    response(response, request) {
        // retry was successful, so clean up after ourselves
        Reflect.deleteProperty(request, 'retryConfig');
        return response;
    }
    /**
     * Handles fetch errors and errors generated by previous interceptors. This
     * function acts as a Promise rejection handler. It wil retry the remembered request based on the
     * configured RetryConfiguration.
     *
     * @param error - The rejection value from the fetch request or from a
     * previous interceptor.
     * @returns The response of the retry; or a Promise for one.
     */
    responseError(error, request, httpClient) {
        const { retryConfig } = request;
        const { requestClone } = retryConfig;
        return Promise.resolve().then(() => {
            if (retryConfig.counter < retryConfig.maxRetries) {
                const result = retryConfig.doRetry !== undefined ? retryConfig.doRetry(error, request) : true;
                return Promise.resolve(result).then(doRetry => {
                    if (doRetry) {
                        retryConfig.counter++;
                        const delay = calculateDelay(retryConfig);
                        return new Promise(resolve => setTimeout(resolve, !isNaN(delay) ? delay : 0))
                            .then(() => {
                            const newRequest = requestClone.clone();
                            if (typeof (retryConfig.beforeRetry) === 'function') {
                                return retryConfig.beforeRetry(newRequest, httpClient);
                            }
                            return newRequest;
                        })
                            .then(newRequest => {
                            const retryableRequest = { ...newRequest, retryConfig };
                            return httpClient.fetch(retryableRequest);
                        });
                    }
                    // no more retries, so clean up
                    Reflect.deleteProperty(request, 'retryConfig');
                    throw error;
                });
            }
            // no more retries, so clean up
            Reflect.deleteProperty(request, 'retryConfig');
            throw error;
        });
    }
}
function calculateDelay(retryConfig) {
    const { interval, strategy, minRandomInterval, maxRandomInterval, counter } = retryConfig;
    if (typeof (strategy) === 'function') {
        return retryConfig.strategy(counter);
    }
    switch (strategy) {
        case (retryStrategy.fixed):
            return retryStrategies[retryStrategy.fixed](interval);
        case (retryStrategy.incremental):
            return retryStrategies[retryStrategy.incremental](counter, interval);
        case (retryStrategy.exponential):
            return retryStrategies[retryStrategy.exponential](counter, interval);
        case (retryStrategy.random):
            return retryStrategies[retryStrategy.random](counter, interval, minRandomInterval, maxRandomInterval);
        default:
            throw new Error('Unrecognized retry strategy');
    }
}
const retryStrategies = [
    // fixed
    interval => interval,
    // incremental
    (retryCount, interval) => interval * retryCount,
    // exponential
    (retryCount, interval) => retryCount === 1 ? interval : interval ** retryCount / 1000,
    // random
    (retryCount, interval, minRandomInterval = 0, maxRandomInterval = 60000) => {
        return Math.random() * (maxRandomInterval - minRandomInterval) + minRandomInterval;
    }
];
//# sourceMappingURL=retry-interceptor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/util.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/util.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "json": () => /* binding */ json
/* harmony export */ });
/**
 * Serialize an object to JSON. Useful for easily creating JSON fetch request bodies.
 *
 * @param body - The object to be serialized to JSON.
 * @param replacer - The JSON.stringify replacer used when serializing.
 * @returns A JSON string.
 */
function json(body, replacer) {
    return JSON.stringify((body !== undefined ? body : {}), replacer);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/di.js":
/*!*****************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/di.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResolverBuilder": () => /* binding */ ResolverBuilder,
/* harmony export */   "DefaultResolver": () => /* binding */ DefaultResolver,
/* harmony export */   "ContainerConfiguration": () => /* binding */ ContainerConfiguration,
/* harmony export */   "DI": () => /* binding */ DI,
/* harmony export */   "IContainer": () => /* binding */ IContainer,
/* harmony export */   "IServiceLocator": () => /* binding */ IServiceLocator,
/* harmony export */   "inject": () => /* binding */ inject,
/* harmony export */   "transient": () => /* binding */ transient,
/* harmony export */   "singleton": () => /* binding */ singleton,
/* harmony export */   "all": () => /* binding */ all,
/* harmony export */   "lazy": () => /* binding */ lazy,
/* harmony export */   "optional": () => /* binding */ optional,
/* harmony export */   "ignore": () => /* binding */ ignore,
/* harmony export */   "newInstanceForScope": () => /* binding */ newInstanceForScope,
/* harmony export */   "newInstanceOf": () => /* binding */ newInstanceOf,
/* harmony export */   "ResolverStrategy": () => /* binding */ ResolverStrategy,
/* harmony export */   "Resolver": () => /* binding */ Resolver,
/* harmony export */   "Factory": () => /* binding */ Factory,
/* harmony export */   "Container": () => /* binding */ Container,
/* harmony export */   "ParameterizedRegistry": () => /* binding */ ParameterizedRegistry,
/* harmony export */   "Registration": () => /* binding */ Registration,
/* harmony export */   "InstanceProvider": () => /* binding */ InstanceProvider,
/* harmony export */   "validateKey": () => /* binding */ validateKey
/* harmony export */ });
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions.js */ "./node_modules/@aurelia/kernel/dist/esm/functions.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");

(0,_aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.applyMetadataPolyfill)(Reflect);



class ResolverBuilder {
    constructor(container, key) {
        this.container = container;
        this.key = key;
    }
    instance(value) {
        return this.registerResolver(0 /* instance */, value);
    }
    singleton(value) {
        return this.registerResolver(1 /* singleton */, value);
    }
    transient(value) {
        return this.registerResolver(2 /* transient */, value);
    }
    callback(value) {
        return this.registerResolver(3 /* callback */, value);
    }
    cachedCallback(value) {
        return this.registerResolver(3 /* callback */, cacheCallbackResult(value));
    }
    aliasTo(destinationKey) {
        return this.registerResolver(5 /* alias */, destinationKey);
    }
    registerResolver(strategy, state) {
        const { container, key } = this;
        this.container = this.key = (void 0);
        return container.registerResolver(key, new Resolver(key, strategy, state));
    }
}
function cloneArrayWithPossibleProps(source) {
    const clone = source.slice();
    const keys = Object.keys(source);
    const len = keys.length;
    let key;
    for (let i = 0; i < len; ++i) {
        key = keys[i];
        if (!(0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.isArrayIndex)(key)) {
            clone[key] = source[key];
        }
    }
    return clone;
}
const DefaultResolver = {
    none(key) { throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`); },
    singleton(key) { return new Resolver(key, 1 /* singleton */, key); },
    transient(key) { return new Resolver(key, 2 /* transient */, key); },
};
class ContainerConfiguration {
    constructor(inheritParentResources, defaultResolver) {
        this.inheritParentResources = inheritParentResources;
        this.defaultResolver = defaultResolver;
    }
    static from(config) {
        if (config === void 0 ||
            config === ContainerConfiguration.DEFAULT) {
            return ContainerConfiguration.DEFAULT;
        }
        return new ContainerConfiguration(config.inheritParentResources ?? false, config.defaultResolver ?? DefaultResolver.singleton);
    }
}
ContainerConfiguration.DEFAULT = ContainerConfiguration.from({});
const DI = {
    createContainer(config) {
        return new Container(null, ContainerConfiguration.from(config));
    },
    getDesignParamtypes(Type) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn('design:paramtypes', Type);
    },
    getAnnotationParamtypes(Type) {
        const key = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor('di:paramtypes');
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, Type);
    },
    getOrCreateAnnotationParamTypes(Type) {
        const key = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor('di:paramtypes');
        let annotationParamtypes = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, Type);
        if (annotationParamtypes === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, annotationParamtypes = [], Type);
            _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.appendTo(Type, key);
        }
        return annotationParamtypes;
    },
    getDependencies(Type) {
        // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,
        // so be careful with making changes here as it can have a huge impact on complex end user apps.
        // Preferably, only make changes to the dependency resolution process via a RFC.
        const key = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor('di:dependencies');
        let dependencies = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, Type);
        if (dependencies === void 0) {
            // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor
            // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).
            // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.
            // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.
            const inject = Type.inject;
            if (inject === void 0) {
                // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.
                const designParamtypes = DI.getDesignParamtypes(Type);
                // au:annotation:di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject
                const annotationParamtypes = DI.getAnnotationParamtypes(Type);
                if (designParamtypes === void 0) {
                    if (annotationParamtypes === void 0) {
                        // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as
                        // there is no sound way to merge a type's deps with its prototype's deps
                        const Proto = Object.getPrototypeOf(Type);
                        if (typeof Proto === 'function' && Proto !== Function.prototype) {
                            dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));
                        }
                        else {
                            dependencies = [];
                        }
                    }
                    else {
                        // No design:paramtypes so just use the au:annotation:di:paramtypes
                        dependencies = cloneArrayWithPossibleProps(annotationParamtypes);
                    }
                }
                else if (annotationParamtypes === void 0) {
                    // No au:annotation:di:paramtypes so just use the design:paramtypes
                    dependencies = cloneArrayWithPossibleProps(designParamtypes);
                }
                else {
                    // We've got both, so merge them (in case of conflict on same index, au:annotation:di:paramtypes take precedence)
                    dependencies = cloneArrayWithPossibleProps(designParamtypes);
                    let len = annotationParamtypes.length;
                    let auAnnotationParamtype;
                    for (let i = 0; i < len; ++i) {
                        auAnnotationParamtype = annotationParamtypes[i];
                        if (auAnnotationParamtype !== void 0) {
                            dependencies[i] = auAnnotationParamtype;
                        }
                    }
                    const keys = Object.keys(annotationParamtypes);
                    len = keys.length;
                    let key;
                    for (let i = 0; i < len; ++i) {
                        key = keys[i];
                        if (!(0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.isArrayIndex)(key)) {
                            dependencies[key] = annotationParamtypes[key];
                        }
                    }
                }
            }
            else {
                // Ignore paramtypes if we have static inject
                dependencies = cloneArrayWithPossibleProps(inject);
            }
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, dependencies, Type);
            _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.appendTo(Type, key);
        }
        return dependencies;
    },
    /**
     * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.
     * ```ts
     * const ILogger = DI.createInterface<Logger>('Logger');
     * container.register(Registration.singleton(ILogger, getSomeLogger()));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * you can also build default registrations into your interface.
     * ```ts
     * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * but these default registrations won't work the same with other decorators that take keys, for example
     * ```ts
     * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));
     * class Foo {
     *   constructor( @optional(MyStr) public readonly str: string ) {
     *   }
     * }
     * container.get(Foo).str; // returns undefined
     * ```
     * to fix this add this line somewhere before you do a `get`
     * ```ts
     * container.register(MyStr);
     * container.get(Foo).str; // returns 'somestring'
     * ```
     *
     * - @param friendlyName used to improve error messaging
     */
    createInterface(configureOrName, configuror) {
        const configure = typeof configureOrName === 'function' ? configureOrName : configuror;
        const friendlyName = typeof configureOrName === 'string' ? configureOrName : undefined;
        const Interface = function (target, property, index) {
            if (target == null || new.target !== undefined) {
                throw new Error(`No registration for interface: '${Interface.friendlyName}'`); // TODO: add error (trying to resolve an InterfaceSymbol that has no registrations)
            }
            const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
            annotationParamtypes[index] = Interface;
        };
        Interface.$isInterface = true;
        Interface.friendlyName = friendlyName == null ? '(anonymous)' : friendlyName;
        if (configure != null) {
            Interface.register = function (container, key) {
                return configure(new ResolverBuilder(container, key ?? Interface));
            };
        }
        Interface.toString = function toString() {
            return `InterfaceSymbol<${Interface.friendlyName}>`;
        };
        return Interface;
    },
    inject(...dependencies) {
        return function (target, key, descriptor) {
            if (typeof descriptor === 'number') { // It's a parameter decorator.
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
                const dep = dependencies[0];
                if (dep !== void 0) {
                    annotationParamtypes[descriptor] = dep;
                }
            }
            else if (key) { // It's a property decorator. Not supported by the container without plugins.
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target.constructor);
                const dep = dependencies[0];
                if (dep !== void 0) {
                    annotationParamtypes[key] = dep;
                }
            }
            else if (descriptor) { // It's a function decorator (not a Class constructor)
                const fn = descriptor.value;
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(fn);
                let dep;
                for (let i = 0; i < dependencies.length; ++i) {
                    dep = dependencies[i];
                    if (dep !== void 0) {
                        annotationParamtypes[i] = dep;
                    }
                }
            }
            else { // It's a class decorator.
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
                let dep;
                for (let i = 0; i < dependencies.length; ++i) {
                    dep = dependencies[i];
                    if (dep !== void 0) {
                        annotationParamtypes[i] = dep;
                    }
                }
            }
        };
    },
    /**
     * Registers the `target` class as a transient dependency; each time the dependency is resolved
     * a new instance will be created.
     *
     * @param target - The class / constructor function to register as transient.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     *
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.transient(Foo);
     *
     * // Inline declaration
     * const Foo = DI.transient(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    transient(target) {
        target.register = function register(container) {
            const registration = Registration.transient(target, target);
            return registration.register(container, target);
        };
        target.registerInRequestor = false;
        return target;
    },
    /**
     * Registers the `target` class as a singleton dependency; the class will only be created once. Each
     * consecutive time the dependency is resolved, the same instance will be returned.
     *
     * @param target - The class / constructor function to register as a singleton.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.singleton(Foo);
     *
     * // Inline declaration
     * const Foo = DI.singleton(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    singleton(target, options = defaultSingletonOptions) {
        target.register = function register(container) {
            const registration = Registration.singleton(target, target);
            return registration.register(container, target);
        };
        target.registerInRequestor = options.scoped;
        return target;
    },
};
const IContainer = DI.createInterface('IContainer');
const IServiceLocator = IContainer;
function createResolver(getter) {
    return function (key) {
        const resolver = function (target, property, descriptor) {
            DI.inject(resolver)(target, property, descriptor);
        };
        resolver.$isResolver = true;
        resolver.resolve = function (handler, requestor) {
            return getter(key, handler, requestor);
        };
        return resolver;
    };
}
const inject = DI.inject;
function transientDecorator(target) {
    return DI.transient(target);
}
function transient(target) {
    return target == null ? transientDecorator : transientDecorator(target);
}
const defaultSingletonOptions = { scoped: false };
function singletonDecorator(target) {
    return DI.singleton(target);
}
function singleton(targetOrOptions) {
    if (typeof targetOrOptions === 'function') {
        return DI.singleton(targetOrOptions);
    }
    return function ($target) {
        return DI.singleton($target, targetOrOptions);
    };
}
function createAllResolver(getter) {
    return function (key, searchAncestors) {
        searchAncestors = !!searchAncestors;
        const resolver = function (target, property, descriptor) {
            DI.inject(resolver)(target, property, descriptor);
        };
        resolver.$isResolver = true;
        resolver.resolve = function (handler, requestor) {
            return getter(key, handler, requestor, searchAncestors);
        };
        return resolver;
    };
}
const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));
/**
 * Lazily inject a dependency depending on whether the [[`Key`]] is present at the time of function call.
 *
 * You need to make your argument a function that returns the type, for example
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => number )
 * }
 * const foo = container.get(Foo); // instanceof Foo
 * foo.random(); // throws
 * ```
 * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a
 * new [['Math.random()']] number each time.
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => random )
 * }
 * container.register(Registration.callback('random', Math.random ));
 * container.get(Foo).random(); // some random number
 * container.get(Foo).random(); // another random number
 * ```
 * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a
 * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.
 *
 * - @param key [[`Key`]]
 * see { @link DI.createInterface } on interactions with interfaces
 */
const lazy = createResolver((key, handler, requestor) => {
    return () => requestor.get(key);
});
/**
 * Allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example
 * ```ts
 * class Foo {
 *   constructor( @inject('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo); // throws
 * ```
 * would fail
 * ```ts
 * class Foo {
 *   constructor( @optional('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo).str // somestring
 * ```
 * if you use it without a default it will inject `undefined`, so rember to mark your input type as
 * possibly `undefined`!
 *
 * - @param key: [[`Key`]]
 *
 * see { @link DI.createInterface } on interactions with interfaces
 */
const optional = createResolver((key, handler, requestor) => {
    if (requestor.has(key, true)) {
        return requestor.get(key);
    }
    else {
        return undefined;
    }
});
/**
 * ignore tells the container not to try to inject a dependency
 */
function ignore(target, property, descriptor) {
    DI.inject(ignore)(target, property, descriptor);
}
ignore.$isResolver = true;
ignore.resolve = () => undefined;
const newInstanceForScope = createResolver((key, handler, requestor) => {
    const instance = createNewInstance(key, handler);
    const instanceProvider = new InstanceProvider(String(key));
    instanceProvider.prepare(instance);
    requestor.registerResolver(key, instanceProvider, true);
    return instance;
});
const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));
function createNewInstance(key, handler) {
    return handler.getFactory(key).construct(handler);
}
/** @internal */
var ResolverStrategy;
(function (ResolverStrategy) {
    ResolverStrategy[ResolverStrategy["instance"] = 0] = "instance";
    ResolverStrategy[ResolverStrategy["singleton"] = 1] = "singleton";
    ResolverStrategy[ResolverStrategy["transient"] = 2] = "transient";
    ResolverStrategy[ResolverStrategy["callback"] = 3] = "callback";
    ResolverStrategy[ResolverStrategy["array"] = 4] = "array";
    ResolverStrategy[ResolverStrategy["alias"] = 5] = "alias";
})(ResolverStrategy || (ResolverStrategy = {}));
/** @internal */
class Resolver {
    constructor(key, strategy, state) {
        this.key = key;
        this.strategy = strategy;
        this.state = state;
        this.resolving = false;
    }
    get $isResolver() { return true; }
    register(container, key) {
        return container.registerResolver(key || this.key, this);
    }
    resolve(handler, requestor) {
        switch (this.strategy) {
            case 0 /* instance */:
                return this.state;
            case 1 /* singleton */: {
                if (this.resolving) {
                    throw new Error(`Cyclic dependency found: ${this.state.name}`);
                }
                this.resolving = true;
                this.state = handler.getFactory(this.state).construct(requestor);
                this.strategy = 0 /* instance */;
                this.resolving = false;
                return this.state;
            }
            case 2 /* transient */: {
                // Always create transients from the requesting container
                const factory = handler.getFactory(this.state);
                if (factory === null) {
                    throw new Error(`Resolver for ${String(this.key)} returned a null factory`);
                }
                return factory.construct(requestor);
            }
            case 3 /* callback */:
                return this.state(handler, requestor, this);
            case 4 /* array */:
                return this.state[0].resolve(handler, requestor);
            case 5 /* alias */:
                return requestor.get(this.state);
            default:
                throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);
        }
    }
    getFactory(container) {
        switch (this.strategy) {
            case 1 /* singleton */:
            case 2 /* transient */:
                return container.getFactory(this.state);
            case 5 /* alias */:
                return container.getResolver(this.state)?.getFactory?.(container) ?? null;
            default:
                return null;
        }
    }
}
function containerGetKey(d) {
    return this.get(d);
}
function transformInstance(inst, transform) {
    return transform(inst);
}
/** @internal */
class Factory {
    constructor(Type, dependencies) {
        this.Type = Type;
        this.dependencies = dependencies;
        this.transformers = null;
    }
    construct(container, dynamicDependencies) {
        let instance;
        if (dynamicDependencies === void 0) {
            instance = new this.Type(...this.dependencies.map(containerGetKey, container));
        }
        else {
            instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
        }
        if (this.transformers == null) {
            return instance;
        }
        return this.transformers.reduce(transformInstance, instance);
    }
    registerTransformer(transformer) {
        (this.transformers ?? (this.transformers = [])).push(transformer);
    }
}
const containerResolver = {
    $isResolver: true,
    resolve(handler, requestor) {
        return requestor;
    }
};
function isRegistry(obj) {
    return typeof obj.register === 'function';
}
function isSelfRegistry(obj) {
    return isRegistry(obj) && typeof obj.registerInRequestor === 'boolean';
}
function isRegisterInRequester(obj) {
    return isSelfRegistry(obj) && obj.registerInRequestor;
}
function isClass(obj) {
    return obj.prototype !== void 0;
}
function isResourceKey(key) {
    return typeof key === 'string' && key.indexOf(':') > 0;
}
const InstrinsicTypeNames = new Set([
    'Array',
    'ArrayBuffer',
    'Boolean',
    'DataView',
    'Date',
    'Error',
    'EvalError',
    'Float32Array',
    'Float64Array',
    'Function',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Map',
    'Number',
    'Object',
    'Promise',
    'RangeError',
    'ReferenceError',
    'RegExp',
    'Set',
    'SharedArrayBuffer',
    'String',
    'SyntaxError',
    'TypeError',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array',
    'URIError',
    'WeakMap',
    'WeakSet',
]);
const factoryKey = 'di:factory';
const factoryAnnotationKey = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor(factoryKey);
/** @internal */
class Container {
    constructor(parent, config) {
        this.parent = parent;
        this.config = config;
        this.registerDepth = 0;
        this.disposableResolvers = new Set();
        if (parent === null) {
            this.root = this;
            this.resolvers = new Map();
            this.factories = new Map();
            this.resourceResolvers = Object.create(null);
        }
        else {
            this.root = parent.root;
            this.resolvers = new Map();
            this.factories = parent.factories;
            if (config.inheritParentResources) {
                this.resourceResolvers = Object.assign(Object.create(null), parent.resourceResolvers, this.root.resourceResolvers);
            }
            else {
                this.resourceResolvers = Object.assign(Object.create(null), this.root.resourceResolvers);
            }
        }
        this.resolvers.set(IContainer, containerResolver);
    }
    get depth() {
        return this.parent === null ? 0 : this.parent.depth + 1;
    }
    register(...params) {
        if (++this.registerDepth === 100) {
            throw new Error(`Unable to autoregister dependency: [${params.map(String)}]`);
            // TODO: change to reporter.error and add various possible causes in description.
            // Most likely cause is trying to register a plain object that does not have a
            // register method and is not a class constructor
        }
        let current;
        let keys;
        let value;
        let j;
        let jj;
        for (let i = 0, ii = params.length; i < ii; ++i) {
            current = params[i];
            if (!(0,_aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.isObject)(current)) {
                continue;
            }
            if (isRegistry(current)) {
                current.register(this);
            }
            else if (_resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.has(current)) {
                const defs = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.getAll(current);
                if (defs.length === 1) {
                    // Fast path for the very common case
                    defs[0].register(this);
                }
                else {
                    const len = defs.length;
                    for (let d = 0; d < len; ++d) {
                        defs[d].register(this);
                    }
                }
            }
            else if (isClass(current)) {
                Registration.singleton(current, current).register(this);
            }
            else {
                keys = Object.keys(current);
                j = 0;
                jj = keys.length;
                for (; j < jj; ++j) {
                    value = current[keys[j]];
                    if (!(0,_aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
                        continue;
                    }
                    // note: we could remove this if-branch and call this.register directly
                    // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator
                    if (isRegistry(value)) {
                        value.register(this);
                    }
                    else {
                        this.register(value);
                    }
                }
            }
        }
        --this.registerDepth;
        return this;
    }
    registerResolver(key, resolver, isDisposable = false) {
        validateKey(key);
        const resolvers = this.resolvers;
        const result = resolvers.get(key);
        if (result == null) {
            resolvers.set(key, resolver);
            if (isResourceKey(key)) {
                this.resourceResolvers[key] = resolver;
            }
        }
        else if (result instanceof Resolver && result.strategy === 4 /* array */) {
            result.state.push(resolver);
        }
        else {
            resolvers.set(key, new Resolver(key, 4 /* array */, [result, resolver]));
        }
        if (isDisposable) {
            this.disposableResolvers.add(resolver);
        }
        return resolver;
    }
    // public deregisterResolverFor<K extends Key, T = K>(key: K): void {
    //   // const console =  (globalThis as any).console;
    //   // console.group("deregisterResolverFor");
    //   validateKey(key);
    //   let current: Container = this;
    //   let resolver: IResolver | undefined;
    //   while (current != null) {
    //     resolver = current.resolvers.get(key);
    //     if (resolver != null) { break; }
    //     if (current.parent == null) { return; }
    //     current = current.parent;
    //   }
    //   if (resolver === void 0) { return; }
    //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {
    //     throw new Error('Cannot deregister a resolver with array strategy');
    //   }
    //   if (this.disposableResolvers.has(resolver as IDisposableResolver<T>)) {
    //     (resolver as IDisposableResolver<T>).dispose();
    //   }
    //   if (isResourceKey(key)) {
    //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    //     delete this.resourceResolvers[key];
    //   }
    //   // console.log(`BEFORE delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);
    //   current.resolvers.delete(key);
    //   // console.log(`AFTER delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);
    //   // console.groupEnd();
    // }
    registerTransformer(key, transformer) {
        const resolver = this.getResolver(key);
        if (resolver == null) {
            return false;
        }
        if (resolver.getFactory) {
            const factory = resolver.getFactory(this);
            if (factory == null) {
                return false;
            }
            // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.
            // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on
            // type Constructable. So the return type of that optional method has this additional constraint, which
            // seems to confuse the type checker.
            factory.registerTransformer(transformer);
            return true;
        }
        return false;
    }
    getResolver(key, autoRegister = true) {
        validateKey(key);
        if (key.resolve !== void 0) {
            return key;
        }
        let current = this;
        let resolver;
        while (current != null) {
            resolver = current.resolvers.get(key);
            if (resolver == null) {
                if (current.parent == null) {
                    const handler = (isRegisterInRequester(key)) ? this : current;
                    return autoRegister ? this.jitRegister(key, handler) : null;
                }
                current = current.parent;
            }
            else {
                return resolver;
            }
        }
        return null;
    }
    has(key, searchAncestors = false) {
        return this.resolvers.has(key)
            ? true
            : searchAncestors && this.parent != null
                ? this.parent.has(key, true)
                : false;
    }
    get(key) {
        validateKey(key);
        if (key.$isResolver) {
            return key.resolve(this, this);
        }
        let current = this;
        let resolver;
        while (current != null) {
            resolver = current.resolvers.get(key);
            if (resolver == null) {
                if (current.parent == null) {
                    const handler = (isRegisterInRequester(key)) ? this : current;
                    resolver = this.jitRegister(key, handler);
                    return resolver.resolve(current, this);
                }
                current = current.parent;
            }
            else {
                return resolver.resolve(current, this);
            }
        }
        throw new Error(`Unable to resolve key: ${key}`);
    }
    getAll(key, searchAncestors = false) {
        validateKey(key);
        const requestor = this;
        let current = requestor;
        let resolver;
        if (searchAncestors) {
            let resolutions = _platform_js__WEBPACK_IMPORTED_MODULE_2__.emptyArray;
            while (current != null) {
                resolver = current.resolvers.get(key);
                if (resolver != null) {
                    resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));
                }
                current = current.parent;
            }
            return resolutions;
        }
        else {
            while (current != null) {
                resolver = current.resolvers.get(key);
                if (resolver == null) {
                    current = current.parent;
                    if (current == null) {
                        return _platform_js__WEBPACK_IMPORTED_MODULE_2__.emptyArray;
                    }
                }
                else {
                    return buildAllResponse(resolver, current, requestor);
                }
            }
        }
        return _platform_js__WEBPACK_IMPORTED_MODULE_2__.emptyArray;
    }
    getFactory(Type) {
        let factory = this.factories.get(Type);
        if (factory === void 0) {
            if ((0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.isNativeFunction)(Type)) {
                throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);
            }
            this.factories.set(Type, factory = new Factory(Type, DI.getDependencies(Type)));
        }
        return factory;
    }
    registerFactory(key, factory) {
        this.factories.set(key, factory);
    }
    createChild(config) {
        if (config === void 0 && this.config.inheritParentResources) {
            if (this.config === ContainerConfiguration.DEFAULT) {
                return new Container(this, this.config);
            }
            return new Container(this, ContainerConfiguration.from({
                ...this.config,
                inheritParentResources: false,
            }));
        }
        return new Container(this, ContainerConfiguration.from(config ?? this.config));
    }
    disposeResolvers() {
        const disposables = Array.from(this.disposableResolvers);
        while (disposables.length > 0) {
            disposables.pop()?.dispose();
        }
    }
    find(kind, name) {
        const key = kind.keyFrom(name);
        let resolver = this.resourceResolvers[key];
        if (resolver === void 0) {
            resolver = this.root.resourceResolvers[key];
            if (resolver === void 0) {
                return null;
            }
        }
        if (resolver === null) {
            return null;
        }
        if (typeof resolver.getFactory === 'function') {
            const factory = resolver.getFactory(this);
            if (factory === null || factory === void 0) {
                return null;
            }
            const definition = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(kind.name, factory.Type);
            if (definition === void 0) {
                // TODO: we may want to log a warning here, or even throw. This would happen if a dependency is registered with a resource-like key
                // but does not actually have a definition associated via the type's metadata. That *should* generally not happen.
                return null;
            }
            return definition;
        }
        return null;
    }
    create(kind, name) {
        const key = kind.keyFrom(name);
        let resolver = this.resourceResolvers[key];
        if (resolver === void 0) {
            resolver = this.root.resourceResolvers[key];
            if (resolver === void 0) {
                return null;
            }
            return resolver.resolve(this.root, this) ?? null;
        }
        return resolver.resolve(this, this) ?? null;
    }
    dispose() {
        this.disposeResolvers();
        this.resolvers.clear();
    }
    jitRegister(keyAsValue, handler) {
        if (typeof keyAsValue !== 'function') {
            throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this resource?`);
        }
        if (InstrinsicTypeNames.has(keyAsValue.name)) {
            throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);
        }
        if (isRegistry(keyAsValue)) {
            const registrationResolver = keyAsValue.register(handler, keyAsValue);
            if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
                const newResolver = handler.resolvers.get(keyAsValue);
                if (newResolver != void 0) {
                    return newResolver;
                }
                throw new Error(`Invalid resolver returned from the static register method`);
            }
            return registrationResolver;
        }
        else if (_resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.has(keyAsValue)) {
            const defs = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.getAll(keyAsValue);
            if (defs.length === 1) {
                // Fast path for the very common case
                defs[0].register(handler);
            }
            else {
                const len = defs.length;
                for (let d = 0; d < len; ++d) {
                    defs[d].register(handler);
                }
            }
            const newResolver = handler.resolvers.get(keyAsValue);
            if (newResolver != void 0) {
                return newResolver;
            }
            throw new Error(`Invalid resolver returned from the static register method`);
        }
        else if (keyAsValue.$isInterface) {
            throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);
        }
        else {
            const resolver = this.config.defaultResolver(keyAsValue, handler);
            handler.resolvers.set(keyAsValue, resolver);
            return resolver;
        }
    }
}
/**
 * An implementation of IRegistry that delegates registration to a
 * separately registered class. The ParameterizedRegistry facilitates the
 * passing of parameters to the final registry.
 */
class ParameterizedRegistry {
    constructor(key, params) {
        this.key = key;
        this.params = params;
    }
    register(container) {
        if (container.has(this.key, true)) {
            const registry = container.get(this.key);
            registry.register(container, ...this.params);
        }
        else {
            container.register(...this.params.filter(x => typeof x === 'object'));
        }
    }
}
const cache = new WeakMap();
function cacheCallbackResult(fun) {
    return function (handler, requestor, resolver) {
        if (cache.has(resolver)) {
            return cache.get(resolver);
        }
        const t = fun(handler, requestor, resolver);
        cache.set(resolver, t);
        return t;
    };
}
/**
 * you can use the resulting {@linkcode IRegistration} of any of the factory methods
 * to register with the container, e.g.
 * ```
 * class Foo {}
 * const container = DI.createContainer();
 * container.register(Registration.instance(Foo, new Foo()));
 * container.get(Foo);
 * ```
 */
const Registration = {
    /**
     * allows you to pass an instance.
     * Every time you request this {@linkcode Key} you will get this instance back.
     * ```
     * Registration.instance(Foo, new Foo()));
     * ```
     *
     * @param key
     * @param value
     */
    instance(key, value) {
        return new Resolver(key, 0 /* instance */, value);
    },
    /**
     * Creates an instance from the class.
     * Every time you request this {@linkcode Key} you will get the same one back.
     * ```
     * Registration.singleton(Foo, Foo);
     * ```
     *
     * @param key
     * @param value
     */
    singleton(key, value) {
        return new Resolver(key, 1 /* singleton */, value);
    },
    /**
     * Creates an instance from a class.
     * Every time you request this {@linkcode Key} you will get a new instance.
     * ```
     * Registration.instance(Foo, Foo);
     * ```
     *
     * @param key
     * @param value
     */
    transient(key, value) {
        return new Resolver(key, 2 /* transient */, value);
    },
    /**
     * Creates an instance from the method passed.
     * Every time you request this {@linkcode Key} you will get a new instance.
     * ```
     * Registration.callback(Foo, () => new Foo());
     * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
     * ```
     *
     * @param key
     * @param callback
     */
    callback(key, callback) {
        return new Resolver(key, 3 /* callback */, callback);
    },
    /**
     * Creates an instance from the method passed.
     * On the first request for the {@linkcode Key} your callback is called and returns an instance.
     * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.
     * If you pass the same {@linkcode Registration} to another container the same cached value will be used.
     * Should all references to the resolver returned be removed, the cache will expire.
     * ```
     * Registration.cachedCallback(Foo, () => new Foo());
     * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
     * ```
     *
     * @param key
     * @param callback
     */
    cachedCallback(key, callback) {
        return new Resolver(key, 3 /* callback */, cacheCallbackResult(callback));
    },
    /**
     * creates an alternate {@linkcode Key} to retrieve an instance by.
     * Returns the same scope as the original {@linkcode Key}.
     * ```
     * Register.singleton(Foo, Foo)
     * Register.aliasTo(Foo, MyFoos);
     *
     * container.getAll(MyFoos) // contains an instance of Foo
     * ```
     *
     * @param originalKey
     * @param aliasKey
     */
    aliasTo(originalKey, aliasKey) {
        return new Resolver(aliasKey, 5 /* alias */, originalKey);
    },
    /**
     * @internal
     * @param key
     * @param params
     */
    defer(key, ...params) {
        return new ParameterizedRegistry(key, params);
    }
};
class InstanceProvider {
    constructor(friendlyName) {
        this.friendlyName = friendlyName;
        this.instance = null;
    }
    prepare(instance) {
        this.instance = instance;
    }
    get $isResolver() { return true; }
    resolve() {
        if (this.instance == null) {
            throw new Error(`Cannot call resolve ${this.friendlyName} before calling prepare or after calling dispose.`);
        }
        return this.instance;
    }
    dispose() {
        this.instance = null;
    }
}
/** @internal */
function validateKey(key) {
    if (key === null || key === void 0) {
        throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
    }
}
function buildAllResponse(resolver, handler, requestor) {
    if (resolver instanceof Resolver && resolver.strategy === 4 /* array */) {
        const state = resolver.state;
        let i = state.length;
        const results = new Array(i);
        while (i--) {
            results[i] = state[i].resolve(handler, requestor);
        }
        return results;
    }
    return [resolver.resolve(handler, requestor)];
}
//# sourceMappingURL=di.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/eventaggregator.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/eventaggregator.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IEventAggregator": () => /* binding */ IEventAggregator,
/* harmony export */   "EventAggregator": () => /* binding */ EventAggregator
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* eslint-disable @typescript-eslint/restrict-template-expressions */

/**
 * Represents a handler for an EventAggregator event.
 */
class Handler {
    constructor(messageType, callback) {
        this.messageType = messageType;
        this.callback = callback;
    }
    handle(message) {
        if (message instanceof this.messageType) {
            this.callback.call(null, message);
        }
    }
}
const IEventAggregator = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IEventAggregator', x => x.singleton(EventAggregator));
/**
 * Enables loosely coupled publish/subscribe messaging.
 */
class EventAggregator {
    constructor() {
        /** @internal */
        this.eventLookup = {};
        /** @internal */
        this.messageHandlers = [];
    }
    publish(channelOrInstance, message) {
        if (!channelOrInstance) {
            throw new Error(`Invalid channel name or instance: ${channelOrInstance}.`);
        }
        if (typeof channelOrInstance === 'string') {
            let subscribers = this.eventLookup[channelOrInstance];
            if (subscribers !== void 0) {
                subscribers = subscribers.slice();
                let i = subscribers.length;
                while (i-- > 0) {
                    subscribers[i](message, channelOrInstance);
                }
            }
        }
        else {
            const subscribers = this.messageHandlers.slice();
            let i = subscribers.length;
            while (i-- > 0) {
                subscribers[i].handle(channelOrInstance);
            }
        }
    }
    subscribe(channelOrType, callback) {
        if (!channelOrType) {
            throw new Error(`Invalid channel name or type: ${channelOrType}.`);
        }
        let handler;
        let subscribers;
        if (typeof channelOrType === 'string') {
            if (this.eventLookup[channelOrType] === void 0) {
                this.eventLookup[channelOrType] = [];
            }
            handler = callback;
            subscribers = this.eventLookup[channelOrType];
        }
        else {
            handler = new Handler(channelOrType, callback);
            subscribers = this.messageHandlers;
        }
        subscribers.push(handler);
        return {
            dispose() {
                const idx = subscribers.indexOf(handler);
                if (idx !== -1) {
                    subscribers.splice(idx, 1);
                }
            }
        };
    }
    subscribeOnce(channelOrType, callback) {
        const sub = this.subscribe(channelOrType, function (message, event) {
            sub.dispose();
            callback(message, event);
        });
        return sub;
    }
}
//# sourceMappingURL=eventaggregator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/functions.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/functions.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isArrayIndex": () => /* binding */ isArrayIndex,
/* harmony export */   "isNumberOrBigInt": () => /* binding */ isNumberOrBigInt,
/* harmony export */   "isStringOrDate": () => /* binding */ isStringOrDate,
/* harmony export */   "camelCase": () => /* binding */ camelCase,
/* harmony export */   "pascalCase": () => /* binding */ pascalCase,
/* harmony export */   "kebabCase": () => /* binding */ kebabCase,
/* harmony export */   "toArray": () => /* binding */ toArray,
/* harmony export */   "nextId": () => /* binding */ nextId,
/* harmony export */   "resetId": () => /* binding */ resetId,
/* harmony export */   "compareNumber": () => /* binding */ compareNumber,
/* harmony export */   "mergeDistinct": () => /* binding */ mergeDistinct,
/* harmony export */   "bound": () => /* binding */ bound,
/* harmony export */   "mergeArrays": () => /* binding */ mergeArrays,
/* harmony export */   "mergeObjects": () => /* binding */ mergeObjects,
/* harmony export */   "firstDefined": () => /* binding */ firstDefined,
/* harmony export */   "getPrototypeChain": () => /* binding */ getPrototypeChain,
/* harmony export */   "toLookup": () => /* binding */ toLookup,
/* harmony export */   "isNativeFunction": () => /* binding */ isNativeFunction,
/* harmony export */   "onResolve": () => /* binding */ onResolve,
/* harmony export */   "resolveAll": () => /* binding */ resolveAll
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");

const isNumericLookup = {};
/**
 * Efficiently determine whether the provided property key is numeric
 * (and thus could be an array indexer) or not.
 *
 * Always returns true for values of type `'number'`.
 *
 * Otherwise, only returns true for strings that consist only of positive integers.
 *
 * Results are cached.
 */
function isArrayIndex(value) {
    switch (typeof value) {
        case 'number':
            return value >= 0 && (value | 0) === value;
        case 'string': {
            const result = isNumericLookup[value];
            if (result !== void 0) {
                return result;
            }
            const length = value.length;
            if (length === 0) {
                return isNumericLookup[value] = false;
            }
            let ch = 0;
            for (let i = 0; i < length; ++i) {
                ch = value.charCodeAt(i);
                if (i === 0 && ch === 0x30 && length > 1 /* must not start with 0 */ || ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
                    return isNumericLookup[value] = false;
                }
            }
            return isNumericLookup[value] = true;
        }
        default:
            return false;
    }
}
/**
 * Determines if the value passed is a number or bigint for parsing purposes
 *
 * @param value - Value to evaluate
 */
function isNumberOrBigInt(value) {
    switch (typeof value) {
        case 'number':
        case 'bigint':
            return true;
        default:
            return false;
    }
}
/**
 * Determines if the value passed is a number or bigint for parsing purposes
 *
 * @param value - Value to evaluate
 */
function isStringOrDate(value) {
    switch (typeof value) {
        case 'string':
            return true;
        case 'object':
            return value instanceof Date;
        default:
            return false;
    }
}
/**
 * Base implementation of camel and kebab cases
 */
const baseCase = (function () {
    let CharKind;
    (function (CharKind) {
        CharKind[CharKind["none"] = 0] = "none";
        CharKind[CharKind["digit"] = 1] = "digit";
        CharKind[CharKind["upper"] = 2] = "upper";
        CharKind[CharKind["lower"] = 3] = "lower";
    })(CharKind || (CharKind = {}));
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    const isDigit = Object.assign(Object.create(null), {
        '0': true,
        '1': true,
        '2': true,
        '3': true,
        '4': true,
        '5': true,
        '6': true,
        '7': true,
        '8': true,
        '9': true,
    });
    function charToKind(char) {
        if (char === '') {
            // We get this if we do charAt() with an index out of range
            return 0 /* none */;
        }
        if (char !== char.toUpperCase()) {
            return 3 /* lower */;
        }
        if (char !== char.toLowerCase()) {
            return 2 /* upper */;
        }
        if (isDigit[char] === true) {
            return 1 /* digit */;
        }
        return 0 /* none */;
    }
    return function (input, cb) {
        const len = input.length;
        if (len === 0) {
            return input;
        }
        let sep = false;
        let output = '';
        let prevKind;
        let curChar = '';
        let curKind = 0 /* none */;
        let nextChar = input.charAt(0);
        let nextKind = charToKind(nextChar);
        for (let i = 0; i < len; ++i) {
            prevKind = curKind;
            curChar = nextChar;
            curKind = nextKind;
            nextChar = input.charAt(i + 1);
            nextKind = charToKind(nextChar);
            if (curKind === 0 /* none */) {
                if (output.length > 0) {
                    // Only set sep to true if it's not at the beginning of output.
                    sep = true;
                }
            }
            else {
                if (!sep && output.length > 0 && curKind === 2 /* upper */) {
                    // Separate UAFoo into UA Foo.
                    // Separate uaFOO into ua FOO.
                    sep = prevKind === 3 /* lower */ || nextKind === 3 /* lower */;
                }
                output += cb(curChar, sep);
                sep = false;
            }
        }
        return output;
    };
})();
/**
 * Efficiently convert a string to camelCase.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert DOM attribute names to ViewModel property names.
 *
 * Results are cached.
 */
const camelCase = (function () {
    const cache = Object.create(null);
    function callback(char, sep) {
        return sep ? char.toUpperCase() : char.toLowerCase();
    }
    return function (input) {
        let output = cache[input];
        if (output === void 0) {
            output = cache[input] = baseCase(input, callback);
        }
        return output;
    };
})();
/**
 * Efficiently convert a string to PascalCase.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert element names to class names for synthetic types.
 *
 * Results are cached.
 */
const pascalCase = (function () {
    const cache = Object.create(null);
    return function (input) {
        let output = cache[input];
        if (output === void 0) {
            output = camelCase(input);
            if (output.length > 0) {
                output = output[0].toUpperCase() + output.slice(1);
            }
            cache[input] = output;
        }
        return output;
    };
})();
/**
 * Efficiently convert a string to kebab-case.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert ViewModel property names to DOM attribute names.
 *
 * Results are cached.
 */
const kebabCase = (function () {
    const cache = Object.create(null);
    function callback(char, sep) {
        return sep ? `-${char.toLowerCase()}` : char.toLowerCase();
    }
    return function (input) {
        let output = cache[input];
        if (output === void 0) {
            output = cache[input] = baseCase(input, callback);
        }
        return output;
    };
})();
/**
 * Efficiently (up to 10x faster than `Array.from`) convert an `ArrayLike` to a real array.
 *
 * Primarily used by Aurelia to convert DOM node lists to arrays.
 */
function toArray(input) {
    // benchmark: http://jsben.ch/xjsyF
    const { length } = input;
    const arr = Array(length);
    for (let i = 0; i < length; ++i) {
        arr[i] = input[i];
    }
    return arr;
}
const ids = {};
/**
 * Retrieve the next ID in a sequence for a given string, starting with `1`.
 *
 * Used by Aurelia to assign unique ID's to controllers and resources.
 *
 * Aurelia will always prepend the context name with `au$`, so as long as you avoid
 * using that convention you should be safe from collisions.
 */
function nextId(context) {
    if (ids[context] === void 0) {
        ids[context] = 0;
    }
    return ++ids[context];
}
/**
 * Reset the ID for the given string, so that `nextId` will return `1` again for the next call.
 *
 * Used by Aurelia to reset ID's in between unit tests.
 */
function resetId(context) {
    ids[context] = 0;
}
/**
 * A compare function to pass to `Array.prototype.sort` for sorting numbers.
 * This is needed for numeric sort, since the default sorts them as strings.
 */
function compareNumber(a, b) {
    return a - b;
}
/**
 * Efficiently merge and deduplicate the (primitive) values in two arrays.
 *
 * Does not deduplicate existing values in the first array.
 *
 * Guards against null or undefined arrays.
 *
 * Returns `emptyArray` if both arrays are either `null`, `undefined` or `emptyArray`
 *
 * @param slice - If `true`, always returns a new array copy (unless neither array is/has a value)
 */
function mergeDistinct(arr1, arr2, slice) {
    if (arr1 === void 0 || arr1 === null || arr1 === _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        if (arr2 === void 0 || arr2 === null || arr2 === _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
            return _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        else {
            return slice ? arr2.slice(0) : arr2;
        }
    }
    else if (arr2 === void 0 || arr2 === null || arr2 === _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        return slice ? arr1.slice(0) : arr1;
    }
    const lookup = {};
    const arr3 = slice ? arr1.slice(0) : arr1;
    let len1 = arr1.length;
    let len2 = arr2.length;
    while (len1-- > 0) {
        lookup[arr1[len1]] = true;
    }
    let item;
    while (len2-- > 0) {
        item = arr2[len2];
        if (lookup[item] === void 0) {
            arr3.push(item);
            lookup[item] = true;
        }
    }
    return arr3;
}
/**
 * Decorator. (lazily) bind the method to the class instance on first call.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function bound(target, key, descriptor) {
    return {
        configurable: true,
        enumerable: descriptor.enumerable,
        get() {
            const boundFn = descriptor.value.bind(this);
            Reflect.defineProperty(this, key, {
                value: boundFn,
                writable: true,
                configurable: true,
                enumerable: descriptor.enumerable,
            });
            return boundFn;
        },
    };
}
function mergeArrays(...arrays) {
    const result = [];
    let k = 0;
    const arraysLen = arrays.length;
    let arrayLen = 0;
    let array;
    for (let i = 0; i < arraysLen; ++i) {
        array = arrays[i];
        if (array !== void 0) {
            arrayLen = array.length;
            for (let j = 0; j < arrayLen; ++j) {
                result[k++] = array[j];
            }
        }
    }
    return result;
}
function mergeObjects(...objects) {
    const result = {};
    const objectsLen = objects.length;
    let object;
    let key;
    for (let i = 0; i < objectsLen; ++i) {
        object = objects[i];
        if (object !== void 0) {
            for (key in object) {
                result[key] = object[key];
            }
        }
    }
    return result;
}
function firstDefined(...values) {
    const len = values.length;
    let value;
    for (let i = 0; i < len; ++i) {
        value = values[i];
        if (value !== void 0) {
            return value;
        }
    }
    throw new Error(`No default value found`);
}
const getPrototypeChain = (function () {
    const functionPrototype = Function.prototype;
    const getPrototypeOf = Object.getPrototypeOf;
    const cache = new WeakMap();
    let proto = functionPrototype;
    let i = 0;
    let chain = void 0;
    return function (Type) {
        chain = cache.get(Type);
        if (chain === void 0) {
            cache.set(Type, chain = [proto = Type]);
            i = 0;
            while ((proto = getPrototypeOf(proto)) !== functionPrototype) {
                chain[++i] = proto;
            }
        }
        return chain;
    };
})();
function toLookup(...objs) {
    return Object.assign(Object.create(null), ...objs);
}
/**
 * Determine whether the value is a native function.
 *
 * @param fn - The function to check.
 * @returns `true` is the function is a native function, otherwise `false`
 */
const isNativeFunction = (function () {
    // eslint-disable-next-line @typescript-eslint/ban-types
    const lookup = new WeakMap();
    let isNative = false;
    let sourceText = '';
    let i = 0;
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (fn) {
        isNative = lookup.get(fn);
        if (isNative === void 0) {
            sourceText = fn.toString();
            i = sourceText.length;
            // http://www.ecma-international.org/ecma-262/#prod-NativeFunction
            isNative = (
            // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string
            i >= 29 &&
                // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.
                i <= 100 &&
                // This whole heuristic *could* be tricked by a comment. Do we need to care about that?
                sourceText.charCodeAt(i - 1) === 0x7D && // }
                // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.
                sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace
                sourceText.charCodeAt(i - 3) === 0x5D && // ]
                sourceText.charCodeAt(i - 4) === 0x65 && // e
                sourceText.charCodeAt(i - 5) === 0x64 && // d
                sourceText.charCodeAt(i - 6) === 0x6F && // o
                sourceText.charCodeAt(i - 7) === 0x63 && // c
                sourceText.charCodeAt(i - 8) === 0x20 && //
                sourceText.charCodeAt(i - 9) === 0x65 && // e
                sourceText.charCodeAt(i - 10) === 0x76 && // v
                sourceText.charCodeAt(i - 11) === 0x69 && // i
                sourceText.charCodeAt(i - 12) === 0x74 && // t
                sourceText.charCodeAt(i - 13) === 0x61 && // a
                sourceText.charCodeAt(i - 14) === 0x6E && // n
                sourceText.charCodeAt(i - 15) === 0x58 // [
            );
            lookup.set(fn, isNative);
        }
        return isNative;
    };
})();
/**
 * Normalize a potential promise via a callback, to ensure things stay synchronous when they can.
 *
 * If the value is a promise, it is `then`ed before the callback is invoked. Otherwise the callback is invoked synchronously.
 */
function onResolve(maybePromise, resolveCallback) {
    if (maybePromise instanceof Promise) {
        return maybePromise.then(resolveCallback);
    }
    return resolveCallback(maybePromise);
}
/**
 * Normalize an array of potential promises, to ensure things stay synchronous when they can.
 *
 * If exactly one value is a promise, then that promise is returned.
 *
 * If more than one value is a promise, a new `Promise.all` is returned.
 *
 * If none of the values is a promise, nothing is returned, to indicate that things can stay synchronous.
 */
function resolveAll(...maybePromises) {
    let maybePromise = void 0;
    let firstPromise = void 0;
    let promises = void 0;
    for (let i = 0, ii = maybePromises.length; i < ii; ++i) {
        maybePromise = maybePromises[i];
        if ((maybePromise = maybePromises[i]) instanceof Promise) {
            if (firstPromise === void 0) {
                firstPromise = maybePromise;
            }
            else if (promises === void 0) {
                promises = [firstPromise, maybePromise];
            }
            else {
                promises.push(maybePromise);
            }
        }
    }
    if (promises === void 0) {
        return firstPromise;
    }
    return Promise.all(promises);
}
//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IPlatform": () => /* binding */ IPlatform,
/* harmony export */   "Platform": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Platform,
/* harmony export */   "TaskQueue": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueue,
/* harmony export */   "Task": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Task,
/* harmony export */   "TaskAbortError": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskAbortError,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueuePriority,
/* harmony export */   "TaskStatus": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskStatus,
/* harmony export */   "all": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.all,
/* harmony export */   "DI": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.DI,
/* harmony export */   "IContainer": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.IContainer,
/* harmony export */   "inject": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.inject,
/* harmony export */   "IServiceLocator": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.IServiceLocator,
/* harmony export */   "lazy": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.lazy,
/* harmony export */   "optional": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.optional,
/* harmony export */   "ignore": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.ignore,
/* harmony export */   "Registration": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.Registration,
/* harmony export */   "singleton": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.singleton,
/* harmony export */   "transient": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.transient,
/* harmony export */   "InstanceProvider": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider,
/* harmony export */   "newInstanceForScope": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.newInstanceForScope,
/* harmony export */   "newInstanceOf": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.newInstanceOf,
/* harmony export */   "ContainerConfiguration": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.ContainerConfiguration,
/* harmony export */   "DefaultResolver": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.DefaultResolver,
/* harmony export */   "metadata": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata,
/* harmony export */   "Metadata": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Metadata,
/* harmony export */   "isNullOrUndefined": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined,
/* harmony export */   "isObject": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.isObject,
/* harmony export */   "applyMetadataPolyfill": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.applyMetadataPolyfill,
/* harmony export */   "LogLevel": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.LogLevel,
/* harmony export */   "ColorOptions": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ColorOptions,
/* harmony export */   "ILogConfig": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ILogConfig,
/* harmony export */   "ILogEventFactory": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ILogEventFactory,
/* harmony export */   "ISink": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ISink,
/* harmony export */   "ILogger": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ILogger,
/* harmony export */   "LogConfig": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.LogConfig,
/* harmony export */   "DefaultLogEvent": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.DefaultLogEvent,
/* harmony export */   "DefaultLogEventFactory": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.DefaultLogEventFactory,
/* harmony export */   "DefaultLogger": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.DefaultLogger,
/* harmony export */   "ConsoleSink": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ConsoleSink,
/* harmony export */   "LoggerConfiguration": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.LoggerConfiguration,
/* harmony export */   "format": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.format,
/* harmony export */   "sink": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.sink,
/* harmony export */   "IModuleLoader": () => /* reexport safe */ _module_loader_js__WEBPACK_IMPORTED_MODULE_4__.IModuleLoader,
/* harmony export */   "AnalyzedModule": () => /* reexport safe */ _module_loader_js__WEBPACK_IMPORTED_MODULE_4__.AnalyzedModule,
/* harmony export */   "ModuleItem": () => /* reexport safe */ _module_loader_js__WEBPACK_IMPORTED_MODULE_4__.ModuleItem,
/* harmony export */   "noop": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_5__.noop,
/* harmony export */   "emptyArray": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_5__.emptyArray,
/* harmony export */   "emptyObject": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_5__.emptyObject,
/* harmony export */   "Protocol": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.Protocol,
/* harmony export */   "fromAnnotationOrDefinitionOrTypeOrDefault": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.fromAnnotationOrDefinitionOrTypeOrDefault,
/* harmony export */   "fromAnnotationOrTypeOrDefault": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.fromAnnotationOrTypeOrDefault,
/* harmony export */   "fromDefinitionOrDefault": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.fromDefinitionOrDefault,
/* harmony export */   "EventAggregator": () => /* reexport safe */ _eventaggregator_js__WEBPACK_IMPORTED_MODULE_7__.EventAggregator,
/* harmony export */   "IEventAggregator": () => /* reexport safe */ _eventaggregator_js__WEBPACK_IMPORTED_MODULE_7__.IEventAggregator,
/* harmony export */   "isArrayIndex": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isArrayIndex,
/* harmony export */   "camelCase": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.camelCase,
/* harmony export */   "kebabCase": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.kebabCase,
/* harmony export */   "pascalCase": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.pascalCase,
/* harmony export */   "toArray": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.toArray,
/* harmony export */   "nextId": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.nextId,
/* harmony export */   "resetId": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.resetId,
/* harmony export */   "compareNumber": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.compareNumber,
/* harmony export */   "mergeDistinct": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.mergeDistinct,
/* harmony export */   "isNumberOrBigInt": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isNumberOrBigInt,
/* harmony export */   "isStringOrDate": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isStringOrDate,
/* harmony export */   "bound": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.bound,
/* harmony export */   "mergeArrays": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.mergeArrays,
/* harmony export */   "mergeObjects": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.mergeObjects,
/* harmony export */   "firstDefined": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.firstDefined,
/* harmony export */   "getPrototypeChain": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.getPrototypeChain,
/* harmony export */   "isNativeFunction": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isNativeFunction,
/* harmony export */   "onResolve": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.onResolve,
/* harmony export */   "resolveAll": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.resolveAll
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger.js */ "./node_modules/@aurelia/kernel/dist/esm/logger.js");
/* harmony import */ var _module_loader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./module-loader.js */ "./node_modules/@aurelia/kernel/dist/esm/module-loader.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");
/* harmony import */ var _eventaggregator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./eventaggregator.js */ "./node_modules/@aurelia/kernel/dist/esm/eventaggregator.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./functions.js */ "./node_modules/@aurelia/kernel/dist/esm/functions.js");

const IPlatform = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IPlatform');









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/logger.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/logger.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogLevel": () => /* binding */ LogLevel,
/* harmony export */   "ColorOptions": () => /* binding */ ColorOptions,
/* harmony export */   "ILogConfig": () => /* binding */ ILogConfig,
/* harmony export */   "ISink": () => /* binding */ ISink,
/* harmony export */   "ILogEventFactory": () => /* binding */ ILogEventFactory,
/* harmony export */   "ILogger": () => /* binding */ ILogger,
/* harmony export */   "ILogScopes": () => /* binding */ ILogScopes,
/* harmony export */   "LoggerSink": () => /* binding */ LoggerSink,
/* harmony export */   "sink": () => /* binding */ sink,
/* harmony export */   "format": () => /* binding */ format,
/* harmony export */   "LogConfig": () => /* binding */ LogConfig,
/* harmony export */   "DefaultLogEvent": () => /* binding */ DefaultLogEvent,
/* harmony export */   "DefaultLogEventFactory": () => /* binding */ DefaultLogEventFactory,
/* harmony export */   "ConsoleSink": () => /* binding */ ConsoleSink,
/* harmony export */   "DefaultLogger": () => /* binding */ DefaultLogger,
/* harmony export */   "LoggerConfiguration": () => /* binding */ LoggerConfiguration
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions.js */ "./node_modules/@aurelia/kernel/dist/esm/functions.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




var LogLevel;
(function (LogLevel) {
    /**
     * The most detailed information about internal app state.
     *
     * Disabled by default and should never be enabled in a production environment.
     */
    LogLevel[LogLevel["trace"] = 0] = "trace";
    /**
     * Information that is useful for debugging during development and has no long-term value.
     */
    LogLevel[LogLevel["debug"] = 1] = "debug";
    /**
     * Information about the general flow of the application that has long-term value.
     */
    LogLevel[LogLevel["info"] = 2] = "info";
    /**
     * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.
     */
    LogLevel[LogLevel["warn"] = 3] = "warn";
    /**
     * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.
     */
    LogLevel[LogLevel["error"] = 4] = "error";
    /**
     * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.
     */
    LogLevel[LogLevel["fatal"] = 5] = "fatal";
    /**
     * No messages should be written.
     */
    LogLevel[LogLevel["none"] = 6] = "none";
})(LogLevel || (LogLevel = {}));
/**
 * Flags to enable/disable color usage in the logging output.
 */
var ColorOptions;
(function (ColorOptions) {
    /**
     * Do not use ASCII color codes in logging output.
     */
    ColorOptions[ColorOptions["noColors"] = 0] = "noColors";
    /**
     * Use ASCII color codes in logging output. By default, timestamps and the TRC and DBG prefix are colored grey. INF white, WRN yellow, and ERR and FTL red.
     */
    ColorOptions[ColorOptions["colors"] = 1] = "colors";
})(ColorOptions || (ColorOptions = {}));
const ILogConfig = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogConfig', x => x.instance(new LogConfig(0 /* noColors */, 3 /* warn */)));
const ISink = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISink');
const ILogEventFactory = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogEventFactory', x => x.singleton(DefaultLogEventFactory));
const ILogger = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogger', x => x.singleton(DefaultLogger));
const ILogScopes = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogScope');
const LoggerSink = Object.freeze({
    key: _resource_js__WEBPACK_IMPORTED_MODULE_2__.Protocol.annotation.keyFor('logger-sink-handles'),
    define(target, definition) {
        _aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata.define(this.key, definition.handles, target.prototype);
        return target;
    },
    getHandles(target) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata.get(this.key, target);
    },
});
function sink(definition) {
    return function (target) {
        return LoggerSink.define(target, definition);
    };
}
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
const format = (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
    red(str) {
        return `\u001b[31m${str}\u001b[39m`;
    },
    green(str) {
        return `\u001b[32m${str}\u001b[39m`;
    },
    yellow(str) {
        return `\u001b[33m${str}\u001b[39m`;
    },
    blue(str) {
        return `\u001b[34m${str}\u001b[39m`;
    },
    magenta(str) {
        return `\u001b[35m${str}\u001b[39m`;
    },
    cyan(str) {
        return `\u001b[36m${str}\u001b[39m`;
    },
    white(str) {
        return `\u001b[37m${str}\u001b[39m`;
    },
    grey(str) {
        return `\u001b[90m${str}\u001b[39m`;
    },
});
class LogConfig {
    constructor(colorOptions, level) {
        this.colorOptions = colorOptions;
        this.level = level;
    }
}
const getLogLevelString = (function () {
    const logLevelString = [
        (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
            TRC: 'TRC',
            DBG: 'DBG',
            INF: 'INF',
            WRN: 'WRN',
            ERR: 'ERR',
            FTL: 'FTL',
            QQQ: '???',
        }),
        (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
            TRC: format.grey('TRC'),
            DBG: format.grey('DBG'),
            INF: format.white('INF'),
            WRN: format.yellow('WRN'),
            ERR: format.red('ERR'),
            FTL: format.red('FTL'),
            QQQ: format.grey('???'),
        }),
    ];
    return function (level, colorOptions) {
        if (level <= 0 /* trace */) {
            return logLevelString[colorOptions].TRC;
        }
        if (level <= 1 /* debug */) {
            return logLevelString[colorOptions].DBG;
        }
        if (level <= 2 /* info */) {
            return logLevelString[colorOptions].INF;
        }
        if (level <= 3 /* warn */) {
            return logLevelString[colorOptions].WRN;
        }
        if (level <= 4 /* error */) {
            return logLevelString[colorOptions].ERR;
        }
        if (level <= 5 /* fatal */) {
            return logLevelString[colorOptions].FTL;
        }
        return logLevelString[colorOptions].QQQ;
    };
})();
function getScopeString(scope, colorOptions) {
    if (colorOptions === 0 /* noColors */) {
        return scope.join('.');
    }
    return scope.map(format.cyan).join('.');
}
function getIsoString(timestamp, colorOptions) {
    if (colorOptions === 0 /* noColors */) {
        return new Date(timestamp).toISOString();
    }
    return format.grey(new Date(timestamp).toISOString());
}
class DefaultLogEvent {
    constructor(severity, message, optionalParams, scope, colorOptions, timestamp) {
        this.severity = severity;
        this.message = message;
        this.optionalParams = optionalParams;
        this.scope = scope;
        this.colorOptions = colorOptions;
        this.timestamp = timestamp;
    }
    toString() {
        const { severity, message, scope, colorOptions, timestamp } = this;
        if (scope.length === 0) {
            return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;
        }
        return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;
    }
}
let DefaultLogEventFactory = class DefaultLogEventFactory {
    constructor(config) {
        this.config = config;
    }
    createLogEvent(logger, level, message, optionalParams) {
        return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());
    }
};
DefaultLogEventFactory = __decorate([
    __param(0, ILogConfig)
], DefaultLogEventFactory);

class ConsoleSink {
    constructor($console) {
        this.handleEvent = function emit(event) {
            const optionalParams = event.optionalParams;
            if (optionalParams === void 0 || optionalParams.length === 0) {
                switch (event.severity) {
                    case 0 /* trace */:
                    case 1 /* debug */:
                        return $console.debug(event.toString());
                    case 2 /* info */:
                        return $console.info(event.toString());
                    case 3 /* warn */:
                        return $console.warn(event.toString());
                    case 4 /* error */:
                    case 5 /* fatal */:
                        return $console.error(event.toString());
                }
            }
            else {
                switch (event.severity) {
                    case 0 /* trace */:
                    case 1 /* debug */:
                        return $console.debug(event.toString(), ...optionalParams);
                    case 2 /* info */:
                        return $console.info(event.toString(), ...optionalParams);
                    case 3 /* warn */:
                        return $console.warn(event.toString(), ...optionalParams);
                    case 4 /* error */:
                    case 5 /* fatal */:
                        return $console.error(event.toString(), ...optionalParams);
                }
            }
        };
    }
}
let DefaultLogger = class DefaultLogger {
    constructor(
    /**
     * The global logger configuration.
     */
    config, factory, sinks, 
    /**
     * The scopes that this logger was created for, if any.
     */
    scope = [], parent = null) {
        this.config = config;
        this.factory = factory;
        this.scope = scope;
        this.scopedLoggers = Object.create(null);
        let traceSinks;
        let debugSinks;
        let infoSinks;
        let warnSinks;
        let errorSinks;
        let fatalSinks;
        if (parent === null) {
            this.root = this;
            this.parent = this;
            traceSinks = this.traceSinks = [];
            debugSinks = this.debugSinks = [];
            infoSinks = this.infoSinks = [];
            warnSinks = this.warnSinks = [];
            errorSinks = this.errorSinks = [];
            fatalSinks = this.fatalSinks = [];
            for (const $sink of sinks) {
                const handles = LoggerSink.getHandles($sink);
                if (handles?.includes(0 /* trace */) ?? true) {
                    traceSinks.push($sink);
                }
                if (handles?.includes(1 /* debug */) ?? true) {
                    debugSinks.push($sink);
                }
                if (handles?.includes(2 /* info */) ?? true) {
                    infoSinks.push($sink);
                }
                if (handles?.includes(3 /* warn */) ?? true) {
                    warnSinks.push($sink);
                }
                if (handles?.includes(4 /* error */) ?? true) {
                    errorSinks.push($sink);
                }
                if (handles?.includes(5 /* fatal */) ?? true) {
                    fatalSinks.push($sink);
                }
            }
        }
        else {
            this.root = parent.root;
            this.parent = parent;
            traceSinks = this.traceSinks = parent.traceSinks;
            debugSinks = this.debugSinks = parent.debugSinks;
            infoSinks = this.infoSinks = parent.infoSinks;
            warnSinks = this.warnSinks = parent.warnSinks;
            errorSinks = this.errorSinks = parent.errorSinks;
            fatalSinks = this.fatalSinks = parent.fatalSinks;
        }
    }
    trace(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 0 /* trace */) {
            this.emit(this.traceSinks, 0 /* trace */, messageOrGetMessage, optionalParams);
        }
    }
    debug(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 1 /* debug */) {
            this.emit(this.debugSinks, 1 /* debug */, messageOrGetMessage, optionalParams);
        }
    }
    info(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 2 /* info */) {
            this.emit(this.infoSinks, 2 /* info */, messageOrGetMessage, optionalParams);
        }
    }
    warn(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 3 /* warn */) {
            this.emit(this.warnSinks, 3 /* warn */, messageOrGetMessage, optionalParams);
        }
    }
    error(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 4 /* error */) {
            this.emit(this.errorSinks, 4 /* error */, messageOrGetMessage, optionalParams);
        }
    }
    fatal(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 5 /* fatal */) {
            this.emit(this.fatalSinks, 5 /* fatal */, messageOrGetMessage, optionalParams);
        }
    }
    /**
     * Create a new logger with an additional permanent prefix added to the logging outputs.
     * When chained, multiple scopes are separated by a dot.
     *
     * This is preliminary API and subject to change before alpha release.
     *
     * @example
     *
     * ```ts
     * export class MyComponent {
     *   constructor(@ILogger private logger: ILogger) {
     *     this.logger.debug('before scoping');
     *     // console output: '[DBG] before scoping'
     *     this.logger = logger.scopeTo('MyComponent');
     *     this.logger.debug('after scoping');
     *     // console output: '[DBG MyComponent] after scoping'
     *   }
     *
     *   public doStuff(): void {
     *     const logger = this.logger.scopeTo('doStuff()');
     *     logger.debug('doing stuff');
     *     // console output: '[DBG MyComponent.doStuff()] doing stuff'
     *   }
     * }
     * ```
     */
    scopeTo(name) {
        const scopedLoggers = this.scopedLoggers;
        let scopedLogger = scopedLoggers[name];
        if (scopedLogger === void 0) {
            scopedLogger = scopedLoggers[name] = new DefaultLogger(this.config, this.factory, (void 0), this.scope.concat(name), this);
        }
        return scopedLogger;
    }
    emit(sinks, level, msgOrGetMsg, optionalParams) {
        const message = typeof msgOrGetMsg === 'function' ? msgOrGetMsg() : msgOrGetMsg;
        const event = this.factory.createLogEvent(this, level, message, optionalParams);
        for (let i = 0, ii = sinks.length; i < ii; ++i) {
            sinks[i].handleEvent(event);
        }
    }
};
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "trace", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "debug", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "info", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "warn", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "error", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "fatal", null);
DefaultLogger = __decorate([
    __param(0, ILogConfig),
    __param(1, ILogEventFactory),
    __param(2, (0,_di_js__WEBPACK_IMPORTED_MODULE_0__.all)(ISink)),
    __param(3, (0,_di_js__WEBPACK_IMPORTED_MODULE_0__.optional)(ILogScopes)),
    __param(4, _di_js__WEBPACK_IMPORTED_MODULE_0__.ignore)
], DefaultLogger);

/**
 * A basic `ILogger` configuration that configures a single `console` sink based on provided options.
 *
 * NOTE: You *must* register the return value of `.create` with the container / au instance, not this `LoggerConfiguration` object itself.
 *
 * @example
 * ```ts
 * container.register(LoggerConfiguration.create());
 *
 * container.register(LoggerConfiguration.create({$console: console}))
 *
 * container.register(LoggerConfiguration.create({$console: console, level: LogLevel.debug}))
 *
 * container.register(LoggerConfiguration.create({
 *  $console: {
 *     debug: noop,
 *     info: noop,
 *     warn: noop,
 *     error: msg => {
 *       throw new Error(msg);
 *     }
 *  },
 *  level: LogLevel.debug
 * }))
 *
 * ```
 */
const LoggerConfiguration = (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
    /**
     * @param $console - The `console` object to use. Can be the native `window.console` / `global.console`, but can also be a wrapper or mock that implements the same interface.
     * @param level - The global `LogLevel` to configure. Defaults to `warn` or higher.
     * @param colorOptions - Whether to use colors or not. Defaults to `noColors`. Colors are especially nice in nodejs environments but don't necessarily work (well) in all environments, such as browsers.
     */
    create({ $console, level = 3 /* warn */, colorOptions = 0 /* noColors */, sinks = [], } = {}) {
        return (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
            register(container) {
                container.register(_di_js__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(ILogConfig, new LogConfig(colorOptions, level)));
                if ($console !== void 0 && $console !== null) {
                    container.register(_di_js__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(ISink, new ConsoleSink($console)));
                }
                for (const $sink of sinks) {
                    container.register(_di_js__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(ISink, $sink));
                }
                return container;
            },
        });
    },
});
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/module-loader.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/module-loader.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IModuleLoader": () => /* binding */ IModuleLoader,
/* harmony export */   "ModuleLoader": () => /* binding */ ModuleLoader,
/* harmony export */   "AnalyzedModule": () => /* binding */ AnalyzedModule,
/* harmony export */   "ModuleItem": () => /* binding */ ModuleItem
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");



const IModuleLoader = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface(x => x.singleton(ModuleLoader));
function noTransform(m) {
    return m;
}
class ModuleTransformer {
    constructor($transform) {
        this.$transform = $transform;
        this.promiseCache = new Map();
        this.objectCache = new Map();
    }
    transform(objOrPromise) {
        if (objOrPromise instanceof Promise) {
            return this.transformPromise(objOrPromise);
        }
        else if (typeof objOrPromise === 'object' && objOrPromise !== null) {
            return this.transformObject(objOrPromise);
        }
        else {
            throw new Error(`Invalid input: ${String(objOrPromise)}. Expected Promise or Object.`);
        }
    }
    transformPromise(promise) {
        if (this.promiseCache.has(promise)) {
            return this.promiseCache.get(promise);
        }
        const ret = promise.then(obj => {
            return this.transformObject(obj);
        });
        this.promiseCache.set(promise, ret);
        void ret.then(value => {
            // make it synchronous for future requests
            this.promiseCache.set(promise, value);
        });
        return ret;
    }
    transformObject(obj) {
        if (this.objectCache.has(obj)) {
            return this.objectCache.get(obj);
        }
        const ret = this.$transform(this.analyze(obj));
        this.objectCache.set(obj, ret);
        if (ret instanceof Promise) {
            void ret.then(value => {
                // make it synchronous for future requests
                this.objectCache.set(obj, value);
            });
        }
        return ret;
    }
    analyze(m) {
        let value;
        let isRegistry;
        let isConstructable;
        let definitions;
        const items = [];
        for (const key in m) {
            switch (typeof (value = m[key])) {
                case 'object':
                    if (value === null) {
                        continue;
                    }
                    isRegistry = typeof value.register === 'function';
                    isConstructable = false;
                    definitions = _platform_js__WEBPACK_IMPORTED_MODULE_1__.emptyArray;
                    break;
                case 'function':
                    isRegistry = typeof value.register === 'function';
                    isConstructable = value.prototype !== void 0;
                    definitions = _resource_js__WEBPACK_IMPORTED_MODULE_2__.Protocol.resource.getAll(value);
                    break;
                default:
                    continue;
            }
            items.push(new ModuleItem(key, value, isRegistry, isConstructable, definitions));
        }
        return new AnalyzedModule(m, items);
    }
}
class ModuleLoader {
    constructor() {
        this.transformers = new Map();
    }
    load(objOrPromise, transform = noTransform) {
        const transformers = this.transformers;
        let transformer = transformers.get(transform);
        if (transformer === void 0) {
            transformers.set(transform, transformer = new ModuleTransformer(transform));
        }
        return transformer.transform(objOrPromise);
    }
    dispose() {
        this.transformers.clear();
    }
}
class AnalyzedModule {
    constructor(raw, items) {
        this.raw = raw;
        this.items = items;
    }
}
class ModuleItem {
    constructor(key, value, isRegistry, isConstructable, definitions) {
        this.key = key;
        this.value = value;
        this.isRegistry = isRegistry;
        this.isConstructable = isConstructable;
        this.definitions = definitions;
    }
}
//# sourceMappingURL=module-loader.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/platform.js":
/*!***********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/platform.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "emptyArray": () => /* binding */ emptyArray,
/* harmony export */   "emptyObject": () => /* binding */ emptyObject,
/* harmony export */   "noop": () => /* binding */ noop
/* harmony export */ });
/* eslint-disable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */
const emptyArray = Object.freeze([]);
const emptyObject = Object.freeze({});
/* eslint-enable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */
// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() { }
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/resource.js":
/*!***********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/resource.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Protocol": () => /* binding */ Protocol,
/* harmony export */   "fromAnnotationOrDefinitionOrTypeOrDefault": () => /* binding */ fromAnnotationOrDefinitionOrTypeOrDefault,
/* harmony export */   "fromAnnotationOrTypeOrDefault": () => /* binding */ fromAnnotationOrTypeOrDefault,
/* harmony export */   "fromDefinitionOrDefault": () => /* binding */ fromDefinitionOrDefault
/* harmony export */ });
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");


const annotation = {
    name: 'au:annotation',
    appendTo(target, key) {
        const keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(annotation.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(annotation.name, [key], target);
        }
        else {
            keys.push(key);
        }
    },
    set(target, prop, value) {
        _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(annotation.keyFor(prop), value, target);
    },
    get(target, prop) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(annotation.keyFor(prop), target);
    },
    getKeys(target) {
        let keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(annotation.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(annotation.name, keys = [], target);
        }
        return keys;
    },
    isKey(key) {
        return key.startsWith(annotation.name);
    },
    keyFor(name, context) {
        if (context === void 0) {
            return `${annotation.name}:${name}`;
        }
        return `${annotation.name}:${name}:${context}`;
    },
};
const resource = {
    name: 'au:resource',
    appendTo(target, key) {
        const keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(resource.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(resource.name, [key], target);
        }
        else {
            keys.push(key);
        }
    },
    has(target) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(resource.name, target);
    },
    getAll(target) {
        const keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(resource.name, target);
        if (keys === void 0) {
            return _platform_js__WEBPACK_IMPORTED_MODULE_1__.emptyArray;
        }
        else {
            return keys.map(k => _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(k, target));
        }
    },
    getKeys(target) {
        let keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(resource.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(resource.name, keys = [], target);
        }
        return keys;
    },
    isKey(key) {
        return key.startsWith(resource.name);
    },
    keyFor(name, context) {
        if (context === void 0) {
            return `${resource.name}:${name}`;
        }
        return `${resource.name}:${name}:${context}`;
    },
};
const Protocol = {
    annotation,
    resource,
};
const hasOwn = Object.prototype.hasOwnProperty;
/**
 * The order in which the values are checked:
 * 1. Annotations (usually set by decorators) have the highest priority; they override the definition as well as static properties on the type.
 * 2. Definition properties (usually set by the customElement decorator object literal) come next. They override static properties on the type.
 * 3. Static properties on the type come last. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)
 * 4. The default property that is provided last. The function is only called if the default property is needed
 */
function fromAnnotationOrDefinitionOrTypeOrDefault(name, def, Type, getDefault) {
    let value = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Protocol.annotation.keyFor(name), Type);
    if (value === void 0) {
        value = def[name];
        if (value === void 0) {
            value = Type[name];
            if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain
                return getDefault();
            }
            return value;
        }
        return value;
    }
    return value;
}
/**
 * The order in which the values are checked:
 * 1. Annotations (usually set by decorators) have the highest priority; they override static properties on the type.
 * 2. Static properties on the typ. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)
 * 3. The default property that is provided last. The function is only called if the default property is needed
 */
function fromAnnotationOrTypeOrDefault(name, Type, getDefault) {
    let value = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Protocol.annotation.keyFor(name), Type);
    if (value === void 0) {
        value = Type[name];
        if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain
            return getDefault();
        }
        return value;
    }
    return value;
}
/**
 * The order in which the values are checked:
 * 1. Definition properties.
 * 2. The default property that is provided last. The function is only called if the default property is needed
 */
function fromDefinitionOrDefault(name, def, getDefault) {
    const value = def[name];
    if (value === void 0) {
        return getDefault();
    }
    return value;
}
//# sourceMappingURL=resource.js.map

/***/ }),

/***/ "./node_modules/@aurelia/metadata/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aurelia/metadata/dist/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObject": () => /* binding */ isObject,
/* harmony export */   "isNullOrUndefined": () => /* binding */ isNullOrUndefined,
/* harmony export */   "metadata": () => /* binding */ metadata,
/* harmony export */   "Metadata": () => /* binding */ Metadata,
/* harmony export */   "applyMetadataPolyfill": () => /* binding */ applyMetadataPolyfill
/* harmony export */ });
/**
 * Determine whether a value is an object.
 *
 * Uses `typeof` to guarantee this works cross-realm, which is where `instanceof Object` might fail.
 *
 * Some environments where these issues are known to arise:
 * - same-origin iframes (accessing the other realm via `window.top`)
 * - `jest`.
 *
 * The exact test is:
 * ```ts
 * typeof value === 'object' && value !== null || typeof value === 'function'
 * ```
 *
 * @param value - The value to test.
 * @returns `true` if the value is an object, otherwise `false`.
 * Also performs a type assertion that defaults to `value is Object | Function` which, if the input type is a union with an object type, will infer the correct type.
 * This can be overridden with the generic type argument.
 *
 * @example
 *
 * ```ts
 * class Foo {
 *   bar = 42;
 * }
 *
 * function doStuff(input?: Foo | null) {
 *   input.bar; // Object is possibly 'null' or 'undefined'
 *
 *   // input has an object type in its union (Foo) so that type will be extracted for the 'true' condition
 *   if (isObject(input)) {
 *     input.bar; // OK (input is now typed as Foo)
 *   }
 * }
 *
 * function doOtherStuff(input: unknown) {
 *   input.bar; // Object is of type 'unknown'
 *
 *   // input is 'unknown' so there is no union type to match and it will default to 'Object | Function'
 *   if (isObject(input)) {
 *     input.bar; // Property 'bar' does not exist on type 'Object | Function'
 *   }
 *
 *   // if we know for sure that, if input is an object, it must be a specific type, we can explicitly tell the function to assert that for us
 *   if (isObject<Foo>(input)) {
 *    input.bar; // OK (input is now typed as Foo)
 *   }
 * }
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(value) {
    return typeof value === 'object' && value !== null || typeof value === 'function';
}
/**
 * Determine whether a value is `null` or `undefined`.
 *
 * @param value - The value to test.
 * @returns `true` if the value is `null` or `undefined`, otherwise `false`.
 * Also performs a type assertion that ensures TypeScript treats the value appropriately in the `if` and `else` branches after this check.
 */
function isNullOrUndefined(value) {
    return value === null || value === void 0;
}
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/ban-types */
const metadataInternalSlot = new WeakMap();
function $typeError(operation, args, paramName, actualValue, expectedType) {
    return new TypeError(`${operation}(${args.map(String).join(',')}) - Expected '${paramName}' to be of type ${expectedType}, but got: ${Object.prototype.toString.call(actualValue)} (${String(actualValue)})`);
}
function toPropertyKeyOrUndefined(propertyKey) {
    switch (typeof propertyKey) {
        case 'undefined':
        case 'string':
        case 'symbol':
            return propertyKey;
        default:
            return `${propertyKey}`;
    }
}
function toPropertyKey(propertyKey) {
    switch (typeof propertyKey) {
        case 'string':
        case 'symbol':
            return propertyKey;
        default:
            return `${propertyKey}`;
    }
}
function ensurePropertyKeyOrUndefined(propertyKey) {
    switch (typeof propertyKey) {
        case 'undefined':
        case 'string':
        case 'symbol':
            return propertyKey;
        default:
            throw new TypeError(`Invalid metadata propertyKey: ${propertyKey}.`);
    }
}
function GetOrCreateMetadataMap(O, P, Create) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let targetMetadata be the value of O's [[Metadata]] internal slot.
    let targetMetadata = metadataInternalSlot.get(O);
    // 3. If targetMetadata is undefined, then
    if (targetMetadata === void 0) {
        // 3. a. If Create is false, return undefined.
        if (!Create) {
            return void 0;
        }
        // 3. b. Set targetMetadata to be a newly created Map object.
        targetMetadata = new Map();
        // 3. c. Set the [[Metadata]] internal slot of O to targetMetadata.
        metadataInternalSlot.set(O, targetMetadata);
    }
    // 4. Let metadataMap be ? Invoke(targetMetadata, "get", P).
    let metadataMap = targetMetadata.get(P);
    // 5. If metadataMap is undefined, then
    if (metadataMap === void 0) {
        // 5. a. If Create is false, return undefined.
        if (!Create) {
            return void 0;
        }
        // 5. b. Set metadataMap to be a newly created Map object.
        metadataMap = new Map();
        // 5. c. Perform ? Invoke(targetMetadata, "set", P, metadataMap).
        targetMetadata.set(P, metadataMap);
    }
    // 6. Return metadataMap.
    return metadataMap;
}
// 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);
    // 3. If metadataMap is undefined, return false.
    if (metadataMap === void 0) {
        return false;
    }
    // 4. Return ? ToBoolean(? Invoke(metadataMap, "has", MetadataKey)).
    return metadataMap.has(MetadataKey);
}
// 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
function OrdinaryHasMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).
    // 3. If hasOwn is true, return true.
    if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {
        return true;
    }
    // 4. Let parent be ? O.[[GetPrototypeOf]]().
    const parent = Object.getPrototypeOf(O);
    // 5. If parent is not null, Return ? parent.[[HasMetadata]](MetadataKey, P).
    if (parent !== null) {
        return OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    // 6. Return false.
    return false;
}
// 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);
    // 3. If metadataMap is undefined, return undefined.
    if (metadataMap === void 0) {
        return void 0;
    }
    // 4. Return ? Invoke(metadataMap, "get", MetadataKey).
    return metadataMap.get(MetadataKey);
}
// 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
function OrdinaryGetMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).
    // 3. If hasOwn is true, return ? OrdinaryGetOwnMetadata(MetadataKey, O, P).
    if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
    }
    // 4. Let parent be ? O.[[GetPrototypeOf]]().
    const parent = Object.getPrototypeOf(O);
    // 5. If parent is not null, return ? parent.[[GetMetadata]](MetadataKey, P).
    if (parent !== null) {
        return OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    // 6. Return undefined.
    return void 0;
}
// 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, true).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ true);
    // 3. Return ? Invoke(metadataMap, "set", MetadataKey, MetadataValue).
    metadataMap.set(MetadataKey, MetadataValue);
}
// 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
function OrdinaryOwnMetadataKeys(O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let keys be ? ArrayCreate(0).
    const keys = [];
    // 3. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);
    // 4. If metadataMap is undefined, return keys.
    if (metadataMap === void 0) {
        return keys;
    }
    // 5. Let keysObj be ? Invoke(metadataMap, "keys").
    const keysObj = metadataMap.keys();
    // 6. Let iterator be ? GetIterator(keysObj).
    // 7. Let k be 0.
    let k = 0;
    // 8. Repeat
    for (const key of keysObj) {
        // 8. a. Let Pk be ! ToString(k).
        // 8. b. Let next be ? IteratorStep(iterator).
        // 8. c. If next is false, then
        // 8. c. i. Let setStatus be ? Set(keys, "length", k, true).
        // 8. c. ii. Assert: setStatus is true.
        // 8. c. iii. Return keys.
        // 8. d. Let nextValue be ? IteratorValue(next).
        // 8. e. Let defineStatus be CreateDataPropertyOrThrow(keys, Pk, nextValue).
        keys[k] = key;
        // 8. f. If defineStatus is an abrupt completion, return ? IteratorClose(iterator, defineStatus).
        // 8. g. Increase k by 1.
        ++k;
    }
    return keys;
}
// 3.1.6.1 OrdinaryMetadataKeys(O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
function OrdinaryMetadataKeys(O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let ownKeys be ? OrdinaryOwnMetadataKeys(O, P).
    const ownKeys = OrdinaryOwnMetadataKeys(O, P);
    // 3. Let parent be ? O.[[GetPrototypeOf]]().
    const parent = Object.getPrototypeOf(O);
    // 4. If parent is null, then return ownKeys.
    if (parent === null) {
        return ownKeys;
    }
    // 5. Let parentKeys be ? O.[[OrdinaryMetadataKeys]](P).
    const parentKeys = OrdinaryMetadataKeys(parent, P);
    // 6. Let ownKeysLen = ? Get(ownKeys, "length").
    const ownKeysLen = ownKeys.length;
    // 7. If ownKeysLen is 0, return parentKeys.
    if (ownKeysLen === 0) {
        return parentKeys;
    }
    // 8. Let parentKeysLen = ? Get(parentKeys, "length").
    const parentKeysLen = parentKeys.length;
    // 9. If parentKeysLen is 0, return ownKeys.
    if (parentKeysLen === 0) {
        return ownKeys;
    }
    // 10. Let set be a newly created Set object.
    const set = new Set();
    // 11. Let keys be ? ArrayCreate(0).
    const keys = [];
    // 12. Let k be 0.
    let k = 0;
    // 13. For each element key of ownKeys
    let key;
    for (let i = 0; i < ownKeysLen; ++i) {
        key = ownKeys[i];
        // 13. a. Let hasKey be ? Invoke(set, "has", key).
        // 13. b. If hasKey is false, then
        if (!set.has(key)) {
            // 13. b. i. Let Pk be ! ToString(k).
            // 13. b. ii. Perform ? Invoke(set, "add", key).
            set.add(key);
            // 13. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).
            // 13. b. iv. Assert: defineStatus is true.
            keys[k] = key;
            // 13. b. v. Increase k by 1.
            ++k;
        }
    }
    // 14. For each element key of parentKeys
    for (let i = 0; i < parentKeysLen; ++i) {
        key = parentKeys[i];
        // 14. a. Let hasKey be ? Invoke(set, "has", key).
        // 14. b. If hasKey is false, then
        if (!set.has(key)) {
            // 14. b. i. Let Pk be ! ToString(k).
            // 14. b. ii. Perform ? Invoke(set, "add", key).
            set.add(key);
            // 14. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).
            // 14. b. iv. Assert: defineStatus is true.
            keys[k] = key;
            // 14. b. v. Increase k by 1.
            ++k;
        }
    }
    // 15. Perform ? Set(keys, "length", k).
    // 16. return keys.
    return keys;
}
// 3.1.8 DeleteMetadata(MetadataKey, P)
// https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots-deletemetadata
function OrdinaryDeleteMetadata(O, MetadataKey, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, false);
    // 3. If metadataMap is undefined, return false.
    if (metadataMap === void 0) {
        return false;
    }
    // 4. Return ? Invoke(metadataMap, "delete", MetadataKey).
    return metadataMap.delete(MetadataKey);
}
// 4.1.2 Reflect.metadata(metadataKey, metadataValue)
// https://rbuckton.github.io/reflect-metadata/#reflect.metadata
/**
 * A default metadata decorator factory that can be used on a class, class member, or parameter.
 *
 * @param metadataKey - The key for the metadata entry.
 * If `metadataKey` is already defined for the target and target key, the
 * metadataValue for that key will be overwritten.
 * @param metadataValue - The value for the metadata entry.
 * @returns A decorator function.
 */
function metadata(metadataKey, metadataValue) {
    function decorator(target, propertyKey) {
        // 1. Assert: F has a [[MetadataKey]] internal slot whose value is an ECMAScript language value, or undefined.
        // 2. Assert: F has a [[MetadataValue]] internal slot whose value is an ECMAScript language value, or undefined.
        // 3. If Type(target) is not Object, throw a TypeError exception.
        if (!isObject(target)) {
            throw $typeError('@metadata', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');
        }
        // 4. If key is not undefined and IsPropertyKey(key) is false, throw a TypeError exception.
        // 5. Let metadataKey be the value of F's [[MetadataKey]] internal slot.
        // 6. Let metadataValue be the value of F's [[MetadataValue]] internal slot.
        // 7. Perform ? target.[[DefineMetadata]](metadataKey, metadataValue, target, key).
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, ensurePropertyKeyOrUndefined(propertyKey));
        // 8. Return undefined.
    }
    return decorator;
}
function decorate(decorators, target, propertyKey, attributes) {
    if (propertyKey !== void 0) {
        if (!Array.isArray(decorators)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');
        }
        if (!isObject(target)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Object or Function');
        }
        if (!isObject(attributes) && !isNullOrUndefined(attributes)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'attributes', attributes, 'Object, Function, null, or undefined');
        }
        if (attributes === null) {
            attributes = void 0;
        }
        propertyKey = toPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
    }
    else {
        if (!Array.isArray(decorators)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');
        }
        if (typeof target !== 'function') {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Function');
        }
        return DecorateConstructor(decorators, target);
    }
}
function DecorateConstructor(decorators, target) {
    for (let i = decorators.length - 1; i >= 0; --i) {
        const decorator = decorators[i];
        const decorated = decorator(target);
        if (!isNullOrUndefined(decorated)) {
            if (typeof decorated !== 'function') {
                throw $typeError('DecorateConstructor', [decorators, target], 'decorated', decorated, 'Function, null, or undefined');
            }
            target = decorated;
        }
    }
    return target;
}
function DecorateProperty(decorators, target, propertyKey, descriptor) {
    for (let i = decorators.length - 1; i >= 0; --i) {
        const decorator = decorators[i];
        const decorated = decorator(target, propertyKey, descriptor);
        if (!isNullOrUndefined(decorated)) {
            if (!isObject(decorated)) {
                throw $typeError('DecorateProperty', [decorators, target, propertyKey, descriptor], 'decorated', decorated, 'Object, Function, null, or undefined');
            }
            descriptor = decorated;
        }
    }
    return descriptor;
}
function $define(metadataKey, metadataValue, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.define', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[DefineMetadata]](metadataKey, metadataValue, propertyKey).
    return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, toPropertyKeyOrUndefined(propertyKey));
}
function $has(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.has', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[HasMetadata]](metadataKey, propertyKey).
    return OrdinaryHasMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $hasOwn(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.hasOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[HasOwn]](metadataKey, propertyKey).
    return OrdinaryHasOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $get(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.get', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetMetadata]](metadataKey, propertyKey).
    return OrdinaryGetMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $getOwn(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.getOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetOwnMetadata]](metadataKey, propertyKey).
    return OrdinaryGetOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $getKeys(target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.getKeys', [target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetMetadataKeys]](propertyKey).
    return OrdinaryMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));
}
function $getOwnKeys(target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.getOwnKeys', [target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetOwnMetadataKeys]](propertyKey).
    return OrdinaryOwnMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));
}
function $delete(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.delete', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[DeleteMetadata]](metadataKey, propertyKey).
    return OrdinaryDeleteMetadata(target, metadataKey, toPropertyKeyOrUndefined(propertyKey));
}
const Metadata = {
    define: $define,
    has: $has,
    hasOwn: $hasOwn,
    get: $get,
    getOwn: $getOwn,
    getKeys: $getKeys,
    getOwnKeys: $getOwnKeys,
    delete: $delete,
};
function def(obj, key, value, writable, configurable) {
    if (!Reflect.defineProperty(obj, key, {
        writable,
        enumerable: false,
        configurable,
        value,
    })) {
        throw new Error(`Unable to apply metadata polyfill: could not add property '${key}' to the global Reflect object`);
    }
}
const internalSlotName = '[[$au]]';
function hasInternalSlot(reflect) {
    return internalSlotName in reflect;
}
function $applyMetadataPolyfill(reflect, writable, configurable) {
    def(reflect, internalSlotName, metadataInternalSlot, writable, configurable);
    def(reflect, 'metadata', metadata, writable, configurable);
    def(reflect, 'decorate', decorate, writable, configurable);
    def(reflect, 'defineMetadata', $define, writable, configurable);
    def(reflect, 'hasMetadata', $has, writable, configurable);
    def(reflect, 'hasOwnMetadata', $hasOwn, writable, configurable);
    def(reflect, 'getMetadata', $get, writable, configurable);
    def(reflect, 'getOwnMetadata', $getOwn, writable, configurable);
    def(reflect, 'getMetadataKeys', $getKeys, writable, configurable);
    def(reflect, 'getOwnMetadataKeys', $getOwnKeys, writable, configurable);
    def(reflect, 'deleteMetadata', $delete, writable, configurable);
}
function applyMetadataPolyfill(reflect, throwIfConflict = true, forceOverwrite = false, writable = true, configurable = true) {
    if (hasInternalSlot(reflect)) {
        if (reflect[internalSlotName] === metadataInternalSlot) {
            return;
        }
        throw new Error(`Conflicting @aurelia/metadata module import detected. Please make sure you have the same version of all Aurelia packages in your dependency tree.`);
    }
    const presentProps = [
        'metadata',
        'decorate',
        'defineMetadata',
        'hasMetadata',
        'hasOwnMetadata',
        'getMetadata',
        'getOwnMetadata',
        'getMetadataKeys',
        'getOwnMetadataKeys',
        'deleteMetadata',
    ].filter(function (p) {
        return p in Reflect;
    });
    if (presentProps.length > 0) {
        if (throwIfConflict) {
            const implementationSummary = presentProps.map(function (p) {
                const impl = `${Reflect[p].toString().slice(0, 100)}...`;
                return `${p}:\n${impl}`;
            }).join('\n\n');
            throw new Error(`Conflicting reflect.metadata polyfill found. If you have 'reflect-metadata' or any other reflect polyfill imported, please remove it, if not (or if you must use a specific polyfill) please file an issue at https://github.com/aurelia/aurelia/issues so that we can look into compatibility options for this scenario. Implementation summary:\n\n${implementationSummary}`);
        }
        else if (forceOverwrite) {
            $applyMetadataPolyfill(reflect, writable, configurable);
        }
    }
    else {
        $applyMetadataPolyfill(reflect, writable, configurable);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/platform-browser/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aurelia/platform-browser/dist/esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserPlatform": () => /* binding */ BrowserPlatform
/* harmony export */ });
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");

const lookup = new Map();
function notImplemented(name) {
    return function notImplemented() {
        throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name}'.`); // TODO: link to docs describing how to fix this issue
    };
}
class BrowserPlatform extends _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.Platform {
    constructor(g, overrides = {}) {
        super(g, overrides);
        this.domReadRequested = false;
        this.domReadHandle = -1;
        this.domWriteRequested = false;
        this.domWriteHandle = -1;
        this.Node = 'Node' in overrides ? overrides.Node : g.Node;
        this.Element = 'Element' in overrides ? overrides.Element : g.Element;
        this.HTMLElement = 'HTMLElement' in overrides ? overrides.HTMLElement : g.HTMLElement;
        this.CustomEvent = 'CustomEvent' in overrides ? overrides.CustomEvent : g.CustomEvent;
        this.CSSStyleSheet = 'CSSStyleSheet' in overrides ? overrides.CSSStyleSheet : g.CSSStyleSheet;
        this.ShadowRoot = 'ShadowRoot' in overrides ? overrides.ShadowRoot : g.ShadowRoot;
        this.MutationObserver = 'MutationObserver' in overrides ? overrides.MutationObserver : g.MutationObserver;
        this.window = 'window' in overrides ? overrides.window : g.window;
        this.document = 'document' in overrides ? overrides.document : g.document;
        this.location = 'location' in overrides ? overrides.location : g.location;
        this.history = 'history' in overrides ? overrides.history : g.history;
        this.navigator = 'navigator' in overrides ? overrides.navigator : g.navigator;
        this.fetch = 'fetch' in overrides ? overrides.fetch : g.fetch?.bind(g) ?? notImplemented('fetch');
        this.requestAnimationFrame = 'requestAnimationFrame' in overrides ? overrides.requestAnimationFrame : g.requestAnimationFrame?.bind(g) ?? notImplemented('requestAnimationFrame');
        this.cancelAnimationFrame = 'cancelAnimationFrame' in overrides ? overrides.cancelAnimationFrame : g.cancelAnimationFrame?.bind(g) ?? notImplemented('cancelAnimationFrame');
        this.customElements = 'customElements' in overrides ? overrides.customElements : g.customElements;
        this.flushDomRead = this.flushDomRead.bind(this);
        this.flushDomWrite = this.flushDomWrite.bind(this);
        this.domReadQueue = new _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueue(this, this.requestDomRead.bind(this), this.cancelDomRead.bind(this));
        this.domWriteQueue = new _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueue(this, this.requestDomWrite.bind(this), this.cancelDomWrite.bind(this));
        /* eslint-enable @typescript-eslint/no-unnecessary-type-assertion */
    }
    static getOrCreate(g, overrides = {}) {
        let platform = lookup.get(g);
        if (platform === void 0) {
            lookup.set(g, platform = new BrowserPlatform(g, overrides));
        }
        return platform;
    }
    static set(g, platform) {
        lookup.set(g, platform);
    }
    requestDomRead() {
        this.domReadRequested = true;
        // Yes, this is intentional: the timing of the read can only be "found" by doing a write first.
        // The flushDomWrite queues the read.
        // If/when requestPostAnimationFrame is implemented in browsers, we can use that instead.
        if (this.domWriteHandle === -1) {
            this.domWriteHandle = this.requestAnimationFrame(this.flushDomWrite);
        }
    }
    cancelDomRead() {
        this.domReadRequested = false;
        if (this.domReadHandle > -1) {
            this.clearTimeout(this.domReadHandle);
            this.domReadHandle = -1;
        }
        if (this.domWriteRequested === false && this.domWriteHandle > -1) {
            this.cancelAnimationFrame(this.domWriteHandle);
            this.domWriteHandle = -1;
        }
    }
    flushDomRead() {
        this.domReadHandle = -1;
        if (this.domReadRequested === true) {
            this.domReadRequested = false;
            this.domReadQueue.flush();
        }
    }
    requestDomWrite() {
        this.domWriteRequested = true;
        if (this.domWriteHandle === -1) {
            this.domWriteHandle = this.requestAnimationFrame(this.flushDomWrite);
        }
    }
    cancelDomWrite() {
        this.domWriteRequested = false;
        if (this.domWriteHandle > -1 &&
            // if dom read is requested and there is no readHandle yet, we need the rAF to proceed regardless.
            // The domWriteRequested=false will prevent the read flush from happening.
            (this.domReadRequested === false || this.domReadHandle > -1)) {
            this.cancelAnimationFrame(this.domWriteHandle);
            this.domWriteHandle = -1;
        }
    }
    flushDomWrite() {
        this.domWriteHandle = -1;
        if (this.domWriteRequested === true) {
            this.domWriteRequested = false;
            this.domWriteQueue.flush();
        }
        if (this.domReadRequested === true && this.domReadHandle === -1) {
            this.domReadHandle = this.setTimeout(this.flushDomRead, 0);
        }
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/platform/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aurelia/platform/dist/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Platform": () => /* binding */ Platform,
/* harmony export */   "TaskQueue": () => /* binding */ TaskQueue,
/* harmony export */   "TaskAbortError": () => /* binding */ TaskAbortError,
/* harmony export */   "TaskStatus": () => /* binding */ TaskStatus,
/* harmony export */   "Task": () => /* binding */ Task,
/* harmony export */   "TaskQueuePriority": () => /* binding */ TaskQueuePriority
/* harmony export */ });
const lookup = new Map();
function notImplemented(name) {
    return function notImplemented() {
        throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name}'.`); // TODO: link to docs describing how to fix this issue
    };
}
class Platform {
    constructor(g, overrides = {}) {
        this.macroTaskRequested = false;
        this.macroTaskHandle = -1;
        this.globalThis = g;
        this.decodeURI = 'decodeURI' in overrides ? overrides.decodeURI : g.decodeURI;
        this.decodeURIComponent = 'decodeURIComponent' in overrides ? overrides.decodeURIComponent : g.decodeURIComponent;
        this.encodeURI = 'encodeURI' in overrides ? overrides.encodeURI : g.encodeURI;
        this.encodeURIComponent = 'encodeURIComponent' in overrides ? overrides.encodeURIComponent : g.encodeURIComponent;
        this.Date = 'Date' in overrides ? overrides.Date : g.Date;
        this.Reflect = 'Reflect' in overrides ? overrides.Reflect : g.Reflect;
        this.clearInterval = 'clearInterval' in overrides ? overrides.clearInterval : g.clearInterval?.bind(g) ?? notImplemented('clearInterval');
        this.clearTimeout = 'clearTimeout' in overrides ? overrides.clearTimeout : g.clearTimeout?.bind(g) ?? notImplemented('clearTimeout');
        this.queueMicrotask = 'queueMicrotask' in overrides ? overrides.queueMicrotask : g.queueMicrotask?.bind(g) ?? notImplemented('queueMicrotask');
        this.setInterval = 'setInterval' in overrides ? overrides.setInterval : g.setInterval?.bind(g) ?? notImplemented('setInterval');
        this.setTimeout = 'setTimeout' in overrides ? overrides.setTimeout : g.setTimeout?.bind(g) ?? notImplemented('setTimeout');
        this.console = 'console' in overrides ? overrides.console : g.console;
        this.performanceNow = 'performanceNow' in overrides ? overrides.performanceNow : g.performance?.now?.bind(g.performance) ?? notImplemented('performance.now');
        this.flushMacroTask = this.flushMacroTask.bind(this);
        this.macroTaskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));
    }
    static getOrCreate(g, overrides = {}) {
        let platform = lookup.get(g);
        if (platform === void 0) {
            lookup.set(g, platform = new Platform(g, overrides));
        }
        return platform;
    }
    static set(g, platform) {
        lookup.set(g, platform);
    }
    requestMacroTask() {
        this.macroTaskRequested = true;
        if (this.macroTaskHandle === -1) {
            this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);
        }
    }
    cancelMacroTask() {
        this.macroTaskRequested = false;
        if (this.macroTaskHandle > -1) {
            this.clearTimeout(this.macroTaskHandle);
            this.macroTaskHandle = -1;
        }
    }
    flushMacroTask() {
        this.macroTaskHandle = -1;
        if (this.macroTaskRequested === true) {
            this.macroTaskRequested = false;
            this.macroTaskQueue.flush();
        }
    }
}
function isPersistent(task) {
    return task.persistent;
}
class TaskQueue {
    constructor(platform, $request, $cancel) {
        this.platform = platform;
        this.$request = $request;
        this.$cancel = $cancel;
        this.processing = [];
        this.suspenderTask = void 0;
        this.pendingAsyncCount = 0;
        this.pending = [];
        this.delayed = [];
        this.flushRequested = false;
        this.yieldPromise = void 0;
        this.taskPool = [];
        this.taskPoolSize = 0;
        this.lastRequest = 0;
        this.lastFlush = 0;
        this.requestFlush = () => {
            if (this.tracer.enabled) {
                this.tracer.enter(this, 'requestFlush');
            }
            if (!this.flushRequested) {
                this.flushRequested = true;
                this.lastRequest = this.platform.performanceNow();
                this.$request();
            }
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'requestFlush');
            }
        };
        this.tracer = new Tracer(platform.console);
    }
    get isEmpty() {
        return this.processing.length === 0 && this.pending.length === 0 && this.delayed.length === 0;
    }
    /**
     * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,
     * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.
     *
     * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.
     *
     * If that is the case, we can resolve the promise that was created when `yield()` is called.
     */
    get hasNoMoreFiniteWork() {
        return (this.pendingAsyncCount === 0 &&
            this.processing.every(isPersistent) &&
            this.pending.every(isPersistent) &&
            this.delayed.every(isPersistent));
    }
    flush(time = this.platform.performanceNow()) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'flush');
        }
        this.flushRequested = false;
        this.lastFlush = time;
        // Only process normally if we are *not* currently waiting for an async task to finish
        if (this.suspenderTask === void 0) {
            if (this.pending.length > 0) {
                this.processing.push(...this.pending);
                this.pending.length = 0;
            }
            if (this.delayed.length > 0) {
                let i = -1;
                while (++i < this.delayed.length && this.delayed[i].queueTime <= time) { /* do nothing */ }
                this.processing.push(...this.delayed.splice(0, i));
            }
            let cur;
            while (this.processing.length > 0) {
                (cur = this.processing.shift()).run();
                // If it's still running, it can only be an async task
                if (cur.status === 1 /* running */) {
                    if (cur.suspend === true) {
                        this.suspenderTask = cur;
                        this.requestFlush();
                        if (this.tracer.enabled) {
                            this.tracer.leave(this, 'flush early async');
                        }
                        return;
                    }
                    else {
                        ++this.pendingAsyncCount;
                    }
                }
            }
            if (this.pending.length > 0) {
                this.processing.push(...this.pending);
                this.pending.length = 0;
            }
            if (this.delayed.length > 0) {
                let i = -1;
                while (++i < this.delayed.length && this.delayed[i].queueTime <= time) { /* do nothing */ }
                this.processing.push(...this.delayed.splice(0, i));
            }
            if (this.processing.length > 0 || this.delayed.length > 0 || this.pendingAsyncCount > 0) {
                this.requestFlush();
            }
            if (this.yieldPromise !== void 0 &&
                this.hasNoMoreFiniteWork) {
                const p = this.yieldPromise;
                this.yieldPromise = void 0;
                p.resolve();
            }
        }
        else {
            // If we are still waiting for an async task to finish, just schedule the next flush and do nothing else.
            // Should the task finish before the next flush is invoked,
            // the callback to `completeAsyncTask` will have reset `this.suspenderTask` back to undefined so processing can return back to normal next flush.
            this.requestFlush();
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'flush full');
        }
    }
    /**
     * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.
     *
     * This operation is idempotent and will do nothing if no flush is scheduled.
     */
    cancel() {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'cancel');
        }
        if (this.flushRequested) {
            this.$cancel();
            this.flushRequested = false;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'cancel');
        }
    }
    /**
     * Returns a promise that, when awaited, resolves when:
     * - all *non*-persistent (including async) tasks have finished;
     * - the last-added persistent task has run exactly once;
     *
     * This operation is idempotent: the same promise will be returned until it resolves.
     *
     * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.
     */
    async yield() {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'yield');
        }
        if (this.isEmpty) {
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'yield empty');
            }
        }
        else {
            if (this.yieldPromise === void 0) {
                if (this.tracer.enabled) {
                    this.tracer.trace(this, 'yield - creating promise');
                }
                this.yieldPromise = createExposedPromise();
            }
            await this.yieldPromise;
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'yield task');
            }
        }
    }
    queueTask(callback, opts) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'queueTask');
        }
        const { delay, preempt, persistent, reusable, suspend } = { ...defaultQueueTaskOptions, ...opts };
        if (preempt) {
            if (delay > 0) {
                throw new Error(`Invalid arguments: preempt cannot be combined with a greater-than-zero delay`);
            }
            if (persistent) {
                throw new Error(`Invalid arguments: preempt cannot be combined with persistent`);
            }
        }
        if (this.processing.length === 0) {
            this.requestFlush();
        }
        const time = this.platform.performanceNow();
        let task;
        if (reusable) {
            const taskPool = this.taskPool;
            const index = this.taskPoolSize - 1;
            if (index >= 0) {
                task = taskPool[index];
                taskPool[index] = (void 0);
                this.taskPoolSize = index;
                task.reuse(time, delay, preempt, persistent, suspend, callback);
            }
            else {
                task = new Task(this.tracer, this, time, time + delay, preempt, persistent, suspend, reusable, callback);
            }
        }
        else {
            task = new Task(this.tracer, this, time, time + delay, preempt, persistent, suspend, reusable, callback);
        }
        if (preempt) {
            this.processing[this.processing.length] = task;
        }
        else if (delay === 0) {
            this.pending[this.pending.length] = task;
        }
        else {
            this.delayed[this.delayed.length] = task;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'queueTask');
        }
        return task;
    }
    /**
     * Remove the task from this queue.
     */
    remove(task) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'remove');
        }
        let idx = this.processing.indexOf(task);
        if (idx > -1) {
            this.processing.splice(idx, 1);
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'remove processing');
            }
            return;
        }
        idx = this.pending.indexOf(task);
        if (idx > -1) {
            this.pending.splice(idx, 1);
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'remove pending');
            }
            return;
        }
        idx = this.delayed.indexOf(task);
        if (idx > -1) {
            this.delayed.splice(idx, 1);
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'remove delayed');
            }
            return;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'remove error');
        }
        throw new Error(`Task #${task.id} could not be found`);
    }
    /**
     * Return a reusable task to the shared task pool.
     * The next queued callback will reuse this task object instead of creating a new one, to save overhead of creating additional objects.
     */
    returnToPool(task) {
        if (this.tracer.enabled) {
            this.tracer.trace(this, 'returnToPool');
        }
        this.taskPool[this.taskPoolSize++] = task;
    }
    /**
     * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.
     */
    resetPersistentTask(task) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'resetPersistentTask');
        }
        task.reset(this.platform.performanceNow());
        if (task.createdTime === task.queueTime) {
            this.pending[this.pending.length] = task;
        }
        else {
            this.delayed[this.delayed.length] = task;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'resetPersistentTask');
        }
    }
    /**
     * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.
     */
    completeAsyncTask(task) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'completeAsyncTask');
        }
        if (task.suspend === true) {
            if (this.suspenderTask !== task) {
                if (this.tracer.enabled) {
                    this.tracer.leave(this, 'completeAsyncTask error');
                }
                throw new Error(`Async task completion mismatch: suspenderTask=${this.suspenderTask?.id}, task=${task.id}`);
            }
            this.suspenderTask = void 0;
        }
        else {
            --this.pendingAsyncCount;
        }
        if (this.yieldPromise !== void 0 &&
            this.hasNoMoreFiniteWork) {
            const p = this.yieldPromise;
            this.yieldPromise = void 0;
            p.resolve();
        }
        if (this.isEmpty) {
            this.cancel();
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'completeAsyncTask');
        }
    }
}
class TaskAbortError extends Error {
    constructor(task) {
        super('Task was canceled.');
        this.task = task;
    }
}
let id = 0;
var TaskStatus;
(function (TaskStatus) {
    TaskStatus[TaskStatus["pending"] = 0] = "pending";
    TaskStatus[TaskStatus["running"] = 1] = "running";
    TaskStatus[TaskStatus["completed"] = 2] = "completed";
    TaskStatus[TaskStatus["canceled"] = 3] = "canceled";
})(TaskStatus || (TaskStatus = {}));
class Task {
    constructor(tracer, taskQueue, createdTime, queueTime, preempt, persistent, suspend, reusable, callback) {
        this.tracer = tracer;
        this.taskQueue = taskQueue;
        this.createdTime = createdTime;
        this.queueTime = queueTime;
        this.preempt = preempt;
        this.persistent = persistent;
        this.suspend = suspend;
        this.reusable = reusable;
        this.callback = callback;
        this.id = ++id;
        this.resolve = void 0;
        this.reject = void 0;
        this._result = void 0;
        this._status = 0 /* pending */;
    }
    get result() {
        const result = this._result;
        if (result === void 0) {
            switch (this._status) {
                case 0 /* pending */: {
                    const promise = this._result = createExposedPromise();
                    this.resolve = promise.resolve;
                    this.reject = promise.reject;
                    return promise;
                }
                case 1 /* running */:
                    throw new Error('Trying to await task from within task will cause a deadlock.');
                case 2 /* completed */:
                    return this._result = Promise.resolve();
                case 3 /* canceled */:
                    return this._result = Promise.reject(new TaskAbortError(this));
            }
        }
        return result;
    }
    get status() {
        return this._status;
    }
    run(time = this.taskQueue.platform.performanceNow()) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'run');
        }
        if (this._status !== 0 /* pending */) {
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'run error');
            }
            throw new Error(`Cannot run task in ${this._status} state`);
        }
        // this.persistent could be changed while the task is running (this can only be done by the task itself if canceled, and is a valid way of stopping a loop)
        // so we deliberately reference this.persistent instead of the local variable, but we keep it around to know whether the task *was* persistent before running it,
        // so we can set the correct cancelation state.
        const { persistent, reusable, taskQueue, callback, resolve, reject, createdTime, } = this;
        this._status = 1 /* running */;
        try {
            const ret = callback(time - createdTime);
            if (ret instanceof Promise) {
                ret.then($ret => {
                    if (this.persistent) {
                        taskQueue['resetPersistentTask'](this);
                    }
                    else {
                        if (persistent) {
                            // Persistent tasks never reach completed status. They're either pending, running, or canceled.
                            this._status = 3 /* canceled */;
                        }
                        else {
                            this._status = 2 /* completed */;
                        }
                        this.dispose();
                    }
                    taskQueue['completeAsyncTask'](this);
                    if (this.tracer.enabled) {
                        this.tracer.leave(this, 'run async then');
                    }
                    if (resolve !== void 0) {
                        resolve($ret);
                    }
                    if (!this.persistent && reusable) {
                        taskQueue['returnToPool'](this);
                    }
                })
                    .catch(err => {
                    if (!this.persistent) {
                        this.dispose();
                    }
                    taskQueue['completeAsyncTask'](this);
                    if (this.tracer.enabled) {
                        this.tracer.leave(this, 'run async catch');
                    }
                    if (reject !== void 0) {
                        reject(err);
                    }
                    else {
                        throw err;
                    }
                });
            }
            else {
                if (this.persistent) {
                    taskQueue['resetPersistentTask'](this);
                }
                else {
                    if (persistent) {
                        // Persistent tasks never reach completed status. They're either pending, running, or canceled.
                        this._status = 3 /* canceled */;
                    }
                    else {
                        this._status = 2 /* completed */;
                    }
                    this.dispose();
                }
                if (this.tracer.enabled) {
                    this.tracer.leave(this, 'run sync success');
                }
                if (resolve !== void 0) {
                    resolve(ret);
                }
                if (!this.persistent && reusable) {
                    taskQueue['returnToPool'](this);
                }
            }
        }
        catch (err) {
            if (!this.persistent) {
                this.dispose();
            }
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'run sync error');
            }
            if (reject !== void 0) {
                reject(err);
            }
            else {
                throw err;
            }
        }
    }
    cancel() {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'cancel');
        }
        if (this._status === 0 /* pending */) {
            const taskQueue = this.taskQueue;
            const reusable = this.reusable;
            const reject = this.reject;
            taskQueue.remove(this);
            if (taskQueue.isEmpty) {
                taskQueue.cancel();
            }
            this._status = 3 /* canceled */;
            this.dispose();
            if (reusable) {
                taskQueue['returnToPool'](this);
            }
            if (reject !== void 0) {
                reject(new TaskAbortError(this));
            }
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'cancel true =pending');
            }
            return true;
        }
        else if (this._status === 1 /* running */ && this.persistent) {
            this.persistent = false;
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'cancel true =running+persistent');
            }
            return true;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'cancel false');
        }
        return false;
    }
    reset(time) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'reset');
        }
        const delay = this.queueTime - this.createdTime;
        this.createdTime = time;
        this.queueTime = time + delay;
        this._status = 0 /* pending */;
        this.resolve = void 0;
        this.reject = void 0;
        this._result = void 0;
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'reset');
        }
    }
    reuse(time, delay, preempt, persistent, suspend, callback) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'reuse');
        }
        this.createdTime = time;
        this.queueTime = time + delay;
        this.preempt = preempt;
        this.persistent = persistent;
        this.suspend = suspend;
        this.callback = callback;
        this._status = 0 /* pending */;
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'reuse');
        }
    }
    dispose() {
        if (this.tracer.enabled) {
            this.tracer.trace(this, 'dispose');
        }
        this.callback = (void 0);
        this.resolve = void 0;
        this.reject = void 0;
        this._result = void 0;
    }
}
function taskStatus(status) {
    switch (status) {
        case 0 /* pending */: return 'pending';
        case 1 /* running */: return 'running';
        case 3 /* canceled */: return 'canceled';
        case 2 /* completed */: return 'completed';
    }
}
class Tracer {
    constructor(console) {
        this.console = console;
        this.enabled = false;
        this.depth = 0;
    }
    enter(obj, method) {
        this.log(`${'  '.repeat(this.depth++)}> `, obj, method);
    }
    leave(obj, method) {
        this.log(`${'  '.repeat(--this.depth)}< `, obj, method);
    }
    trace(obj, method) {
        this.log(`${'  '.repeat(this.depth)}- `, obj, method);
    }
    log(prefix, obj, method) {
        if (obj instanceof TaskQueue) {
            const processing = obj['processing'].length;
            const pending = obj['pending'].length;
            const delayed = obj['delayed'].length;
            const flushReq = obj['flushRequested'];
            const susTask = !!obj['suspenderTask'];
            const info = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;
            this.console.log(`${prefix}[Q.${method}] ${info}`);
        }
        else {
            const id = obj['id'];
            const created = Math.round(obj['createdTime'] * 10) / 10;
            const queue = Math.round(obj['queueTime'] * 10) / 10;
            const preempt = obj['preempt'];
            const reusable = obj['reusable'];
            const persistent = obj['persistent'];
            const suspend = obj['suspend'];
            const status = taskStatus(obj['_status']);
            const info = `id=${id} created=${created} queue=${queue} preempt=${preempt} persistent=${persistent} reusable=${reusable} status=${status} suspend=${suspend}`;
            this.console.log(`${prefix}[T.${method}] ${info}`);
        }
    }
}
var TaskQueuePriority;
(function (TaskQueuePriority) {
    TaskQueuePriority[TaskQueuePriority["render"] = 0] = "render";
    TaskQueuePriority[TaskQueuePriority["macroTask"] = 1] = "macroTask";
    TaskQueuePriority[TaskQueuePriority["postRender"] = 2] = "postRender";
})(TaskQueuePriority || (TaskQueuePriority = {}));
const defaultQueueTaskOptions = {
    delay: 0,
    preempt: false,
    persistent: false,
    reusable: true,
    suspend: false,
};
let $resolve;
let $reject;
function executor(resolve, reject) {
    $resolve = resolve;
    $reject = reject;
}
/**
 * Efficiently create a promise where the `resolve` and `reject` functions are stored as properties on the prommise itself.
 */
function createExposedPromise() {
    const p = new Promise(executor);
    p.resolve = $resolve;
    p.reject = $reject;
    return p;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/route-recognizer/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aurelia/route-recognizer/dist/esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigurableRoute": () => /* binding */ ConfigurableRoute,
/* harmony export */   "Endpoint": () => /* binding */ Endpoint,
/* harmony export */   "RecognizedRoute": () => /* binding */ RecognizedRoute,
/* harmony export */   "RouteRecognizer": () => /* binding */ RouteRecognizer
/* harmony export */ });
class ConfigurableRoute {
    constructor(path, caseSensitive, handler) {
        this.path = path;
        this.caseSensitive = caseSensitive;
        this.handler = handler;
    }
}
class Endpoint {
    constructor(route, paramNames) {
        this.route = route;
        this.paramNames = paramNames;
    }
}
class RecognizedRoute {
    constructor(endpoint, params) {
        this.endpoint = endpoint;
        this.params = params;
    }
}
class Candidate {
    constructor(chars, states, skippedStates, result) {
        this.chars = chars;
        this.states = states;
        this.skippedStates = skippedStates;
        this.result = result;
        this.head = states[states.length - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        this.endpoint = this.head?.endpoint;
    }
    advance(ch) {
        const { chars, states, skippedStates, result } = this;
        let stateToAdd = null;
        let matchCount = 0;
        const state = states[states.length - 1];
        function $process(nextState, skippedState) {
            if (nextState.isMatch(ch)) {
                if (++matchCount === 1) {
                    stateToAdd = nextState;
                }
                else {
                    result.add(new Candidate(chars.concat(ch), states.concat(nextState), skippedState === null ? skippedStates : skippedStates.concat(skippedState), result));
                }
            }
            if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {
                if (nextState.nextStates.length > 1) {
                    throw new Error(`${nextState.nextStates.length} nextStates`);
                }
                const separator = nextState.nextStates[0];
                if (!separator.isSeparator) {
                    throw new Error(`Not a separator`);
                }
                if (separator.nextStates !== null) {
                    for (const $nextState of separator.nextStates) {
                        $process($nextState, nextState);
                    }
                }
            }
        }
        if (state.isDynamic) {
            $process(state, null);
        }
        if (state.nextStates !== null) {
            for (const nextState of state.nextStates) {
                $process(nextState, null);
            }
        }
        if (stateToAdd !== null) {
            states.push(this.head = stateToAdd);
            chars.push(ch);
            if (stateToAdd.endpoint !== null) {
                this.endpoint = stateToAdd.endpoint;
            }
        }
        if (matchCount === 0) {
            result.remove(this);
        }
    }
    finalize() {
        function collectSkippedStates(skippedStates, state) {
            const nextStates = state.nextStates;
            if (nextStates !== null) {
                if (nextStates.length === 1 && nextStates[0].segment === null) {
                    collectSkippedStates(skippedStates, nextStates[0]);
                }
                else {
                    for (const nextState of nextStates) {
                        if (nextState.isOptional && nextState.endpoint !== null) {
                            skippedStates.push(nextState);
                            if (nextState.nextStates !== null) {
                                for (const $nextState of nextState.nextStates) {
                                    collectSkippedStates(skippedStates, $nextState);
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        collectSkippedStates(this.skippedStates, this.head);
    }
    getParams() {
        const { states, chars, endpoint } = this;
        const params = {};
        // First initialize all properties with undefined so they all exist (even if they're not filled, e.g. non-matched optional params)
        for (const name of endpoint.paramNames) {
            params[name] = void 0;
        }
        for (let i = 0, ii = states.length; i < ii; ++i) {
            const state = states[i];
            if (state.isDynamic) {
                const name = state.segment.name;
                if (params[name] === void 0) {
                    params[name] = chars[i];
                }
                else {
                    params[name] += chars[i];
                }
            }
        }
        return params;
    }
    /**
     * Compares this candidate to another candidate to determine the correct sorting order.
     *
     * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares
     * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types
     *
     * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the
     * same sorting value because they both consist of two static segments and one dynamic segment.
     *
     * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,
     * and static wins over dynamic.
     *
     * ### NOTE
     * This algorithm violates some of the invariants of v1's algorithm,
     * but those invariants were arguably not very sound to begin with. Example:
     *
     * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`
     * - in v1, the first would win because that match has fewer stars
     * - in v2, the second will win because there is a bigger static match at the start of the pattern
     *
     * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of
     * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,
     * intentionally or unintentionally.
     *
     * @param b - The candidate to compare this to.
     * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.
     * This will bring the candidate with the highest score to the first position of the array.
     */
    compareTo(b) {
        const statesA = this.states;
        const statesB = b.states;
        for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {
            let stateA = statesA[iA];
            if (stateA === void 0) {
                return 1;
            }
            let stateB = statesB[iB];
            if (stateB === void 0) {
                return -1;
            }
            let segmentA = stateA.segment;
            let segmentB = stateB.segment;
            if (segmentA === null) {
                if (segmentB === null) {
                    ++iB;
                    continue;
                }
                if ((stateA = statesA[++iA]) === void 0) {
                    return 1;
                }
                segmentA = stateA.segment;
            }
            else if (segmentB === null) {
                if ((stateB = statesB[++iB]) === void 0) {
                    return -1;
                }
                segmentB = stateB.segment;
            }
            if (segmentA.kind < segmentB.kind) {
                return 1;
            }
            if (segmentA.kind > segmentB.kind) {
                return -1;
            }
            ++iB;
        }
        const skippedStatesA = this.skippedStates;
        const skippedStatesB = b.skippedStates;
        const skippedStatesALen = skippedStatesA.length;
        const skippedStatesBLen = skippedStatesB.length;
        if (skippedStatesALen < skippedStatesBLen) {
            return 1;
        }
        if (skippedStatesALen > skippedStatesBLen) {
            return -1;
        }
        for (let i = 0; i < skippedStatesALen; ++i) {
            const skippedStateA = skippedStatesA[i];
            const skippedStateB = skippedStatesB[i];
            if (skippedStateA.length < skippedStateB.length) {
                return 1;
            }
            if (skippedStateA.length > skippedStateB.length) {
                return -1;
            }
        }
        // This should only be possible with a single pattern with multiple consecutive star segments.
        // TODO: probably want to warn or even throw here, but leave it be for now.
        return 0;
    }
}
function hasEndpoint(candidate) {
    return candidate.head.endpoint !== null;
}
function compareChains(a, b) {
    return a.compareTo(b);
}
class RecognizeResult {
    constructor(rootState) {
        this.candidates = [];
        this.candidates = [new Candidate([''], [rootState], [], this)];
    }
    get isEmpty() {
        return this.candidates.length === 0;
    }
    getSolution() {
        const candidates = this.candidates.filter(hasEndpoint);
        if (candidates.length === 0) {
            return null;
        }
        for (const candidate of candidates) {
            candidate.finalize();
        }
        candidates.sort(compareChains);
        return candidates[0];
    }
    add(candidate) {
        this.candidates.push(candidate);
    }
    remove(candidate) {
        this.candidates.splice(this.candidates.indexOf(candidate), 1);
    }
    advance(ch) {
        const candidates = this.candidates.slice();
        for (const candidate of candidates) {
            candidate.advance(ch);
        }
    }
}
class RouteRecognizer {
    constructor() {
        this.rootState = new State(null, null, '');
        this.cache = new Map();
    }
    add(routeOrRoutes) {
        if (routeOrRoutes instanceof Array) {
            for (const route of routeOrRoutes) {
                this.$add(route);
            }
        }
        else {
            this.$add(routeOrRoutes);
        }
        // Clear the cache whenever there are state changes, because the recognizeResults could be arbitrarily different as a result
        this.cache.clear();
    }
    $add(route) {
        const path = route.path;
        const $route = new ConfigurableRoute(route.path, route.caseSensitive === true, route.handler);
        // Normalize leading, trailing and double slashes by ignoring empty segments
        const parts = path === '' ? [''] : path.split('/').filter(isNotEmpty);
        const paramNames = [];
        let state = this.rootState;
        for (const part of parts) {
            // Each segment always begins with a slash, so we represent this with a non-segment state
            state = state.append(null, '/');
            switch (part.charAt(0)) {
                case ':': { // route parameter
                    const isOptional = part.endsWith('?');
                    const name = isOptional ? part.slice(1, -1) : part.slice(1);
                    paramNames.push(name);
                    state = new DynamicSegment(name, isOptional).appendTo(state);
                    break;
                }
                case '*': { // dynamic route
                    const name = part.slice(1);
                    paramNames.push(name);
                    state = new StarSegment(name).appendTo(state);
                    break;
                }
                default: { // standard path route
                    state = new StaticSegment(part, $route.caseSensitive).appendTo(state);
                    break;
                }
            }
        }
        const endpoint = new Endpoint($route, paramNames);
        state.setEndpoint(endpoint);
    }
    recognize(path) {
        let result = this.cache.get(path);
        if (result === void 0) {
            this.cache.set(path, result = this.$recognize(path));
        }
        return result;
    }
    $recognize(path) {
        path = decodeURI(path);
        if (!path.startsWith('/')) {
            path = `/${path}`;
        }
        if (path.length > 1 && path.endsWith('/')) {
            path = path.slice(0, -1);
        }
        const result = new RecognizeResult(this.rootState);
        for (let i = 0, ii = path.length; i < ii; ++i) {
            const ch = path.charAt(i);
            result.advance(ch);
            if (result.isEmpty) {
                return null;
            }
        }
        const candidate = result.getSolution();
        if (candidate === null) {
            return null;
        }
        const { endpoint } = candidate;
        const params = candidate.getParams();
        return new RecognizedRoute(endpoint, params);
    }
}
class State {
    constructor(prevState, segment, value) {
        this.prevState = prevState;
        this.segment = segment;
        this.value = value;
        this.nextStates = null;
        this.endpoint = null;
        switch (segment?.kind) {
            case 2 /* dynamic */:
                this.length = prevState.length + 1;
                this.isSeparator = false;
                this.isDynamic = true;
                this.isOptional = segment.optional;
                break;
            case 1 /* star */:
                this.length = prevState.length + 1;
                this.isSeparator = false;
                this.isDynamic = true;
                this.isOptional = false;
                break;
            case 3 /* static */:
                this.length = prevState.length + 1;
                this.isSeparator = false;
                this.isDynamic = false;
                this.isOptional = false;
                break;
            case undefined:
                this.length = prevState === null ? 0 : prevState.length;
                this.isSeparator = true;
                this.isDynamic = false;
                this.isOptional = false;
                break;
        }
    }
    append(segment, value) {
        let state;
        let nextStates = this.nextStates;
        if (nextStates === null) {
            state = void 0;
            nextStates = this.nextStates = [];
        }
        else if (segment === null) {
            state = nextStates.find(s => s.value === value);
        }
        else {
            state = nextStates.find(s => s.segment?.equals(segment));
        }
        if (state === void 0) {
            nextStates.push(state = new State(this, segment, value));
        }
        return state;
    }
    setEndpoint(endpoint) {
        if (this.endpoint !== null) {
            throw new Error(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);
        }
        this.endpoint = endpoint;
        if (this.isOptional) {
            this.prevState.setEndpoint(endpoint);
            if (this.prevState.isSeparator && this.prevState.prevState !== null) {
                this.prevState.prevState.setEndpoint(endpoint);
            }
        }
    }
    isMatch(ch) {
        const segment = this.segment;
        switch (segment?.kind) {
            case 2 /* dynamic */:
                return !this.value.includes(ch);
            case 1 /* star */:
                return true;
            case 3 /* static */:
            case undefined:
                // segment separators (slashes) are non-segments. We could say return ch === '/' as well, technically.
                return this.value.includes(ch);
        }
    }
}
function isNotEmpty(segment) {
    return segment.length > 0;
}
var SegmentKind;
(function (SegmentKind) {
    SegmentKind[SegmentKind["star"] = 1] = "star";
    SegmentKind[SegmentKind["dynamic"] = 2] = "dynamic";
    SegmentKind[SegmentKind["static"] = 3] = "static";
})(SegmentKind || (SegmentKind = {}));
class StaticSegment {
    constructor(value, caseSensitive) {
        this.value = value;
        this.caseSensitive = caseSensitive;
    }
    get kind() { return 3 /* static */; }
    appendTo(state) {
        const { value, value: { length } } = this;
        if (this.caseSensitive) {
            for (let i = 0; i < length; ++i) {
                state = state.append(
                /* segment */ this, 
                /* value   */ value.charAt(i));
            }
        }
        else {
            for (let i = 0; i < length; ++i) {
                const ch = value.charAt(i);
                state = state.append(
                /* segment */ this, 
                /* value   */ ch.toUpperCase() + ch.toLowerCase());
            }
        }
        return state;
    }
    equals(b) {
        return (b.kind === 3 /* static */ &&
            b.caseSensitive === this.caseSensitive &&
            b.value === this.value);
    }
}
class DynamicSegment {
    constructor(name, optional) {
        this.name = name;
        this.optional = optional;
    }
    get kind() { return 2 /* dynamic */; }
    appendTo(state) {
        state = state.append(
        /* segment */ this, 
        /* value   */ '/');
        return state;
    }
    equals(b) {
        return (b.kind === 2 /* dynamic */ &&
            b.optional === this.optional &&
            b.name === this.name);
    }
}
class StarSegment {
    constructor(name) {
        this.name = name;
    }
    get kind() { return 1 /* star */; }
    appendTo(state) {
        state = state.append(
        /* segment */ this, 
        /* value   */ '');
        return state;
    }
    equals(b) {
        return (b.kind === 1 /* star */ &&
            b.name === this.name);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/awaitable-map.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/awaitable-map.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AwaitableMap": () => /* binding */ AwaitableMap
/* harmony export */ });
/* harmony import */ var _open_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./open-promise.js */ "./node_modules/@aurelia/router/dist/esm/open-promise.js");
// export class OpenPromise<T> {
//   public isPending: boolean = true;
//   public promise!: Promise<T>;
//   public resolve!: (value: T | PromiseLike<T>) => void;
//   public reject!: () => void;
// }

class AwaitableMap {
    constructor() {
        this.map = new Map();
    }
    set(key, value) {
        const openPromise = this.map.get(key);
        if (openPromise instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise) {
            openPromise.resolve(value);
            // openPromise.isPending = false;
        }
        this.map.set(key, value);
    }
    delete(key) {
        const current = this.map.get(key);
        if (current instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise) {
            current.reject();
            // current.isPending = false;
        }
        this.map.delete(key);
    }
    await(key) {
        if (!this.map.has(key)) {
            const openPromise = new _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise();
            // openPromise.promise = new Promise((res, rej) => {
            //   openPromise.resolve = res;
            //   openPromise.reject = rej;
            // });
            this.map.set(key, openPromise);
            return openPromise.promise;
        }
        const current = this.map.get(key);
        if (current instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise) {
            return current.promise;
        }
        return current;
    }
    has(key) {
        return this.map.has(key) && !(this.map.get(key) instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise);
    }
    clone() {
        const clone = new AwaitableMap();
        clone.map = new Map(this.map);
        return clone;
    }
}
//# sourceMappingURL=awaitable-map.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/browser-viewer-store.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/browser-viewer-store.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserViewerStore": () => /* binding */ BrowserViewerStore
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _task_queue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./task-queue.js */ "./node_modules/@aurelia/router/dist/esm/task-queue.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


/**
 * @internal - Shouldn't be used directly
 */
let BrowserViewerStore = class BrowserViewerStore {
    constructor(platform, window, history, location) {
        this.platform = platform;
        this.window = window;
        this.history = history;
        this.location = location;
        this.allowedExecutionCostWithinTick = 2; // Limit no of executed actions within the same RAF (due to browser limitation)
        this.isActive = false;
        this.options = {
            useUrlFragmentHash: true,
            callback: () => { return; },
        };
        this.forwardedState = { eventTask: null, suppressPopstate: false };
        this.handlePopstate = async (event) => {
            const { eventTask, suppressPopstate } = this.forwardedState;
            this.forwardedState = { eventTask: null, suppressPopstate: false };
            return this.pendingCalls.enqueue(async (task) => {
                const store = this;
                const ev = event;
                const evTask = eventTask;
                const suppressPopstateEvent = suppressPopstate;
                await store.popstate(ev, evTask, suppressPopstateEvent);
                task.resolve();
            }, 1).wait();
        };
        this.pendingCalls = new _task_queue_js__WEBPACK_IMPORTED_MODULE_1__.TaskQueue();
    }
    start(options) {
        if (this.isActive) {
            throw new Error('Browser navigation has already been started');
        }
        this.isActive = true;
        this.options.callback = options.callback;
        if (options.useUrlFragmentHash != void 0) {
            this.options.useUrlFragmentHash = options.useUrlFragmentHash;
        }
        this.pendingCalls.start({ platform: this.platform, allowedExecutionCostWithinTick: this.allowedExecutionCostWithinTick });
        this.window.addEventListener('popstate', this.handlePopstate);
    }
    stop() {
        if (!this.isActive) {
            throw new Error('Browser navigation has not been started');
        }
        this.window.removeEventListener('popstate', this.handlePopstate);
        this.pendingCalls.stop();
        this.options = { useUrlFragmentHash: true, callback: () => { return; } };
        this.isActive = false;
    }
    get length() {
        return this.history.length;
    }
    get state() {
        return this.history.state;
    }
    get viewerState() {
        const { pathname, search, hash } = this.location;
        return {
            path: pathname,
            query: search,
            hash,
            instruction: this.options.useUrlFragmentHash ? hash.slice(1) : pathname,
        };
    }
    async go(delta, suppressPopstateEvent = false) {
        const doneTask = this.pendingCalls.createQueueTask((task) => task.resolve(), 1);
        this.pendingCalls.enqueue([
            (task) => {
                const store = this;
                const eventTask = doneTask;
                const suppressPopstate = suppressPopstateEvent;
                store.forwardState({ eventTask, suppressPopstate });
                task.resolve();
            },
            (task) => {
                const history = this.history;
                const steps = delta;
                history.go(steps);
                task.resolve();
            },
        ], [0, 1]);
        return doneTask.wait();
    }
    async pushNavigatorState(state) {
        const { title, path } = state.currentEntry;
        const fragment = this.options.useUrlFragmentHash ? '#/' : '';
        return this.pendingCalls.enqueue((task) => {
            const history = this.history;
            const data = state;
            const titleOrEmpty = title || '';
            const url = `${fragment}${path}`;
            history.pushState(data, titleOrEmpty, url);
            task.resolve();
        }, 1).wait();
    }
    async replaceNavigatorState(state) {
        const { title, path } = state.currentEntry;
        const fragment = this.options.useUrlFragmentHash ? '#/' : '';
        return this.pendingCalls.enqueue((task) => {
            const history = this.history;
            const data = state;
            const titleOrEmpty = title || '';
            const url = `${fragment}${path}`;
            history.replaceState(data, titleOrEmpty, url);
            task.resolve();
        }, 1).wait();
    }
    async popNavigatorState() {
        const doneTask = this.pendingCalls.createQueueTask((task) => task.resolve(), 1);
        this.pendingCalls.enqueue(async (task) => {
            const store = this;
            const eventTask = doneTask;
            await store.popState(eventTask);
            task.resolve();
        }, 1);
        return doneTask.wait();
    }
    async popState(doneTask) {
        await this.go(-1, true);
        const state = this.history.state;
        // TODO: Fix browser forward bug after pop on first entry
        if (state && state.currentEntry && !state.currentEntry.firstEntry) {
            await this.go(-1, true);
            await this.pushNavigatorState(state);
        }
        await doneTask.execute();
    }
    forwardState(state) {
        this.forwardedState = state;
    }
    async popstate(ev, eventTask, suppressPopstate = false) {
        if (!suppressPopstate) {
            this.options.callback({
                ...this.viewerState,
                ...{
                    event: ev,
                    state: this.history.state,
                },
            });
        }
        if (eventTask !== null) {
            await eventTask.execute();
        }
    }
    setTitle(title) {
        this.window.document.title = title;
    }
};
BrowserViewerStore = __decorate([
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IPlatform),
    __param(1, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IWindow),
    __param(2, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IHistory),
    __param(3, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.ILocation)
], BrowserViewerStore);

//# sourceMappingURL=browser-viewer-store.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/collection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/collection.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Collection": () => /* binding */ Collection
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");

/**
 * @internal - Helper class
 */
class Collection extends Array {
    constructor() {
        super(...arguments);
        this.currentIndex = -1;
    }
    next() {
        if (this.length > this.currentIndex + 1) {
            return this[++this.currentIndex];
        }
        else {
            this.currentIndex = -1;
            return null;
        }
    }
    removeCurrent() {
        this.splice(this.currentIndex--, 1);
    }
    remove(instruction) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.arrayRemove)(this, value => value === instruction);
    }
}
//# sourceMappingURL=collection.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/configuration.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/configuration.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterRegistration": () => /* binding */ RouterRegistration,
/* harmony export */   "DefaultComponents": () => /* binding */ DefaultComponents,
/* harmony export */   "ViewportCustomElement": () => /* reexport safe */ _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement,
/* harmony export */   "ViewportScopeCustomElement": () => /* reexport safe */ _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__.ViewportScopeCustomElement,
/* harmony export */   "NavCustomElement": () => /* reexport safe */ _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__.NavCustomElement,
/* harmony export */   "GotoCustomAttribute": () => /* reexport safe */ _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__.GotoCustomAttribute,
/* harmony export */   "LoadCustomAttribute": () => /* reexport safe */ _resources_load_js__WEBPACK_IMPORTED_MODULE_6__.LoadCustomAttribute,
/* harmony export */   "HrefCustomAttribute": () => /* reexport safe */ _resources_href_js__WEBPACK_IMPORTED_MODULE_7__.HrefCustomAttribute,
/* harmony export */   "ViewportCustomElementRegistration": () => /* binding */ ViewportCustomElementRegistration,
/* harmony export */   "ViewportScopeCustomElementRegistration": () => /* binding */ ViewportScopeCustomElementRegistration,
/* harmony export */   "NavCustomElementRegistration": () => /* binding */ NavCustomElementRegistration,
/* harmony export */   "GotoCustomAttributeRegistration": () => /* binding */ GotoCustomAttributeRegistration,
/* harmony export */   "LoadCustomAttributeRegistration": () => /* binding */ LoadCustomAttributeRegistration,
/* harmony export */   "HrefCustomAttributeRegistration": () => /* binding */ HrefCustomAttributeRegistration,
/* harmony export */   "DefaultResources": () => /* binding */ DefaultResources,
/* harmony export */   "RouterConfiguration": () => /* binding */ RouterConfiguration
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/nav.js */ "./node_modules/@aurelia/router/dist/esm/resources/nav.js");
/* harmony import */ var _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/viewport.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport.js");
/* harmony import */ var _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resources/viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js");
/* harmony import */ var _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resources/goto.js */ "./node_modules/@aurelia/router/dist/esm/resources/goto.js");
/* harmony import */ var _resources_load_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resources/load.js */ "./node_modules/@aurelia/router/dist/esm/resources/load.js");
/* harmony import */ var _resources_href_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./resources/href.js */ "./node_modules/@aurelia/router/dist/esm/resources/href.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");









const RouterRegistration = _router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter;
/**
 * Default runtime/environment-agnostic implementations for the following interfaces:
 * - `IRouter`
 */
const DefaultComponents = [
    RouterRegistration,
];

const ViewportCustomElementRegistration = _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement;
const ViewportScopeCustomElementRegistration = _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__.ViewportScopeCustomElement;
const NavCustomElementRegistration = _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__.NavCustomElement;
const GotoCustomAttributeRegistration = _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__.GotoCustomAttribute;
const LoadCustomAttributeRegistration = _resources_load_js__WEBPACK_IMPORTED_MODULE_6__.LoadCustomAttribute;
const HrefCustomAttributeRegistration = _resources_href_js__WEBPACK_IMPORTED_MODULE_7__.HrefCustomAttribute;
/**
 * Default router resources:
 * - Custom Elements: `au-viewport`, `au-nav`
 * - Custom Attributes: `goto`, `load`, `href`
 */
const DefaultResources = [
    _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement,
    _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__.ViewportScopeCustomElement,
    _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__.NavCustomElement,
    _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__.GotoCustomAttribute,
    _resources_load_js__WEBPACK_IMPORTED_MODULE_6__.LoadCustomAttribute,
    _resources_href_js__WEBPACK_IMPORTED_MODULE_7__.HrefCustomAttribute,
];
let configurationOptions = {};
let configurationCall = (router) => {
    router.start(configurationOptions);
};
/**
 * A DI configuration object containing router resource registrations.
 */
const routerConfiguration = {
    /**
     * Apply this configuration to the provided container.
     */
    register(container) {
        return container.register(...DefaultComponents, ...DefaultResources, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter).beforeActivate().call(configurationCall), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter).afterActivate().call(router => router.loadUrl()), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter).afterDeactivate().call(router => router.stop()));
    },
    /**
     * Create a new container with this configuration applied to it.
     */
    createContainer() {
        return this.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer());
    }
};
const RouterConfiguration = {
    /**
     * Make it possible to specify options to Router activation.
     * Parameter is either a config object that's passed to Router's start
     * or a config function that's called instead of Router's start.
     */
    customize(config) {
        if (config === undefined) {
            configurationOptions = {};
            configurationCall = (router) => {
                router.start(configurationOptions);
            };
        }
        else if (config instanceof Function) {
            configurationCall = config;
        }
        else {
            configurationOptions = config;
        }
        return { ...routerConfiguration };
    },
    ...routerConfiguration,
};
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/found-route.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/found-route.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FoundRoute": () => /* binding */ FoundRoute
/* harmony export */ });
/**
 * @internal - Used when founding route/instructions
 */
class FoundRoute {
    constructor(match = null, matching = '', instructions = [], remaining = '', 
    // public remaining: string | null = null,
    params = {}) {
        this.match = match;
        this.matching = matching;
        this.instructions = instructions;
        this.remaining = remaining;
        this.params = params;
    }
    get foundConfiguration() {
        return this.match !== null;
    }
    get foundInstructions() {
        return this.instructions.length > 0;
    }
    get hasRemaining() {
        return this.remaining !== null && this.remaining.length > 0;
    }
}
//# sourceMappingURL=found-route.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/hook-manager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/hook-manager.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HookTypes": () => /* binding */ HookTypes,
/* harmony export */   "HookManager": () => /* binding */ HookManager
/* harmony export */ });
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hook.js */ "./node_modules/@aurelia/router/dist/esm/hook.js");

/**
 * Public API
 */
var HookTypes;
(function (HookTypes) {
    HookTypes["BeforeNavigation"] = "beforeNavigation";
    HookTypes["TransformFromUrl"] = "transformFromUrl";
    HookTypes["TransformToUrl"] = "transformToUrl";
    HookTypes["SetTitle"] = "setTitle";
})(HookTypes || (HookTypes = {}));
/**
 * @internal - Shouldn't be used directly
 */
class HookManager {
    constructor() {
        this.hooks = {
            beforeNavigation: [],
            transformFromUrl: [],
            transformToUrl: [],
            setTitle: [],
        };
        this.lastIdentity = 0;
    }
    addHook(hookFunction, options) {
        const hook = new _hook_js__WEBPACK_IMPORTED_MODULE_0__.Hook(hookFunction, options || {}, ++this.lastIdentity);
        this.hooks[hook.type].push(hook);
        return this.lastIdentity;
    }
    removeHook(id) {
        for (const type in this.hooks) {
            if (Object.prototype.hasOwnProperty.call(this.hooks, type)) {
                const index = this.hooks[type].findIndex(hook => hook.id === id);
                if (index >= 0) {
                    this.hooks[type].splice(index, 1);
                }
            }
        }
    }
    async invokeBeforeNavigation(viewportInstructions, navigationInstruction) {
        return this.invoke("beforeNavigation" /* BeforeNavigation */, navigationInstruction, viewportInstructions);
    }
    async invokeTransformFromUrl(url, navigationInstruction) {
        return this.invoke("transformFromUrl" /* TransformFromUrl */, navigationInstruction, url);
    }
    async invokeTransformToUrl(state, navigationInstruction) {
        return this.invoke("transformToUrl" /* TransformToUrl */, navigationInstruction, state);
    }
    async invokeSetTitle(title, navigationInstruction) {
        return this.invoke("setTitle" /* SetTitle */, navigationInstruction, title);
    }
    async invoke(type, navigationInstruction, arg) {
        for (const hook of this.hooks[type]) {
            if (!hook.wantsMatch || hook.matches(arg)) {
                const outcome = await hook.invoke(navigationInstruction, arg);
                if (typeof outcome === 'boolean') {
                    if (!outcome) {
                        return false;
                    }
                }
                else {
                    arg = outcome;
                }
            }
        }
        return arg;
    }
}
//# sourceMappingURL=hook-manager.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/hook.js":
/*!*******************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/hook.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hook": () => /* binding */ Hook
/* harmony export */ });
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");


/**
 * @internal - Shouldn't be used directly
 */
class Hook {
    constructor(hook, options, id) {
        this.hook = hook;
        this.id = id;
        this.type = "beforeNavigation" /* BeforeNavigation */;
        this.includeTargets = [];
        this.excludeTargets = [];
        if (options.type !== void 0) {
            this.type = options.type;
        }
        for (const target of options.include || []) {
            this.includeTargets.push(new Target(target));
        }
        for (const target of options.exclude || []) {
            this.excludeTargets.push(new Target(target));
        }
    }
    get wantsMatch() {
        return this.includeTargets.length > 0 || this.excludeTargets.length > 0;
    }
    matches(viewportInstructions) {
        if (this.includeTargets.length && !this.includeTargets.some(target => target.matches(viewportInstructions))) {
            return false;
        }
        if (this.excludeTargets.length && this.excludeTargets.some(target => target.matches(viewportInstructions))) {
            return false;
        }
        return true;
    }
    invoke(navigationInstruction, arg) {
        // TODO: Fix the type here
        return this.hook(arg, navigationInstruction);
    }
}
class Target {
    constructor(target) {
        this.componentType = null;
        this.componentName = null;
        this.viewport = null;
        this.viewportName = null;
        if (typeof target === 'string') {
            this.componentName = target;
        }
        else if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.isType(target)) {
            this.componentType = target;
            this.componentName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.getName(target);
        }
        else {
            const cvTarget = target;
            if (cvTarget.component) {
                this.componentType = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.isType(cvTarget.component)
                    ? _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.getType(cvTarget.component)
                    : null;
                this.componentName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.getName(cvTarget.component);
            }
            if (cvTarget.viewport) {
                this.viewport = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ViewportHandleResolver.isInstance(cvTarget.viewport) ? cvTarget.viewport : null;
                this.viewportName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ViewportHandleResolver.getName(cvTarget.viewport);
            }
        }
    }
    matches(viewportInstructions) {
        const instructions = viewportInstructions.slice();
        if (!instructions.length) {
            // instructions.push(new ViewportInstruction(''));
            instructions.push(_viewport_instruction_js__WEBPACK_IMPORTED_MODULE_1__.ViewportInstruction.create(null, ''));
        }
        for (const instruction of instructions) {
            if ((this.componentName !== null && this.componentName === instruction.componentName) ||
                (this.componentType !== null && this.componentType === instruction.componentType) ||
                (this.viewportName !== null && this.viewportName === instruction.viewportName) ||
                (this.viewport !== null && this.viewport === instruction.viewport)) {
                return true;
            }
        }
        return false;
    }
}
//# sourceMappingURL=hook.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkHandler": () => /* reexport safe */ _link_handler_js__WEBPACK_IMPORTED_MODULE_0__.LinkHandler,
/* harmony export */   "InstructionResolver": () => /* reexport safe */ _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_1__.InstructionResolver,
/* harmony export */   "ReentryBehavior": () => /* reexport safe */ _interfaces_js__WEBPACK_IMPORTED_MODULE_2__.ReentryBehavior,
/* harmony export */   "lifecycleLogger": () => /* reexport safe */ _lifecycle_logger_js__WEBPACK_IMPORTED_MODULE_3__.lifecycleLogger,
/* harmony export */   "LifecycleClass": () => /* reexport safe */ _lifecycle_logger_js__WEBPACK_IMPORTED_MODULE_3__.LifecycleClass,
/* harmony export */   "HookManager": () => /* reexport safe */ _hook_manager_js__WEBPACK_IMPORTED_MODULE_4__.HookManager,
/* harmony export */   "HookTypes": () => /* reexport safe */ _hook_manager_js__WEBPACK_IMPORTED_MODULE_4__.HookTypes,
/* harmony export */   "Nav": () => /* reexport safe */ _nav_js__WEBPACK_IMPORTED_MODULE_5__.Nav,
/* harmony export */   "NavRoute": () => /* reexport safe */ _nav_route_js__WEBPACK_IMPORTED_MODULE_6__.NavRoute,
/* harmony export */   "Navigation": () => /* reexport safe */ _navigation_js__WEBPACK_IMPORTED_MODULE_7__.Navigation,
/* harmony export */   "Navigator": () => /* reexport safe */ _navigator_js__WEBPACK_IMPORTED_MODULE_8__.Navigator,
/* harmony export */   "Runner": () => /* reexport safe */ _runner_js__WEBPACK_IMPORTED_MODULE_9__.Runner,
/* harmony export */   "Queue": () => /* reexport safe */ _queue_js__WEBPACK_IMPORTED_MODULE_10__.Queue,
/* harmony export */   "RouteRecognizer": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.RouteRecognizer,
/* harmony export */   "ConfigurableRoute": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.ConfigurableRoute,
/* harmony export */   "RecognizedRoute": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.RecognizedRoute,
/* harmony export */   "Endpoint": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.Endpoint,
/* harmony export */   "IRouter": () => /* reexport safe */ _router_js__WEBPACK_IMPORTED_MODULE_12__.IRouter,
/* harmony export */   "Router": () => /* reexport safe */ _router_js__WEBPACK_IMPORTED_MODULE_12__.Router,
/* harmony export */   "RouterOptions": () => /* reexport safe */ _router_options_js__WEBPACK_IMPORTED_MODULE_13__.RouterOptions,
/* harmony export */   "Viewport": () => /* reexport safe */ _viewport_js__WEBPACK_IMPORTED_MODULE_14__.Viewport,
/* harmony export */   "ContentStatus": () => /* reexport safe */ _viewport_content_js__WEBPACK_IMPORTED_MODULE_15__.ContentStatus,
/* harmony export */   "ViewportContent": () => /* reexport safe */ _viewport_content_js__WEBPACK_IMPORTED_MODULE_15__.ViewportContent,
/* harmony export */   "ViewportInstruction": () => /* reexport safe */ _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_16__.ViewportInstruction,
/* harmony export */   "RouterConfiguration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.RouterConfiguration,
/* harmony export */   "RouterRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.RouterRegistration,
/* harmony export */   "DefaultComponents": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.DefaultComponents,
/* harmony export */   "DefaultResources": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.DefaultResources,
/* harmony export */   "ViewportCustomElement": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.ViewportCustomElement,
/* harmony export */   "ViewportCustomElementRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.ViewportCustomElementRegistration,
/* harmony export */   "NavCustomElement": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.NavCustomElement,
/* harmony export */   "NavCustomElementRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.NavCustomElementRegistration,
/* harmony export */   "GotoCustomAttribute": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.GotoCustomAttribute,
/* harmony export */   "GotoCustomAttributeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.GotoCustomAttributeRegistration,
/* harmony export */   "LoadCustomAttribute": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.LoadCustomAttribute,
/* harmony export */   "LoadCustomAttributeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.LoadCustomAttributeRegistration,
/* harmony export */   "HrefCustomAttribute": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.HrefCustomAttribute,
/* harmony export */   "HrefCustomAttributeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.HrefCustomAttributeRegistration
/* harmony export */ });
/* harmony import */ var _link_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./link-handler.js */ "./node_modules/@aurelia/router/dist/esm/link-handler.js");
/* harmony import */ var _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instruction-resolver.js */ "./node_modules/@aurelia/router/dist/esm/instruction-resolver.js");
/* harmony import */ var _interfaces_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interfaces.js */ "./node_modules/@aurelia/router/dist/esm/interfaces.js");
/* harmony import */ var _lifecycle_logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lifecycle-logger.js */ "./node_modules/@aurelia/router/dist/esm/lifecycle-logger.js");
/* harmony import */ var _hook_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hook-manager.js */ "./node_modules/@aurelia/router/dist/esm/hook-manager.js");
/* harmony import */ var _nav_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nav.js */ "./node_modules/@aurelia/router/dist/esm/nav.js");
/* harmony import */ var _nav_route_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nav-route.js */ "./node_modules/@aurelia/router/dist/esm/nav-route.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _navigator_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./navigator.js */ "./node_modules/@aurelia/router/dist/esm/navigator.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");
/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./queue.js */ "./node_modules/@aurelia/router/dist/esm/queue.js");
/* harmony import */ var _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./route-recognizer.js */ "./node_modules/@aurelia/router/dist/esm/route-recognizer.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _router_options_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./router-options.js */ "./node_modules/@aurelia/router/dist/esm/router-options.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _viewport_content_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./viewport-content.js */ "./node_modules/@aurelia/router/dist/esm/viewport-content.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");
/* harmony import */ var _configuration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./configuration.js */ "./node_modules/@aurelia/router/dist/esm/configuration.js");


















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/instruction-resolver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/instruction-resolver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstructionResolver": () => /* binding */ InstructionResolver
/* harmony export */ });
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");

class InstructionResolver {
    constructor() {
        this.separators = {
            viewport: '@',
            sibling: '+',
            scope: '/',
            scopeStart: '(',
            scopeEnd: ')',
            noScope: '!',
            parameters: '(',
            parametersEnd: ')',
            parameterSeparator: ',',
            parameterKeySeparator: '=',
            parameter: '&',
            add: '+',
            clear: '-',
            action: '.',
        };
    }
    start(options) {
        options = options || {};
        this.separators = { ...this.separators, ...options.separators };
    }
    get clearViewportInstruction() {
        return this.separators.clear;
    }
    get addViewportInstruction() {
        return this.separators.add;
    }
    isClearViewportInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.clearViewportInstruction && !!instruction.viewportName
            : instruction.startsWith(this.clearViewportInstruction) && instruction !== this.clearViewportInstruction;
    }
    isAddViewportInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.addViewportInstruction
            : (instruction === this.addViewportInstruction
                || instruction.startsWith(`${this.separators.add}${this.separators.viewport}`));
    }
    isClearViewportScopeInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.clearViewportInstruction && !!instruction.viewportScope
            : instruction.startsWith(this.clearViewportInstruction) && instruction !== this.clearViewportInstruction;
    }
    isClearAllViewportsInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.clearViewportInstruction && !instruction.viewportName
            : instruction === this.clearViewportInstruction;
    }
    isAddAllViewportsInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.addViewportInstruction && !instruction.viewportName
            : instruction === this.addViewportInstruction;
    }
    createViewportInstruction(component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
        if (component instanceof Promise) {
            return component.then((resolvedComponent) => {
                return this.createViewportInstruction(resolvedComponent, viewport, parameters, ownsScope, nextScopeInstructions);
            });
        }
        // const instruction: ViewportInstruction = new ViewportInstruction(component, viewport, parameters, ownsScope, nextScopeInstructions);
        // instruction.setInstructionResolver(this);
        // return instruction;
        return _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction.create(this, component, viewport, parameters, ownsScope, nextScopeInstructions);
    }
    parseViewportInstructions(instructions) {
        const match = /^[./]+/.exec(instructions);
        let context = '';
        if (Array.isArray(match) && match.length > 0) {
            context = match[0];
            instructions = instructions.slice(context.length);
        }
        const parsedInstructions = this.parseViewportInstructionsWorker(instructions, true).instructions;
        for (const instruction of parsedInstructions) {
            instruction.context = context;
        }
        return parsedInstructions;
    }
    parseViewportInstruction(instruction) {
        const instructions = this.parseViewportInstructions(instruction);
        if (instructions.length) {
            return instructions[0];
        }
        return this.createViewportInstruction('');
    }
    stringifyViewportInstructions(instructions, excludeViewport = false, viewportContext = false) {
        return typeof (instructions) === 'string'
            ? instructions
            : instructions
                .map(instruction => this.stringifyViewportInstruction(instruction, excludeViewport, viewportContext))
                .filter(instruction => instruction && instruction.length)
                .join(this.separators.sibling);
    }
    stringifyViewportInstruction(instruction, excludeViewport = false, viewportContext = false) {
        if (typeof instruction === 'string') {
            return this.stringifyAViewportInstruction(instruction, excludeViewport);
        }
        else {
            let excludeCurrentViewport = excludeViewport;
            let excludeCurrentComponent = false;
            if (viewportContext) {
                if (instruction.viewport && instruction.viewport.options.noLink) {
                    return '';
                }
                if (!instruction.needsViewportDescribed && instruction.viewport && !instruction.viewport.options.forceDescription) {
                    excludeCurrentViewport = true;
                }
                if (instruction.viewport && instruction.viewport.options.fallback === instruction.componentName) {
                    excludeCurrentComponent = true;
                }
                if (!instruction.needsViewportDescribed && instruction.viewportScope) {
                    excludeCurrentViewport = true;
                }
            }
            let route = instruction.route ?? null;
            const nextInstructions = instruction.nextScopeInstructions;
            let stringified = instruction.context;
            // It's a configured route
            if (route !== null) {
                // Already added as part of a configuration, skip to next scope
                if (route === '') {
                    return Array.isArray(nextInstructions)
                        ? this.stringifyViewportInstructions(nextInstructions, excludeViewport, viewportContext)
                        : '';
                }
                route = route.matching;
                stringified += route.endsWith(this.separators.scope) ? route.slice(0, -this.separators.scope.length) : route;
            }
            else {
                stringified += this.stringifyAViewportInstruction(instruction, excludeCurrentViewport, excludeCurrentComponent);
            }
            if (Array.isArray(nextInstructions) && nextInstructions.length) {
                const nextStringified = this.stringifyViewportInstructions(nextInstructions, excludeViewport, viewportContext);
                if (nextStringified.length > 0) {
                    stringified += nextInstructions.length === 1 // TODO: This should really also check that the instructions have value
                        ? `${this.separators.scope}${nextStringified}`
                        : `${this.separators.scope}${this.separators.scopeStart}${nextStringified}${this.separators.scopeEnd}`;
                }
            }
            return stringified;
        }
    }
    stringifyScopedViewportInstructions(instructions) {
        if (!Array.isArray(instructions)) {
            return this.stringifyScopedViewportInstructions([instructions]);
        }
        return instructions.map((instruction) => this.stringifyViewportInstruction(instruction)).join(this.separators.scope);
    }
    encodeViewportInstructions(instructions) {
        return encodeURIComponent(this.stringifyViewportInstructions(instructions)).replace(/\(/g, '%28').replace(/\)/g, '%29');
    }
    decodeViewportInstructions(instructions) {
        return this.parseViewportInstructions(decodeURIComponent(instructions));
    }
    buildScopedLink(scopeContext, href) {
        if (scopeContext) {
            href = `/${scopeContext}${this.separators.scope}${href}`;
        }
        return href;
    }
    shouldClearViewports(path) {
        const clearViewports = (path === this.separators.clear || path.startsWith(this.separators.clear + this.separators.add));
        const newPath = path.startsWith(this.separators.clear) ? path.slice(2) : path;
        return { clearViewports, newPath };
    }
    mergeViewportInstructions(instructions) {
        const merged = [];
        for (let instruction of instructions) {
            if (typeof instruction === 'string') {
                instruction = this.parseViewportInstruction(instruction);
            }
            const index = merged.findIndex(merge => merge.sameViewport(instruction));
            if (index >= 0) {
                merged.splice(index, 1, instruction);
            }
            else {
                merged.push(instruction);
            }
        }
        return merged;
    }
    flattenViewportInstructions(instructions) {
        const flat = [];
        for (const instruction of instructions) {
            flat.push(instruction);
            if (instruction.nextScopeInstructions) {
                flat.push(...this.flattenViewportInstructions(instruction.nextScopeInstructions));
            }
        }
        return flat;
    }
    cloneViewportInstructions(instructions, keepInstances = false, context = false) {
        const clones = [];
        for (const instruction of instructions) {
            const clone = this.createViewportInstruction(instruction.componentName, instruction.viewportName, instruction.typedParameters !== null ? instruction.typedParameters : void 0);
            if (keepInstances) {
                clone.setComponent(instruction.componentInstance ?? instruction.componentType ?? instruction.componentName);
                clone.setViewport(instruction.viewport ?? instruction.viewportName);
            }
            clone.needsViewportDescribed = instruction.needsViewportDescribed;
            clone.route = instruction.route;
            if (context) {
                clone.context = instruction.context;
            }
            clone.viewportScope = keepInstances ? instruction.viewportScope : null;
            clone.scope = keepInstances ? instruction.scope : null;
            if (instruction.nextScopeInstructions) {
                clone.nextScopeInstructions = this.cloneViewportInstructions(instruction.nextScopeInstructions, keepInstances, context);
            }
            clones.push(clone);
        }
        return clones;
    }
    // TODO: Deal with separators in data and complex types
    parseComponentParameters(parameters, uriComponent = false) {
        if (parameters === undefined || parameters === null || parameters.length === 0) {
            return [];
        }
        if (typeof parameters === 'string') {
            const list = [];
            const params = parameters.split(this.separators.parameterSeparator);
            for (const param of params) {
                let key;
                let value;
                [key, value] = param.split(this.separators.parameterKeySeparator);
                if (value === void 0) {
                    value = uriComponent ? decodeURIComponent(key) : key;
                    key = void 0;
                }
                else if (uriComponent) {
                    key = decodeURIComponent(key);
                    value = decodeURIComponent(value);
                }
                list.push({ key, value });
            }
            return list;
        }
        if (Array.isArray(parameters)) {
            return parameters.map(param => ({ key: void 0, value: param }));
        }
        const keys = Object.keys(parameters);
        keys.sort();
        return keys.map(key => ({ key, value: parameters[key] }));
    }
    // TODO: Deal with separators in data and complex types
    stringifyComponentParameters(parameters, uriComponent = false) {
        if (!Array.isArray(parameters) || parameters.length === 0) {
            return '';
        }
        const seps = this.separators;
        return parameters
            .map(param => {
            const key = param.key !== void 0 && uriComponent ? encodeURIComponent(param.key) : param.key;
            const value = uriComponent ? encodeURIComponent(param.value) : param.value;
            return key !== void 0 && key !== value ? key + seps.parameterKeySeparator + value : value;
        })
            .join(seps.parameterSeparator);
    }
    matchScope(instructions, scope) {
        const matching = [];
        matching.push(...instructions.filter(instruction => instruction.scope === scope));
        matching.push(...instructions
            .filter(instr => instr.scope !== scope)
            .map(instr => Array.isArray(instr.nextScopeInstructions) ? this.matchScope(instr.nextScopeInstructions, scope) : [])
            .flat());
        return matching;
    }
    matchChildren(instructions, active) {
        for (const instruction of instructions) {
            const matching = active.filter(instr => instr.sameComponent(instruction));
            if (matching.length === 0) {
                return false;
            }
            if (Array.isArray(instruction.nextScopeInstructions)
                && instruction.nextScopeInstructions.length > 0
                && this.matchChildren(instruction.nextScopeInstructions, matching.map(instr => Array.isArray(instr.nextScopeInstructions) ? instr.nextScopeInstructions : []).flat()) === false) {
                return false;
            }
        }
        return true;
    }
    parseViewportInstructionsWorker(instructions, grouped = false) {
        if (!instructions) {
            return { instructions: [], remaining: '' };
        }
        if (instructions.startsWith(this.separators.scopeStart)) {
            instructions = `${this.separators.scope}${instructions}`;
        }
        const viewportInstructions = [];
        let guard = 1000;
        while (instructions.length && guard) {
            guard--;
            if (instructions.startsWith(this.separators.scope)) {
                instructions = instructions.slice(this.separators.scope.length);
                const scopeStart = instructions.startsWith(this.separators.scopeStart);
                if (scopeStart) {
                    instructions = instructions.slice(this.separators.scopeStart.length);
                }
                const { instructions: found, remaining } = this.parseViewportInstructionsWorker(instructions, scopeStart);
                if (viewportInstructions.length) {
                    viewportInstructions[viewportInstructions.length - 1].nextScopeInstructions = found;
                }
                else {
                    viewportInstructions.push(...found);
                }
                instructions = remaining;
            }
            else if (instructions.startsWith(this.separators.scopeEnd)) {
                if (grouped) {
                    instructions = instructions.slice(this.separators.scopeEnd.length);
                }
                return { instructions: viewportInstructions, remaining: instructions };
            }
            else if (instructions.startsWith(this.separators.sibling) && !this.isAddViewportInstruction(instructions)) {
                if (!grouped) {
                    return { instructions: viewportInstructions, remaining: instructions };
                }
                instructions = instructions.slice(this.separators.sibling.length);
            }
            else {
                const { instruction: viewportInstruction, remaining } = this.parseAViewportInstruction(instructions);
                viewportInstructions.push(viewportInstruction);
                instructions = remaining;
            }
        }
        return { instructions: viewportInstructions, remaining: instructions };
    }
    findNextToken(instruction, tokens) {
        const matches = {};
        // Tokens can have length > 1
        for (const token of tokens) {
            const tokenPos = instruction.indexOf(token);
            if (tokenPos > -1) {
                matches[token] = instruction.indexOf(token);
            }
        }
        const pos = Math.min(...Object.values(matches));
        for (const token in matches) {
            if (matches[token] === pos) {
                return { token, pos };
            }
        }
        return { token: '', pos: -1 };
    }
    parseAViewportInstruction(instruction) {
        const seps = this.separators;
        const tokens = [seps.parameters, seps.viewport, seps.noScope, seps.scopeEnd, seps.scope, seps.sibling];
        let component = void 0;
        let parametersString = void 0;
        let viewport = void 0;
        let scope = true;
        let token;
        let pos;
        const specials = [seps.add, seps.clear];
        for (const special of specials) {
            if (instruction === special) {
                component = instruction;
                instruction = '';
                tokens.shift(); // parameters
                tokens.shift(); // viewport
                token = seps.viewport;
                break;
            }
        }
        if (component === void 0) {
            for (const special of specials) {
                if (instruction.startsWith(`${special}${seps.viewport}`)) {
                    component = special;
                    instruction = instruction.slice(`${special}${seps.viewport}`.length);
                    tokens.shift(); // parameters
                    tokens.shift(); // viewport
                    token = seps.viewport;
                    break;
                }
            }
        }
        if (component === void 0) {
            ({ token, pos } = this.findNextToken(instruction, tokens));
            component = pos !== -1 ? instruction.slice(0, pos) : instruction;
            instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';
            tokens.shift(); // parameters
            if (token === seps.parameters) {
                ({ token, pos } = this.findNextToken(instruction, [seps.parametersEnd]));
                parametersString = instruction.slice(0, pos);
                instruction = instruction.slice(pos + token.length);
                ({ token } = this.findNextToken(instruction, tokens));
                instruction = instruction.slice(token.length);
            }
            tokens.shift(); // viewport
        }
        if (token === seps.viewport) {
            ({ token, pos } = this.findNextToken(instruction, tokens));
            viewport = pos !== -1 ? instruction.slice(0, pos) : instruction;
            instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';
        }
        tokens.shift(); // noScope
        if (token === seps.noScope) {
            scope = false;
        }
        // Restore token that belongs to next instruction
        if (token === seps.scopeEnd || token === seps.scope || token === seps.sibling) {
            instruction = `${token}${instruction}`;
        }
        const viewportInstruction = this.createViewportInstruction(component, viewport, parametersString, scope);
        return { instruction: viewportInstruction, remaining: instruction };
    }
    stringifyAViewportInstruction(instruction, excludeViewport = false, excludeComponent = false) {
        if (typeof instruction === 'string') {
            return this.stringifyViewportInstruction(this.parseViewportInstruction(instruction), excludeViewport, excludeComponent);
        }
        else {
            let instructionString = !excludeComponent ? instruction.componentName : '';
            const specification = instruction.componentType ? instruction.componentType.parameters : null;
            const parameters = this.stringifyComponentParameters(instruction.toSortedParameters(specification));
            if (parameters.length > 0) {
                instructionString += !excludeComponent
                    ? `${this.separators.parameters}${parameters}${this.separators.parametersEnd}`
                    : parameters;
            }
            if (instruction.viewportName !== null && !excludeViewport) {
                instructionString += this.separators.viewport + instruction.viewportName;
            }
            if (!instruction.ownsScope) {
                instructionString += this.separators.noScope;
            }
            return instructionString || '';
        }
    }
}
//# sourceMappingURL=instruction-resolver.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/interfaces.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/interfaces.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReentryBehavior": () => /* binding */ ReentryBehavior
/* harmony export */ });
var ReentryBehavior;
(function (ReentryBehavior) {
    ReentryBehavior["default"] = "default";
    ReentryBehavior["disallow"] = "disallow";
    ReentryBehavior["load"] = "load";
    ReentryBehavior["refresh"] = "refresh";
})(ReentryBehavior || (ReentryBehavior = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/lifecycle-logger.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/lifecycle-logger.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lifecycleLogger": () => /* binding */ lifecycleLogger,
/* harmony export */   "LifecycleClass": () => /* binding */ LifecycleClass
/* harmony export */ });
/**
 * @internal - Will be removed
 */
function lifecycleLogger(name) {
    const lifecycles = [
        'canUnload', 'unload',
        'canLoad', 'load',
        'created',
        'binding', 'bound',
        'beforeAttach', 'attaching',
        'detaching',
        'unbinding',
    ];
    return function (target) {
        for (const lifecycle of lifecycles) {
            const existing = target.prototype[lifecycle];
            if (existing !== void 0) {
                target.prototype[lifecycle] = function (...args) {
                    console.log(`${name} ${lifecycle}`, args);
                    return existing.apply(target, args);
                };
            }
            else {
                target.prototype[lifecycle] = function (...args) {
                    console.log(`${name} ${lifecycle}`, args);
                    if (lifecycle.startsWith('can')) {
                        return true;
                    }
                };
            }
        }
    };
}
class LifecycleClass {
    canLoad() { console.log(`name canLoad`); return true; }
    load(params) { console.log(`name load`); }
    created() { console.log(`name created`); }
    binding() { console.log(`name binding`); }
    bound() { console.log(`name bound`); }
    beforeAttach() { console.log(`name beforeAttach`); }
    attaching() { console.log(`name attaching`); }
    canUnload() { console.log(`name canUnload`); return true; }
    unload() { console.log(`name unload`); }
    detaching() { console.log(`name detaching`); }
    unbinding() { console.log(`name unbinding`); }
}
//# sourceMappingURL=lifecycle-logger.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/link-handler.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/link-handler.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkHandler": () => /* binding */ LinkHandler
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

/**
 * Class responsible for handling interactions that should trigger navigation.
 *
 * @ internal - Shouldn't be used directly.
 * TODO: remove the space between @ and i again at some point (this stripInternal currently screws up the types in the __tests__ package for some reason)
 */
let LinkHandler = class LinkHandler {
    constructor(p) {
        this.options = {
            useHref: true,
            callback: () => { return; }
        };
        this.isActive = false;
        this.handler = (e) => {
            const info = LinkHandler.getEventInfo(e, this.window, this.options);
            if (info.shouldHandleEvent) {
                e.preventDefault();
                this.options.callback(info);
            }
        };
        this.window = p.window;
        this.document = p.document;
    }
    /**
     * Gets the href and a "should handle" recommendation, given an Event.
     *
     * @param event - The Event to inspect for target anchor and href.
     */
    static getEventInfo(event, win, options) {
        const info = {
            shouldHandleEvent: false,
            instruction: null,
            anchor: null
        };
        const target = info.anchor = event.currentTarget;
        // Switch to this for delegation:
        // const target = info.anchor = LinkHandler.closestAnchor(event.target as Element);
        if (!target || !LinkHandler.targetIsThisWindow(target, win)) {
            return info;
        }
        if (target.hasAttribute('external')) {
            return info;
        }
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
            return info;
        }
        const gotoAttr = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(target, 'goto');
        const goto = gotoAttr !== void 0 ? gotoAttr.viewModel.value : null;
        const loadAttr = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(target, 'load');
        const load = loadAttr !== void 0 ? loadAttr.viewModel.value : null;
        const href = options.useHref && target.hasAttribute('href') ? target.getAttribute('href') : null;
        if ((goto === null || goto.length === 0) && (load === null || load.length === 0) && (href === null || href.length === 0)) {
            return info;
        }
        info.anchor = target;
        info.instruction = load ?? goto ?? href;
        const leftButtonClicked = event.button === 0;
        info.shouldHandleEvent = leftButtonClicked;
        return info;
    }
    /**
     * Finds the closest ancestor that's an anchor element.
     *
     * @param el - The element to search upward from.
     * @returns The link element that is the closest ancestor.
     */
    // private static closestAnchor(el: Element): Element | null {
    //   while (el !== null && el !== void 0) {
    //     if (el.tagName === 'A') {
    //       return el;
    //     }
    //     el = el.parentNode as Element;
    //   }
    //   return null;
    // }
    /**
     * Gets a value indicating whether or not an anchor targets the current window.
     *
     * @param target - The anchor element whose target should be inspected.
     * @returns True if the target of the link element is this window; false otherwise.
     */
    static targetIsThisWindow(target, win) {
        const targetWindow = target.getAttribute('target');
        return !targetWindow ||
            targetWindow === win.name ||
            targetWindow === '_self';
    }
    /**
     * Start the instance.
     *
     */
    start(options) {
        if (this.isActive) {
            throw new Error('Link handler has already been started');
        }
        this.isActive = true;
        this.options = { ...options };
    }
    /**
     * Stop the instance. Event handlers and other resources should be cleaned up here.
     */
    stop() {
        if (!this.isActive) {
            throw new Error('Link handler has not been started');
        }
        this.isActive = false;
    }
};
LinkHandler = __decorate([
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IPlatform)
], LinkHandler);

//# sourceMappingURL=link-handler.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/nav-route.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/nav-route.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavRoute": () => /* binding */ NavRoute
/* harmony export */ });
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");

/**
 * @internal - Used by au-nav
 */
class NavRoute {
    constructor(nav, route) {
        this.nav = nav;
        this.instructions = [];
        this.link = null;
        this.linkVisible = null;
        this.linkActive = null;
        this.compareParameters = false;
        this.children = null;
        this.visible = true;
        this.active = '';
        this.title = route.title;
        this.meta = route.meta;
        if (route.route) {
            this.instructions = this.parseRoute(route.route);
            this.link = this.computeLink(this.instructions);
        }
        this.linkActive = route.consideredActive !== null && route.consideredActive !== void 0 ? route.consideredActive : this.link;
        if (this.linkActive !== null && (!(this.linkActive instanceof Function) || _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.isType(this.linkActive))) {
            this.linkActive = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.NavigationInstructionResolver.toViewportInstructions(this.nav.router, this.linkActive);
        }
        this.execute = route.execute;
        this.compareParameters = !!route.compareParameters;
        this.linkVisible = route.condition === undefined ? true : route.condition;
        this.update();
    }
    get hasChildren() {
        return (this.children && this.children.length ? 'nav-has-children' : '');
    }
    update() {
        this.visible = this.computeVisible();
        if ((this.link && this.link.length) || this.execute) {
            this.active = this.computeActive();
        }
        else {
            this.active = (this.active === 'nav-active' ? 'nav-active' : (this.activeChild() ? 'nav-active-child' : ''));
        }
    }
    executeAction(event) {
        if (this.execute) {
            this.execute(this);
        }
        event.stopPropagation();
    }
    toggleActive() {
        this.active = (this.active.startsWith('nav-active') ? '' : 'nav-active');
    }
    parseRoute(routes) {
        return _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.NavigationInstructionResolver.toViewportInstructions(this.nav.router, routes);
    }
    computeVisible() {
        if (this.linkVisible instanceof Function) {
            return this.linkVisible(this);
        }
        return !!this.linkVisible;
    }
    computeActive() {
        if (!Array.isArray(this.linkActive)) {
            return this.linkActive(this) ? 'nav-active' : '';
        }
        const components = this.linkActive;
        const activeComponents = this.nav.router.instructionResolver.flattenViewportInstructions(this.nav.router.activeComponents);
        for (const component of components) {
            if (activeComponents.every((active) => !active.sameComponent(component, this.compareParameters && component.typedParameters !== null))) {
                return '';
            }
        }
        return 'nav-active';
    }
    computeLink(instructions) {
        return this.nav.router.instructionResolver.stringifyViewportInstructions(instructions);
    }
    activeChild() {
        if (this.children) {
            for (const child of this.children) {
                if (child.active.startsWith('nav-active') || child.activeChild()) {
                    return true;
                }
            }
        }
        return false;
    }
}
//# sourceMappingURL=nav-route.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/nav.js":
/*!******************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/nav.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Nav": () => /* binding */ Nav
/* harmony export */ });
/* harmony import */ var _nav_route_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nav-route.js */ "./node_modules/@aurelia/router/dist/esm/nav-route.js");

/**
 * Public API - Used by au-nav and Router add/setNav
 */
class Nav {
    constructor(router, name, routes = [], classes = {}) {
        this.router = router;
        this.name = name;
        this.routes = routes;
        this.classes = classes;
        this.update();
    }
    addRoutes(routes) {
        for (const route of routes) {
            this.addRoute(this.routes, route);
        }
        this.update();
    }
    update() {
        this.updateRoutes(this.routes);
        this.routes = this.routes.slice();
    }
    addRoute(routes, route) {
        const newRoute = new _nav_route_js__WEBPACK_IMPORTED_MODULE_0__.NavRoute(this, route);
        routes.push(newRoute);
        if (route.children) {
            newRoute.children = [];
            for (const child of route.children) {
                this.addRoute(newRoute.children, child);
            }
        }
    }
    updateRoutes(routes) {
        for (const route of routes) {
            route.update();
            if (route.children && route.children.length) {
                this.updateRoutes(route.children);
            }
        }
    }
}
//# sourceMappingURL=nav.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/navigation-coordinator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/navigation-coordinator.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavigationCoordinatorOptions": () => /* binding */ NavigationCoordinatorOptions,
/* harmony export */   "NavigationCoordinator": () => /* binding */ NavigationCoordinator
/* harmony export */ });
/* harmony import */ var _state_coordinator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state-coordinator.js */ "./node_modules/@aurelia/router/dist/esm/state-coordinator.js");

class NavigationCoordinatorOptions {
    constructor(input) {
        // console.log('NavigationCoordinatorOptions constructor', input);
        this.syncStates = input.syncStates ?? [];
    }
}
class NavigationCoordinator extends _state_coordinator_js__WEBPACK_IMPORTED_MODULE_0__.StateCoordinator {
    constructor() {
        super(...arguments);
        this.running = false;
    }
    static create(router, navigation, options) {
        const coordinator = new NavigationCoordinator();
        coordinator.router = router;
        coordinator.navigation = navigation;
        // TODO: Set flow options from router
        options.syncStates.forEach((state) => coordinator.addSyncState(state));
        // console.log('NavigationCoordinator created', coordinator);
        return coordinator;
    }
    // public get isRestrictedNavigation(): boolean {
    //   return this.syncStates.has('guardedLoad') ||
    //     this.syncStates.has('unloaded') ||
    //     this.syncStates.has('loaded') ||
    //     this.syncStates.has('guarded') ||
    //     this.syncStates.has('routed');
    // }
    run() {
        if (!this.running) {
            // console.log('NavigationCoordinator RUN' /*, { ...this } */);
            this.running = true;
            for (const entity of this.entities) {
                if (!entity.running) {
                    entity.running = true;
                    entity.entity.transition(this);
                }
            }
        }
    }
    addEntity(entity) {
        const ent = super.addEntity(entity);
        if (this.running) {
            ent.entity.transition(this);
        }
        return ent;
    }
    finalize() {
        this.entities.forEach(entity => entity.entity.finalizeContentChange());
    }
    cancel() {
        // TODO: Take care of disabling viewports when cancelling and stateful!
        this.entities.forEach(entity => {
            const abort = entity.entity.abortContentChange();
            if (abort instanceof Promise) {
                abort.catch(error => { throw error; });
            }
        });
        this.router.navigator.cancel(this.navigation).then(() => {
            this.router.processingNavigation = null;
            this.navigation.resolve();
        }).catch(error => { throw error; });
    }
    // A new navigation should cancel replaced instructions
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    cancelReplaced(navigation) { }
}
//# sourceMappingURL=navigation-coordinator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/navigation.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/navigation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Navigation": () => /* binding */ Navigation
/* harmony export */ });
class Navigation {
    constructor(entry = {
        instruction: '',
        fullStateInstruction: '',
    }) {
        this.navigation = entry.navigation ?? {
            first: false,
            new: false,
            refresh: false,
            forward: false,
            back: false,
            replace: false,
        };
        this.repeating = entry.repeating;
        // INavigatorEntry
        this.fromBrowser = entry.fromBrowser;
        this.origin = entry.origin;
        this.replacing = entry.replacing;
        this.refreshing = entry.refreshing;
        this.untracked = entry.untracked;
        this.historyMovement = entry.historyMovement;
        this.resolve = entry.resolve;
        this.reject = entry.reject;
        // IStoredNavigatorEntry
        this.instruction = entry.instruction;
        this.fullStateInstruction = entry.fullStateInstruction;
        this.scope = entry.scope;
        this.index = entry.index;
        this.firstEntry = entry.firstEntry;
        this.route = entry.route;
        this.path = entry.path;
        this.title = entry.title;
        this.query = entry.query;
        this.parameters = entry.parameters;
        this.data = entry.data;
    }
    get useFullStateInstruction() {
        return (this.navigation.back ?? false) || (this.navigation.forward ?? false);
    }
    toStored() {
        return {
            navigation: this.navigation,
            repeating: this.repeating,
            // IStoredNavigatorEntry
            instruction: this.instruction,
            fullStateInstruction: this.fullStateInstruction,
            scope: this.scope,
            index: this.index,
            firstEntry: this.firstEntry,
            route: this.route,
            path: this.path,
            title: this.title,
            query: this.query,
            parameters: this.parameters,
            data: this.data,
        };
    }
}
//# sourceMappingURL=navigation.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/navigator.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/navigator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Navigator": () => /* binding */ Navigator
/* harmony export */ });
/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queue.js */ "./node_modules/@aurelia/router/dist/esm/queue.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");



/**
 * @internal - Shouldn't be used directly
 */
class Navigator {
    constructor() {
        this.entries = [];
        this.options = {
            statefulHistoryLength: 0,
        };
        this.isActive = false;
        this.processNavigations = (qEntry) => {
            const entry = qEntry;
            const navigationFlags = {
                first: false,
                new: false,
                refresh: false,
                forward: false,
                back: false,
                replace: false,
            };
            if (this.currentEntry === this.uninitializedEntry) { // Refresh or first entry
                this.loadState();
                if (this.currentEntry !== this.uninitializedEntry) {
                    navigationFlags.refresh = true;
                }
                else {
                    navigationFlags.first = true;
                    navigationFlags.new = true;
                    // TODO: Should this really be created here? Shouldn't it be in the viewer?
                    this.currentEntry = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation({
                        index: 0,
                        instruction: '',
                        fullStateInstruction: '',
                    });
                    this.entries = [];
                }
            }
            if (entry.index !== void 0 && !entry.replacing && !entry.refreshing) { // History navigation
                entry.historyMovement = entry.index - (this.currentEntry.index !== void 0 ? this.currentEntry.index : 0);
                entry.instruction = this.entries[entry.index] !== void 0 && this.entries[entry.index] !== null ? this.entries[entry.index].fullStateInstruction : entry.fullStateInstruction;
                entry.replacing = true;
                if (entry.historyMovement > 0) {
                    navigationFlags.forward = true;
                }
                else if (entry.historyMovement < 0) {
                    navigationFlags.back = true;
                }
            }
            else if (entry.refreshing || navigationFlags.refresh) { // Refreshing
                entry.index = this.currentEntry.index;
            }
            else if (entry.replacing) { // Replacing
                navigationFlags.replace = true;
                navigationFlags.new = true;
                entry.index = this.currentEntry.index;
            }
            else { // New entry
                navigationFlags.new = true;
                entry.index = this.currentEntry.index !== void 0 ? this.currentEntry.index + 1 : this.entries.length;
            }
            this.invokeCallback(entry, navigationFlags, this.currentEntry);
        };
        this.uninitializedEntry = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation({
            instruction: 'NAVIGATOR UNINITIALIZED',
            fullStateInstruction: '',
        });
        this.currentEntry = this.uninitializedEntry;
        this.pendingNavigations = new _queue_js__WEBPACK_IMPORTED_MODULE_0__.Queue(this.processNavigations);
    }
    get queued() {
        return this.pendingNavigations.length;
    }
    start(router, options) {
        if (this.isActive) {
            throw new Error('Navigator has already been started');
        }
        this.isActive = true;
        this.router = router;
        this.options = { ...options };
    }
    stop() {
        if (!this.isActive) {
            throw new Error('Navigator has not been started');
        }
        this.pendingNavigations.clear();
        this.isActive = false;
    }
    async navigate(entry) {
        return this.pendingNavigations.enqueue(entry);
    }
    async refresh() {
        const entry = this.currentEntry;
        if (entry === this.uninitializedEntry) {
            return Promise.reject();
        }
        entry.replacing = true;
        entry.refreshing = true;
        return this.navigate(entry);
    }
    async go(movement) {
        const newIndex = (this.currentEntry.index !== undefined ? this.currentEntry.index : 0) + movement;
        if (newIndex >= this.entries.length) {
            return Promise.reject();
        }
        const entry = this.entries[newIndex];
        return this.navigate(entry);
    }
    async setEntryTitle(title) {
        this.currentEntry.title = title;
        return this.saveState();
    }
    get titles() {
        if (this.currentEntry === this.uninitializedEntry) {
            return [];
        }
        const index = this.currentEntry.index !== void 0 ? this.currentEntry.index : 0;
        return this.entries.slice(0, index + 1).filter((value) => !!value.title).map((value) => value.title ? value.title : '');
    }
    // Get the stored navigator state (json okay)
    getState() {
        const state = this.options.store ? { ...this.options.store.state } : {};
        const entries = (state.entries ?? []);
        const currentEntry = (state.currentEntry ?? null);
        return { state, entries, currentEntry };
    }
    // Load a stored state into Navigation entries
    loadState() {
        const state = this.getState();
        this.entries = state.entries.map(entry => new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation(entry));
        this.currentEntry = state.currentEntry !== null
            ? new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation(state.currentEntry)
            : this.uninitializedEntry;
    }
    // Save storeable versions of Navigation entries
    async saveState(push = false) {
        if (this.currentEntry === this.uninitializedEntry) {
            return Promise.resolve();
        }
        const storedEntry = this.currentEntry.toStored();
        this.entries[storedEntry.index !== void 0 ? storedEntry.index : 0] = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation(storedEntry);
        // If preserving history, serialize entries that aren't preserved
        if (this.options.statefulHistoryLength > 0) {
            const index = this.entries.length - this.options.statefulHistoryLength;
            for (let i = 0; i < index; i++) {
                const entry = this.entries[i];
                if (typeof entry.instruction !== 'string' || typeof entry.fullStateInstruction !== 'string') {
                    await this.serializeEntry(entry, this.entries.slice(index));
                }
            }
        }
        if (!this.options.store) {
            return Promise.resolve();
        }
        const state = {
            entries: (this.entries ?? []).map((entry) => this.toStoreableEntry(entry)),
            currentEntry: this.toStoreableEntry(storedEntry),
        };
        // for (const entry of this.entries) {
        //   state.entries.push(this.toStoreableEntry(entry));
        // }
        if (state.currentEntry.title !== void 0) {
            this.options.store.setTitle(state.currentEntry.title);
        }
        if (push) {
            return this.options.store.pushNavigatorState(state);
        }
        else {
            return this.options.store.replaceNavigatorState(state);
        }
    }
    toStoredEntry(entry) {
        const { previous, fromBrowser, origin, replacing, refreshing, untracked, historyMovement, navigation, scope, resolve, reject, ...storableEntry } = entry;
        return storableEntry;
    }
    async finalize(instruction) {
        this.currentEntry = instruction;
        let index = this.currentEntry.index !== undefined ? this.currentEntry.index : 0;
        if (this.currentEntry.untracked) {
            if (instruction.fromBrowser && this.options.store) {
                await this.options.store.popNavigatorState();
            }
            index--;
            this.currentEntry.index = index;
            this.entries[index] = this.currentEntry;
            await this.saveState();
        }
        else if (this.currentEntry.replacing) {
            this.entries[index] = this.currentEntry;
            await this.saveState();
        }
        else { // New entry (add and discard later entries)
            if (this.options.serializeCallback !== void 0 && this.options.statefulHistoryLength > 0) {
                // Need to clear the instructions we discard!
                const indexPreserve = this.entries.length - this.options.statefulHistoryLength;
                for (const entry of this.entries.slice(index)) {
                    if (typeof entry.instruction !== 'string' || typeof entry.fullStateInstruction !== 'string') {
                        await this.options.serializeCallback(entry, this.entries.slice(indexPreserve, index));
                    }
                }
            }
            this.entries = this.entries.slice(0, index);
            this.entries.push(this.currentEntry);
            await this.saveState(true);
        }
        if (this.currentEntry.resolve) {
            this.currentEntry.resolve();
        }
    }
    async cancel(instruction) {
        if (instruction.fromBrowser && this.options.store) {
            if (instruction.navigation && instruction.navigation.new) {
                await this.options.store.popNavigatorState();
            }
            else {
                await this.options.store.go(-(instruction.historyMovement || 0), true);
            }
        }
        if (this.currentEntry.resolve) {
            this.currentEntry.resolve();
        }
    }
    invokeCallback(entry, navigationFlags, previousEntry) {
        const instruction = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation({ ...entry });
        instruction.navigation = navigationFlags;
        instruction.previous = previousEntry;
        if (this.options.callback) {
            this.options.callback(instruction);
        }
    }
    toStoreableEntry(entry) {
        const storeable = entry instanceof _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation ? entry.toStored() : entry;
        storeable.instruction = this.router.instructionResolver.stringifyViewportInstructions(storeable.instruction);
        storeable.fullStateInstruction = this.router.instructionResolver.stringifyViewportInstructions(storeable.fullStateInstruction);
        if (typeof storeable.scope !== 'string') {
            storeable.scope = null;
        }
        return storeable;
    }
    async serializeEntry(entry, preservedEntries) {
        const instructionResolver = this.router.instructionResolver;
        let excludeComponents = [];
        // Components in preserved entries should not be serialized/freed
        for (const preservedEntry of preservedEntries) {
            if (typeof preservedEntry.instruction !== 'string') {
                excludeComponents.push(...instructionResolver.flattenViewportInstructions(preservedEntry.instruction)
                    .filter(instruction => instruction.viewport !== null)
                    .map(instruction => instruction.componentInstance));
            }
            if (typeof preservedEntry.fullStateInstruction !== 'string') {
                excludeComponents.push(...instructionResolver.flattenViewportInstructions(preservedEntry.fullStateInstruction)
                    .filter(instruction => instruction.viewport !== null)
                    .map(instruction => instruction.componentInstance));
            }
        }
        // Make unique
        excludeComponents = excludeComponents.filter((component, i, arr) => component !== null && arr.indexOf(component) === i);
        let instructions = [];
        // The instructions, one or two, with possible components to free
        if (typeof entry.fullStateInstruction !== 'string') {
            instructions.push(...entry.fullStateInstruction);
            entry.fullStateInstruction = instructionResolver.stringifyViewportInstructions(entry.fullStateInstruction);
        }
        if (typeof entry.instruction !== 'string') {
            instructions.push(...entry.instruction);
            entry.instruction = instructionResolver.stringifyViewportInstructions(entry.instruction);
        }
        // Process only those with instances and make unique
        instructions = instructions.filter((instruction, i, arr) => instruction !== null
            && instruction.componentInstance !== null
            && arr.indexOf(instruction) === i);
        // Already freed components (updated when component is freed)
        const alreadyDone = [];
        for (const instruction of instructions) {
            await this.freeInstructionComponents(instruction, excludeComponents, alreadyDone);
        }
    }
    freeInstructionComponents(instruction, excludeComponents, alreadyDone) {
        const component = instruction.componentInstance;
        const viewport = instruction.viewport;
        if (component === null || viewport === null || alreadyDone.some(done => done === component)) {
            return;
        }
        if (!excludeComponents.some(exclude => exclude === component)) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_2__.Runner.run(() => viewport.freeContent(component), () => {
                alreadyDone.push(component);
            });
        }
        if (instruction.nextScopeInstructions !== null) {
            for (const nextInstruction of instruction.nextScopeInstructions) {
                return _runner_js__WEBPACK_IMPORTED_MODULE_2__.Runner.run(() => this.freeInstructionComponents(nextInstruction, excludeComponents, alreadyDone));
            }
        }
    }
}
//# sourceMappingURL=navigator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/open-promise.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/open-promise.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OpenPromise": () => /* binding */ OpenPromise
/* harmony export */ });
class OpenPromise {
    constructor() {
        this.isPending = true;
        this.promise = new Promise((res, rej) => {
            this.res = res;
            this.rej = rej;
        });
    }
    resolve(value) {
        this.res(value);
        this.isPending = false;
    }
    reject(value) {
        this.rej(value);
        this.isPending = false;
    }
}
//# sourceMappingURL=open-promise.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/parser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseQuery": () => /* binding */ parseQuery
/* harmony export */ });
/**
 * @internal - Shouldn't be used directly
 */
function parseQuery(query) {
    if (!query || !query.length) {
        return {};
    }
    const parameters = {};
    // TODO: Deal with complex parameters such as lists and objects
    const params = query.replace('+', ' ').split('&');
    for (const param of params) {
        const [key, value] = param.split('=');
        parameters[decodeURIComponent(key)] = decodeURIComponent(value !== void 0 ? value : key);
    }
    return parameters;
}
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/queue.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/queue.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Queue": () => /* binding */ Queue
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A first-in-first-out queue that only processes the next queued item
 * when the current one has been resolved or rejected. Sends queued items
 * one at a time to a specified callback function. The callback function
 * should resolve or reject the queued item when processing is done.
 * Enqueued items can be awaited. Enqueued items can specify an (arbitrary)
 * execution cost and the queue can be set up (started) to only process
 * a specific amount of execution cost per RAF/tick.
 *
 * @internal - Shouldn't be used directly.
 */
class Queue {
    constructor(callback) {
        this.callback = callback;
        this.pending = [];
        this.processing = null;
        this.allowedExecutionCostWithinTick = null;
        this.currentExecutionCostInCurrentTick = 0;
        this.platform = null;
        this.task = null;
    }
    get isActive() {
        return this.task !== null;
    }
    get length() {
        return this.pending.length;
    }
    start(options) {
        if (this.isActive) {
            throw new Error('Queue has already been started');
        }
        this.platform = options.platform;
        this.allowedExecutionCostWithinTick = options.allowedExecutionCostWithinTick;
        this.task = this.platform.domWriteQueue.queueTask(this.dequeue, { persistent: true });
    }
    stop() {
        if (!this.isActive) {
            throw new Error('Queue has not been started');
        }
        this.task.cancel();
        this.task = null;
        this.allowedExecutionCostWithinTick = null;
        this.clear();
    }
    enqueue(itemOrItems, costOrCosts) {
        const list = Array.isArray(itemOrItems);
        const items = list ? itemOrItems : [itemOrItems];
        const costs = items
            .map((value, index) => !Array.isArray(costOrCosts) ? costOrCosts : costOrCosts[index])
            .map(value => value !== undefined ? value : 1);
        const promises = [];
        for (const item of items) {
            const qItem = { ...item };
            qItem.cost = costs.shift();
            promises.push(new Promise((resolve, reject) => {
                qItem.resolve = () => {
                    resolve();
                    this.processing = null;
                    this.dequeue();
                };
                qItem.reject = (reason) => {
                    reject(reason);
                    this.processing = null;
                    this.dequeue();
                };
            }));
            this.pending.push(qItem);
        }
        this.dequeue();
        return list ? promises : promises[0];
    }
    dequeue(delta) {
        if (this.processing !== null) {
            return;
        }
        if (delta !== undefined) {
            this.currentExecutionCostInCurrentTick = 0;
        }
        if (!this.pending.length) {
            return;
        }
        if (this.allowedExecutionCostWithinTick !== null && delta === undefined && this.currentExecutionCostInCurrentTick + (this.pending[0].cost || 0) > this.allowedExecutionCostWithinTick) {
            return;
        }
        this.processing = this.pending.shift() || null;
        if (this.processing) {
            this.currentExecutionCostInCurrentTick += this.processing.cost || 0;
            this.callback(this.processing);
        }
    }
    clear() {
        this.pending.splice(0, this.pending.length);
    }
}
__decorate([
    _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.bound
], Queue.prototype, "dequeue", null);
//# sourceMappingURL=queue.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/goto.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/goto.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GotoCustomAttribute": () => /* binding */ GotoCustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




let GotoCustomAttribute = class GotoCustomAttribute {
    constructor(element, router) {
        this.element = element;
        this.router = router;
        this.hasHref = null;
        this.activeClass = 'goto-active';
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.deprecationWarning)('"goto" custom attribute', '"load" custom attribute');
    }
    binding() {
        this.element.addEventListener('click', this.router.linkHandler.handler);
        this.updateValue();
        const observerLocator = this.router.container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IObserverLocator);
        this.observer = observerLocator.getObserver(this.router, 'activeComponents');
        this.observer.subscribe(this);
    }
    unbinding() {
        this.element.removeEventListener('click', this.router.linkHandler.handler);
        this.observer.unsubscribe(this);
    }
    valueChanged(newValue) {
        this.updateValue();
    }
    updateValue() {
        if (this.hasHref === null) {
            this.hasHref = this.element.hasAttribute('href');
        }
        if (!this.hasHref) {
            // TODO: Figure out a better value here for non-strings (using InstructionResolver?)
            const value = typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
            this.element.setAttribute('href', value);
        }
    }
    handleChange() {
        const controller = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(this.element, 'goto').parent;
        const created = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.createViewportInstructions(this.router, this.value, { context: controller });
        const instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.toViewportInstructions(this.router, created.instructions);
        for (const instruction of instructions) {
            if (instruction.scope === null) {
                instruction.scope = created.scope;
            }
        }
        // TODO: Use router configuration for class name and update target
        if (this.router.checkActive(instructions)) {
            this.element.classList.add(this.activeClass);
        }
        else {
            this.element.classList.remove(this.activeClass);
        }
    }
};
__decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable)({ mode: _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView })
], GotoCustomAttribute.prototype, "value", void 0);
GotoCustomAttribute = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customAttribute)('goto'),
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(1, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], GotoCustomAttribute);

//# sourceMappingURL=goto.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/href.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/href.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HrefCustomAttribute": () => /* binding */ HrefCustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _configuration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../configuration.js */ "./node_modules/@aurelia/router/dist/esm/configuration.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



let HrefCustomAttribute = class HrefCustomAttribute {
    constructor(element, router) {
        this.element = element;
        this.router = router;
    }
    binding() {
        if (this.router.options.useHref && !this.hasGoto()) {
            this.element.addEventListener('click', this.router.linkHandler.handler);
        }
        this.updateValue();
    }
    unbinding() {
        this.element.removeEventListener('click', this.router.linkHandler.handler);
    }
    valueChanged() {
        this.updateValue();
    }
    updateValue() {
        this.element.setAttribute('href', this.value);
    }
    hasGoto() {
        const parent = this.$controller.parent;
        const siblings = parent.children;
        return siblings !== null
            && siblings.some(c => c.vmKind === 1 /* customAttribute */ && c.viewModel instanceof _configuration_js__WEBPACK_IMPORTED_MODULE_2__.GotoCustomAttribute);
    }
};
__decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable)({ mode: _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView })
], HrefCustomAttribute.prototype, "value", void 0);
HrefCustomAttribute = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customAttribute)({
        name: 'href',
        noMultiBindings: true
    }),
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(1, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], HrefCustomAttribute);

//# sourceMappingURL=href.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/load.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/load.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoadCustomAttribute": () => /* binding */ LoadCustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



let LoadCustomAttribute = class LoadCustomAttribute {
    constructor(element, router) {
        this.element = element;
        this.router = router;
        this.hasHref = null;
        this.activeClass = 'load-active';
    }
    binding() {
        this.element.addEventListener('click', this.router.linkHandler.handler);
        this.updateValue();
        const observerLocator = this.router.container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IObserverLocator);
        this.observer = observerLocator.getObserver(this.router, 'activeComponents');
        this.observer.subscribe(this);
    }
    unbinding() {
        this.element.removeEventListener('click', this.router.linkHandler.handler);
        this.observer.unsubscribe(this);
    }
    valueChanged(newValue) {
        this.updateValue();
    }
    updateValue() {
        if (this.hasHref === null) {
            this.hasHref = this.element.hasAttribute('href');
        }
        if (!this.hasHref) {
            // TODO: Figure out a better value here for non-strings (using InstructionResolver?)
            const value = typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
            this.element.setAttribute('href', value);
        }
    }
    handleChange() {
        const controller = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(this.element, 'load').parent;
        const created = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.createViewportInstructions(this.router, this.value, { context: controller });
        const instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.toViewportInstructions(this.router, created.instructions);
        for (const instruction of instructions) {
            if (instruction.scope === null) {
                instruction.scope = created.scope;
            }
        }
        // TODO: Use router configuration for class name and update target
        if (this.router.checkActive(instructions)) {
            this.element.classList.add(this.activeClass);
        }
        else {
            this.element.classList.remove(this.activeClass);
        }
    }
};
__decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable)({ mode: _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView })
], LoadCustomAttribute.prototype, "value", void 0);
LoadCustomAttribute = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customAttribute)('load'),
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(1, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], LoadCustomAttribute);

//# sourceMappingURL=load.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/nav.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/nav.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavCustomElement": () => /* binding */ NavCustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


let NavCustomElement = class NavCustomElement {
    constructor(router) {
        this.router = router;
        this.name = null;
        this.routes = null;
        this.level = 0;
        this.classes = {};
    }
    get navRoutes() {
        const nav = this.router.navs[this.name];
        return (nav !== void 0 && nav !== null ? nav.routes : []);
    }
    get navClasses() {
        const nav = this.router.navs[this.name];
        const navClasses = (nav !== void 0 && nav !== null ? nav.classes : {});
        return {
            ...{
                nav: '',
                ul: '',
                li: '',
                a: '',
                ulActive: '',
                liActive: 'nav-active',
                aActive: '',
            }, ...navClasses
        };
    }
    active(route) {
        return 'Active';
    }
};
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "name", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "routes", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "level", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "classes", void 0);
NavCustomElement = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customElement)({
        name: 'au-nav', template: `<template>
  <nav if.bind="name" class="\${name} \${navClasses.nav}">
    <au-nav routes.bind="navRoutes" classes.bind="navClasses" containerless></au-nav>
  </nav>
  <ul if.bind="routes" class="nav-level-\${level} \${classes.ul}">
    <li repeat.for="route of routes" if.bind="route.visible" class="\${route.active ? classes.liActive : ''} \${route.hasChildren} \${classes.li}">
      <a if.bind="route.link && route.link.length" load="\${route.link}" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <a if.bind="route.execute" click.trigger="route.executeAction($event)" href="" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <span if.bind="(!route.link || !route.link.length) && !route.execute && !route.children" class="\${route.active ? classes.aActive : ''} \${classes.span} nav-separator" innerhtml.bind="route.title"></span>
      <a if.bind="(!route.link || !route.link.length) && !route.execute && route.children" click.delegate="route.toggleActive()" href="" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <au-nav if.bind="route.children" routes.bind="route.children" level.bind="level + 1" classes.bind="classes" containerless></au-nav>
    </li>
  </ul>
</template>`
    }),
    __param(0, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], NavCustomElement);

//# sourceMappingURL=nav.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParentViewportScope": () => /* binding */ ParentViewportScope,
/* harmony export */   "ViewportScopeCustomElement": () => /* binding */ ViewportScopeCustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ViewportScopeCustomElement_1;




const ParentViewportScope = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.createInjectable();
let ViewportScopeCustomElement = ViewportScopeCustomElement_1 = class ViewportScopeCustomElement {
    constructor(router, element, container, parent, parentController) {
        this.router = router;
        this.element = element;
        this.container = container;
        this.parent = parent;
        this.parentController = parentController;
        this.name = 'default';
        this.catches = '';
        this.collection = false;
        this.source = null;
        this.viewportScope = null;
        this.isBound = false;
    }
    // Maybe this really should be here. Check with Fred
    // public create(
    //   controller: IDryCustomElementController<this>,
    //   parentContainer: IContainer,
    //   definition: CustomElementDefinition,
    //   parts: PartialCustomElementDefinitionParts | undefined,
    // ): PartialCustomElementDefinition {
    //   // TODO(fkleuver): describe this somewhere in the docs instead
    //   // Under the condition that there is no `replace` attribute on this custom element's declaration,
    //   // and this custom element is containerless, its content will be placed in a part named 'default'
    //   // See packages/jit-html/src/template-binder.ts line 411 (`replace = 'default';`) for the logic that governs this.
    //   // We could tidy this up into a formal api in the future. For now, there are two ways to do this:
    //   // 1. inject the `@IInstruction` (IHydrateElementInstruction) and grab .parts['default'] from there, manually creating a view factory from that, etc.
    //   // 2. what we're doing right here: grab the 'default' part from the create hook and return it as the definition, telling the render context to use that part to compile this element instead
    //   // This effectively causes this element to render its declared content as if it was its own template.
    //   // We do need to set `containerless` to true on the part definition so that the correct projector is used since parts default to non-containerless.
    //   // Otherwise, the controller will try to do `appendChild` on a comment node when it has to do `insertBefore`.
    //   // Also, in this particular scenario (specific to viewport-scope) we need to clone the part so as to prevent the resulting compiled definition
    //   // from ever being cached. That's the only reason why we're spreading the part into a new object for `getOrCreate`. If we didn't clone the object, this specific element wouldn't work correctly.
    //   const part = parts!['default'];
    //   return CustomElementDefinition.getOrCreate({ ...part, containerless: true });
    // }
    hydrated(controller) {
        this.controller = controller;
        // Don't update the container here (probably because it wants to be a part of the structure)
        // this.container = controller.context.get(IContainer);
        // console.log('ViewportScope creating', this.getAttribute('name', this.name), this.container, this.parent, controller, this);
        // this.connect();
    }
    bound(initiator, parent, flags) {
        this.isBound = true;
        this.$controller.scope = this.parentController.scope;
        this.connect();
        if (this.viewportScope !== null) {
            this.viewportScope.binding();
        }
    }
    unbinding(initiator, parent, flags) {
        if (this.viewportScope !== null) {
            this.viewportScope.unbinding();
        }
        return Promise.resolve();
    }
    afterUnbind(initiator, parent, flags) {
        this.disconnect();
        return Promise.resolve();
    }
    afterUnbound() {
        this.isBound = false;
    }
    connect() {
        if (this.router.rootScope === null) {
            return;
        }
        const name = this.getAttribute('name', this.name);
        const options = {};
        let value = this.getAttribute('catches', this.catches);
        if (value !== void 0) {
            options.catches = value;
        }
        value = this.getAttribute('collection', this.collection, true);
        if (value !== void 0) {
            options.collection = value;
        }
        // TODO: Needs to be bound? How to solve?
        options.source = this.source || null;
        this.controller.routingContainer = this.container;
        this.viewportScope = this.router.connectViewportScope(this.viewportScope, this, name, options);
    }
    disconnect() {
        if (this.viewportScope) {
            this.router.disconnectViewportScope(this.viewportScope, this);
        }
        this.viewportScope = null;
    }
    getAttribute(key, value, checkExists = false) {
        const result = {};
        if (this.isBound) {
            return value;
        }
        else {
            if (this.element.hasAttribute(key)) {
                if (checkExists) {
                    return true;
                }
                else {
                    value = this.element.getAttribute(key);
                    if (value.length > 0) {
                        return value;
                    }
                }
            }
        }
        return void 0;
    }
    isCustomElementController(value) {
        return (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.isCustomElementController)(value);
    }
    isCustomElementViewModel(value) {
        return (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.isCustomElementViewModel)(value);
    }
    getClosestCustomElement() {
        let parent = this.controller.parent;
        let customElement = null;
        while (parent !== null && customElement === null) {
            if (parent.viewModel instanceof _viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement || parent.viewModel instanceof ViewportScopeCustomElement_1) {
                customElement = parent.viewModel;
            }
            parent = parent.parent;
        }
        return customElement;
    }
};
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "name", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "catches", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "collection", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "source", void 0);
ViewportScopeCustomElement = ViewportScopeCustomElement_1 = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customElement)({
        name: 'au-viewport-scope',
        template: '<template></template>',
        containerless: false,
        injectable: ParentViewportScope
    }),
    __param(0, _router_js__WEBPACK_IMPORTED_MODULE_2__.IRouter),
    __param(1, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(2, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.IContainer),
    __param(3, ParentViewportScope),
    __param(4, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IController)
], ViewportScopeCustomElement);

//# sourceMappingURL=viewport-scope.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/viewport.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/viewport.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParentViewport": () => /* binding */ ParentViewport,
/* harmony export */   "ViewportCustomElement": () => /* binding */ ViewportCustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _viewport_scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ViewportCustomElement_1;





const ParentViewport = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.createInjectable();
let ViewportCustomElement = ViewportCustomElement_1 = class ViewportCustomElement {
    constructor(router, element, container, parentViewport) {
        this.router = router;
        this.element = element;
        this.container = container;
        this.parentViewport = parentViewport;
        this.name = 'default';
        this.usedBy = '';
        this.default = '';
        this.fallback = '';
        this.noScope = false;
        this.noLink = false;
        this.noTitle = false;
        this.noHistory = false;
        this.stateful = false;
        this.viewport = null;
        this.isBound = false;
    }
    hydrated(controller) {
        // console.log('hydrated', this.name, this.router.isActive);
        this.controller = controller;
        this.container = controller.context.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer);
        // The first viewport(s) might be compiled before the router is active
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.waitForRouterStart(), () => {
            if (this.router.isRestrictedNavigation) {
                this.connect();
            }
        });
    }
    binding(initiator, parent, flags) {
        this.isBound = true;
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.waitForRouterStart(), () => {
            if (!this.router.isRestrictedNavigation) {
                this.connect();
            }
        });
    }
    attaching(initiator, parent, flags) {
        if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
            // console.log('attaching', this.viewport?.toString());
            this.viewport.enabled = true;
            return this.viewport.activate(initiator, this.$controller, flags, true);
            // TODO: Restore scroll state
        }
    }
    unbinding(initiator, parent, flags) {
        if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
            // console.log('unbinding', this.viewport?.toString());
            // TODO: Save to cache, something like
            // this.viewport.cacheContent();
            // From viewport-content:
            // public unloadComponent(cache: ViewportContent[], stateful: boolean = false): void {
            //   // TODO: We might want to do something here eventually, who knows?
            //   if (this.contentStatus !== ContentStatus.loaded) {
            //     return;
            //   }
            //   // Don't unload components when stateful
            //   if (!stateful) {
            //     this.contentStatus = ContentStatus.created;
            //   } else {
            //     cache.push(this);
            //   }
            // }
            // TODO: Save scroll state before detach
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.viewport.deactivate(initiator, parent, flags), () => {
                this.isBound = false;
                this.viewport.enabled = false;
            });
            // this.isBound = false;
            // this.viewport.enabled = false;
            // return this.viewport.deactivate(initiator, parent, flags);
            // // this.viewport.enabled = false;
        }
    }
    // public detaching(initiator: IHydratedController, parent: ISyntheticView | ICustomElementController<ICustomElementViewModel> | null, flags: LifecycleFlags): void | Promise<void> {
    //   if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
    //     console.log('detaching', this.viewport?.toString());
    //   }
    // }
    dispose() {
        if (this.viewport !== null) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => (this.viewport?.nextContent ?? null) === null ? this.viewport?.dispose() : void 0, () => this.disconnect());
        }
    }
    connect() {
        if (this.router.rootScope === null || (this.viewport !== null && this.router.isRestrictedNavigation)) {
            return;
        }
        // let controllerContainer = (this.controller.context as any).container;
        // let output = '';
        // do {
        //   console.log(output, ':', controllerContainer === this.container, this.controller, controllerContainer, this.container);
        //   if (controllerContainer === this.container) {
        //     break;
        //   }
        //   controllerContainer = controllerContainer.parent;
        //   output += '.parent';
        // } while (controllerContainer);
        const name = this.getAttribute('name', this.name);
        let value = this.getAttribute('no-scope', this.noScope);
        const options = { scope: value === void 0 || !value ? true : false };
        value = this.getAttribute('used-by', this.usedBy);
        if (value !== void 0) {
            options.usedBy = value;
        }
        value = this.getAttribute('default', this.default);
        if (value !== void 0) {
            options.default = value;
        }
        value = this.getAttribute('fallback', this.fallback);
        if (value !== void 0) {
            options.fallback = value;
        }
        value = this.getAttribute('no-link', this.noLink, true);
        if (value !== void 0) {
            options.noLink = value;
        }
        value = this.getAttribute('no-title', this.noTitle, true);
        if (value !== void 0) {
            options.noTitle = value;
        }
        value = this.getAttribute('no-history', this.noHistory, true);
        if (value !== void 0) {
            options.noHistory = value;
        }
        value = this.getAttribute('stateful', this.stateful, true);
        if (value !== void 0) {
            options.stateful = value;
        }
        this.controller.routingContainer = this.container;
        this.viewport = this.router.connectViewport(this.viewport, this, name, options);
    }
    disconnect() {
        if (this.viewport) {
            this.router.disconnectViewport(this.viewport, this);
        }
        this.viewport = null;
    }
    getAttribute(key, value, checkExists = false) {
        const result = {};
        if (this.isBound && !checkExists) {
            return value;
        }
        else {
            if (this.element.hasAttribute(key)) {
                if (checkExists) {
                    return true;
                }
                else {
                    value = this.element.getAttribute(key);
                    if (value.length > 0) {
                        return value;
                    }
                }
            }
        }
        return value;
    }
    getClosestCustomElement() {
        let parent = this.controller.parent;
        let customElement = null;
        while (parent !== null && customElement === null) {
            if (parent.viewModel instanceof ViewportCustomElement_1 || parent.viewModel instanceof _viewport_scope_js__WEBPACK_IMPORTED_MODULE_3__.ViewportScopeCustomElement) {
                customElement = parent.viewModel;
            }
            parent = parent.parent;
        }
        return customElement;
    }
    // TODO: Switch this to use (probably) an event instead
    waitForRouterStart() {
        if (this.router.isActive) {
            return;
        }
        return new Promise((resolve) => {
            this.router.starters.push(resolve);
        });
    }
};
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "name", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "usedBy", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "default", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "fallback", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noScope", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noLink", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noTitle", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noHistory", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "stateful", void 0);
ViewportCustomElement = ViewportCustomElement_1 = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)({
        name: 'au-viewport',
        injectable: ParentViewport
    }),
    __param(0, _router_js__WEBPACK_IMPORTED_MODULE_2__.IRouter),
    __param(1, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(2, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer),
    __param(3, ParentViewport)
], ViewportCustomElement);

//# sourceMappingURL=viewport.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/route-recognizer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/route-recognizer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouteRecognizer": () => /* binding */ RouteRecognizer,
/* harmony export */   "ConfigurableRoute": () => /* binding */ ConfigurableRoute,
/* harmony export */   "RecognizedRoute": () => /* binding */ RecognizedRoute,
/* harmony export */   "Endpoint": () => /* binding */ Endpoint
/* harmony export */ });
/* harmony import */ var _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/route-recognizer */ "./node_modules/@aurelia/route-recognizer/dist/esm/index.js");

const RouteRecognizer = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.RouteRecognizer;
const ConfigurableRoute = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.ConfigurableRoute;
const RecognizedRoute = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.RecognizedRoute;
const Endpoint = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.Endpoint;
//# sourceMappingURL=route-recognizer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/router-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/router-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterOptions": () => /* binding */ RouterOptions
/* harmony export */ });
class RouterOptions {
    constructor() {
        this.separators = {
            viewport: '@',
            sibling: '+',
            scope: '/',
            scopeStart: '(',
            scopeEnd: ')',
            noScope: '!',
            parameters: '(',
            parametersEnd: ')',
            parameterSeparator: ',',
            parameterKeySeparator: '=',
            parameter: '&',
            add: '+',
            clear: '-',
            action: '.',
        };
        this.useUrlFragmentHash = true;
        this.useHref = true;
        this.statefulHistoryLength = 0;
        this.useDirectRoutes = true;
        this.useConfiguredRoutes = true;
        this.additiveInstructionDefault = true;
        this.title = {
            // eslint-disable-next-line no-useless-escape
            appTitle: "${componentTitles}\${appTitleSeparator}Aurelia",
            appTitleSeparator: ' | ',
            componentTitleOrder: 'top-down',
            componentTitleSeparator: ' > ',
            useComponentNames: true,
            componentPrefix: 'app-',
        };
        this.navigationSyncStates = ['guardedUnload', 'swapped', 'completed'];
        this.swapStrategy = 'add-first-sequential';
        this.routingHookIntegration = 'integrated';
    }
}
//# sourceMappingURL=router-options.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/router.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/router.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IRouter": () => /* binding */ IRouter,
/* harmony export */   "Router": () => /* binding */ Router
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction-resolver.js */ "./node_modules/@aurelia/router/dist/esm/instruction-resolver.js");
/* harmony import */ var _link_handler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./link-handler.js */ "./node_modules/@aurelia/router/dist/esm/link-handler.js");
/* harmony import */ var _nav_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nav.js */ "./node_modules/@aurelia/router/dist/esm/nav.js");
/* harmony import */ var _navigator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./navigator.js */ "./node_modules/@aurelia/router/dist/esm/navigator.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");
/* harmony import */ var _found_route_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./found-route.js */ "./node_modules/@aurelia/router/dist/esm/found-route.js");
/* harmony import */ var _hook_manager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hook-manager.js */ "./node_modules/@aurelia/router/dist/esm/hook-manager.js");
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./scope.js */ "./node_modules/@aurelia/router/dist/esm/scope.js");
/* harmony import */ var _viewport_scope_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/viewport-scope.js");
/* harmony import */ var _browser_viewer_store_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./browser-viewer-store.js */ "./node_modules/@aurelia/router/dist/esm/browser-viewer-store.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _navigation_coordinator_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./navigation-coordinator.js */ "./node_modules/@aurelia/router/dist/esm/navigation-coordinator.js");
/* harmony import */ var _router_options_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./router-options.js */ "./node_modules/@aurelia/router/dist/esm/router-options.js");
/* harmony import */ var _open_promise_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./open-promise.js */ "./node_modules/@aurelia/router/dist/esm/open-promise.js");
/* eslint-disable no-template-curly-in-string */
/* eslint-disable prefer-template */
/* eslint-disable max-lines-per-function */



















// export type SwapStrategy = 'add-first-sequential' | 'add-first-parallel' | 'remove-first-sequential' | 'remove-first-parallel';
// export type RoutingHookIntegration = 'integrated' | 'separate';
// /**
//  * Public API
//  */
// export interface IRouterActivateOptions extends Omit<Partial<IRouterOptions>, 'title'> {
//   title?: string | IRouterTitle;
// }
// /**
//  * Public API
//  */
// export interface IRouterOptions extends INavigatorOptions {
//   separators?: IRouteSeparators;
//   useUrlFragmentHash: boolean;
//   useHref: boolean;
//   statefulHistoryLength: number;
//   useDirectRoutes: boolean;
//   useConfiguredRoutes: boolean;
//   additiveInstructionDefault: boolean;
//   title: ITitleConfiguration;
//   hooks?: IHookDefinition[];
//   reportCallback?(instruction: Navigation): void;
//   navigationSyncStates: NavigationState[];
//   swapStrategy: SwapStrategy;
//   routingHookIntegration: RoutingHookIntegration;
// }
// /**
//  * Public API
//  */
// export interface IRouterTitle extends Partial<ITitleConfiguration> { }
// /**
//  * Public API
//  */
// export interface ITitleConfiguration {
//   appTitle: string;
//   appTitleSeparator: string;
//   componentTitleOrder: 'top-down' | 'bottom-up';
//   componentTitleSeparator: string;
//   useComponentNames: boolean;
//   componentPrefix: string;
//   transformTitle?: (title: string, instruction: string | ViewportInstruction | FoundRoute) => string;
// }
/**
 * Public API
 */
const IRouter = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IRouter', x => x.singleton(Router));
class ClosestViewportCustomElement {
}
/**
 * @internal
 */
class ClosestScope {
}
class Router {
    constructor(
    /**
     * @internal - Shouldn't be used directly.
     */
    container, 
    /**
     * @internal - Shouldn't be used directly.
     */
    navigator, navigation, 
    /**
     * @internal - Shouldn't be used directly.
     */
    linkHandler, 
    /**
     * @internal - Shouldn't be used directly. Probably.
     */
    instructionResolver, 
    /**
     * @internal - Shouldn't be used directly. Probably.
     */
    hookManager, options) {
        this.container = container;
        this.navigator = navigator;
        this.navigation = navigation;
        this.linkHandler = linkHandler;
        this.instructionResolver = instructionResolver;
        this.hookManager = hookManager;
        this.options = options;
        this.rootScope = null;
        /**
         * @internal
         */
        // public hookManager: HookManager;
        /**
         * @internal
         */
        this.navs = {};
        /**
         * Public API
         */
        this.activeComponents = [];
        /**
         * @internal
         */
        this.appendedInstructions = [];
        // /**
        //  * @internal
        //  */
        // public options: IRouterOptions = {
        //   useUrlFragmentHash: true,
        //   useHref: true,
        //   statefulHistoryLength: 0,
        //   useDirectRoutes: true,
        //   useConfiguredRoutes: true,
        //   additiveInstructionDefault: true,
        //   title: {
        //     appTitle: "${componentTitles}\${appTitleSeparator}Aurelia",
        //     appTitleSeparator: ' | ',
        //     componentTitleOrder: 'top-down',
        //     componentTitleSeparator: ' > ',
        //     useComponentNames: true,
        //     componentPrefix: 'app-',
        //   },
        //   swapStrategy: 'add-first-sequential',
        //   routingHookIntegration: 'integrated',
        //   navigationSyncStates: ['guardedUnload', 'swapped', 'completed'],
        // };
        this.processingNavigation = null;
        this.isActive = false;
        this.pendingConnects = new Map();
        this.loadedFirst = false;
        this.lastNavigation = null;
        this.staleChecks = {};
        // TODO: Switch this to use (probably) an event instead
        this.starters = [];
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.linkCallback = (info) => {
            let instruction = info.instruction || '';
            if (typeof instruction === 'string' && instruction.startsWith('#')) {
                instruction = instruction.slice(1);
                // '#' === '/' === '#/'
                if (!instruction.startsWith('/')) {
                    instruction = "/" + instruction;
                }
            }
            // Adds to Navigator's Queue, which makes sure it's serial
            this.load(instruction, { origin: info.anchor }).catch(error => { throw error; });
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.navigatorCallback = (instruction) => {
            // Instructions extracted from queue, one at a time
            this.processNavigations(instruction).catch(error => { throw error; });
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.navigatorSerializeCallback = async (entry, preservedEntries) => {
            let excludeComponents = [];
            for (const preservedEntry of preservedEntries) {
                if (typeof preservedEntry.instruction !== 'string') {
                    excludeComponents.push(...this.instructionResolver.flattenViewportInstructions(preservedEntry.instruction)
                        .filter(instruction => instruction.viewport !== null)
                        .map(instruction => instruction.componentInstance));
                }
                if (typeof preservedEntry.fullStateInstruction !== 'string') {
                    excludeComponents.push(...this.instructionResolver.flattenViewportInstructions(preservedEntry.fullStateInstruction)
                        .filter(instruction => instruction.viewport !== null)
                        .map(instruction => instruction.componentInstance));
                }
            }
            excludeComponents = excludeComponents.filter((component, i, arr) => component !== null && arr.indexOf(component) === i);
            const serialized = { ...entry };
            let instructions = [];
            if (serialized.fullStateInstruction && typeof serialized.fullStateInstruction !== 'string') {
                instructions.push(...serialized.fullStateInstruction);
                serialized.fullStateInstruction = this.instructionResolver.stringifyViewportInstructions(serialized.fullStateInstruction);
            }
            if (serialized.instruction && typeof serialized.instruction !== 'string') {
                instructions.push(...serialized.instruction);
                serialized.instruction = this.instructionResolver.stringifyViewportInstructions(serialized.instruction);
            }
            instructions = instructions.filter((instruction, i, arr) => instruction !== null
                && instruction.componentInstance !== null
                && arr.indexOf(instruction) === i);
            const alreadyDone = [];
            for (const instruction of instructions) {
                await this.freeComponents(instruction, excludeComponents, alreadyDone);
            }
            return serialized;
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.browserNavigatorCallback = (browserNavigationEvent) => {
            const entry = new _navigation_js__WEBPACK_IMPORTED_MODULE_15__.Navigation(browserNavigationEvent.state?.currentEntry);
            entry.instruction = browserNavigationEvent.instruction;
            entry.fromBrowser = true;
            this.navigator.navigate(entry).catch(error => { throw error; });
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.processNavigations = async (qInstruction) => {
            const instruction = this.processingNavigation = qInstruction;
            // console.log('pendingConnects', [...this.pendingConnects]);
            this.pendingConnects.clear();
            if (this.options.reportCallback) {
                this.options.reportCallback(instruction);
            }
            // let {
            //   fullStateInstruction,
            //   instructionNavigation,
            //   configuredRoute,
            //   configuredRoutePath,
            //   instructions,
            //   clearScopeOwners,
            //   clearViewportScopes,
            // }
            const coordinator = _navigation_coordinator_js__WEBPACK_IMPORTED_MODULE_16__.NavigationCoordinator.create(this, instruction, { syncStates: this.options.navigationSyncStates });
            // const steps = [
            //   () => coordinator.syncState('loaded'),
            //   () => { console.log('SyncState loaded resolved!', steps); },
            //   () => coordinator.syncState('swapped'),
            //   () => { console.log('SyncState swapped resolved!', steps); },
            //   () => coordinator.syncState('left'),
            //   () => { console.log('SyncState left resolved!', steps); },
            // ];
            // run(...steps);
            // const loadedPromise = ;
            // if (loadedPromise !== void 0) {
            //   loadedPromise.then((value: any) => {
            //     console.log('SyncState loaded resolved!', value);
            //   });
            // }
            // console.log(instruction.instruction);
            // console.log(this.rootScope?.scope.toString(true));
            let transformedInstruction = typeof instruction.instruction === 'string' && !instruction.useFullStateInstruction
                ? await this.hookManager.invokeTransformFromUrl(instruction.instruction, this.processingNavigation)
                : instruction.instruction;
            // TODO: Review this
            if (transformedInstruction === '/') {
                transformedInstruction = '';
            }
            instruction.scope = instruction.scope ?? this.rootScope.scope;
            let configuredRoute = instruction.scope.findInstructions(transformedInstruction);
            let configuredRoutePath = null;
            // let configuredRoute = await this.findInstructions(
            //   this.rootScope!.scope,
            //   instruction.instruction,
            //   instruction.scope ?? this.rootScope!.scope,
            //   !instruction.useFullStateInstruction);
            if (instruction.instruction.length > 0 && !configuredRoute.foundConfiguration && !configuredRoute.foundInstructions) {
                // TODO: Do something here!
                this.unknownRoute(configuredRoute.remaining);
            }
            let instructions = configuredRoute.instructions;
            if (configuredRoute.foundConfiguration) {
                instruction.path = instruction.instruction.startsWith('/')
                    ? instruction.instruction.slice(1)
                    : instruction.instruction;
                configuredRoutePath = (configuredRoutePath ?? '') + configuredRoute.matching;
                this.rootScope.path = configuredRoutePath;
            }
            // TODO: Used to have an early exit if no instructions. Restore it?
            if (!this.options.additiveInstructionDefault &&
                instructions.length > 0 &&
                !this.instructionResolver.isAddAllViewportsInstruction(instructions[0]) &&
                !this.instructionResolver.isClearAllViewportsInstruction(instructions[0])) {
                const instr = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction);
                instr.scope = instructions[0].scope;
                instructions.unshift(instr);
            }
            const clearScopeOwners = [];
            let clearViewportScopes = [];
            for (const clearInstruction of instructions.filter(instr => this.instructionResolver.isClearAllViewportsInstruction(instr))) {
                const scope = clearInstruction.scope || this.rootScope.scope;
                const scopes = scope.allScopes().filter(scope => !scope.owner.isEmpty).map(scope => scope.owner);
                // TODO: Tell Fred about the need for reverse
                // scopes.reverse();
                clearScopeOwners.push(...scopes);
                if (scope.viewportScope !== null && scope.viewportScope !== this.rootScope) {
                    clearViewportScopes.push(scope.viewportScope);
                }
            }
            instructions = instructions.filter(instr => !this.instructionResolver.isClearAllViewportsInstruction(instr));
            for (const addInstruction of instructions.filter(instr => this.instructionResolver.isAddAllViewportsInstruction(instr))) {
                addInstruction.setViewport((addInstruction.scope || this.rootScope.scope).viewportScope.name);
                addInstruction.scope = addInstruction.scope.owningScope;
            }
            for (const instr of instructions) {
                instr.topInstruction = true;
            }
            const updatedScopeOwners = [];
            const alreadyFoundInstructions = [];
            // TODO: Take care of cancellations down in subsets/iterations
            let { found: viewportInstructions, remaining: remainingInstructions } = this.findViewports(instructions, alreadyFoundInstructions);
            let guard = 100;
            do {
                if (!guard--) { // Guard against endless loop
                    const err = new Error(remainingInstructions.length + ' remaining instructions after 100 iterations; there is likely an infinite loop.');
                    err['remainingInstructions'] = remainingInstructions;
                    console.log('remainingInstructions', remainingInstructions);
                    throw err;
                }
                const changedScopeOwners = [];
                // TODO: Review whether this await poses a problem (it's currently necessary for new viewports to load)
                const hooked = await this.hookManager.invokeBeforeNavigation(viewportInstructions, instruction);
                if (hooked === false) {
                    coordinator.cancel();
                    return;
                    // return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], instruction);
                }
                else {
                    viewportInstructions = hooked;
                }
                for (const viewportInstruction of viewportInstructions) {
                    const scopeOwner = viewportInstruction.owner;
                    if (scopeOwner !== null) {
                        scopeOwner.path = configuredRoutePath;
                        const action = scopeOwner.setNextContent(viewportInstruction, instruction);
                        if (action !== 'skip') {
                            changedScopeOwners.push(scopeOwner);
                            coordinator.addEntity(scopeOwner);
                        }
                        const dontClear = [scopeOwner];
                        if (action === 'swap') {
                            dontClear.push(...scopeOwner.scope.allScopes(true, true).map(scope => scope.owner));
                        }
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(clearScopeOwners, value => dontClear.includes(value));
                        // arrayRemove(clearScopeOwners, value => value === scopeOwner);
                        if (!this.instructionResolver.isClearViewportInstruction(viewportInstruction)
                            && viewportInstruction.scope !== null
                            && viewportInstruction.scope.parent !== null
                            && viewportInstruction.scope.parent.isViewportScope) {
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(clearViewportScopes, value => value === viewportInstruction.scope.parent.viewportScope);
                        }
                    }
                }
                if (!this.isRestrictedNavigation) {
                    coordinator.finalEntity();
                }
                coordinator.run();
                // await coordinator.syncState('routed');
                // // eslint-disable-next-line no-await-in-loop
                // let results = await Promise.all(changedScopeOwners.map((scopeOwner) => scopeOwner.canUnload()));
                // if (results.some(result => result === false)) {
                //   return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], instruction);
                // }
                // // eslint-disable-next-line no-await-in-loop
                // results = await Promise.all(changedScopeOwners.map(async (scopeOwner) => {
                //   const canLoad = await scopeOwner.canLoad();
                //   if (typeof canLoad === 'boolean') {
                //     if (canLoad) {
                //       coordinator.addEntityState(scopeOwner, 'loaded');
                //       return scopeOwner.load();
                //     } else {
                //       return false;
                //     }
                //   }
                //   await this.load(canLoad, { append: true });
                //   await scopeOwner.abortContentChange();
                //   // TODO: Abort content change in the viewports
                //   return true;
                // }));
                // if (results.some(result => result === false)) {
                //   return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], qInstruction);
                // }
                for (const viewport of changedScopeOwners) {
                    if (updatedScopeOwners.every(scopeOwner => scopeOwner !== viewport)) {
                        updatedScopeOwners.push(viewport);
                    }
                }
                // TODO: Fix multi level recursiveness!
                alreadyFoundInstructions.push(...viewportInstructions);
                ({ found: viewportInstructions, remaining: remainingInstructions } = this.findViewports(remainingInstructions, alreadyFoundInstructions));
                // Look for configured child routes (once we've loaded everything so far?)
                if (configuredRoute.hasRemaining &&
                    viewportInstructions.length === 0 &&
                    remainingInstructions.length === 0) {
                    let configured = new _found_route_js__WEBPACK_IMPORTED_MODULE_10__.FoundRoute();
                    const routeScopeOwners = alreadyFoundInstructions
                        .filter(instr => instr.owner !== null && instr.owner.path === configuredRoutePath)
                        .map(instr => instr.owner)
                        .filter((value, index, arr) => arr.indexOf(value) === index);
                    // Need to await new viewports being bound
                    if (!this.isRestrictedNavigation) {
                        // await Promise.resolve();
                        // console.log('Awaiting swapped');
                        await coordinator.syncState('swapped');
                        // console.log('Awaited swapped');
                        // console.log('pendingConnects before find new', [...this.pendingConnects]);
                        // const pending = [...this.pendingConnects.values()].filter(connect => connect.isPending);
                        // if (pending.length > 0) {
                        //   console.log('Beginning await for ', pending.length);
                        //   await Promise.all(pending.map(connect => connect.promise));
                        //   console.log('Await done');
                        // }
                    }
                    for (const owner of routeScopeOwners) {
                        configured = owner.scope.findInstructions(configuredRoute.remaining);
                        // configured = await this.findInstructions(owner.scope, configuredRoute.remaining, owner.scope);
                        if (configured.foundConfiguration) {
                            break;
                        }
                    }
                    if (configured.foundInstructions) {
                        configuredRoute = configured;
                        configuredRoutePath = (configuredRoutePath ?? '') + "/" + configuredRoute.matching;
                    }
                    else {
                        // TODO: Do something here!
                        this.unknownRoute(configured.remaining);
                    }
                    this.appendInstructions(configured.instructions);
                }
                // Don't use defaults when it's a full state navigation
                if (instruction.useFullStateInstruction) {
                    this.appendedInstructions = this.appendedInstructions.filter(instruction => !instruction.default);
                }
                // Process non-defaults first
                let appendedInstructions = this.appendedInstructions.filter(instruction => !instruction.default);
                this.appendedInstructions = this.appendedInstructions.filter(instruction => instruction.default);
                if (appendedInstructions.length === 0) {
                    const index = this.appendedInstructions.findIndex(instruction => instruction.default);
                    if (index >= 0) {
                        appendedInstructions = this.appendedInstructions.splice(index, 1);
                    }
                }
                while (appendedInstructions.length > 0) {
                    const appendedInstruction = appendedInstructions.shift();
                    const existingAlreadyFound = alreadyFoundInstructions.some(instruction => instruction.sameViewport(appendedInstruction));
                    const existingFound = viewportInstructions.find(value => value.sameViewport(appendedInstruction));
                    const existingRemaining = remainingInstructions.find(value => value.sameViewport(appendedInstruction));
                    if (appendedInstruction.default &&
                        (existingAlreadyFound ||
                            (existingFound !== void 0 && !existingFound.default) ||
                            (existingRemaining !== void 0 && !existingRemaining.default))) {
                        continue;
                    }
                    if (existingFound !== void 0) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(viewportInstructions, value => value === existingFound);
                    }
                    if (existingRemaining !== void 0) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(remainingInstructions, value => value === existingRemaining);
                    }
                    if (appendedInstruction.viewport !== null) {
                        viewportInstructions.push(appendedInstruction);
                    }
                    else {
                        remainingInstructions.push(appendedInstruction);
                    }
                }
                if (viewportInstructions.length === 0 && remainingInstructions.length === 0) {
                    viewportInstructions = clearScopeOwners.map(owner => {
                        const instruction = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction, owner.isViewport ? owner : void 0);
                        if (owner.isViewportScope) {
                            instruction.viewportScope = owner;
                        }
                        return instruction;
                    });
                    viewportInstructions.push(...clearViewportScopes.map(viewportScope => {
                        const instr = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction);
                        instr.viewportScope = viewportScope;
                        return instr;
                    }));
                    clearViewportScopes = [];
                }
                // await new Promise(res => setTimeout(res, 100));
            } while (viewportInstructions.length > 0 || remainingInstructions.length > 0);
            coordinator.finalEntity();
            // await Promise.all(updatedScopeOwners.map((value) => value.loadContent()));
            await coordinator.syncState('completed');
            coordinator.finalize();
            // updatedScopeOwners.forEach((viewport) => {
            //   viewport.finalizeContentChange();
            // });
            await this.replacePaths(instruction);
            // this.updateNav();
            // Remove history entry if no history viewports updated
            if (instruction.navigation.new && !instruction.navigation.first && !instruction.repeating && updatedScopeOwners.every(viewport => viewport.options.noHistory)) {
                instruction.untracked = true;
            }
            // updatedScopeOwners.forEach((viewport) => {
            //   viewport.finalizeContentChange();
            // });
            this.lastNavigation = this.processingNavigation;
            if (this.lastNavigation?.repeating ?? false) {
                this.lastNavigation.repeating = false;
            }
            this.processingNavigation = null;
            await this.navigator.finalize(instruction);
        };
        // this.hookManager = new HookManager();
    }
    /**
     * Public API
     */
    get isNavigating() {
        return this.processingNavigation !== null;
    }
    get isRestrictedNavigation() {
        const syncStates = this.options.navigationSyncStates;
        return syncStates.includes('guardedLoad') ||
            syncStates.includes('unloaded') ||
            syncStates.includes('loaded') ||
            syncStates.includes('guarded') ||
            syncStates.includes('routed');
    }
    /**
     * @internal
     */
    get statefulHistory() {
        return this.options.statefulHistoryLength !== void 0 && this.options.statefulHistoryLength > 0;
    }
    /**
     * Public API
     */
    start(options) {
        if (this.isActive) {
            throw new Error('Router has already been started');
        }
        this.isActive = true;
        options = options ?? {};
        const titleOptions = {
            ...this.options.title,
            ...(typeof options.title === 'string' ? { appTitle: options.title } : options.title),
        };
        options.title = titleOptions;
        const separatorOptions = {
            ...this.options.separators,
            ...options.separators ?? {},
        };
        options.separators = separatorOptions;
        Object.assign(this.options, options);
        if (this.options.hooks !== void 0) {
            this.addHooks(this.options.hooks);
        }
        this.instructionResolver.start({ separators: this.options.separators });
        this.navigator.start(this, {
            callback: this.navigatorCallback,
            store: this.navigation,
            statefulHistoryLength: this.options.statefulHistoryLength,
            serializeCallback: this.statefulHistory ? this.navigatorSerializeCallback : void 0,
        });
        this.linkHandler.start({ callback: this.linkCallback, useHref: this.options.useHref });
        this.navigation.start({
            callback: this.browserNavigatorCallback,
            useUrlFragmentHash: this.options.useUrlFragmentHash
        });
        this.ensureRootScope();
        // TODO: Switch this to use (probably) an event instead
        for (const starter of this.starters) {
            starter();
        }
    }
    /**
     * Public API
     */
    async loadUrl() {
        const entry = new _navigation_js__WEBPACK_IMPORTED_MODULE_15__.Navigation({
            ...this.navigation.viewerState,
            ...{
                fullStateInstruction: '',
                replacing: true,
                fromBrowser: false,
            }
        });
        const result = this.navigator.navigate(entry);
        this.loadedFirst = true;
        return result;
    }
    /**
     * Public API
     */
    stop() {
        if (!this.isActive) {
            throw new Error('Router has not been started');
        }
        this.linkHandler.stop();
        this.navigator.stop();
        this.navigation.stop();
    }
    /**
     * @internal
     */
    findScope(origin) {
        // this.ensureRootScope();
        if (origin === void 0 || origin === null) {
            return this.rootScope.scope;
        }
        if (origin instanceof _scope_js__WEBPACK_IMPORTED_MODULE_12__.Scope || origin instanceof _viewport_js__WEBPACK_IMPORTED_MODULE_8__.Viewport) {
            return origin.scope;
        }
        return this.getClosestScope(origin) || this.rootScope.scope;
    }
    /**
     * @internal
     */
    findParentScope(container) {
        if (container === null) {
            return this.rootScope.scope;
        }
        // Already (prematurely) set on this view model so get it from container's parent instead
        if (container.has(ClosestScope, false)) {
            container = container.parent;
            if (container === null) {
                return this.rootScope.scope;
            }
        }
        if (container.has(ClosestScope, true)) {
            return container.get(ClosestScope);
        }
        return this.rootScope.scope;
    }
    /**
     * Public API - Get viewport by name
     */
    getViewport(name) {
        return this.allViewports().find(viewport => viewport.name === name) || null;
    }
    /**
     * Public API (not yet implemented)
     */
    addViewport(...args) {
        throw new Error('Not implemented');
    }
    /**
     * Public API (not yet implemented)
     */
    findViewportScope(...args) {
        throw new Error('Not implemented');
    }
    /**
     * Public API (not yet implemented)
     */
    addViewportScope(...args) {
        throw new Error('Not implemented');
    }
    /**
     * @internal - Called from the viewport scope custom element in created()
     */
    setClosestScope(viewModelOrContainer, scope) {
        const container = this.getContainer(viewModelOrContainer);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(ClosestScope, scope).register(container);
    }
    /**
     * @internal
     */
    getClosestScope(viewModelOrElement) {
        const container = 'resourceResolvers' in viewModelOrElement
            ? viewModelOrElement
            : this.getClosestContainer(viewModelOrElement);
        if (container === null) {
            return null;
        }
        if (!container.has(ClosestScope, true)) {
            return null;
        }
        return container.get(ClosestScope) || null;
    }
    /**
     * @internal
     */
    unsetClosestScope(viewModelOrContainer) {
        const container = this.getContainer(viewModelOrContainer);
        // TODO: Get an 'unregister' on container
        container.resolvers.delete(ClosestScope);
    }
    /**
     * @internal - Called from the viewport custom element
     */
    connectViewport(viewport, connectedCE, name, options) {
        const parentScope = this.findParentScope(connectedCE.container);
        // console.log('Viewport parentScope', parentScope.toString(), (connectedCE as any).getClosestCustomElement());
        const parentViewportScope = (connectedCE.parentViewport?.viewport ?? this.rootScope).scope;
        if (parentScope !== parentViewportScope) {
            console.error('Viewport parentScope !== parentViewportScope', parentScope.toString(true), parentViewportScope.toString(true), connectedCE.getClosestCustomElement());
        }
        if (viewport === null) {
            viewport = parentScope.addViewport(name, connectedCE, options);
            this.setClosestScope(connectedCE.container, viewport.connectedScope);
            if (!this.isRestrictedNavigation) {
                this.pendingConnects.set(connectedCE, new _open_promise_js__WEBPACK_IMPORTED_MODULE_18__.OpenPromise());
            }
        }
        else {
            this.pendingConnects.get(connectedCE)?.resolve();
        }
        return viewport;
    }
    /**
     * @internal - Called from the viewport custom element
     */
    disconnectViewport(viewport, connectedCE) {
        if (!viewport.connectedScope.parent.removeViewport(viewport, connectedCE)) {
            throw new Error("Failed to remove viewport: " + viewport.name);
        }
        this.unsetClosestScope(connectedCE.container);
    }
    /**
     * @internal - Called from the viewport scope custom element
     */
    connectViewportScope(viewportScope, connectedCE, name, options) {
        const parentScope = this.findParentScope(connectedCE.container);
        // console.log('ViewportScope parentScope', parentScope.toString(), (connectedCE as any).getClosestCustomElement());
        if (viewportScope === null) {
            viewportScope = parentScope.addViewportScope(name, connectedCE, options);
            this.setClosestScope(connectedCE.container, viewportScope.connectedScope);
        }
        return viewportScope;
    }
    /**
     * @internal - Called from the viewport scope custom element
     */
    disconnectViewportScope(viewportScope, connectedCE) {
        if (!viewportScope.connectedScope.parent.removeViewportScope(viewportScope)) {
            throw new Error("Failed to remove viewport scope: " + viewportScope.path);
        }
        this.unsetClosestScope(connectedCE.container);
    }
    allViewports(includeDisabled = false, includeReplaced = false) {
        // this.ensureRootScope();
        return this.rootScope.scope.allViewports(includeDisabled, includeReplaced);
    }
    /**
     * Public API - THE navigation API
     */
    async goto(instructions, options) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.deprecationWarning)('"goto" method', '"load" method');
        return this.load(instructions, options);
    }
    async load(instructions, options) {
        options = options || {};
        // TODO: Review query extraction; different pos for path and fragment!
        if (typeof instructions === 'string' && !options.query) {
            const [path, search] = instructions.split('?');
            instructions = path;
            options.query = search;
        }
        const toOptions = {};
        if (options.origin) {
            toOptions.context = options.origin;
        }
        let scope = null;
        ({ instructions, scope } = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_6__.NavigationInstructionResolver.createViewportInstructions(this, instructions, toOptions));
        if (options.append && this.processingNavigation) {
            instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_6__.NavigationInstructionResolver.toViewportInstructions(this, instructions);
            this.appendInstructions(instructions, scope);
            // Can't return current navigation promise since it can lead to deadlock in load
            return Promise.resolve();
        }
        const entry = new _navigation_js__WEBPACK_IMPORTED_MODULE_15__.Navigation({
            instruction: instructions,
            fullStateInstruction: '',
            scope: scope,
            title: options.title,
            data: options.data,
            query: options.query,
            replacing: options.replace,
            repeating: options.append,
            fromBrowser: false,
            origin: options.origin,
        });
        return this.navigator.navigate(entry);
    }
    /**
     * Public API
     */
    refresh() {
        return this.navigator.refresh();
    }
    /**
     * Public API
     */
    back() {
        return this.navigator.go(-1);
    }
    /**
     * Public API
     */
    forward() {
        return this.navigator.go(1);
    }
    /**
     * Public API
     */
    go(delta) {
        return this.navigator.go(delta);
    }
    /**
     * Public API
     */
    checkActive(instructions) {
        for (const instruction of instructions) {
            const scopeInstructions = this.instructionResolver.matchScope(this.activeComponents, instruction.scope);
            const matching = scopeInstructions.filter(instr => instr.sameComponent(instruction, true));
            if (matching.length === 0) {
                return false;
            }
            if (Array.isArray(instruction.nextScopeInstructions)
                && instruction.nextScopeInstructions.length > 0
                && this.instructionResolver.matchChildren(instruction.nextScopeInstructions, matching.map(instr => Array.isArray(instr.nextScopeInstructions) ? instr.nextScopeInstructions : []).flat()) === false) {
                return false;
            }
        }
        return true;
    }
    /**
     * Public API
     */
    setNav(name, routes, classes) {
        const nav = this.findNav(name);
        if (nav !== void 0 && nav !== null) {
            nav.routes = [];
        }
        this.addNav(name, routes, classes);
    }
    /**
     * Public API
     */
    addNav(name, routes, classes) {
        let nav = this.navs[name];
        if (nav === void 0 || nav === null) {
            nav = this.navs[name] = new _nav_js__WEBPACK_IMPORTED_MODULE_4__.Nav(this, name, [], classes);
        }
        nav.addRoutes(routes);
        nav.update();
    }
    /**
     * Public API
     */
    updateNav(name) {
        const navs = name
            ? [name]
            : Object.keys(this.navs);
        for (const nav of navs) {
            if (this.navs[nav] !== void 0 && this.navs[nav] !== null) {
                this.navs[nav].update();
            }
        }
    }
    /**
     * Public API
     */
    findNav(name) {
        return this.navs[name];
    }
    /**
     * Public API
     */
    addRoutes(routes, context) {
        // TODO: This should add to the context instead
        // TODO: Add routes without context to rootScope content (which needs to be created)?
        return [];
        // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;
        // return viewport.addRoutes(routes);
    }
    /**
     * Public API
     */
    removeRoutes(routes, context) {
        // TODO: This should remove from the context instead
        // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;
        // return viewport.removeRoutes(routes);
    }
    /**
     * Public API
     */
    addHooks(hooks) {
        return hooks.map(hook => this.addHook(hook.hook, hook.options));
    }
    addHook(hook, options) {
        return this.hookManager.addHook(hook, options);
    }
    /**
     * Public API
     */
    removeHooks(hooks) {
        return;
    }
    /**
     * Public API - The right way to create ViewportInstructions
     */
    createViewportInstruction(component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
        return this.instructionResolver.createViewportInstruction(component, viewport, parameters, ownsScope, nextScopeInstructions);
    }
    hasSiblingInstructions(instructions) {
        if (instructions === null) {
            return false;
        }
        if (instructions.length > 1) {
            return true;
        }
        return instructions.some(instruction => this.hasSiblingInstructions(instruction.nextScopeInstructions));
    }
    appendInstructions(instructions, scope = null) {
        if (scope === null) {
            scope = this.rootScope.scope;
        }
        for (const instruction of instructions) {
            if (instruction.scope === null) {
                instruction.scope = scope;
            }
        }
        this.appendedInstructions.push(...instructions);
    }
    checkStale(name, instructions) {
        const staleCheck = this.staleChecks[name];
        if (staleCheck === void 0) {
            this.staleChecks[name] = instructions.slice();
            return false;
        }
        if (staleCheck.length !== instructions.length) {
            this.staleChecks[name] = instructions.slice();
            return false;
        }
        for (let i = 0, ii = instructions.length; i < ii; i++) {
            if (staleCheck[i] !== instructions[i]) {
                this.staleChecks[name] = instructions.slice();
                return false;
            }
        }
        return true;
    }
    unknownRoute(route) {
        if (typeof route !== 'string' || route.length === 0) {
            return;
        }
        if (this.options.useConfiguredRoutes && this.options.useDirectRoutes) {
            // TODO: Add missing/unknown route handling
            throw new Error("No matching configured route or component found for '" + route + "'");
        }
        else if (this.options.useConfiguredRoutes) {
            // TODO: Add missing/unknown route handling
            throw new Error("No matching configured route found for '" + route + "'");
        }
        else {
            // TODO: Add missing/unknown route handling
            throw new Error("No matching route/component found for '" + route + "'");
        }
    }
    findViewports(instructions, alreadyFound, withoutViewports = false) {
        const found = [];
        const remaining = [];
        while (instructions.length) {
            if (instructions[0].scope === null) {
                instructions[0].scope = this.rootScope.scope;
            }
            const scope = instructions[0].scope;
            const { foundViewports, remainingInstructions } = scope.findViewports(instructions.filter(instruction => instruction.scope === scope), alreadyFound, withoutViewports);
            found.push(...foundViewports);
            remaining.push(...remainingInstructions);
            instructions = instructions.filter(instruction => instruction.scope !== scope);
        }
        return { found: found.slice(), remaining };
    }
    async cancelNavigation(updatedScopeOwners, qInstruction) {
        // TODO: Take care of disabling viewports when cancelling and stateful!
        updatedScopeOwners.forEach((viewport) => {
            const abort = viewport.abortContentChange();
            if (abort instanceof Promise) {
                abort.catch(error => { throw error; });
            }
        });
        await this.navigator.cancel(qInstruction);
        this.processingNavigation = null;
        qInstruction.resolve();
    }
    ensureRootScope() {
        if (!this.rootScope) {
            const root = this.container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAppRoot);
            // root.config.component shouldn't be used in the end. Metadata will probably eliminate it
            this.rootScope = new _viewport_scope_js__WEBPACK_IMPORTED_MODULE_13__.ViewportScope('rootScope', this, root.controller.viewModel, null, true, root.config.component);
        }
        return this.rootScope;
    }
    async replacePaths(instruction) {
        this.rootScope.scope.reparentViewportInstructions();
        let instructions = this.rootScope.scope.hoistedChildren
            .filter(scope => scope.viewportInstruction !== null && !scope.viewportInstruction.isEmpty())
            .map(scope => scope.viewportInstruction);
        instructions = this.instructionResolver.cloneViewportInstructions(instructions, true);
        // The following makes sure right viewport/viewport scopes are set and update
        // whether viewport name is necessary or not
        const alreadyFound = [];
        let { found, remaining } = this.findViewports(instructions, alreadyFound, true);
        let guard = 100;
        while (remaining.length > 0) {
            // Guard against endless loop
            if (guard-- === 0) {
                throw new Error('Failed to find viewport when updating viewer paths.');
            }
            alreadyFound.push(...found);
            ({ found, remaining } = this.findViewports(remaining, alreadyFound, true));
        }
        this.activeComponents = instructions;
        this.activeRoute = instruction.route;
        // First invoke with viewport instructions (should it perhaps get full state?)
        let state = await this.hookManager.invokeTransformToUrl(instructions, instruction);
        if (typeof state !== 'string') {
            // Convert to string if necessary
            state = this.instructionResolver.stringifyViewportInstructions(state, false, true);
        }
        // Invoke again with string
        state = await this.hookManager.invokeTransformToUrl(state, instruction);
        const query = (instruction.query && instruction.query.length ? "?" + instruction.query : '');
        // if (instruction.path === void 0 || instruction.path.length === 0 || instruction.path === '/') {
        instruction.path = state + query;
        // }
        const fullViewportStates = [this.createViewportInstruction(this.instructionResolver.clearViewportInstruction)];
        fullViewportStates.push(...this.instructionResolver.cloneViewportInstructions(instructions, this.statefulHistory));
        instruction.fullStateInstruction = fullViewportStates;
        if ((instruction.title ?? null) === null) {
            const title = await this.getTitle(instructions, instruction);
            if (title !== null) {
                instruction.title = title;
            }
        }
        return Promise.resolve();
    }
    async getTitle(instructions, instruction) {
        // First invoke with viewport instructions
        let title = await this.hookManager.invokeSetTitle(instructions, instruction);
        if (typeof title !== 'string') {
            // Hook didn't return a title, so run title logic
            const componentTitles = this.stringifyTitles(title, instruction);
            title = this.options.title.appTitle;
            title = title.replace("${componentTitles}", componentTitles);
            title = title.replace("${appTitleSeparator}", componentTitles !== ''
                ? this.options.title.appTitleSeparator
                : '');
        }
        // Invoke again with complete string
        title = await this.hookManager.invokeSetTitle(title, instruction);
        return title;
    }
    stringifyTitles(instructions, navigationInstruction) {
        const titles = instructions
            .map(instruction => this.stringifyTitle(instruction, navigationInstruction))
            .filter(instruction => (instruction?.length ?? 0) > 0);
        return titles.join(' + ');
    }
    stringifyTitle(instruction, navigationInstruction) {
        if (typeof instruction === 'string') {
            return this.resolveTitle(instruction, navigationInstruction);
        }
        const route = instruction.route ?? null;
        const nextInstructions = instruction.nextScopeInstructions;
        let stringified = '';
        // It's a configured route
        if (route !== null) {
            // Already added as part of a configuration, skip to next scope
            if (route === '') {
                return Array.isArray(nextInstructions)
                    ? this.stringifyTitles(nextInstructions, navigationInstruction)
                    : '';
            }
            else {
                stringified += this.resolveTitle(route, navigationInstruction);
            }
        }
        else {
            stringified += this.resolveTitle(instruction, navigationInstruction);
        }
        if (Array.isArray(nextInstructions) && nextInstructions.length > 0) {
            let nextStringified = this.stringifyTitles(nextInstructions, navigationInstruction);
            if (nextStringified.length > 0) {
                if (nextInstructions.length !== 1) { // TODO: This should really also check that the instructions have value
                    nextStringified = "[ " + nextStringified + " ]";
                }
                if (stringified.length > 0) {
                    stringified = this.options.title.componentTitleOrder === 'top-down'
                        ? stringified + this.options.title.componentTitleSeparator + nextStringified
                        : nextStringified + this.options.title.componentTitleSeparator + stringified;
                }
                else {
                    stringified = nextStringified;
                }
            }
        }
        return stringified;
    }
    resolveTitle(instruction, navigationInstruction) {
        let title = '';
        if (typeof instruction === 'string') {
            title = instruction;
        }
        else if (instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_9__.ViewportInstruction) {
            return instruction.viewport.getTitle(navigationInstruction);
        }
        else if (instruction instanceof _found_route_js__WEBPACK_IMPORTED_MODULE_10__.FoundRoute) {
            const routeTitle = instruction.match?.title;
            if (routeTitle !== void 0) {
                if (typeof routeTitle === 'string') {
                    title = routeTitle;
                }
                else {
                    title = routeTitle.call(instruction, instruction, navigationInstruction);
                }
            }
        }
        if (this.options.title.transformTitle !== void 0) {
            title = this.options.title.transformTitle.call(this, title, instruction);
        }
        return title;
    }
    async freeComponents(instruction, excludeComponents, alreadyDone) {
        const component = instruction.componentInstance;
        const viewport = instruction.viewport;
        if (component === null || viewport === null || alreadyDone.some(done => done === component)) {
            return;
        }
        if (!excludeComponents.some(exclude => exclude === component)) {
            await viewport.freeContent(component);
            alreadyDone.push(component);
            return;
        }
        if (instruction.nextScopeInstructions !== null) {
            for (const nextInstruction of instruction.nextScopeInstructions) {
                await this.freeComponents(nextInstruction, excludeComponents, alreadyDone);
            }
        }
    }
    getClosestContainer(viewModelOrElement) {
        if ('context' in viewModelOrElement) {
            return viewModelOrElement.context;
        }
        if ('$controller' in viewModelOrElement) {
            return viewModelOrElement.$controller.context;
        }
        const controller = this.CustomElementFor(viewModelOrElement);
        if (controller === void 0) {
            return null;
        }
        return controller.context;
    }
    getContainer(viewModelOrContainer) {
        if ('resourceResolvers' in viewModelOrContainer) {
            return viewModelOrContainer;
        }
        if ((0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.isRenderContext)(viewModelOrContainer)) {
            return viewModelOrContainer.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer);
        }
        if ('$controller' in viewModelOrContainer) {
            return viewModelOrContainer.$controller.context.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer);
        }
        return null;
    }
    // TODO: This is probably wrong since it caused test fails when in CustomElement.for
    // Fred probably knows and will need to look at it
    // This can most likely also be changed so that the node traversal isn't necessary
    CustomElementFor(node) {
        let cur = node;
        while (cur !== null) {
            const nodeResourceName = cur.nodeName.toLowerCase();
            const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.name + ":" + nodeResourceName, cur)
                || _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.name, cur);
            if (controller !== void 0) {
                return controller;
            }
            cur = (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.getEffectiveParentNode)(cur);
        }
        return (void 0);
    }
}
Router.inject = [_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer, _navigator_js__WEBPACK_IMPORTED_MODULE_5__.Navigator, _browser_viewer_store_js__WEBPACK_IMPORTED_MODULE_14__.BrowserViewerStore, _link_handler_js__WEBPACK_IMPORTED_MODULE_3__.LinkHandler, _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_2__.InstructionResolver, _hook_manager_js__WEBPACK_IMPORTED_MODULE_11__.HookManager, _router_options_js__WEBPACK_IMPORTED_MODULE_17__.RouterOptions];
//# sourceMappingURL=router.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/runner.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/runner.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Runner": () => /* binding */ Runner
/* harmony export */ });
/**
 * Class for running a sequence of steps with values,
 * functions and promises. Stays sync if possible.
 *
 * Usage:
 *
 * ```ts
 * const promise = Runner.run(
 *   'one',
 *   prev => `${previous}, two`,
 *   prev => createPromise(prev), // creates a promise that resolves to `${prev}, three`
 * );
 *
 * // Run can be cancelled with Runner.cancel(promise);
 *
 * const stepsRunner = Runner.runner(promise);
 * const result = await promise;
 * if (stepsRunner?.isResolved) { // Make sure promise wasn't rejected
 *   // result === 'one, two, three'
 * }
 * ```
 */
class Runner {
    constructor() {
        this.isDone = false;
        this.isCancelled = false;
        this.isResolved = false;
        this.isRejected = false;
        this.isAsync = false;
    }
    get stop() {
        return this.isCancelled || this.isRejected;
    }
    /**
     * Runs a set of steps and retuns the last value
     *
     * Steps are processed in sequence and can be either a
     *
     * - value - which is then propagated as input into the next step
     * - function - which is executed in time. The result is replacing the step which is then reprocessed
     * - promise - which is awaited
     *
     * ```ts
     * result = await Runner.run(
     *   'one',
     *   prev => `${previous}, two`,
     *   prev => createPromise(prev), // creates a promise that resolves to `${prev}, three`
     * ); // result === 'one, two, three'
     * ```
     *
     */
    static run(...steps) {
        // debugger; // FIX ARRAY CHECK!
        const $runner = new Runner();
        const value = Runner.$run($runner, ...steps);
        if (value instanceof Promise) {
            this.runners.set(value, $runner);
            value.then(() => {
                $runner.isDone = true;
                if ($runner.isAsync && !$runner.stop) {
                    $runner.isResolved = true;
                }
                this.runners.delete(value);
                // console.log('$runner done', $runner, this.runners);
            }).catch(err => { throw err; });
        }
        return value;
    }
    /**
     * Gets the runner for a promise returned by Runner.run
     *
     * The runner can be used to check status and outcome of
     * the run as well as cancel it
     *
     */
    static runner(value) {
        if (value instanceof Promise) {
            return Runner.runners.get(value);
        }
    }
    /**
     * Cancels the runner for a promise returned by Runner.run
     *
     * Once a runner has been cancelled, it's no longer possible
     * to retrieve it from the promise
     *
     */
    static cancel(value) {
        const $runner = Runner.runner(value);
        if ($runner !== void 0) {
            $runner.cancel();
        }
    }
    static runAll(steps) {
        const $runner = new Runner();
        const values = Runner.$runAll($runner, steps);
        if ($runner.isAsync) {
            const promise = Promise.all(values);
            this.runners.set(promise, $runner);
            promise.then(() => {
                $runner.isDone = true;
                if ($runner.isAsync && !$runner.stop) {
                    $runner.isResolved = true;
                }
                this.runners.delete(promise);
                // console.log('$runner done', $runner, this.runners);
            }).catch(err => { throw err; });
            return promise;
        }
        return values;
    }
    static runOne(step) {
        let value;
        // Iteratively resolve Functions (until value or Promise)
        while (step instanceof Function) {
            step = step(value);
            if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                value = step;
            }
        }
        // In case there wasn't a Function before the value
        if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
            value = step;
        }
        // If we've got a Promise, run the remaining
        if (step instanceof Promise) {
            return step.then((resolvedValue) => {
                return Runner.runOne(resolvedValue);
            }).catch((err) => { throw err; });
        }
        return value;
    }
    cancel() {
        this.isCancelled = true;
    }
    static $run($runner, ...steps) {
        let step;
        while (steps.length > 0 && !$runner.stop) {
            step = steps.shift();
            // Iteratively resolve Functions (until value or Promise)
            while (step instanceof Function && !$runner.stop) {
                step = step($runner.value);
                if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                    $runner.value = step;
                }
            }
            // In case there wasn't a Function before the value
            if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                $runner.value = step;
            }
            // Run steps until done or we get a Promise
            if (step instanceof Promise) {
                break;
            }
        }
        // If we've got a Promise, run the remaining
        if (step instanceof Promise && !$runner.stop) {
            $runner.isAsync = true;
            return step.then((resolvedValue) => {
                return Runner.$run($runner, resolvedValue, ...steps);
            }).catch((err) => {
                $runner.isRejected = true;
                throw err;
            });
        }
        return $runner.value;
    }
    static $runAll($runner, steps) {
        const results = new Array(steps.length);
        steps.forEach((step, index) => {
            // Iteratively resolve Functions (until value or Promise)
            while (step instanceof Function) {
                step = step(results[index]);
                if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                    results[index] = step;
                }
            }
            // In case there wasn't a Function before the value
            if (!(step instanceof Function)) { // === isValue(step)
                results[index] = step;
            }
            // If we've got a Promise, run the remaining
            if (step instanceof Promise) {
                $runner.isAsync = true;
            }
        });
        return results;
    }
}
Runner.runners = new WeakMap();
//# sourceMappingURL=runner.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/scope.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/scope.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scope": () => /* binding */ Scope
/* harmony export */ });
/* harmony import */ var _viewport_scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/viewport-scope.js");
/* harmony import */ var _found_route_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./found-route.js */ "./node_modules/@aurelia/router/dist/esm/found-route.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./collection.js */ "./node_modules/@aurelia/router/dist/esm/collection.js");
/* harmony import */ var _route_recognizer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./route-recognizer.js */ "./node_modules/@aurelia/router/dist/esm/route-recognizer.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");








/**
 * @internal - Shouldn't be used directly
 */
class Scope {
    constructor(router, hasScope, owningScope, viewport = null, viewportScope = null, rootComponentType = null) {
        this.router = router;
        this.hasScope = hasScope;
        this.owningScope = owningScope;
        this.viewport = viewport;
        this.viewportScope = viewportScope;
        this.rootComponentType = rootComponentType;
        this.id = '.';
        this.parent = null;
        this.children = [];
        this.replacedChildren = [];
        this.path = null;
        this.enabled = true;
        // Support collection feature in viewport scopes
        this.childCollections = {};
        this.owningScope = owningScope ?? this;
        this.scope = this.hasScope ? this : this.owningScope.scope;
        // console.log('Created scope', this.toString());
    }
    toString(recurse = false) {
        return `${this.owningScope !== this ? this.owningScope.toString() : ''}/${this.owner.toString()}` +
            // eslint-disable-next-line prefer-template
            `${recurse ? `\n` + this.children.map(child => child.toString(true)).join('') : ''}`;
    }
    get isViewport() {
        return this.viewport !== null;
    }
    get isViewportScope() {
        return this.viewportScope !== null;
    }
    get passThroughScope() {
        return this.isViewportScope && this.viewportScope.passThroughScope;
    }
    get owner() {
        if (this.isViewport) {
            return this.viewport;
        }
        if (this.isViewportScope) {
            return this.viewportScope;
        }
        return null;
    }
    get enabledChildren() {
        return this.children.filter(scope => scope.enabled);
    }
    get hoistedChildren() {
        const scopes = this.enabledChildren;
        while (scopes.some(scope => scope.passThroughScope)) {
            for (const scope of scopes.slice()) {
                if (scope.passThroughScope) {
                    const index = scopes.indexOf(scope);
                    scopes.splice(index, 1, ...scope.enabledChildren);
                }
            }
        }
        return scopes;
    }
    get enabledViewports() {
        return this.children
            .filter(scope => scope.isViewport && scope.enabled)
            .map(scope => scope.viewport);
    }
    get viewportInstruction() {
        if (this.isViewportScope) {
            return this.viewportScope.content;
        }
        if (this.isViewport) {
            return this.viewport.content.content;
        }
        return null;
    }
    get parentNextContentAction() {
        if (this.parent === null) {
            return '';
        }
        const parentAction = this.parent.owner.nextContentAction;
        if (parentAction === 'swap' || parentAction === 'skip') {
            return parentAction;
        }
        return this.parent.parentNextContentAction;
    }
    getEnabledViewports(viewportScopes) {
        return viewportScopes
            .filter(scope => !scope.isViewportScope)
            .map(scope => scope.viewport)
            .reduce((viewports, viewport) => {
            viewports[viewport.name] = viewport;
            return viewports;
        }, {});
    }
    getOwnedViewports(includeDisabled = false) {
        return this.allViewports(includeDisabled).filter(viewport => viewport.owningScope === this);
    }
    getOwnedScopes(includeDisabled = false) {
        const scopes = this.allScopes(includeDisabled).filter(scope => scope.owningScope === this);
        // Hoist children to pass through scopes
        for (const scope of scopes.slice()) {
            if (scope.passThroughScope) {
                const index = scopes.indexOf(scope);
                scopes.splice(index, 1, ...scope.getOwnedScopes());
            }
        }
        return scopes;
    }
    findInstructions(instruction) {
        let route = new _found_route_js__WEBPACK_IMPORTED_MODULE_1__.FoundRoute();
        if (typeof instruction === 'string') {
            const instructions = this.router.instructionResolver.parseViewportInstructions(instruction);
            if (this.router.options.useConfiguredRoutes && !this.router.hasSiblingInstructions(instructions)) {
                const foundRoute = this.findMatchingRoute(instruction);
                if (foundRoute?.foundConfiguration ?? false) {
                    route = foundRoute;
                }
                else {
                    if (this.router.options.useDirectRoutes) {
                        route.instructions = instructions;
                        if (route.instructions.length > 0) {
                            const nextInstructions = route.instructions[0].nextScopeInstructions ?? [];
                            route.remaining = this.router.instructionResolver.stringifyViewportInstructions(nextInstructions);
                            // TODO: Verify that it's okay to leave this in
                            route.instructions[0].nextScopeInstructions = null;
                        }
                    }
                }
            }
            else if (this.router.options.useDirectRoutes) {
                route.instructions = instructions;
            }
        }
        else {
            route.instructions = instruction;
        }
        for (const instr of route.instructions) {
            if (instr.scope === null) {
                instr.scope = this;
            }
        }
        return route;
    }
    // Note: This can't change state other than the instructions!
    findViewports(instructions, alreadyFound, disregardViewports = false) {
        const foundViewports = [];
        let remainingInstructions = [];
        const ownedScopes = this.getOwnedScopes();
        // Get a shallow copy of all available manual viewport scopes
        const viewportScopes = ownedScopes.filter(scope => scope.isViewportScope).map(scope => scope.viewportScope);
        const availableViewportScopes = viewportScopes.filter(viewportScope => alreadyFound.every(found => found.viewportScope !== viewportScope));
        // Get a shallow copy of all available viewports
        const availableViewports = { ...this.getEnabledViewports(ownedScopes) };
        for (const instruction of alreadyFound.filter(found => found.scope === this)) {
            availableViewports[instruction.viewportName] = null;
        }
        const viewportInstructions = new _collection_js__WEBPACK_IMPORTED_MODULE_5__.Collection(...instructions.slice());
        let instruction = null;
        // The viewport scope is already known
        while ((instruction = viewportInstructions.next()) !== null) {
            if (instruction.viewportScope !== null && !this.router.instructionResolver.isAddViewportInstruction(instruction)) {
                remainingInstructions.push(...this.foundViewportScope(instruction, instruction.viewportScope));
                foundViewports.push(instruction);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.arrayRemove)(availableViewportScopes, available => available === instruction.viewportScope);
                viewportInstructions.removeCurrent();
            }
        }
        // The viewport is already known
        if (!disregardViewports) {
            while ((instruction = viewportInstructions.next()) !== null) {
                if (instruction.viewport !== null) {
                    remainingInstructions.push(...this.foundViewport(instruction, instruction.viewport, disregardViewports));
                    foundViewports.push(instruction);
                    availableViewports[instruction.viewport.name] = null;
                    viewportInstructions.removeCurrent();
                }
            }
        }
        // Viewport scopes have priority
        while ((instruction = viewportInstructions.next()) !== null) {
            for (let viewportScope of viewportScopes) {
                if (viewportScope.acceptSegment(instruction.componentName)) {
                    if (Array.isArray(viewportScope.source)) {
                        // console.log('available', viewportScope.available, source);
                        let available = availableViewportScopes.find(available => available.name === viewportScope.name);
                        if (available === void 0 || this.router.instructionResolver.isAddViewportInstruction(instruction)) {
                            const item = viewportScope.addSourceItem();
                            available = this.getOwnedScopes()
                                .filter(scope => scope.isViewportScope)
                                .map(scope => scope.viewportScope)
                                .find(viewportScope => viewportScope.sourceItem === item);
                        }
                        viewportScope = available;
                    }
                    remainingInstructions.push(...this.foundViewportScope(instruction, viewportScope));
                    foundViewports.push(instruction);
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.arrayRemove)(availableViewportScopes, available => available === instruction.viewportScope);
                    viewportInstructions.removeCurrent();
                    break;
                }
            }
        }
        // Configured viewport is ruling
        while ((instruction = viewportInstructions.next()) !== null) {
            instruction.needsViewportDescribed = true;
            for (const name in availableViewports) {
                const viewport = availableViewports[name];
                // TODO: Also check if (resolved) component wants a specific viewport
                if (viewport?.wantComponent(instruction.componentName)) {
                    const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
                    foundViewports.push(instruction);
                    remainingInstructions.push(...remaining);
                    availableViewports[name] = null;
                    viewportInstructions.removeCurrent();
                    break;
                }
            }
        }
        // Next in line is specified viewport (but not if we're disregarding viewports)
        if (!disregardViewports) {
            while ((instruction = viewportInstructions.next()) !== null) {
                const name = instruction.viewportName;
                if (!name || !name.length) {
                    continue;
                }
                const newScope = instruction.ownsScope;
                if (!this.getEnabledViewports(ownedScopes)[name]) {
                    continue;
                    // TODO: No longer pre-creating viewports. Evaluate!
                    this.addViewport(name, null, { scope: newScope, forceDescription: true });
                    availableViewports[name] = this.getEnabledViewports(ownedScopes)[name];
                }
                const viewport = availableViewports[name];
                if (viewport?.acceptComponent(instruction.componentName)) {
                    const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
                    foundViewports.push(instruction);
                    remainingInstructions.push(...remaining);
                    availableViewports[name] = null;
                    viewportInstructions.removeCurrent();
                }
            }
        }
        // Finally, only one accepting viewport left?
        while ((instruction = viewportInstructions.next()) !== null) {
            const remainingViewports = [];
            for (const name in availableViewports) {
                const viewport = availableViewports[name];
                if (viewport?.acceptComponent(instruction.componentName)) {
                    remainingViewports.push(viewport);
                }
            }
            if (remainingViewports.length === 1) {
                const viewport = remainingViewports.shift();
                const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
                foundViewports.push(instruction);
                remainingInstructions.push(...remaining);
                availableViewports[viewport.name] = null;
                viewportInstructions.removeCurrent();
            }
        }
        // If we're ignoring viewports, we now match them anyway
        if (disregardViewports) {
            while ((instruction = viewportInstructions.next()) !== null) {
                let viewport = instruction.viewport;
                if (!viewport) {
                    const name = instruction.viewportName;
                    if ((name?.length ?? 0) === 0) {
                        continue;
                    }
                    const newScope = instruction.ownsScope;
                    if (!this.getEnabledViewports(ownedScopes)[name]) {
                        continue;
                        // TODO: No longer pre-creating viewports. Evaluate!
                        this.addViewport(name, null, { scope: newScope, forceDescription: true });
                        availableViewports[name] = this.getEnabledViewports(ownedScopes)[name];
                    }
                    viewport = availableViewports[name];
                }
                if (viewport?.acceptComponent(instruction.componentName)) {
                    const remaining = this.foundViewport(instruction, viewport, disregardViewports);
                    foundViewports.push(instruction);
                    remainingInstructions.push(...remaining);
                    availableViewports[viewport.name] = null;
                    viewportInstructions.removeCurrent();
                }
            }
        }
        remainingInstructions = [...viewportInstructions, ...remainingInstructions];
        return {
            foundViewports,
            remainingInstructions,
        };
    }
    foundViewportScope(instruction, viewportScope) {
        instruction.viewportScope = viewportScope;
        instruction.needsViewportDescribed = false;
        const remaining = instruction.nextScopeInstructions?.slice() ?? [];
        for (const rem of remaining) {
            if (rem.scope === null) {
                rem.scope = viewportScope.scope.scope;
            }
        }
        return remaining;
    }
    foundViewport(instruction, viewport, withoutViewports, doesntNeedViewportDescribed = false) {
        instruction.setViewport(viewport);
        if (doesntNeedViewportDescribed) {
            instruction.needsViewportDescribed = false;
        }
        const remaining = instruction.nextScopeInstructions?.slice() ?? [];
        for (const rem of remaining) {
            if (rem.scope === null) {
                rem.scope = viewport.scope;
            }
        }
        return remaining;
    }
    addViewport(name, connectedCE, options = {}) {
        let viewport = this.getEnabledViewports(this.getOwnedScopes())[name];
        // Each au-viewport element has its own Viewport
        if (((connectedCE ?? null) !== null) &&
            ((viewport?.connectedCE ?? null) !== null) &&
            viewport.connectedCE !== connectedCE) {
            viewport.enabled = false;
            viewport = this.getOwnedViewports(true).find(child => child.name === name && child.connectedCE === connectedCE) ?? null;
            if ((viewport ?? null) !== null) {
                viewport.enabled = true;
            }
        }
        if ((viewport ?? null) === null) {
            viewport = new _viewport_js__WEBPACK_IMPORTED_MODULE_3__.Viewport(this.router, name, connectedCE, this.scope, !!options.scope, options);
            this.addChild(viewport.connectedScope);
        }
        if ((connectedCE ?? null) !== null) {
            viewport.setConnectedCE(connectedCE, options);
        }
        return viewport;
    }
    removeViewport(viewport, connectedCE) {
        if (((connectedCE ?? null) !== null) || viewport.remove(connectedCE)) {
            this.removeChild(viewport.connectedScope);
            return true;
        }
        return false;
    }
    addViewportScope(name, connectedCE, options = {}) {
        const viewportScope = new _viewport_scope_js__WEBPACK_IMPORTED_MODULE_0__.ViewportScope(name, this.router, connectedCE, this.scope, true, null, options);
        this.addChild(viewportScope.connectedScope);
        return viewportScope;
    }
    removeViewportScope(viewportScope) {
        // viewportScope.remove();
        this.removeChild(viewportScope.connectedScope);
        return true;
    }
    addChild(scope) {
        if (!this.children.some(vp => vp === scope)) {
            if (scope.parent !== null) {
                scope.parent.removeChild(scope);
            }
            this.children.push(scope);
            scope.parent = this;
        }
    }
    removeChild(scope) {
        const index = this.children.indexOf(scope);
        if (index >= 0) {
            this.children.splice(index, 1);
            scope.parent = null;
        }
    }
    clearReplacedChildren() {
        this.replacedChildren = [];
    }
    disableReplacedChildren() {
        this.replacedChildren = this.enabledChildren;
        for (const scope of this.replacedChildren) {
            scope.enabled = false;
        }
    }
    reenableReplacedChildren() {
        for (const scope of this.replacedChildren) {
            scope.enabled = true;
        }
    }
    allViewports(includeDisabled = false, includeReplaced = false) {
        return this.allScopes(includeDisabled, includeReplaced).filter(scope => scope.isViewport).map(scope => scope.viewport);
    }
    allScopes(includeDisabled = false, includeReplaced = false) {
        const scopes = includeDisabled ? this.children.slice() : this.enabledChildren;
        for (const scope of scopes.slice()) {
            scopes.push(...scope.allScopes(includeDisabled, includeReplaced));
        }
        return scopes;
    }
    reparentViewportInstructions() {
        const scopes = this.hoistedChildren
            .filter(scope => scope.viewportInstruction !== null && scope.viewportInstruction.componentName);
        if (!scopes.length) {
            return null;
        }
        for (const scope of scopes) {
            const childInstructions = scope.reparentViewportInstructions();
            scope.viewportInstruction.nextScopeInstructions =
                childInstructions !== null && childInstructions.length > 0 ? childInstructions : null;
        }
        return scopes.map(scope => scope.viewportInstruction);
    }
    findMatchingRoute(path) {
        if (this.isViewportScope && !this.passThroughScope) {
            return this.findMatchingRouteInRoutes(path, this.viewportScope.getRoutes());
        }
        if (this.isViewport) {
            return this.findMatchingRouteInRoutes(path, this.viewport.getRoutes());
        }
        // TODO: Match specified names here
        for (const child of this.enabledChildren) {
            const found = child.findMatchingRoute(path);
            if (found !== null) {
                return found;
            }
        }
        return null;
    }
    canLoad(recurse) {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.canLoad(recurse)
            : child.canLoad(recurse)));
        if (results instanceof Promise) {
            return results.then(resolvedResults => resolvedResults.every(result => result));
        }
        return results.every(result => result);
    }
    canUnload() {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.canUnload()
            : child.canUnload()));
        if (results instanceof Promise) {
            return results.then(resolvedResults => {
                return resolvedResults.every(result => result);
            });
        }
        return results.every(result => result);
    }
    load(recurse) {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.load(recurse)
            : child.load(recurse)));
        if (results instanceof Promise) {
            return results;
        }
    }
    unload(recurse) {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.unload(recurse)
            : child.unload(recurse)));
        if (results instanceof Promise) {
            return results;
        }
    }
    removeContent() {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.removeContent()
            : child.removeContent()));
        if (results instanceof Promise) {
            return results;
        }
    }
    findMatchingRouteInRoutes(path, routes) {
        if (!Array.isArray(routes)) {
            return null;
        }
        routes = routes.map(route => this.ensureProperRoute(route));
        const cRoutes = routes.map(route => ({
            path: route.path,
            handler: route,
        }));
        for (let i = 0, ii = cRoutes.length; i < ii; ++i) {
            const cRoute = cRoutes[i];
            cRoutes.push({
                ...cRoute,
                path: `${cRoute.path}/*remainingPath`,
            });
        }
        const found = new _found_route_js__WEBPACK_IMPORTED_MODULE_1__.FoundRoute();
        if (path.startsWith('/') || path.startsWith('+')) {
            path = path.slice(1);
        }
        const recognizer = new _route_recognizer_js__WEBPACK_IMPORTED_MODULE_6__.RouteRecognizer();
        recognizer.add(cRoutes);
        const result = recognizer.recognize(path);
        if (result !== null) {
            found.match = result.endpoint.route.handler;
            found.matching = path;
            const $params = { ...result.params };
            if ($params.remainingPath !== void 0) {
                found.remaining = $params.remainingPath;
                Reflect.deleteProperty($params, 'remainingPath');
                found.matching = found.matching.slice(0, found.matching.indexOf(found.remaining));
            }
            found.params = $params;
        }
        if (found.foundConfiguration) {
            // clone it so config doesn't get modified
            found.instructions = this.router.instructionResolver.cloneViewportInstructions(found.match.instructions, false, true);
            const instructions = found.instructions.slice();
            while (instructions.length > 0) {
                const instruction = instructions.shift();
                instruction.addParameters(found.params);
                instruction.route = '';
                if (instruction.nextScopeInstructions !== null) {
                    instructions.unshift(...instruction.nextScopeInstructions);
                }
            }
            if (found.instructions.length > 0) {
                found.instructions[0].route = found;
            }
        }
        return found;
    }
    ensureProperRoute(route) {
        if (route.id === void 0) {
            route.id = route.path;
        }
        if (route.instructions === void 0) {
            route.instructions = [{
                    component: route.component,
                    viewport: route.viewport,
                    parameters: route.parameters,
                    children: route.children,
                }];
        }
        route.instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.toViewportInstructions(this.router, route.instructions);
        return route;
    }
}
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/state-coordinator.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/state-coordinator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Entity": () => /* binding */ Entity,
/* harmony export */   "StateCoordinator": () => /* binding */ StateCoordinator
/* harmony export */ });
/* harmony import */ var _open_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./open-promise.js */ "./node_modules/@aurelia/router/dist/esm/open-promise.js");

class Entity {
    constructor(entity) {
        this.entity = entity;
        this.running = false;
        this.states = [];
        this.checkedStates = [];
        this.syncState = null;
        this.syncPromise = null;
    }
}
class StateCoordinator {
    constructor() {
        this.entities = [];
        this.hasAllEntities = false;
        this.syncStates = new Map();
        this.checkedSyncStates = new Set();
    }
    // public constructor(@ILogger private readonly logger: ILogger) {
    //   this.logger = logger.root.scopeTo('StateCoordinator');
    //   this.logger.trace('constructor()');
    // }
    addSyncState(state) {
        const openPromise = new _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise();
        this.syncStates.set(state, openPromise);
    }
    addEntity(entity) {
        // console.log('Entity received', entity);
        const ent = new Entity(entity);
        this.entities.push(ent);
        this.resetSyncStates();
        return ent;
    }
    addEntityState(entity, state) {
        // console.log(`#### EntityState received ${state}`, (entity as any).name);
        let ent = this.entities.find(e => e.entity === entity);
        if (ent === void 0) {
            ent = this.addEntity(entity);
        }
        ent.states.push(state);
        this.checkSyncState(state);
    }
    syncState(state, entity = null) {
        const openPromise = this.syncStates.get(state);
        if (openPromise === void 0) {
            return;
        }
        if (entity !== null) {
            const ent = this.entities.find(e => e.entity === entity);
            if (ent?.syncPromise === null && openPromise.isPending) {
                ent.syncState = state;
                ent.syncPromise = new _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise();
                ent.checkedStates.push(state);
                this.checkedSyncStates.add(state);
                Promise.resolve().then(() => { this.checkSyncState(state); }).catch(err => { throw err; });
                return ent.syncPromise.promise;
            }
        }
        // this.checkSyncState(state);
        return openPromise.promise;
    }
    checkingSyncState(state) {
        return this.syncStates.has(state);
    }
    finalEntity() {
        this.hasAllEntities = true;
        // console.log('Final entity received', this.entities.length);
        this.syncStates.forEach((_promise, state) => this.checkSyncState(state));
    }
    finalize() { }
    cancel() { }
    // A new navigation should cancel replaced instructions
    cancelReplaced(navigation) { }
    checkSyncState(state) {
        // console.log('StateCoordinator check state', state, this);
        const openPromise = this.syncStates.get(state);
        if (openPromise === void 0) {
            return;
        }
        if (this.hasAllEntities &&
            openPromise.isPending &&
            // Check that this state has been done by all state entities and if so resolve the promise
            this.entities.every(ent => ent.states.includes(state)) &&
            // Check that this state has been checked (reached) by all state entities and if so resolve the promise
            (!this.checkedSyncStates.has(state) || this.entities.every(ent => ent.checkedStates.includes(state)))) {
            for (const entity of this.entities) {
                if (entity.syncState === state) {
                    // console.log('Resolving entity promise for ', state, (entity.entity as any).toString());
                    entity.syncPromise?.resolve();
                    entity.syncPromise = null;
                    entity.syncState = null;
                }
            }
            openPromise.resolve();
            // console.log('#### StateCoordinator state resolved', state /*, this */);
        }
    }
    resetSyncStates() {
        this.syncStates.forEach((promise, state) => {
            if (!promise.isPending &&
                !this.entities.every(entity => entity.states.includes(state))) {
                this.addSyncState(state);
            }
        });
    }
}
//# sourceMappingURL=state-coordinator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/task-queue.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/task-queue.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueueTask": () => /* binding */ QueueTask,
/* harmony export */   "TaskQueue": () => /* binding */ TaskQueue
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * @internal - Shouldn't be used directly
 */
class QueueTask {
    constructor(taskQueue, item, cost = 0) {
        this.taskQueue = taskQueue;
        this.item = item;
        this.cost = cost;
        this.done = false;
        this.promise = new Promise((resolve, reject) => {
            this.resolve = () => {
                this.taskQueue.resolve(this, resolve);
            };
            this.reject = (reason) => {
                this.taskQueue.reject(this, reject, reason);
            };
        });
    }
    async execute() {
        if ('execute' in this.item) {
            await this.item.execute(this);
        }
        else {
            await this.item(this);
        }
    }
    wait() {
        return this.promise;
    }
}
/**
 * A first-in-first-out task queue that only processes the next queued item
 * when the current one has been resolved or rejected. If a callback function
 * is specified, it receives the queued items as tasks one at a time. If no
 * callback is specified, the tasks themselves are either executed (if a
 * function) or the execute method in them are run. The executed function
 * should resolve or reject the task when processing is done.
 * Enqueued items' tasks can be awaited. Enqueued items can specify an
 * (arbitrary) execution cost and the queue can be set up (started) to
 * only process a specific amount of execution cost per RAF/tick.
 *
 * @internal - Shouldn't be used directly.
 */
class TaskQueue {
    constructor(callback) {
        this.callback = callback;
        this.pending = [];
        this.processing = null;
        this.allowedExecutionCostWithinTick = null;
        this.currentExecutionCostInCurrentTick = 0;
        this.platform = null;
        this.task = null;
    }
    get isActive() {
        return this.task !== null;
    }
    get length() {
        return this.pending.length;
    }
    start(options) {
        if (this.isActive) {
            throw new Error('TaskQueue has already been started');
        }
        this.platform = options.platform;
        this.allowedExecutionCostWithinTick = options.allowedExecutionCostWithinTick;
        this.task = this.platform.domWriteQueue.queueTask(this.dequeue, { persistent: true });
    }
    stop() {
        if (!this.isActive) {
            throw new Error('TaskQueue has not been started');
        }
        this.task.cancel();
        this.task = null;
        this.allowedExecutionCostWithinTick = null;
        this.clear();
    }
    enqueue(itemOrItems, costOrCosts) {
        const list = Array.isArray(itemOrItems);
        const items = (list ? itemOrItems : [itemOrItems]);
        const costs = items
            .map((value, index) => !Array.isArray(costOrCosts) ? costOrCosts : costOrCosts[index])
            .map((value) => value !== undefined ? value : 1);
        const tasks = [];
        for (const item of items) {
            tasks.push(item instanceof QueueTask
                ? item
                : this.createQueueTask(item, costs.shift())); // TODO: Get cancellable in as well
        }
        this.pending.push(...tasks);
        this.dequeue();
        return list ? tasks : tasks[0];
    }
    createQueueTask(item, cost) {
        return new QueueTask(this, item, cost);
    }
    dequeue(delta) {
        if (this.processing !== null) {
            return;
        }
        if (delta !== undefined) {
            this.currentExecutionCostInCurrentTick = 0;
        }
        if (!this.pending.length) {
            return;
        }
        if (this.allowedExecutionCostWithinTick !== null && delta === undefined && this.currentExecutionCostInCurrentTick + (this.pending[0].cost || 0) > this.allowedExecutionCostWithinTick) {
            return;
        }
        this.processing = this.pending.shift() || null;
        if (this.processing) {
            this.currentExecutionCostInCurrentTick += this.processing.cost ?? 0;
            if (this.callback !== void 0) {
                this.callback(this.processing);
            }
            else {
                // Don't need to await this since next task won't be dequeued until
                // executed function is resolved
                this.processing.execute().catch(error => { throw error; });
            }
        }
    }
    clear() {
        this.pending.splice(0, this.pending.length);
    }
    resolve(task, resolve) {
        resolve();
        this.processing = null;
        this.dequeue();
    }
    reject(task, reject, reason) {
        reject(reason);
        this.processing = null;
        this.dequeue();
    }
}
__decorate([
    _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.bound
], TaskQueue.prototype, "dequeue", null);
//# sourceMappingURL=task-queue.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/type-resolvers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComponentAppellationResolver": () => /* binding */ ComponentAppellationResolver,
/* harmony export */   "ViewportHandleResolver": () => /* binding */ ViewportHandleResolver,
/* harmony export */   "NavigationInstructionResolver": () => /* binding */ NavigationInstructionResolver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");



const ComponentAppellationResolver = {
    isName(component) {
        return typeof component === 'string';
    },
    isType(component) {
        return _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.isType(component);
    },
    isInstance(component) {
        return !ComponentAppellationResolver.isName(component) && !ComponentAppellationResolver.isType(component);
    },
    getName(component) {
        if (ComponentAppellationResolver.isName(component)) {
            return component;
        }
        else if (ComponentAppellationResolver.isType(component)) {
            return _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.getDefinition(component).name;
        }
        else {
            return ComponentAppellationResolver.getName(component.constructor);
        }
    },
    getType(component) {
        if (ComponentAppellationResolver.isName(component)) {
            return null;
        }
        else if (ComponentAppellationResolver.isType(component)) {
            return component;
        }
        else {
            return component.constructor;
        }
    },
    getInstance(component) {
        if (ComponentAppellationResolver.isName(component) || ComponentAppellationResolver.isType(component)) {
            return null;
        }
        else {
            return component;
        }
    },
};
const ViewportHandleResolver = {
    isName(viewport) {
        return typeof viewport === 'string';
    },
    isInstance(viewport) {
        return viewport instanceof _viewport_js__WEBPACK_IMPORTED_MODULE_1__.Viewport;
    },
    getName(viewport) {
        if (ViewportHandleResolver.isName(viewport)) {
            return viewport;
        }
        else {
            return viewport ? (viewport).name : null;
        }
    },
    getInstance(viewport) {
        if (ViewportHandleResolver.isName(viewport)) {
            return null;
        }
        else {
            return viewport;
        }
    },
};
const NavigationInstructionResolver = {
    createViewportInstructions(router, navigationInstructions, options) {
        options = options || {};
        let scope = null;
        if (options.context) {
            scope = router.findScope(options.context);
            if (typeof navigationInstructions === 'string') {
                // If it's not from scope root, figure out which scope
                if (!navigationInstructions.startsWith('/')) {
                    // Scope modifications
                    if (navigationInstructions.startsWith('.')) {
                        // The same as no scope modification
                        if (navigationInstructions.startsWith('./')) {
                            navigationInstructions = navigationInstructions.slice(2);
                        }
                        // Find out how many scopes upwards we should move
                        while (navigationInstructions.startsWith('../')) {
                            scope = scope.parent || scope;
                            navigationInstructions = navigationInstructions.slice(3);
                        }
                    }
                    if (scope.path !== null) {
                        navigationInstructions = `${scope.path}/${navigationInstructions}`;
                        scope = router.rootScope.scope;
                    }
                }
                else { // Specified root scope with /
                    scope = router.rootScope.scope;
                }
            }
            else {
                navigationInstructions = NavigationInstructionResolver.toViewportInstructions(router, navigationInstructions);
                for (const instruction of navigationInstructions) {
                    if (instruction.scope === null) {
                        instruction.scope = scope;
                    }
                }
            }
        }
        return {
            instructions: navigationInstructions,
            scope,
        };
    },
    toViewportInstructions(router, navigationInstructions) {
        if (!Array.isArray(navigationInstructions)) {
            return NavigationInstructionResolver.toViewportInstructions(router, [navigationInstructions]);
        }
        const instructions = [];
        for (const instruction of navigationInstructions) {
            if (typeof instruction === 'string') {
                instructions.push(...router.instructionResolver.parseViewportInstructions(instruction));
            }
            else if (instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__.ViewportInstruction) {
                instructions.push(instruction);
            }
            else if (instruction.component) {
                const viewportComponent = instruction;
                const newInstruction = router.createViewportInstruction(viewportComponent.component, viewportComponent.viewport, viewportComponent.parameters);
                if (viewportComponent.children !== void 0 && viewportComponent.children !== null) {
                    newInstruction.nextScopeInstructions = NavigationInstructionResolver.toViewportInstructions(router, viewportComponent.children);
                }
                instructions.push(newInstruction);
            }
            else {
                instructions.push(router.createViewportInstruction(instruction));
            }
        }
        return instructions;
    },
};
//# sourceMappingURL=type-resolvers.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayRemove": () => /* binding */ arrayRemove,
/* harmony export */   "resolvePossiblePromise": () => /* binding */ resolvePossiblePromise,
/* harmony export */   "deprecationWarning": () => /* binding */ deprecationWarning
/* harmony export */ });
/**
 * @internal - Shouldn't be used directly
 */
function arrayRemove(arr, func) {
    const removed = [];
    let arrIndex = arr.findIndex(func);
    while (arrIndex >= 0) {
        removed.push(arr.splice(arrIndex, 1)[0]);
        arrIndex = arr.findIndex(func);
    }
    return removed;
}
function resolvePossiblePromise(value, callback) {
    // If we've got a Promise, wait for it's resolve
    if (value instanceof Promise) {
        return value.then((resolvedValue) => {
            if (callback !== void 0) {
                callback(resolvedValue);
            }
            return resolvedValue;
        });
    }
    if (callback !== void 0) {
        callback(value);
    }
    return value;
}
function deprecationWarning(oldFeature, newFeature) {
    console.warn(`[Deprecated] The ${oldFeature} has been deprecated. Please use the ${newFeature} instead.`);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport-content.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport-content.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentStatus": () => /* binding */ ContentStatus,
/* harmony export */   "ViewportContent": () => /* binding */ ViewportContent
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser.js */ "./node_modules/@aurelia/router/dist/esm/parser.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");
/* harmony import */ var _awaitable_map_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./awaitable-map.js */ "./node_modules/@aurelia/router/dist/esm/awaitable-map.js");






/**
 * @internal - Shouldn't be used directly
 */
var ContentStatus;
(function (ContentStatus) {
    ContentStatus[ContentStatus["none"] = 0] = "none";
    ContentStatus[ContentStatus["created"] = 1] = "created";
    ContentStatus[ContentStatus["activated"] = 3] = "activated";
})(ContentStatus || (ContentStatus = {}));
/**
 * @internal - Shouldn't be used directly
 */
class ViewportContent {
    constructor(
    // Can (and wants) be a (resolved) type or a string (to be resolved later)
    // public content: ViewportInstruction = new ViewportInstruction(''),
    content = _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__.ViewportInstruction.create(null, ''), instruction = new _navigation_js__WEBPACK_IMPORTED_MODULE_3__.Navigation({
        instruction: '',
        fullStateInstruction: '',
    }), connectedCE = null) {
        this.content = content;
        this.instruction = instruction;
        // public contentStatus: ContentStatus = ContentStatus.none;
        this.contentStates = new _awaitable_map_js__WEBPACK_IMPORTED_MODULE_5__.AwaitableMap();
        // public contentStates: Map<ContentState, undefined> = new Map();
        this.loaded = false;
        this.fromCache = false;
        this.fromHistory = false;
        this.reentry = false;
        // If we've got a container, we're good to resolve type
        if (!this.content.isComponentType() && (connectedCE?.container ?? null) !== null) {
            this.content.componentType = this.toComponentType(connectedCE.container);
        }
    }
    get componentInstance() {
        return this.content.componentInstance;
    }
    get viewport() {
        return this.content.viewport;
    }
    equalComponent(other) {
        return this.content.sameComponent(other.content);
    }
    equalParameters(other) {
        return this.content.sameComponent(other.content, true) &&
            // TODO: Review whether query is relevant
            this.instruction.query === other.instruction.query;
    }
    reentryBehavior() {
        return (this.content.componentInstance !== null &&
            'reentryBehavior' in this.content.componentInstance &&
            this.content.componentInstance.reentryBehavior !== void 0)
            ? this.content.componentInstance.reentryBehavior
            : "default" /* default */;
    }
    isCacheEqual(other) {
        return this.content.sameComponent(other.content, true);
    }
    contentController(connectedCE) {
        return _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.Controller.forCustomElement(null, connectedCE.container, this.content.componentInstance, connectedCE.element, null, void 0);
    }
    createComponent(connectedCE, fallback) {
        // if (this.contentStatus !== ContentStatus.none) {
        if (this.contentStates.has('created')) {
            return;
        }
        // Don't load cached content or instantiated history content
        if (!this.fromCache && !this.fromHistory) {
            try {
                this.content.componentInstance = this.toComponentInstance(connectedCE.container);
            }
            catch (e) {
                if (fallback !== void 0) {
                    this.content.setParameters({ id: this.content.componentName });
                    this.content.setComponent(fallback);
                    try {
                        this.content.componentInstance = this.toComponentInstance(connectedCE.container);
                    }
                    catch (ee) {
                        throw e;
                    }
                }
                else {
                    throw e;
                }
            }
        }
        this.contentStates.set('created', void 0);
        // this.contentStatus = ContentStatus.created;
        // if (this.contentStatus !== ContentStatus.created || !this.loaded || !this.content.componentInstance) {
        // if (this.contentStatus !== ContentStatus.created || this.loaded || !this.content.componentInstance) {
        if (this.contentStates.has('loaded') || !this.content.componentInstance) {
            return;
        }
        // this.contentStatus = ContentStatus.loaded;
        // Don't load cached content or instantiated history content
        if (!this.fromCache || !this.fromHistory) {
            const controller = this.contentController(connectedCE);
            controller.parent = connectedCE.controller; // CustomElement.for(connectedCE.element)!;
        }
    }
    // public destroyComponent(): void {
    //   // TODO: We might want to do something here eventually, who knows?
    //   // if (this.contentStatus !== ContentStatus.created) {
    //   if (!this.contentStates.has('created')) {
    //     return;
    //   }
    //   // Don't destroy components when stateful
    //   // this.contentStatus = ContentStatus.none;
    //   this.contentStates.delete('created');
    // }
    canLoad(viewport, previousInstruction) {
        if (!this.contentStates.has('created') || (this.contentStates.has('guarded') && !this.reentry)) {
            return true;
        }
        this.contentStates.set('guarded', void 0);
        if (!this.content.componentInstance) {
            return false;
        }
        if (!this.content.componentInstance.canLoad) {
            return true;
        }
        const typeParameters = this.content.componentType ? this.content.componentType.parameters : null;
        this.instruction.parameters = this.content.toSpecifiedParameters(typeParameters);
        const merged = { ...(0,_parser_js__WEBPACK_IMPORTED_MODULE_1__.parseQuery)(this.instruction.query), ...this.instruction.parameters };
        const result = this.content.componentInstance.canLoad(merged, this.instruction, previousInstruction);
        if (typeof result === 'boolean') {
            return result;
        }
        if (typeof result === 'string') {
            return [viewport.router.createViewportInstruction(result, viewport)];
        }
        return result;
    }
    canUnload(nextInstruction) {
        if (!this.content.componentInstance || !this.content.componentInstance.canUnload) {
            return true;
        }
        if (!this.contentStates.has('loaded')) {
            return true;
        }
        return this.content.componentInstance.canUnload(nextInstruction, this.instruction);
    }
    // public async canUnload(nextInstruction: Navigation | null): Promise<boolean> {
    //   if (!this.content.componentInstance || !this.content.componentInstance.canUnload) {
    //     return true;
    //   }
    //   const result = this.content.componentInstance.canUnload(nextInstruction, this.instruction);
    //   if (typeof result === 'boolean') {
    //     return result;
    //   }
    //   return result;
    // }
    load(previousInstruction) {
        // if (!this.reentry && (this.contentStatus !== ContentStatus.created || this.loaded)) {
        // if (!this.reentry && this.loaded) {
        // if (!this.contentStates.has('created') || (this.contentStates.has('loaded') && !this.reentry)) {
        //   return;
        // }
        // this.reentry = false;
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.contentStates.await('guarded'), () => {
            if (!this.contentStates.has('created') || (this.contentStates.has('loaded') && !this.reentry)) {
                return;
            }
            this.reentry = false;
            // this.loaded = true;
            // console.log('loaded', this.content.componentName);
            this.contentStates.set('loaded', void 0);
            if (this.content.componentInstance && this.content.componentInstance.load) {
                const typeParameters = this.content.componentType ? this.content.componentType.parameters : null;
                this.instruction.parameters = this.content.toSpecifiedParameters(typeParameters);
                const merged = { ...(0,_parser_js__WEBPACK_IMPORTED_MODULE_1__.parseQuery)(this.instruction.query), ...this.instruction.parameters };
                return this.content.componentInstance.load(merged, this.instruction, previousInstruction);
            }
        });
    }
    unload(nextInstruction) {
        // if (!this.loaded) {
        if (!this.contentStates.has('loaded')) {
            return;
        }
        // this.loaded = false;
        // console.log('loaded', this.content.componentName, 'deleted');
        this.contentStates.delete('loaded');
        if (this.content.componentInstance && this.content.componentInstance.unload) {
            return this.content.componentInstance.unload(nextInstruction, this.instruction);
        }
    }
    // public unloadComponent(cache: ViewportContent[], stateful: boolean = false): void {
    //   // TODO: We might want to do something here eventually, who knows?
    //   // if (this.contentStatus !== ContentStatus.activated) {
    //   if (!this.contentStates.has('created')) {
    //     return;
    //   }
    //   // Don't unload components when stateful
    //   // TODO: We're missing stuff here
    //   if (!stateful) {
    //     // this.contentStatus = ContentStatus.created;
    //     this.contentStates.delete('created');
    //   } else {
    //     cache.push(this);
    //   }
    // }
    activateComponent(initiator, parent, flags, connectedCE, parentActivated) {
        // if (this.contentStates.has('activated') || !this.contentStates.has('created')) {
        // if (this.contentStates.has('activated')) {
        //   return;
        // }
        // this.contentStates.set('activated', void 0);
        // // if (parentActivated) { // Parent is already part of an activation
        // //   return ;
        // // }
        // const contentController = this.contentController(connectedCE);
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.contentStates.await('loaded'), () => {
            if (this.contentStates.has('activated')) {
                return;
            }
            this.contentStates.set('activated', void 0);
            // if (parentActivated) { // Parent is already part of an activation
            //   return ;
            // }
            const contentController = this.contentController(connectedCE);
            return contentController.activate(initiator ?? contentController, null /* TODO: take back: parent! */, flags);
        }, () => {
            if (this.fromCache || this.fromHistory) {
                const elements = Array.from(connectedCE.element.getElementsByTagName('*'));
                for (const el of elements) {
                    const attr = el.getAttribute('au-element-scroll');
                    if (attr) {
                        const [top, left] = attr.split(',');
                        el.removeAttribute('au-element-scroll');
                        el.scrollTo(+left, +top);
                    }
                }
            }
        });
    }
    // public async activateComponent(initiator: IHydratedController | null, parent: ICustomElementController<ICustomElementViewModel> | null, flags: LifecycleFlags, connectedCE: IConnectedCustomElement): Promise<void> {
    //   // if (this.contentStatus !== ContentStatus.created) {
    //   if (!this.contentStates.has('created')) {
    //     return;
    //   }
    //   // this.contentStatus = ContentStatus.activated;
    //   this.contentStates.add('activated');
    //   const contentController = this.contentController(connectedCE);
    //   await contentController.activate(initiator ?? contentController, parent!, flags);
    //   if (this.fromCache || this.fromHistory) {
    //     const elements = Array.from(connectedCE.element.getElementsByTagName('*'));
    //     for (const el of elements) {
    //       const attr = el.getAttribute('au-element-scroll');
    //       if (attr) {
    //         const [top, left] = attr.split(',');
    //         el.removeAttribute('au-element-scroll');
    //         el.scrollTo(+left, +top);
    //       }
    //     }
    //   }
    // }
    deactivateComponent(initiator, parent, flags, connectedCE, stateful = false) {
        // if (this.contentStatus !== ContentStatus.activated) {
        if (!this.contentStates.has('activated')) {
            return;
        }
        // this.contentStatus = ContentStatus.created;
        this.contentStates.delete('activated');
        if (stateful && connectedCE.element !== null) {
            // const contentController = this.content.componentInstance!.$controller!;
            const elements = Array.from(connectedCE.element.getElementsByTagName('*'));
            for (const el of elements) {
                if (el.scrollTop > 0 || el.scrollLeft) {
                    el.setAttribute('au-element-scroll', `${el.scrollTop},${el.scrollLeft}`);
                }
            }
        }
        const contentController = this.contentController(connectedCE);
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => contentController.deactivate(initiator ?? contentController, parent, flags));
    }
    disposeComponent(connectedCE, cache, stateful = false) {
        if (!this.contentStates.has('created')) {
            return;
        }
        // Don't unload components when stateful
        // TODO: We're missing stuff here
        if (!stateful) {
            this.contentStates.delete('created');
            const contentController = this.contentController(connectedCE);
            return contentController.dispose();
        }
        else {
            cache.push(this);
        }
    }
    freeContent(connectedCE, nextInstruction, cache, stateful = false) {
        // switch (this.contentStatus) {
        //   case ContentStatus.activated:
        //     await this.unload(nextInstruction);
        //     await this.deactivateComponent(null, connectedCE!.controller, LifecycleFlags.none, connectedCE!, stateful);
        //     this.unloadComponent(cache, stateful); // TODO: Hook up to new dispose
        //   case ContentStatus.created:
        //     this.destroyComponent();
        // }
        // TODO: Fix execution order on these
        // These are all safe to run
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.unload(nextInstruction), () => this.deactivateComponent(null, connectedCE.controller, 0 /* none */, connectedCE, stateful), 
        // () => this.unloadComponent(cache, stateful), // TODO: Hook up to new dispose
        // () => this.destroyComponent(),
        () => this.disposeComponent(connectedCE, cache, stateful));
    }
    toComponentName() {
        return this.content.componentName;
    }
    toComponentType(container) {
        if (this.content.isEmpty()) {
            return null;
        }
        return this.content.toComponentType(container);
    }
    toComponentInstance(container) {
        if (this.content.isEmpty()) {
            return null;
        }
        return this.content.toComponentInstance(container);
    }
}
//# sourceMappingURL=viewport-content.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport-instruction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParametersType": () => /* binding */ ParametersType,
/* harmony export */   "ViewportInstruction": () => /* binding */ ViewportInstruction
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _router_options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router-options.js */ "./node_modules/@aurelia/router/dist/esm/router-options.js");



/**
 * @internal - Shouldn't be used directly
 */
var ParametersType;
(function (ParametersType) {
    ParametersType["none"] = "none";
    ParametersType["string"] = "string";
    ParametersType["array"] = "array";
    ParametersType["object"] = "object";
})(ParametersType || (ParametersType = {}));
/**
 * Public API - The viewport instructions are the core of the router's navigations
 */
class ViewportInstruction {
    constructor() {
        this.componentName = null;
        this.componentType = null;
        this.componentInstance = null;
        this.viewportName = null;
        this.viewport = null;
        this.parametersString = null;
        this.parametersRecord = null;
        this.parametersList = null;
        this.parametersType = "none" /* none */;
        this.ownsScope = true;
        this.nextScopeInstructions = null;
        this.scope = null;
        this.context = '';
        this.viewportScope = null;
        this.needsViewportDescribed = false;
        this.route = null;
        this.default = false;
        this.topInstruction = false;
        this.instructionResolver = null;
    }
    // public constructor(
    //   component: ComponentAppellation,
    //   viewport?: ViewportHandle,
    //   parameters?: ComponentParameters,
    //   public ownsScope: boolean = true,
    //   public nextScopeInstructions: ViewportInstruction[] | null = null,
    // ) {
    //   this.setComponent(component);
    //   this.setViewport(viewport);
    //   this.setParameters(parameters);
    // }
    static create(instructionResolver, component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
        // if (component instanceof Promise) {
        //   return component.then((resolvedComponent) => {
        //     return ViewportInstruction.create(instructionResolver, resolvedComponent, viewport, parameters, ownsScope, nextScopeInstructions);
        //   });
        // }
        const instruction = new ViewportInstruction();
        instruction.setComponent(component);
        instruction.setViewport(viewport);
        instruction.setParameters(parameters);
        instruction.ownsScope = ownsScope;
        instruction.nextScopeInstructions = nextScopeInstructions;
        instruction.setInstructionResolver(instructionResolver);
        return instruction;
    }
    get owner() {
        return this.viewport ?? this.viewportScope ?? null;
    }
    get typedParameters() {
        switch (this.parametersType) {
            case "string" /* string */:
                return this.parametersString;
            case "array" /* array */:
                return this.parametersList;
            case "object" /* object */:
                return this.parametersRecord;
            default:
                return null;
        }
    }
    get parameters() {
        if (this.instructionResolver !== null) {
            return this.instructionResolver.parseComponentParameters(this.typedParameters);
        }
        return [];
    }
    get normalizedParameters() {
        if (this.instructionResolver !== null && this.typedParameters !== null) {
            return this.instructionResolver.stringifyComponentParameters(this.parameters);
        }
        return '';
    }
    setComponent(component) {
        if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.isName(component)) {
            this.componentName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getName(component);
            this.componentType = null;
            this.componentInstance = null;
        }
        else if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.isType(component)) {
            this.componentName = this.getNewName(component);
            this.componentType = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getType(component);
            this.componentInstance = null;
        }
        else if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.isInstance(component)) {
            this.componentName = this.getNewName(_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getType(component));
            this.componentType = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getType(component);
            this.componentInstance = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getInstance(component);
        }
    }
    setViewport(viewport) {
        if (viewport === undefined || viewport === '') {
            viewport = null;
        }
        if (typeof viewport === 'string') {
            this.viewportName = viewport;
            this.viewport = null;
        }
        else {
            this.viewport = viewport;
            if (viewport !== null) {
                this.viewportName = viewport.name;
                this.scope = viewport.owningScope;
            }
        }
    }
    setParameters(parameters) {
        if (parameters === undefined || parameters === null || parameters === '') {
            this.parametersType = "none" /* none */;
            parameters = null;
        }
        else if (typeof parameters === 'string') {
            this.parametersType = "string" /* string */;
            this.parametersString = parameters;
        }
        else if (Array.isArray(parameters)) {
            this.parametersType = "array" /* array */;
            this.parametersList = parameters;
        }
        else {
            this.parametersType = "object" /* object */;
            this.parametersRecord = parameters;
        }
    }
    // This only works with objects added to objects!
    addParameters(parameters) {
        if (this.parametersType === "none" /* none */) {
            return this.setParameters(parameters);
        }
        if (this.parametersType !== "object" /* object */) {
            throw new Error('Can\'t add object parameters to existing non-object parameters!');
        }
        this.setParameters({ ...this.parametersRecord, ...parameters });
    }
    setInstructionResolver(instructionResolver) {
        this.instructionResolver = instructionResolver;
    }
    isEmpty() {
        return !this.isComponentName() && !this.isComponentType() && !this.isComponentInstance();
    }
    isComponentName() {
        return !!this.componentName && !this.isComponentType() && !this.isComponentInstance();
    }
    isComponentType() {
        return this.componentType !== null && !this.isComponentInstance();
    }
    isComponentInstance() {
        return this.componentInstance !== null;
    }
    toComponentType(container) {
        if (this.componentType !== null) {
            return this.componentType;
        }
        if (this.componentName !== null
            && typeof this.componentName === 'string'
            && container !== null
            && container.has(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.keyFrom(this.componentName), true)) {
            const resolver = container.getResolver(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.keyFrom(this.componentName));
            if (resolver !== null && resolver.getFactory !== void 0) {
                const factory = resolver.getFactory(container);
                if (factory) {
                    return factory.Type;
                }
            }
        }
        return null;
    }
    toComponentInstance(container) {
        if (this.componentInstance !== null) {
            return this.componentInstance;
        }
        if (container !== void 0 && container !== null) {
            const instance = this.isComponentType()
                ? container.get(this.componentType)
                : container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.keyFrom(this.componentName));
            if (this.isComponentType() &&
                !(instance instanceof this.componentType)) {
                console.warn('Failed to instantiate', this.componentType, instance);
            }
            return instance ?? null;
        }
        return null;
    }
    toViewportInstance(router) {
        if (this.viewport !== null) {
            return this.viewport;
        }
        return router.getViewport(this.viewportName);
    }
    toSpecifiedParameters(specifications) {
        specifications = specifications || [];
        const parameters = this.parameters;
        const specified = {};
        for (const spec of specifications) {
            // First get named if it exists
            let index = parameters.findIndex(param => param.key === spec);
            if (index >= 0) {
                const [parameter] = parameters.splice(index, 1);
                specified[spec] = parameter.value;
            }
            else {
                // Otherwise get first unnamed
                index = parameters.findIndex(param => param.key === void 0);
                if (index >= 0) {
                    const [parameter] = parameters.splice(index, 1);
                    specified[spec] = parameter.value;
                }
            }
        }
        // Add all remaining named
        for (const parameter of parameters.filter(param => param.key !== void 0)) {
            specified[parameter.key] = parameter.value;
        }
        let index = specifications.length;
        // Add all remaining unnamed...
        for (const parameter of parameters.filter(param => param.key === void 0)) {
            // ..with an index
            specified[index++] = parameter.value;
        }
        return specified;
    }
    toSortedParameters(specifications) {
        specifications = specifications || [];
        const parameters = this.parameters;
        const sorted = [];
        for (const spec of specifications) {
            // First get named if it exists
            let index = parameters.findIndex(param => param.key === spec);
            if (index >= 0) {
                const parameter = { ...parameters.splice(index, 1)[0] };
                parameter.key = void 0;
                sorted.push(parameter);
            }
            else {
                // Otherwise get first unnamed
                index = parameters.findIndex(param => param.key === void 0);
                if (index >= 0) {
                    const parameter = { ...parameters.splice(index, 1)[0] };
                    sorted.push(parameter);
                }
                else {
                    // Or an empty
                    sorted.push({ value: void 0 });
                }
            }
        }
        // Add all remaining named
        const params = parameters.filter(param => param.key !== void 0);
        params.sort((a, b) => (a.key || '') < (b.key || '') ? 1 : (b.key || '') < (a.key || '') ? -1 : 0);
        sorted.push(...params);
        // Add all remaining unnamed...
        sorted.push(...parameters.filter(param => param.key === void 0));
        return sorted;
    }
    sameComponent(other, compareParameters = false, compareType = false) {
        if (compareParameters && !this.sameParameters(other, compareType)) {
            return false;
        }
        return compareType ? this.componentType === other.componentType : this.componentName === other.componentName;
    }
    // TODO: Somewhere we need to check for format such as spaces etc
    sameParameters(other, compareType = false) {
        if (!this.sameComponent(other, false, compareType)) {
            return false;
        }
        const typeParameters = this.componentType ? this.componentType.parameters : [];
        const mine = this.toSpecifiedParameters(typeParameters);
        const others = other.toSpecifiedParameters(typeParameters);
        return Object.keys(mine).every(key => mine[key] === others[key])
            && Object.keys(others).every(key => others[key] === mine[key]);
    }
    sameViewport(other) {
        if (this.viewport !== null && other.viewport !== null) {
            return this.viewport === other.viewport;
        }
        return this.scope === other.scope &&
            (this.viewport ? this.viewport.name : this.viewportName) === (other.viewport ? other.viewport.name : other.viewportName);
    }
    getNewName(type) {
        if (this.componentName === null
        // || !type.aliases?.includes(this.componentName)
        ) {
            return _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getName(type);
        }
        return this.componentName;
    }
}
ViewportInstruction.inject = [_router_options_js__WEBPACK_IMPORTED_MODULE_2__.RouterOptions];
//# sourceMappingURL=viewport-instruction.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport-scope.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport-scope.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewportScope": () => /* binding */ ViewportScope
/* harmony export */ });
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scope.js */ "./node_modules/@aurelia/router/dist/esm/scope.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");



class ViewportScope {
    constructor(name, router, connectedCE, owningScope, scope, rootComponentType = null, // temporary. Metadata will probably eliminate it
    options = {
        catches: [],
        source: null,
    }) {
        this.name = name;
        this.router = router;
        this.connectedCE = connectedCE;
        this.rootComponentType = rootComponentType;
        this.options = options;
        this.path = null;
        this.content = null;
        this.nextContent = null;
        this.available = true;
        this.sourceItem = null;
        this.sourceItemIndex = -1;
        this.remove = false;
        this.add = false;
        this.connectedScope = new _scope_js__WEBPACK_IMPORTED_MODULE_0__.Scope(router, scope, owningScope, null, this);
        if (this.catches.length > 0) {
            this.content = router.createViewportInstruction(this.catches[0], this.name);
        }
    }
    get scope() {
        return this.connectedScope.scope;
    }
    get owningScope() {
        return this.connectedScope.owningScope;
    }
    get enabled() {
        return this.connectedScope.enabled;
    }
    set enabled(enabled) {
        this.connectedScope.enabled = enabled;
    }
    get isViewport() {
        return false;
    }
    get isViewportScope() {
        return true;
    }
    get isEmpty() {
        return this.content === null;
    }
    get passThroughScope() {
        return this.rootComponentType === null && this.catches.length === 0;
    }
    get siblings() {
        const parent = this.connectedScope.parent;
        if (parent === null) {
            return [this];
        }
        return parent.enabledChildren
            .filter(child => child.isViewportScope && child.viewportScope.name === this.name)
            .map(child => child.viewportScope);
    }
    get source() {
        return this.options.source || null;
    }
    get catches() {
        let catches = this.options.catches || [];
        if (typeof catches === 'string') {
            catches = catches.split(',');
        }
        return catches;
    }
    get default() {
        if (this.catches.length > 0) {
            return this.catches[0];
        }
    }
    get nextContentActivated() {
        return this.scope.parent?.owner?.nextContentActivated ?? false;
    }
    get parentNextContentActivated() {
        return this.scope.parent?.owner?.nextContentActivated ?? false;
    }
    get nextContentAction() {
        return '';
    }
    toString() {
        const contentName = this.content?.componentName ?? '';
        const nextContentName = this.nextContent?.componentName ?? '';
        return `vs:${this.name}[${contentName}->${nextContentName}]`;
    }
    setNextContent(viewportInstruction, navigation) {
        viewportInstruction.viewportScope = this;
        this.remove = this.router.instructionResolver.isClearViewportInstruction(viewportInstruction)
            || this.router.instructionResolver.isClearAllViewportsInstruction(viewportInstruction);
        this.add = this.router.instructionResolver.isAddViewportInstruction(viewportInstruction)
            && Array.isArray(this.source);
        if (this.add) {
            viewportInstruction.componentName = null;
        }
        if (this.default !== void 0 && viewportInstruction.componentName === null) {
            viewportInstruction.componentName = this.default;
        }
        this.nextContent = viewportInstruction;
        return 'swap';
    }
    transition(coordinator) {
        // console.log('ViewportScope swap'/*, this, coordinator*/);
        _runner_js__WEBPACK_IMPORTED_MODULE_2__.Runner.run(() => coordinator.addEntityState(this, 'guardedUnload'), () => coordinator.addEntityState(this, 'guardedLoad'), () => coordinator.addEntityState(this, 'guarded'), () => coordinator.addEntityState(this, 'loaded'), () => coordinator.addEntityState(this, 'unloaded'), () => coordinator.addEntityState(this, 'routed'), () => coordinator.addEntityState(this, 'swapped'), () => {
            this.content = !this.remove ? this.nextContent : null;
            this.nextContent = null;
            coordinator.addEntityState(this, 'completed');
        });
    }
    canUnload() {
        return true;
    }
    canLoad() {
        return true;
    }
    unload() {
        return;
    }
    load() {
        return;
    }
    // public loadContent(): Promise<boolean> {
    //   this.content = !this.remove ? this.nextContent : null;
    //   this.nextContent = null;
    //   return Promise.resolve(true);
    // }
    finalizeContentChange() {
        // console.log('ViewportScope finalizing', this.content);
        if (this.remove && Array.isArray(this.source)) {
            this.removeSourceItem();
        }
    }
    abortContentChange() {
        this.nextContent = null;
        if (this.add) {
            const index = this.source.indexOf(this.sourceItem);
            this.source.splice(index, 1);
            this.sourceItem = null;
        }
        return Promise.resolve();
    }
    acceptSegment(segment) {
        if (segment === null && segment === void 0 || segment.length === 0) {
            return true;
        }
        if (segment === this.router.instructionResolver.clearViewportInstruction
            || segment === this.router.instructionResolver.addViewportInstruction
            || segment === this.name) {
            return true;
        }
        if (this.catches.length === 0) {
            return true;
        }
        if (this.catches.includes(segment)) {
            return true;
        }
        if (this.catches.filter((value) => value.includes('*')).length) {
            return true;
        }
        return false;
    }
    binding() {
        const source = this.source || [];
        if (source.length > 0 && this.sourceItem === null) {
            this.sourceItem = this.getAvailableSourceItem();
        }
    }
    unbinding() {
        if (this.sourceItem !== null && this.source !== null) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.arrayRemove)(this.source, (item) => item === this.sourceItem);
        }
        this.sourceItem = null;
    }
    getAvailableSourceItem() {
        if (this.source === null) {
            return null;
        }
        const siblings = this.siblings;
        for (const item of this.source) {
            if (siblings.every(sibling => sibling.sourceItem !== item)) {
                return item;
            }
        }
        return null;
    }
    addSourceItem() {
        const item = {};
        this.source.push(item);
        return item;
    }
    removeSourceItem() {
        this.sourceItemIndex = this.source.indexOf(this.sourceItem);
        if (this.sourceItemIndex >= 0) {
            this.source.splice(this.sourceItemIndex, 1);
        }
    }
    getRoutes() {
        if (this.rootComponentType !== null) {
            return this.rootComponentType.routes;
        }
        return null;
    }
}
//# sourceMappingURL=viewport-scope.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Viewport": () => /* binding */ Viewport
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewport-content.js */ "./node_modules/@aurelia/router/dist/esm/viewport-content.js");
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scope.js */ "./node_modules/@aurelia/router/dist/esm/scope.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");





class Viewport {
    constructor(router, name, connectedCE, owningScope, scope, options = {}) {
        this.router = router;
        this.name = name;
        this.connectedCE = connectedCE;
        this.options = options;
        this.nextContent = null;
        this.nextContentAction = '';
        this.forceRemove = false;
        this.path = null;
        this.clear = false;
        this.connectionResolve = null;
        this.previousViewportState = null;
        this.cache = [];
        this.historyCache = [];
        this.content = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent();
        this.connectedScope = new _scope_js__WEBPACK_IMPORTED_MODULE_3__.Scope(router, scope, owningScope, this);
    }
    get scope() {
        return this.connectedScope.scope;
    }
    get owningScope() {
        return this.connectedScope.owningScope;
    }
    get connectedController() {
        return this.connectedCE?.$controller ?? null;
    }
    get enabled() {
        return this.connectedScope.enabled;
    }
    set enabled(enabled) {
        this.connectedScope.enabled = enabled;
    }
    get isViewport() {
        return true;
    }
    get isViewportScope() {
        return false;
    }
    get isEmpty() {
        return this.content.componentInstance === null;
    }
    get doForceRemove() {
        let scope = this.connectedScope;
        while (scope !== null) {
            if (scope.viewport !== null && scope.viewport.forceRemove) {
                return true;
            }
            scope = scope.parent;
        }
        return false;
    }
    get activeContent() {
        return this.nextContent ?? this.content;
    }
    get nextContentActivated() {
        return this.nextContent?.contentStates.has('activated') ?? false;
    }
    get parentNextContentActivated() {
        return this.scope.parent?.owner?.nextContentActivated ?? false;
    }
    get performLoad() {
        return true;
        // return this.nextContentAction !== 'skip' && this.connectedScope.parentNextContentAction !== 'swap';
        // // return this.nextContentAction !== 'skip' && ((this.nextContent?.content.topInstruction ?? false) || this.clear);
    }
    get performSwap() {
        return true;
        // return this.nextContentAction !== 'skip' && this.connectedScope.parentNextContentAction !== 'swap';
        // // return this.nextContentAction !== 'skip' && ((this.nextContent?.content.topInstruction ?? false) || this.clear);
    }
    toString() {
        const contentName = this.content?.content.componentName ?? '';
        const nextContentName = this.nextContent?.content.componentName ?? '';
        return `v:${this.name}[${contentName}->${nextContentName}]`;
    }
    setNextContent(viewportInstruction, navigation) {
        viewportInstruction.setViewport(this);
        this.clear = this.router.instructionResolver.isClearViewportInstruction(viewportInstruction);
        // Can have a (resolved) type or a string (to be resolved later)
        this.nextContent = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent(!this.clear ? viewportInstruction : void 0, navigation, this.connectedCE ?? null);
        this.nextContent.fromHistory = this.nextContent.componentInstance && navigation.navigation
            ? !!navigation.navigation.back || !!navigation.navigation.forward
            : false;
        if (this.options.stateful) {
            // TODO: Add a parameter here to decide required equality
            const cached = this.cache.find((item) => this.nextContent.isCacheEqual(item));
            if (cached) {
                this.nextContent = cached;
                this.nextContent.fromCache = true;
            }
            else {
                this.cache.push(this.nextContent);
            }
        }
        // Children that will be replaced (unless added again) by next content. Will
        // be re-enabled on cancel
        this.connectedScope.clearReplacedChildren();
        // If we get the same _instance_, don't do anything (happens with cached and history)
        if (this.nextContent.componentInstance !== null && this.content.componentInstance === this.nextContent.componentInstance) {
            this.nextContent = null;
            return this.nextContentAction = 'skip'; // false;
        }
        if (!this.content.equalComponent(this.nextContent) ||
            this.connectedScope.parentNextContentAction === 'swap' || // Some parent has been swapped, need to be new component
            navigation.navigation.refresh || // Navigation 'refresh' performed
            this.content.reentryBehavior() === "refresh" /* refresh */ // ReentryBehavior 'refresh' takes precedence
        ) {
            this.connectedScope.disableReplacedChildren();
            return this.nextContentAction = 'swap'; // true;
        }
        // Component is the same name/type
        // Explicitly don't allow navigation back to the same component again
        if (this.content.reentryBehavior() === "disallow" /* disallow */) {
            this.nextContent = null;
            return this.nextContentAction = 'skip'; // false;
        }
        // Explicitly re-load same component again
        if (this.content.reentryBehavior() === "load" /* load */) {
            this.content.reentry = true;
            this.nextContent.content.setComponent(this.content.componentInstance);
            // this.nextContent.contentStatus = this.content.contentStatus;
            this.nextContent.contentStates = this.content.contentStates.clone();
            // this.nextContent.contentStates = new Map(this.content.contentStates);
            this.nextContent.reentry = this.content.reentry;
            return this.nextContentAction = 'reload'; // true;
        }
        // ReentryBehavior is now 'default'
        // Requires updated parameters if viewport stateful
        if (this.options.stateful &&
            this.content.equalParameters(this.nextContent)) {
            this.nextContent = null;
            return this.nextContentAction = 'skip'; // false;
        }
        if (!this.content.equalParameters(this.nextContent)) {
            // TODO: Fix a config option for this
            // eslint-disable-next-line no-constant-condition
            if (false) {}
            else { // Perform a full swap
                this.connectedScope.disableReplacedChildren();
                return this.nextContentAction = 'swap';
            }
        }
        // Default is to do nothing
        return 'skip';
        // // Default is to trigger a refresh (without a check of parameters)
        // this.connectedScope.disableReplacedChildren();
        // return this.nextContentAction = 'reload'; // true;
    }
    setConnectedCE(connectedCE, options) {
        options = options || {};
        if (this.connectedCE !== connectedCE) {
            // TODO: Restore this state on navigation cancel
            this.previousViewportState = { ...this };
            this.clearState();
            this.connectedCE = connectedCE;
            if (options.usedBy) {
                this.options.usedBy = options.usedBy;
            }
            if (options.default) {
                this.options.default = options.default;
            }
            if (options.fallback) {
                this.options.fallback = options.fallback;
            }
            if (options.noLink) {
                this.options.noLink = options.noLink;
            }
            if (options.noTitle) {
                this.options.noTitle = options.noTitle;
            }
            if (options.noHistory) {
                this.options.noHistory = options.noHistory;
            }
            if (options.stateful) {
                this.options.stateful = options.stateful;
            }
            if (this.connectionResolve) {
                this.connectionResolve();
            }
        }
        // TODO: Might not need this? Figure it out
        // if (container) {
        //   container['viewportName'] = this.name;
        // }
        if (!this.content.componentInstance && (!this.nextContent || !this.nextContent.componentInstance) && this.options.default) {
            const instructions = this.router.instructionResolver.parseViewportInstructions(this.options.default);
            for (const instruction of instructions) {
                // Set to name to be delayed one turn
                instruction.setViewport(this.name);
                instruction.scope = this.owningScope;
                instruction.default = true;
            }
            this.router.load(instructions, { append: true }).catch(error => { throw error; });
        }
    }
    remove(connectedCE) {
        if (this.connectedCE === connectedCE) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => {
                if (this.content.componentInstance) {
                    return this.content.freeContent(this.connectedCE, (this.nextContent ? this.nextContent.instruction : null), this.historyCache, this.doForceRemove ? false : this.router.statefulHistory || this.options.stateful); // .catch(error => { throw error; });
                }
            }, () => {
                if (this.doForceRemove) {
                    const removes = [];
                    for (const content of this.historyCache) {
                        removes.push(() => content.freeContent(null, null, this.historyCache, false));
                    }
                    removes.push(() => { this.historyCache = []; });
                    return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(...removes);
                    // return Promise.all(this.historyCache.map(content => content.freeContent(
                    //   null,
                    //   null,
                    //   this.historyCache,
                    //   false,
                    // )));
                    // this.historyCache = [];
                }
                return true;
            });
        }
        return false;
    }
    transition(coordinator) {
        // console.log('Viewport transition', this.toString());
        // let run: unknown;
        const guarded = coordinator.checkingSyncState('guarded');
        const performLoad = this.performLoad || !guarded;
        const performSwap = this.performSwap || !guarded;
        // const performSwap = this.performSwap || !this.router.isRestrictedNavigation || this.clear;
        const guardSteps = [
            () => performLoad ? this.canUnload() : true,
            (canUnloadResult) => {
                if (!canUnloadResult) {
                    _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.cancel(void 0);
                    coordinator.cancel();
                    return;
                }
                if (this.router.isRestrictedNavigation) {
                    this.nextContent.createComponent(this.connectedCE, this.options.fallback);
                }
                coordinator.addEntityState(this, 'guardedUnload');
            },
            () => coordinator.syncState('guardedUnload', this),
            () => performLoad ? this.canLoad(guarded) : true,
            (canLoadResult) => {
                if (typeof canLoadResult === 'boolean') {
                    if (!canLoadResult) {
                        _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.cancel(void 0);
                        coordinator.cancel();
                        return;
                    }
                    coordinator.addEntityState(this, 'guardedLoad');
                    coordinator.addEntityState(this, 'guarded');
                }
                else { // Denied and (probably) redirected
                    _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.router.load(canLoadResult, { append: true }), () => this.abortContentChange());
                }
            },
        ];
        const routingSteps = [
            // () => { console.log("I'm waiting for guarded", this.toString()); },
            () => coordinator.syncState('guarded', this),
            // () => { console.log("I'm guarded", this.toString()); },
            // TODO: For consistency it should probably be this option with 'routed'
            // () => performSwap ? this.unload(coordinator.checkingSyncState('routed')) : true,
            () => performLoad ? this.unload(true) : true,
            () => coordinator.addEntityState(this, 'unloaded'),
            // () => { console.log("I'm waiting for unloaded", this.toString()); },
            () => coordinator.syncState('unloaded', this),
            // () => { console.log("I'm done waiting for unloaded", this.toString()); },
            () => performLoad ? this.load(coordinator.checkingSyncState('routed')) : true,
            () => coordinator.addEntityState(this, 'loaded'),
            () => coordinator.addEntityState(this, 'routed'),
        ];
        const lifecycleSteps = [
            () => coordinator.syncState('routed', this),
        ];
        if (performSwap) {
            if (this.router.options.swapStrategy.includes('parallel')) {
                lifecycleSteps.push(() => {
                    if (this.router.options.swapStrategy.includes('add')) {
                        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(this.addContent(), this.removeContent());
                    }
                    else {
                        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(this.removeContent(), this.addContent());
                    }
                });
            }
            else {
                lifecycleSteps.push(() => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.addContent() : this.removeContent()) : void 0, () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.removeContent() : this.addContent()) : void 0);
            }
        }
        lifecycleSteps.push(() => coordinator.addEntityState(this, 'swapped'));
        // const lifecycleSteps = [
        //   () => coordinator.syncState('routed'),
        //   // () => coordinator.addEntityState(this, 'bound'),
        //   () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.addContent() : this.removeContent()) : true,
        //   () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.removeContent() : this.addContent()) : true,
        //   () => coordinator.addEntityState(this, 'swapped'),
        // ];
        // run =
        _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(...guardSteps, ...routingSteps, ...lifecycleSteps, () => coordinator.addEntityState(this, 'completed'));
    }
    canUnload() {
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => {
            // console.log('viewport canUnload run', this.name, 'before');
            const result = this.connectedScope.canUnload();
            // console.log('viewport canUnload run', this.name, 'after');
            return result;
        }, (canUnloadChildren) => {
            // console.log('viewport canUnload result', this.name, canUnloadChildren);
            if (!canUnloadChildren) {
                return false;
            }
            // This shouldn't happen
            // // Don't stop it because we're not going to actually do anything
            // if (this.content.componentInstance === this.nextContent?.componentInstance) {
            //   return true;
            // }
            return this.content.canUnload(this.nextContent?.instruction ?? null);
        });
    }
    canLoad(recurse) {
        // console.log(this.connectedScope.toString(), 'viewport content canLoad', this.nextContent?.content?.componentName);
        if (this.clear) {
            return true;
        }
        if ((this.nextContent?.content ?? null) === null) {
            return true;
        }
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.waitForConnected(), () => {
            this.nextContent.createComponent(this.connectedCE, this.options.fallback);
            // This shouldn't happen
            // // Don't stop it because we're not going to actually do anything
            // if (this.content.componentInstance === this.nextContent!.componentInstance) {
            //   return true;
            // }
            return this.nextContent.canLoad(this, this.content.instruction);
        });
    }
    load(recurse) {
        // console.log(this.connectedScope.toString(), 'viewport content load', this.nextContent?.content?.componentName);
        if (this.clear || (this.nextContent?.componentInstance ?? null) === null) {
            return;
        }
        // This shouldn't happen
        // // TODO: Verify this
        // if (this.nextContent === this.content) {
        //   return;
        // }
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.nextContent?.load(this.content.instruction));
        // return this.nextContent?.load(this.content.instruction);
        // await this.nextContent.activateComponent(null, this.connectedCE!.$controller as ICustomElementController<ICustomElementViewModel>, LifecycleFlags.none, this.connectedCE!);
        // return true;
    }
    addContent() {
        // console.log('addContent', this.toString());
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.activate(null, this.connectedController, 0 /* none */, this.parentNextContentActivated));
    }
    removeContent() {
        if (this.isEmpty) {
            return;
        }
        // console.log('removeContent', this.toString());
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.connectedScope.removeContent(), () => this.deactivate(null, null /* TODO: verify this.connectedController */, 0 /* none */), () => this.dispose());
    }
    removeChildrenContent() {
        // console.log(this.name, 'removeContent', this.content.content);
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => !this.isEmpty ? this.connectedScope.removeContent() : void 0);
    }
    activate(initiator, parent, flags, fromParent) {
        // console.log('activate' /* , { ...this } */);
        if (this.activeContent.componentInstance !== null) {
            this.connectedScope.reenableReplacedChildren();
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.activeContent.load(this.activeContent.instruction), // Only acts if not already loaded
            () => this.activeContent.activateComponent(initiator, parent, flags, this.connectedCE, fromParent));
        }
    }
    deactivate(initiator, parent, flags) {
        if (this.content.componentInstance &&
            !this.content.reentry &&
            this.content.componentInstance !== this.nextContent?.componentInstance) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.content?.unload(this.content.instruction), // Only acts if not already unloaded
            () => this.content?.deactivateComponent(initiator, parent, flags, this.connectedCE, this.router.statefulHistory || this.options.stateful));
        }
    }
    unload(recurse) {
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => recurse ? this.connectedScope.unload(recurse) : true, () => {
            // console.log(this.connectedScope.toString(), 'viewport content unload', this.content.content.componentName);
            // This shouldn't happen
            // // TODO: Verify this
            // if (this.nextContent === this.content) {
            //   return;
            // }
            if (this.content.componentInstance) {
                return this.content.unload(this.nextContent?.instruction ?? null);
            }
        });
    }
    dispose() {
        if (this.content.componentInstance &&
            !this.content.reentry &&
            this.content.componentInstance !== this.nextContent?.componentInstance) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(
            // () => this.content!.unloadComponent(
            //   this.historyCache,
            //   this.router.statefulHistory || this.options.stateful),
            // () => this.content!.destroyComponent(),
            () => this.content.disposeComponent(this.connectedCE, this.historyCache, this.router.statefulHistory || this.options.stateful));
            // await this.content!.freeContent(
            //   this.connectedCE,
            //   this.nextContent!.instruction,
            //   this.historyCache,
            //   this.router.statefulHistory || this.options.stateful);
        }
    }
    finalizeContentChange() {
        // console.log('finalizeContent', this.nextContent!.content?.componentName);
        if (this.nextContent.componentInstance) {
            this.content = this.nextContent;
            this.content.reentry = false;
        }
        if (this.clear) {
            this.content = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent(void 0, this.nextContent.instruction);
        }
        this.nextContent = null;
        this.nextContentAction = '';
        this.previousViewportState = null;
        this.connectedScope.clearReplacedChildren();
    }
    abortContentChange() {
        this.connectedScope.reenableReplacedChildren();
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.nextContent.freeContent(this.connectedCE, this.nextContent.instruction, this.historyCache, this.router.statefulHistory || this.options.stateful), () => {
            if (this.previousViewportState) {
                Object.assign(this, this.previousViewportState);
            }
            this.nextContentAction = '';
        });
    }
    // TODO: Deal with non-string components
    wantComponent(component) {
        let usedBy = this.options.usedBy || [];
        if (typeof usedBy === 'string') {
            usedBy = usedBy.split(',');
        }
        return usedBy.includes(component);
    }
    // TODO: Deal with non-string components
    acceptComponent(component) {
        if (component === '-' || component === null) {
            return true;
        }
        let usedBy = this.options.usedBy;
        if (!usedBy || !usedBy.length) {
            return true;
        }
        if (typeof usedBy === 'string') {
            usedBy = usedBy.split(',');
        }
        if (usedBy.includes(component)) {
            return true;
        }
        if (usedBy.filter((value) => value.includes('*')).length) {
            return true;
        }
        return false;
    }
    freeContent(component) {
        const content = this.historyCache.find(cached => cached.componentInstance === component);
        if (content !== void 0) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => {
                this.forceRemove = true;
                return content.freeContent(null, null, this.historyCache, false);
            }, () => {
                this.forceRemove = false;
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.arrayRemove)(this.historyCache, (cached => cached === content));
            });
        }
    }
    getRoutes() {
        const componentType = this.getComponentType();
        if (componentType === null) {
            return null;
        }
        const routes = componentType.routes;
        return Array.isArray(routes) ? routes : null;
    }
    getTitle(navigationInstruction) {
        if (this.options.noTitle) {
            return '';
        }
        const componentType = this.getComponentType();
        if (componentType === null) {
            return '';
        }
        let title = '';
        const typeTitle = componentType.title;
        if (typeTitle !== void 0) {
            if (typeof typeTitle === 'string') {
                title = typeTitle;
            }
            else {
                const component = this.getComponentInstance();
                title = typeTitle.call(component, component, navigationInstruction);
            }
        }
        else if (this.router.options.title.useComponentNames) {
            let name = this.getContentInstruction().componentName ?? '';
            const prefix = this.router.options.title.componentPrefix ?? '';
            if (name.startsWith(prefix)) {
                name = name.slice(prefix.length);
            }
            name = name.replace('-', ' ');
            title = name.slice(0, 1).toLocaleUpperCase() + name.slice(1);
        }
        if (this.router.options.title.transformTitle !== void 0) {
            title = this.router.options.title.transformTitle.call(this, title, this.getContentInstruction());
        }
        return title;
    }
    getComponentType() {
        let componentType = this.getContentInstruction().componentType ?? null;
        // TODO: This is going away once Metadata is in!
        if (componentType === null) {
            const controller = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.for(this.connectedCE.element);
            componentType = controller.context
                .componentType;
        }
        return componentType ?? null;
    }
    getComponentInstance() {
        return this.getContentInstruction().componentInstance ?? null;
    }
    getContentInstruction() {
        return this.nextContent?.content ?? this.content.content ?? null;
    }
    clearState() {
        this.options = {};
        this.content = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent();
        this.cache = [];
    }
    waitForConnected() {
        if (this.connectedCE === null) {
            return new Promise((resolve) => {
                this.connectionResolve = resolve;
            });
        }
    }
}
//# sourceMappingURL=viewport.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/app-root.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAppRoot": () => /* binding */ IAppRoot,
/* harmony export */   "AppRoot": () => /* binding */ AppRoot
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _app_task_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-task.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");





const IAppRoot = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAppRoot');
class AppRoot {
    constructor(config, platform, container, rootProvider, enhance = false) {
        this.config = config;
        this.platform = platform;
        this.container = container;
        this.controller = (void 0);
        this.hydratePromise = void 0;
        this.host = config.host;
        rootProvider.prepare(this);
        if (container.has(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode, false) && container.get(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode) !== config.host) {
            this.container = container.createChild();
        }
        this.container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode, config.host));
        if (enhance) {
            const component = config.component;
            this.enhanceDefinition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.getDefinition(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.isType(component)
                ? _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.define({ ..._resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.getDefinition(component), template: this.host, enhance: true }, component)
                : _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.define({ name: (void 0), template: this.host, enhance: true }));
        }
        this.hydratePromise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('beforeCreate'), () => {
            const instance = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.isType(config.component)
                ? this.container.get(config.component)
                : config.component;
            const controller = (this.controller = _templating_controller_js__WEBPACK_IMPORTED_MODULE_4__.Controller.forCustomElement(this, container, instance, this.host, null, 0 /* none */, false, this.enhanceDefinition));
            controller.hydrateCustomElement(container, null);
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('hydrating'), () => {
                controller.hydrate(null);
                return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('hydrated'), () => {
                    controller.hydrateChildren();
                    this.hydratePromise = void 0;
                });
            });
        });
    }
    activate() {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.hydratePromise, () => {
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('beforeActivate'), () => {
                return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.controller.activate(this.controller, null, 32 /* fromBind */, void 0), () => {
                    return this.runAppTasks('afterActivate');
                });
            });
        });
    }
    deactivate() {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('beforeDeactivate'), () => {
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.controller.deactivate(this.controller, null, 0 /* none */), () => {
                return this.runAppTasks('afterDeactivate');
            });
        });
    }
    /** @internal */
    runAppTasks(slot) {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.resolveAll)(...this.container.getAll(_app_task_js__WEBPACK_IMPORTED_MODULE_2__.IAppTask).reduce((results, task) => {
            if (task.slot === slot) {
                results.push(task.run());
            }
            return results;
        }, []));
    }
    dispose() {
        this.controller?.dispose();
    }
}
//# sourceMappingURL=app-root.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/app-task.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAppTask": () => /* binding */ IAppTask,
/* harmony export */   "AppTask": () => /* binding */ AppTask
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const IAppTask = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAppTask');
class $AppTask {
    constructor(key) {
        this.key = key;
        this.slot = (void 0);
        this.callback = (void 0);
        this.container = (void 0);
    }
    static with(key) {
        return new $AppTask(key);
    }
    beforeCreate() {
        return this.at('beforeCreate');
    }
    hydrating() {
        return this.at('hydrating');
    }
    hydrated() {
        return this.at('hydrated');
    }
    beforeActivate() {
        return this.at('beforeActivate');
    }
    afterActivate() {
        return this.at('afterActivate');
    }
    beforeDeactivate() {
        return this.at('beforeDeactivate');
    }
    afterDeactivate() {
        return this.at('afterDeactivate');
    }
    at(slot) {
        this.slot = slot;
        return this;
    }
    call(fn) {
        this.callback = fn;
        return this;
    }
    register(container) {
        return this.container = container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IAppTask, this));
    }
    run() {
        const callback = this.callback;
        const instance = this.container.get(this.key);
        return callback(instance);
    }
}
const AppTask = $AppTask;
//# sourceMappingURL=app-task.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAttrSyntaxTransformer": () => /* binding */ IAttrSyntaxTransformer,
/* harmony export */   "AttrSyntaxTransformer": () => /* binding */ AttrSyntaxTransformer
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const IAttrSyntaxTransformer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAttrSyntaxTransformer', x => x.singleton(AttrSyntaxTransformer));
class AttrSyntaxTransformer {
    constructor() {
        /**
         * @internal
         */
        this.fns = [];
    }
    /**
     * Add a given function to a list of fns that will be used
     * to check if `'bind'` command can be transformed to `'two-way'` command.
     *
     * If one of those functions in this lists returns true, the `'bind'` command
     * will be transformed into `'two-way'` command.
     *
     * The function will be called with 2 parameters:
     * - element: the element that the template compiler is currently working with
     * - property: the target property name
     */
    useTwoWay(fn) {
        this.fns.push(fn);
    }
    /**
     * @internal
     */
    transform(node, attrSyntax) {
        if (attrSyntax.command === 'bind' &&
            (
            // note: even though target could possibly be mapped to a different name
            // the final property name shouldn't affect the two way transformation
            // as they both should work with original source attribute name
            shouldDefaultToTwoWay(node, attrSyntax.target) ||
                this.fns.length > 0 && this.fns.some(fn => fn(node, attrSyntax.target)))) {
            attrSyntax.command = 'two-way';
        }
        attrSyntax.target = this.map(node.tagName, attrSyntax.target);
    }
    /**
     * todo: this should be in the form of a lookup. the following is not extensible
     *
     * @internal
     */
    map(tagName, attr) {
        switch (tagName) {
            case 'LABEL':
                switch (attr) {
                    case 'for':
                        return 'htmlFor';
                    default:
                        return attr;
                }
            case 'IMG':
                switch (attr) {
                    case 'usemap':
                        return 'useMap';
                    default:
                        return attr;
                }
            case 'INPUT':
                switch (attr) {
                    case 'maxlength':
                        return 'maxLength';
                    case 'minlength':
                        return 'minLength';
                    case 'formaction':
                        return 'formAction';
                    case 'formenctype':
                        return 'formEncType';
                    case 'formmethod':
                        return 'formMethod';
                    case 'formnovalidate':
                        return 'formNoValidate';
                    case 'formtarget':
                        return 'formTarget';
                    case 'inputmode':
                        return 'inputMode';
                    default:
                        return attr;
                }
            case 'TEXTAREA':
                switch (attr) {
                    case 'maxlength':
                        return 'maxLength';
                    default:
                        return attr;
                }
            case 'TD':
            case 'TH':
                switch (attr) {
                    case 'rowspan':
                        return 'rowSpan';
                    case 'colspan':
                        return 'colSpan';
                    default:
                        return attr;
                }
            default:
                switch (attr) {
                    case 'accesskey':
                        return 'accessKey';
                    case 'contenteditable':
                        return 'contentEditable';
                    case 'tabindex':
                        return 'tabIndex';
                    case 'textcontent':
                        return 'textContent';
                    case 'innerhtml':
                        return 'innerHTML';
                    case 'scrolltop':
                        return 'scrollTop';
                    case 'scrollleft':
                        return 'scrollLeft';
                    case 'readonly':
                        return 'readOnly';
                    default:
                        return attr;
                }
        }
    }
}
function shouldDefaultToTwoWay(element, attr) {
    switch (element.tagName) {
        case 'INPUT':
            switch (element.type) {
                case 'checkbox':
                case 'radio':
                    return attr === 'checked';
                default:
                    return attr === 'value' || attr === 'files';
            }
        case 'TEXTAREA':
        case 'SELECT':
            return attr === 'value';
        default:
            switch (attr) {
                case 'textcontent':
                case 'innerhtml':
                    return element.hasAttribute('contenteditable');
                case 'scrolltop':
                case 'scrollleft':
                    return true;
                default:
                    return false;
            }
    }
}
//# sourceMappingURL=attribute-syntax-transformer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/aurelia.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/aurelia.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAurelia": () => /* binding */ IAurelia,
/* harmony export */   "Aurelia": () => /* binding */ Aurelia
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform-browser */ "./node_modules/@aurelia/platform-browser/dist/esm/index.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");




const IAurelia = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAurelia');
class Aurelia {
    constructor(container = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer()) {
        this.container = container;
        this._isRunning = false;
        this._isStarting = false;
        this._isStopping = false;
        this._root = void 0;
        this.next = void 0;
        this.startPromise = void 0;
        this.stopPromise = void 0;
        if (container.has(IAurelia, true)) {
            throw new Error('An instance of Aurelia is already registered with the container or an ancestor of it.');
        }
        container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IAurelia, this));
        container.registerResolver(_app_root_js__WEBPACK_IMPORTED_MODULE_2__.IAppRoot, this.rootProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IAppRoot'));
    }
    get isRunning() { return this._isRunning; }
    get isStarting() { return this._isStarting; }
    get isStopping() { return this._isStopping; }
    get root() {
        if (this._root == void 0) {
            if (this.next == void 0) {
                throw new Error(`root is not defined`); // TODO: create error code
            }
            return this.next;
        }
        return this._root;
    }
    register(...params) {
        this.container.register(...params);
        return this;
    }
    app(config) {
        this.next = new _app_root_js__WEBPACK_IMPORTED_MODULE_2__.AppRoot(config, this.initPlatform(config.host), this.container, this.rootProvider, false);
        return this;
    }
    enhance(config) {
        this.next = new _app_root_js__WEBPACK_IMPORTED_MODULE_2__.AppRoot(config, this.initPlatform(config.host), this.container, this.rootProvider, true);
        return this;
    }
    async waitForIdle() {
        const platform = this.root.platform;
        await platform.domWriteQueue.yield();
        await platform.domReadQueue.yield();
        await platform.macroTaskQueue.yield();
    }
    initPlatform(host) {
        let p;
        if (!this.container.has(_platform_js__WEBPACK_IMPORTED_MODULE_3__.IPlatform, false)) {
            if (host.ownerDocument.defaultView === null) {
                throw new Error(`Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView`);
            }
            p = new _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserPlatform(host.ownerDocument.defaultView);
            this.container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(_platform_js__WEBPACK_IMPORTED_MODULE_3__.IPlatform, p));
        }
        else {
            p = this.container.get(_platform_js__WEBPACK_IMPORTED_MODULE_3__.IPlatform);
        }
        return p;
    }
    start(root = this.next) {
        if (root == void 0) {
            throw new Error(`There is no composition root`);
        }
        if (this.startPromise instanceof Promise) {
            return this.startPromise;
        }
        return this.startPromise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.stop(), () => {
            Reflect.set(root.host, '$aurelia', this);
            this.rootProvider.prepare(this._root = root);
            this._isStarting = true;
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(root.activate(), () => {
                this._isRunning = true;
                this._isStarting = false;
                this.startPromise = void 0;
                this.dispatchEvent(root, 'au-started', root.host);
            });
        });
    }
    stop(dispose = false) {
        if (this.stopPromise instanceof Promise) {
            return this.stopPromise;
        }
        if (this._isRunning === true) {
            const root = this._root;
            this._isRunning = false;
            this._isStopping = true;
            return this.stopPromise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(root.deactivate(), () => {
                Reflect.deleteProperty(root.host, '$aurelia');
                if (dispose) {
                    root.dispose();
                }
                this._root = void 0;
                this.rootProvider.dispose();
                this._isStopping = false;
                this.dispatchEvent(root, 'au-stopped', root.host);
            });
        }
    }
    dispose() {
        if (this._isRunning || this._isStopping) {
            throw new Error(`The aurelia instance must be fully stopped before it can be disposed`);
        }
        this.container.dispose();
    }
    dispatchEvent(root, name, target) {
        const ev = new root.platform.window.CustomEvent(name, { detail: this, bubbles: true, cancelable: true });
        target.dispatchEvent(ev);
    }
}
//# sourceMappingURL=aurelia.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/bindable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bindable": () => /* binding */ bindable,
/* harmony export */   "Bindable": () => /* binding */ Bindable,
/* harmony export */   "BindableDefinition": () => /* binding */ BindableDefinition
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


function bindable(configOrTarget, prop) {
    let config;
    function decorator($target, $prop) {
        if (arguments.length > 1) {
            // Non invocation:
            // - @bindable
            // Invocation with or w/o opts:
            // - @bindable()
            // - @bindable({...opts})
            config.property = $prop;
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Bindable.name, BindableDefinition.create($prop, config), $target.constructor, $prop);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo($target.constructor, Bindable.keyFrom($prop));
    }
    if (arguments.length > 1) {
        // Non invocation:
        // - @bindable
        config = {};
        decorator(configOrTarget, prop);
        return;
    }
    else if (typeof configOrTarget === 'string') {
        // ClassDecorator
        // - @bindable('bar')
        // Direct call:
        // - @bindable('bar')(Foo)
        config = {};
        return decorator;
    }
    // Invocation with or w/o opts:
    // - @bindable()
    // - @bindable({...opts})
    config = configOrTarget === void 0 ? {} : configOrTarget;
    return decorator;
}
function isBindableAnnotation(key) {
    return key.startsWith(Bindable.name);
}
const Bindable = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('bindable'),
    keyFrom(name) {
        return `${Bindable.name}:${name}`;
    },
    from(...bindableLists) {
        const bindables = {};
        const isArray = Array.isArray;
        function addName(name) {
            bindables[name] = BindableDefinition.create(name);
        }
        function addDescription(name, def) {
            bindables[name] = def instanceof BindableDefinition ? def : BindableDefinition.create(name, def);
        }
        function addList(maybeList) {
            if (isArray(maybeList)) {
                maybeList.forEach(addName);
            }
            else if (maybeList instanceof BindableDefinition) {
                bindables[maybeList.property] = maybeList;
            }
            else if (maybeList !== void 0) {
                Object.keys(maybeList).forEach(name => addDescription(name, maybeList[name]));
            }
        }
        bindableLists.forEach(addList);
        return bindables;
    },
    for(Type) {
        let def;
        const builder = {
            add(configOrProp) {
                let prop;
                let config;
                if (typeof configOrProp === 'string') {
                    prop = configOrProp;
                    config = { property: prop };
                }
                else {
                    prop = configOrProp.property;
                    config = configOrProp;
                }
                def = BindableDefinition.create(prop, config);
                if (!_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(Bindable.name, Type, prop)) {
                    _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo(Type, Bindable.keyFrom(prop));
                }
                _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Bindable.name, def, Type, prop);
                return builder;
            },
            mode(mode) {
                def.mode = mode;
                return builder;
            },
            callback(callback) {
                def.callback = callback;
                return builder;
            },
            attribute(attribute) {
                def.attribute = attribute;
                return builder;
            },
            primary() {
                def.primary = true;
                return builder;
            },
            set(setInterpreter) {
                def.set = setInterpreter;
                return builder;
            }
        };
        return builder;
    },
    getAll(Type) {
        const propStart = Bindable.name.length + 1;
        const defs = [];
        const prototypeChain = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.getPrototypeChain)(Type);
        let iProto = prototypeChain.length;
        let iDefs = 0;
        let keys;
        let keysLen;
        let Class;
        while (--iProto >= 0) {
            Class = prototypeChain[iProto];
            keys = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.getKeys(Class).filter(isBindableAnnotation);
            keysLen = keys.length;
            for (let i = 0; i < keysLen; ++i) {
                defs[iDefs++] = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Bindable.name, Class, keys[i].slice(propStart));
            }
        }
        return defs;
    },
};
class BindableDefinition {
    constructor(attribute, callback, mode, primary, property, set) {
        this.attribute = attribute;
        this.callback = callback;
        this.mode = mode;
        this.primary = primary;
        this.property = property;
        this.set = set;
    }
    static create(prop, def = {}) {
        return new BindableDefinition((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.attribute, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(prop)), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.callback, `${prop}Changed`), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.mode, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.primary, false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.property, prop), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.set, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop));
    }
}
/* eslint-disable @typescript-eslint/no-unused-vars,spaced-comment */
/**
 * This function serves two purposes:
 * - A playground for contributors to try their changes to the APIs.
 * - Cause the API surface to be properly type-checked and protected against accidental type regressions.
 *
 * It will be automatically removed by dead code elimination.
 */
function apiTypeCheck() {
    let Foo = 
    // > expected error - class decorator only accepts a string
    //@bindable({})
    class Foo {
    };
    __decorate([
        bindable,
        bindable(),
        bindable({})
        // > expected error - 'property' does not exist on decorator input object
        //@bindable({ property: 'prop' })
        ,
        bindable({ mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay }),
        bindable({ callback: 'propChanged' }),
        bindable({ attribute: 'prop' }),
        bindable({ primary: true }),
        bindable({ set: value => String(value) }),
        bindable({ set: value => Number(value) }),
        bindable({
            mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay,
            callback: 'propChanged',
            attribute: 'prop',
            primary: true,
            set: value => String(value)
        })
    ], Foo.prototype, "prop", void 0);
    Foo = __decorate([
        bindable('prop')
        // > expected error - class decorator only accepts a string
        //@bindable({})
    ], Foo);
    Bindable.for(Foo)
        // > expected error - there is no add() function with only optional params on the fluent api
        //.add()
        // > expected error - 'property' is a required property on the fluent api
        //.add({})
        .add({ property: 'prop' })
        .add({ property: 'prop', mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay })
        .add({ property: 'prop', callback: 'propChanged' })
        .add({ property: 'prop', attribute: 'prop' })
        .add({ property: 'prop', primary: true })
        .add({ property: 'prop', mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay, callback: 'propChanged', attribute: 'prop', primary: true })
        .add('prop')
        // > expected error - the add() method that accepts an object literal does not return a fluent api
        //.add({ property: 'prop' }).mode(BindingMode.twoWay)
        //.add({ property: 'prop' }).callback('propChanged')
        //.add({ property: 'prop' }).attribute('prop')
        //.add({ property: 'prop' }).primary()
        // > expected error - fluent api methods can only be invoked once per bindable
        //.add('prop').mode(BindingMode.twoWay).mode(BindingMode.twoWay)
        //.add('prop').mode(BindingMode.twoWay).callback('propChanged').mode(BindingMode.twoWay)
        //.add('prop').mode(BindingMode.twoWay).callback('propChanged').callback('propChanged') // etc
        // > expected error - wrong invocation order
        //.add('prop').callback('propChanged').mode(BindingMode.twoWay)
        //.add('prop').primary().mode(BindingMode.twoWay)  // etc
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay)
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged')
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged').attribute('prop')
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged').attribute('prop').primary()
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).set((value) => Number(value))
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged').set(value => Number(value))
        .add('prop').callback('propChanged')
        .add('prop').callback('propChanged').attribute('prop')
        .add('prop').callback('propChanged').attribute('prop').primary()
        .add('prop').attribute('prop')
        .add('prop').attribute('prop').primary()
        .add('prop').primary();
}
/* eslint-enable @typescript-eslint/no-unused-vars,spaced-comment */
//# sourceMappingURL=bindable.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingModeBehavior": () => /* binding */ BindingModeBehavior,
/* harmony export */   "OneTimeBindingBehavior": () => /* binding */ OneTimeBindingBehavior,
/* harmony export */   "ToViewBindingBehavior": () => /* binding */ ToViewBindingBehavior,
/* harmony export */   "FromViewBindingBehavior": () => /* binding */ FromViewBindingBehavior,
/* harmony export */   "TwoWayBindingBehavior": () => /* binding */ TwoWayBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

class BindingModeBehavior {
    constructor(mode) {
        this.mode = mode;
        this.originalModes = new Map();
    }
    bind(flags, scope, hostScope, binding) {
        this.originalModes.set(binding, binding.mode);
        binding.mode = this.mode;
    }
    unbind(flags, scope, hostScope, binding) {
        binding.mode = this.originalModes.get(binding);
        this.originalModes.delete(binding);
    }
}
class OneTimeBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.oneTime);
    }
}
class ToViewBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView);
    }
}
class FromViewBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.fromView);
    }
}
class TwoWayBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.twoWay);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('oneTime')(OneTimeBindingBehavior);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('toView')(ToViewBindingBehavior);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('fromView')(FromViewBindingBehavior);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('twoWay')(TwoWayBindingBehavior);
//# sourceMappingURL=binding-mode.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebounceBindingBehavior": () => /* binding */ DebounceBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


class DebounceBindingBehavior extends _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingInterceptor {
    constructor(binding, expr) {
        super(binding, expr);
        this.opts = { delay: 0 };
        this.firstArg = null;
        this.task = null;
        this.taskQueue = binding.locator.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform).macroTaskQueue;
        if (expr.args.length > 0) {
            this.firstArg = expr.args[0];
        }
    }
    callSource(args) {
        this.queueTask(() => this.binding.callSource(args));
        return void 0;
    }
    handleChange(newValue, previousValue, flags) {
        this.queueTask(() => this.binding.handleChange(newValue, previousValue, flags));
    }
    queueTask(callback) {
        if (this.task !== null) {
            this.task.cancel();
        }
        this.task = this.taskQueue.queueTask(() => {
            this.task = null;
            return callback();
        }, this.opts);
    }
    $bind(flags, scope, hostScope) {
        if (this.firstArg !== null) {
            const delay = Number(this.firstArg.evaluate(flags, scope, hostScope, this.locator, null));
            if (!isNaN(delay)) {
                this.opts.delay = delay;
            }
        }
        this.binding.$bind(flags, scope, hostScope);
    }
    $unbind(flags) {
        this.task?.cancel();
        this.task = null;
        this.binding.$unbind(flags);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.bindingBehavior)('debounce')(DebounceBindingBehavior);
//# sourceMappingURL=debounce.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SignalBindingBehavior": () => /* binding */ SignalBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

let SignalBindingBehavior = class SignalBindingBehavior {
    constructor(signaler) {
        this.signaler = signaler;
        this.lookup = new Map();
    }
    bind(flags, scope, hostScope, binding, ...names) {
        if (!('handleChange' in binding)) {
            throw new Error(`The signal behavior can only be used with bindings that have a 'handleChange' method`);
        }
        if (names.length === 0) {
            throw new Error(`At least one signal name must be passed to the signal behavior, e.g. \`expr & signal:'my-signal'\``);
        }
        this.lookup.set(binding, names);
        for (const name of names) {
            this.signaler.addSignalListener(name, binding);
        }
    }
    unbind(flags, scope, hostScope, binding) {
        const names = this.lookup.get(binding);
        this.lookup.delete(binding);
        for (const name of names) {
            this.signaler.removeSignalListener(name, binding);
        }
    }
};
SignalBindingBehavior = __decorate([
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.ISignaler)
], SignalBindingBehavior);

(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('signal')(SignalBindingBehavior);
//# sourceMappingURL=signals.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThrottleBindingBehavior": () => /* binding */ ThrottleBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


class ThrottleBindingBehavior extends _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingInterceptor {
    constructor(binding, expr) {
        super(binding, expr);
        this.opts = { delay: 0 };
        this.firstArg = null;
        this.task = null;
        this.lastCall = 0;
        this.platform = binding.locator.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform);
        this.taskQueue = this.platform.macroTaskQueue;
        if (expr.args.length > 0) {
            this.firstArg = expr.args[0];
        }
    }
    callSource(args) {
        this.queueTask(() => this.binding.callSource(args));
        return void 0;
    }
    handleChange(newValue, previousValue, flags) {
        this.queueTask(() => this.binding.handleChange(newValue, previousValue, flags));
    }
    queueTask(callback) {
        const opts = this.opts;
        const platform = this.platform;
        const nextDelay = this.lastCall + opts.delay - platform.performanceNow();
        if (nextDelay > 0) {
            if (this.task !== null) {
                this.task.cancel();
            }
            opts.delay = nextDelay;
            this.task = this.taskQueue.queueTask(() => {
                this.lastCall = platform.performanceNow();
                this.task = null;
                callback();
            }, opts);
        }
        else {
            this.lastCall = platform.performanceNow();
            callback();
        }
    }
    $bind(flags, scope, hostScope) {
        if (this.firstArg !== null) {
            const delay = Number(this.firstArg.evaluate(flags, scope, hostScope, this.locator, null));
            if (!isNaN(delay)) {
                this.opts.delay = delay;
            }
        }
        this.binding.$bind(flags, scope, hostScope);
    }
    $unbind(flags) {
        this.task?.cancel();
        this.task = null;
        super.$unbind(flags);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.bindingBehavior)('throttle')(ThrottleBindingBehavior);
//# sourceMappingURL=throttle.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeBinding": () => /* binding */ AttributeBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_element_attribute_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/element-attribute-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");



// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak
const { oneTime, toView, fromView } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode;
// pre-combining flags for bitwise checks is a minor perf tweak
const toViewOrOneTime = toView | oneTime;
const taskOptions = {
    reusable: false,
    preempt: true,
};
/**
 * Attribute binding. Handle attribute binding betwen view/view model. Understand Html special attributes
 */
class AttributeBinding {
    constructor(sourceExpression, target, 
    // some attributes may have inner structure
    // such as class -> collection of class names
    // such as style -> collection of style rules
    //
    // for normal attributes, targetAttribute and targetProperty are the same and can be ignore
    targetAttribute, targetProperty, mode, observerLocator, locator) {
        this.sourceExpression = sourceExpression;
        this.targetAttribute = targetAttribute;
        this.targetProperty = targetProperty;
        this.mode = mode;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = null;
        this.$hostScope = null;
        this.task = null;
        this.persistentFlags = 0 /* none */;
        this.value = void 0;
        this.target = target;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
        this.$platform = locator.get(_platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform);
    }
    updateTarget(value, flags) {
        flags |= this.persistentFlags;
        this.targetObserver.setValue(value, flags | 8 /* updateTarget */, this.target, this.targetProperty);
    }
    updateSource(value, flags) {
        flags |= this.persistentFlags;
        this.sourceExpression.assign(flags | 16 /* updateSource */, this.$scope, this.$hostScope, this.locator, value);
    }
    handleChange(newValue, _previousValue, flags) {
        if (!this.isBound) {
            return;
        }
        flags |= this.persistentFlags;
        const mode = this.mode;
        const interceptor = this.interceptor;
        const sourceExpression = this.sourceExpression;
        const $scope = this.$scope;
        const locator = this.locator;
        if (mode === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.fromView) {
            flags &= ~8 /* updateTarget */;
            flags |= 16 /* updateSource */;
        }
        if (flags & 8 /* updateTarget */) {
            const targetObserver = this.targetObserver;
            // Alpha: during bind a simple strategy for bind is always flush immediately
            // todo:
            //  (1). determine whether this should be the behavior
            //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start()
            const shouldQueueFlush = (flags & 32 /* fromBind */) === 0 && (targetObserver.type & 4 /* Layout */) > 0;
            if (sourceExpression.$kind !== 10082 /* AccessScope */ || this.obs.count > 1) {
                const shouldConnect = (mode & oneTime) === 0;
                if (shouldConnect) {
                    this.obs.version++;
                }
                newValue = sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, interceptor);
                if (shouldConnect) {
                    this.obs.clear(false);
                }
            }
            if (newValue !== this.value) {
                this.value = newValue;
                if (shouldQueueFlush) {
                    this.task?.cancel();
                    this.task = this.$platform.domWriteQueue.queueTask(() => {
                        this.task = null;
                        interceptor.updateTarget(newValue, flags);
                    }, taskOptions);
                }
                else {
                    interceptor.updateTarget(newValue, flags);
                }
            }
            return;
        }
        if (flags & 16 /* updateSource */) {
            if (newValue !== sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, null)) {
                interceptor.updateSource(newValue, flags);
            }
            return;
        }
        throw new Error('Unexpected handleChange context in AttributeBinding');
    }
    $bind(flags, scope, hostScope, projection) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        // Store flags which we can only receive during $bind and need to pass on
        // to the AST during evaluate/connect/assign
        this.persistentFlags = flags & 15367 /* persistentBindingFlags */;
        this.$scope = scope;
        this.$hostScope = hostScope;
        this.projection = projection;
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        let targetObserver = this.targetObserver;
        if (!targetObserver) {
            targetObserver = this.targetObserver = new _observation_element_attribute_observer_js__WEBPACK_IMPORTED_MODULE_1__.AttributeObserver(this.$platform, this.observerLocator, this.target, this.targetProperty, this.targetAttribute);
        }
        // during bind, binding behavior might have changed sourceExpression
        sourceExpression = this.sourceExpression;
        const $mode = this.mode;
        const interceptor = this.interceptor;
        if ($mode & toViewOrOneTime) {
            const shouldConnect = ($mode & toView) > 0;
            interceptor.updateTarget(this.value = sourceExpression.evaluate(flags, scope, this.$hostScope, this.locator, shouldConnect ? interceptor : null), flags);
        }
        if ($mode & fromView) {
            targetObserver[this.id] |= 16 /* updateSource */;
            targetObserver.subscribe(interceptor);
        }
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        // clear persistent flags
        this.persistentFlags = 0 /* none */;
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope
            = this.$hostScope
                = null;
        this.value = void 0;
        const targetObserver = this.targetObserver;
        if (targetObserver.unsubscribe) {
            targetObserver.unsubscribe(this.interceptor);
            targetObserver[this.id] &= ~16 /* updateSource */;
        }
        this.task?.cancel();
        this.task = null;
        this.obs.clear(true);
        // remove isBound and isUnbinding flags
        this.isBound = false;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(AttributeBinding);
//# sourceMappingURL=attribute.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallBinding": () => /* binding */ CallBinding
/* harmony export */ });
class CallBinding {
    constructor(sourceExpression, target, targetProperty, observerLocator, locator) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = targetProperty;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$hostScope = null;
        this.targetObserver = observerLocator.getObserver(target, targetProperty);
    }
    callSource(args) {
        const overrideContext = this.$scope.overrideContext;
        // really need to delete the following line
        // and the for..in loop below
        // convenience in the template won't outweight the draw back of such confusing feature
        // OR, at the very least, use getter/setter for each property in args to get/set original source
        // ---
        Object.assign(overrideContext, args);
        const result = this.sourceExpression.evaluate(128 /* mustEvaluate */, this.$scope, this.$hostScope, this.locator, null);
        for (const prop in args) {
            Reflect.deleteProperty(overrideContext, prop);
        }
        return result;
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        if (this.sourceExpression.hasBind) {
            this.sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        this.targetObserver.setValue(($args) => this.interceptor.callSource($args), flags, this.target, this.targetProperty);
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.targetObserver.setValue(null, flags, this.target, this.targetProperty);
        this.isBound = false;
    }
    observeProperty(obj, propertyName) {
        return;
    }
    handleChange(newValue, previousValue, flags) {
        return;
    }
}
//# sourceMappingURL=call-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InterpolationBinding": () => /* binding */ InterpolationBinding,
/* harmony export */   "ContentBinding": () => /* binding */ ContentBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

const { toView } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode;
const queueTaskOptions = {
    reusable: false,
    preempt: true,
};
// a pseudo binding to manage multiple InterpolationBinding s
// ========
// Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include
// value converters and binding behaviors.
// Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,
// in which case the renderer will create the TextBinding directly
class InterpolationBinding {
    constructor(observerLocator, interpolation, target, targetProperty, mode, locator, taskQueue) {
        this.observerLocator = observerLocator;
        this.interpolation = interpolation;
        this.target = target;
        this.targetProperty = targetProperty;
        this.mode = mode;
        this.locator = locator;
        this.taskQueue = taskQueue;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
        this.task = null;
        this.targetObserver = observerLocator.getAccessor(target, targetProperty);
        const expressions = interpolation.expressions;
        const partBindings = this.partBindings = Array(expressions.length);
        for (let i = 0, ii = expressions.length; i < ii; ++i) {
            partBindings[i] = new ContentBinding(expressions[i], target, targetProperty, locator, observerLocator, this);
        }
    }
    updateTarget(value, flags) {
        const partBindings = this.partBindings;
        const staticParts = this.interpolation.parts;
        const ii = partBindings.length;
        let result = '';
        if (ii === 1) {
            result = staticParts[0] + partBindings[0].value + staticParts[1];
        }
        else {
            result = staticParts[0];
            for (let i = 0; ii > i; ++i) {
                result += partBindings[i].value + staticParts[i + 1];
            }
        }
        const targetObserver = this.targetObserver;
        // Alpha: during bind a simple strategy for bind is always flush immediately
        // todo:
        //  (1). determine whether this should be the behavior
        //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start().wait()
        const shouldQueueFlush = (flags & 32 /* fromBind */) === 0 && (targetObserver.type & 4 /* Layout */) > 0;
        if (shouldQueueFlush) {
            this.task?.cancel();
            this.task = this.taskQueue.queueTask(() => {
                this.task = null;
                targetObserver.setValue(result, flags, this.target, this.targetProperty);
            }, queueTaskOptions);
        }
        else {
            targetObserver.setValue(result, flags, this.target, this.targetProperty);
        }
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags);
        }
        this.isBound = true;
        this.$scope = scope;
        const partBindings = this.partBindings;
        for (let i = 0, ii = partBindings.length; ii > i; ++i) {
            partBindings[i].$bind(flags, scope, hostScope);
        }
        this.updateTarget(void 0, flags);
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.$scope = void 0;
        const partBindings = this.partBindings;
        for (let i = 0, ii = partBindings.length; i < ii; ++i) {
            partBindings[i].interceptor.$unbind(flags);
        }
        this.task?.cancel();
        this.task = null;
    }
}
class ContentBinding {
    constructor(sourceExpression, target, targetProperty, locator, observerLocator, owner) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = targetProperty;
        this.locator = locator;
        this.observerLocator = observerLocator;
        this.owner = owner;
        this.interceptor = this;
        // at runtime, mode may be overriden by binding behavior
        // but it wouldn't matter here, just start with something for later check
        this.mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView;
        this.value = '';
        this.$hostScope = null;
        this.task = null;
        this.isBound = false;
    }
    handleChange(newValue, oldValue, flags) {
        if (!this.isBound) {
            return;
        }
        const sourceExpression = this.sourceExpression;
        const obsRecord = this.obs;
        const canOptimize = sourceExpression.$kind === 10082 /* AccessScope */ && obsRecord.count === 1;
        if (!canOptimize) {
            const shouldConnect = (this.mode & toView) > 0;
            if (shouldConnect) {
                obsRecord.version++;
            }
            newValue = sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, shouldConnect ? this.interceptor : null);
            if (shouldConnect) {
                obsRecord.clear(false);
            }
        }
        if (newValue != this.value) {
            this.value = newValue;
            if (newValue instanceof Array) {
                this.observeCollection(newValue);
            }
            this.owner.updateTarget(newValue, flags);
        }
    }
    handleCollectionChange(indexMap, flags) {
        this.owner.updateTarget(void 0, flags);
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags);
        }
        this.isBound = true;
        this.$scope = scope;
        this.$hostScope = hostScope;
        if (this.sourceExpression.hasBind) {
            this.sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        const v = this.value = this.sourceExpression.evaluate(flags, scope, hostScope, this.locator, (this.mode & toView) > 0 ? this.interceptor : null);
        if (v instanceof Array) {
            this.observeCollection(v);
        }
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        this.obs.clear(true);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(ContentBinding);
//# sourceMappingURL=interpolation-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LetBinding": () => /* binding */ LetBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

class LetBinding {
    constructor(sourceExpression, targetProperty, observerLocator, locator, toBindingContext = false) {
        this.sourceExpression = sourceExpression;
        this.targetProperty = targetProperty;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.toBindingContext = toBindingContext;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
        this.task = null;
        this.target = null;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    handleChange(_newValue, _previousValue, flags) {
        if (!this.isBound) {
            return;
        }
        if (flags & 8 /* updateTarget */) {
            const target = this.target;
            const targetProperty = this.targetProperty;
            const previousValue = target[targetProperty];
            this.obs.version++;
            const newValue = this.sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, this.interceptor);
            this.obs.clear(false);
            if (newValue !== previousValue) {
                target[targetProperty] = newValue;
            }
            return;
        }
        throw new Error('Unexpected handleChange context in LetBinding');
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        this.target = (this.toBindingContext ? (hostScope ?? scope).bindingContext : (hostScope ?? scope).overrideContext);
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        // sourceExpression might have been changed during bind
        this.target[this.targetProperty]
            = this.sourceExpression.evaluate(flags | 32 /* fromBind */, scope, hostScope, this.locator, this.interceptor);
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasUnbind) {
            sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        this.obs.clear(true);
        // remove isBound and isUnbinding flags
        this.isBound = false;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(LetBinding);
//# sourceMappingURL=let-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Listener": () => /* binding */ Listener
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");


const options = {
    [_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.capturing]: { capture: true },
    [_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.bubbling]: { capture: false },
};
/**
 * Listener binding. Handle event binding between view and view model
 */
class Listener {
    constructor(platform, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, eventDelegator, locator) {
        this.platform = platform;
        this.targetEvent = targetEvent;
        this.delegationStrategy = delegationStrategy;
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.preventDefault = preventDefault;
        this.eventDelegator = eventDelegator;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$hostScope = null;
        this.handler = null;
    }
    callSource(event) {
        const overrideContext = this.$scope.overrideContext;
        overrideContext.$event = event;
        const result = this.sourceExpression.evaluate(128 /* mustEvaluate */, this.$scope, this.$hostScope, this.locator, null);
        Reflect.deleteProperty(overrideContext, '$event');
        if (result !== true && this.preventDefault) {
            event.preventDefault();
        }
        return result;
    }
    handleEvent(event) {
        this.interceptor.callSource(event);
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        if (this.delegationStrategy === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.none) {
            this.target.addEventListener(this.targetEvent, this);
        }
        else {
            const eventTarget = this.locator.get(_dom_js__WEBPACK_IMPORTED_MODULE_1__.IEventTarget);
            this.handler = this.eventDelegator.addEventListener(eventTarget, this.target, this.targetEvent, this, options[this.delegationStrategy]);
        }
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasUnbind) {
            sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = null;
        if (this.delegationStrategy === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.none) {
            this.target.removeEventListener(this.targetEvent, this);
        }
        else {
            this.handler.dispose();
            this.handler = null;
        }
        // remove isBound and isUnbinding flags
        this.isBound = false;
    }
    observeProperty(obj, propertyName) {
        return;
    }
    handleChange(newValue, previousValue, flags) {
        return;
    }
}
//# sourceMappingURL=listener.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyBinding": () => /* binding */ PropertyBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak
const { oneTime, toView, fromView } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode;
// pre-combining flags for bitwise checks is a minor perf tweak
const toViewOrOneTime = toView | oneTime;
const updateTaskOpts = {
    reusable: false,
    preempt: true,
};
class PropertyBinding {
    constructor(sourceExpression, target, targetProperty, mode, observerLocator, locator, taskQueue) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = targetProperty;
        this.mode = mode;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.taskQueue = taskQueue;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
        this.targetObserver = void 0;
        this.persistentFlags = 0 /* none */;
        this.task = null;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    updateTarget(value, flags) {
        flags |= this.persistentFlags;
        this.targetObserver.setValue(value, flags, this.target, this.targetProperty);
    }
    updateSource(value, flags) {
        flags |= this.persistentFlags;
        this.sourceExpression.assign(flags, this.$scope, this.$hostScope, this.locator, value);
    }
    handleChange(newValue, _previousValue, flags) {
        if (!this.isBound) {
            return;
        }
        flags |= this.persistentFlags;
        const targetObserver = this.targetObserver;
        const interceptor = this.interceptor;
        const sourceExpression = this.sourceExpression;
        const $scope = this.$scope;
        const locator = this.locator;
        if ((flags & 8 /* updateTarget */) > 0) {
            // Alpha: during bind a simple strategy for bind is always flush immediately
            // todo:
            //  (1). determine whether this should be the behavior
            //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start()
            const shouldQueueFlush = (flags & 32 /* fromBind */) === 0 && (targetObserver.type & 4 /* Layout */) > 0;
            const obsRecord = this.obs;
            // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value
            if (sourceExpression.$kind !== 10082 /* AccessScope */ || obsRecord.count > 1) {
                // todo: in VC expressions, from view also requires connect
                const shouldConnect = this.mode > oneTime;
                if (shouldConnect) {
                    obsRecord.version++;
                }
                newValue = sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, interceptor);
                if (shouldConnect) {
                    obsRecord.clear(false);
                }
            }
            if (shouldQueueFlush) {
                this.task?.cancel();
                this.task = this.taskQueue.queueTask(() => {
                    interceptor.updateTarget(newValue, flags);
                    this.task = null;
                }, updateTaskOpts);
            }
            else {
                interceptor.updateTarget(newValue, flags);
            }
            return;
        }
        if ((flags & 16 /* updateSource */) > 0) {
            if (newValue !== sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, null)) {
                interceptor.updateSource(newValue, flags);
            }
            return;
        }
        throw new Error('Unexpected handleChange context in PropertyBinding');
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        // Force property binding to always be strict
        flags |= 4 /* isStrictBindingStrategy */;
        // Store flags which we can only receive during $bind and need to pass on
        // to the AST during evaluate/connect/assign
        this.persistentFlags = flags & 15367 /* persistentBindingFlags */;
        this.$scope = scope;
        this.$hostScope = hostScope;
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        const $mode = this.mode;
        let targetObserver = this.targetObserver;
        if (!targetObserver) {
            const observerLocator = this.observerLocator;
            if ($mode & fromView) {
                targetObserver = observerLocator.getObserver(this.target, this.targetProperty);
            }
            else {
                targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);
            }
            this.targetObserver = targetObserver;
        }
        // during bind, binding behavior might have changed sourceExpression
        // deepscan-disable-next-line
        sourceExpression = this.sourceExpression;
        const interceptor = this.interceptor;
        const shouldConnect = ($mode & toView) > 0;
        if ($mode & toViewOrOneTime) {
            interceptor.updateTarget(sourceExpression.evaluate(flags, scope, this.$hostScope, this.locator, shouldConnect ? interceptor : null), flags);
        }
        if ($mode & fromView) {
            targetObserver.subscribe(interceptor);
            if (!shouldConnect) {
                interceptor.updateSource(targetObserver.getValue(this.target, this.targetProperty), flags);
            }
            targetObserver[this.id] |= 16 /* updateSource */;
        }
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        this.persistentFlags = 0 /* none */;
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        const targetObserver = this.targetObserver;
        const task = this.task;
        if (targetObserver.unsubscribe) {
            targetObserver.unsubscribe(this.interceptor);
            targetObserver[this.id] &= ~16 /* updateSource */;
        }
        if (task != null) {
            task.cancel();
            this.task = null;
        }
        this.obs.clear(true);
        this.isBound = false;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(PropertyBinding);
//# sourceMappingURL=property-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RefBinding": () => /* binding */ RefBinding
/* harmony export */ });
class RefBinding {
    constructor(sourceExpression, target, locator) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        if (this.sourceExpression.hasBind) {
            this.sourceExpression.bind(flags, scope, hostScope, this);
        }
        this.sourceExpression.assign(flags | 16 /* updateSource */, this.$scope, hostScope, this.locator, this.target);
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, null) === this.target) {
            sourceExpression.assign(flags, this.$scope, this.$hostScope, this.locator, null);
        }
        // source expression might have been modified durring assign, via a BB
        // deepscan-disable-next-line
        sourceExpression = this.sourceExpression;
        if (sourceExpression.hasUnbind) {
            sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        this.isBound = false;
    }
    observeProperty(obj, propertyName) {
        return;
    }
    handleChange(newValue, previousValue, flags) {
        return;
    }
}
//# sourceMappingURL=ref-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/configuration.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/configuration.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebounceBindingBehaviorRegistration": () => /* binding */ DebounceBindingBehaviorRegistration,
/* harmony export */   "OneTimeBindingBehaviorRegistration": () => /* binding */ OneTimeBindingBehaviorRegistration,
/* harmony export */   "ToViewBindingBehaviorRegistration": () => /* binding */ ToViewBindingBehaviorRegistration,
/* harmony export */   "FromViewBindingBehaviorRegistration": () => /* binding */ FromViewBindingBehaviorRegistration,
/* harmony export */   "SignalBindingBehaviorRegistration": () => /* binding */ SignalBindingBehaviorRegistration,
/* harmony export */   "ThrottleBindingBehaviorRegistration": () => /* binding */ ThrottleBindingBehaviorRegistration,
/* harmony export */   "TwoWayBindingBehaviorRegistration": () => /* binding */ TwoWayBindingBehaviorRegistration,
/* harmony export */   "ITemplateCompilerRegistration": () => /* binding */ ITemplateCompilerRegistration,
/* harmony export */   "INodeObserverLocatorRegistration": () => /* binding */ INodeObserverLocatorRegistration,
/* harmony export */   "DefaultComponents": () => /* binding */ DefaultComponents,
/* harmony export */   "SVGAnalyzerRegistration": () => /* binding */ SVGAnalyzerRegistration,
/* harmony export */   "AtPrefixedTriggerAttributePatternRegistration": () => /* binding */ AtPrefixedTriggerAttributePatternRegistration,
/* harmony export */   "ColonPrefixedBindAttributePatternRegistration": () => /* binding */ ColonPrefixedBindAttributePatternRegistration,
/* harmony export */   "RefAttributePatternRegistration": () => /* binding */ RefAttributePatternRegistration,
/* harmony export */   "DotSeparatedAttributePatternRegistration": () => /* binding */ DotSeparatedAttributePatternRegistration,
/* harmony export */   "DefaultBindingSyntax": () => /* binding */ DefaultBindingSyntax,
/* harmony export */   "ShortHandBindingSyntax": () => /* binding */ ShortHandBindingSyntax,
/* harmony export */   "CallBindingCommandRegistration": () => /* binding */ CallBindingCommandRegistration,
/* harmony export */   "DefaultBindingCommandRegistration": () => /* binding */ DefaultBindingCommandRegistration,
/* harmony export */   "ForBindingCommandRegistration": () => /* binding */ ForBindingCommandRegistration,
/* harmony export */   "FromViewBindingCommandRegistration": () => /* binding */ FromViewBindingCommandRegistration,
/* harmony export */   "OneTimeBindingCommandRegistration": () => /* binding */ OneTimeBindingCommandRegistration,
/* harmony export */   "ToViewBindingCommandRegistration": () => /* binding */ ToViewBindingCommandRegistration,
/* harmony export */   "TwoWayBindingCommandRegistration": () => /* binding */ TwoWayBindingCommandRegistration,
/* harmony export */   "RefBindingCommandRegistration": () => /* binding */ RefBindingCommandRegistration,
/* harmony export */   "TriggerBindingCommandRegistration": () => /* binding */ TriggerBindingCommandRegistration,
/* harmony export */   "DelegateBindingCommandRegistration": () => /* binding */ DelegateBindingCommandRegistration,
/* harmony export */   "CaptureBindingCommandRegistration": () => /* binding */ CaptureBindingCommandRegistration,
/* harmony export */   "AttrBindingCommandRegistration": () => /* binding */ AttrBindingCommandRegistration,
/* harmony export */   "ClassBindingCommandRegistration": () => /* binding */ ClassBindingCommandRegistration,
/* harmony export */   "StyleBindingCommandRegistration": () => /* binding */ StyleBindingCommandRegistration,
/* harmony export */   "DefaultBindingLanguage": () => /* binding */ DefaultBindingLanguage,
/* harmony export */   "SanitizeValueConverterRegistration": () => /* binding */ SanitizeValueConverterRegistration,
/* harmony export */   "ViewValueConverterRegistration": () => /* binding */ ViewValueConverterRegistration,
/* harmony export */   "FrequentMutationsRegistration": () => /* binding */ FrequentMutationsRegistration,
/* harmony export */   "ObserveShallowRegistration": () => /* binding */ ObserveShallowRegistration,
/* harmony export */   "IfRegistration": () => /* binding */ IfRegistration,
/* harmony export */   "ElseRegistration": () => /* binding */ ElseRegistration,
/* harmony export */   "RepeatRegistration": () => /* binding */ RepeatRegistration,
/* harmony export */   "WithRegistration": () => /* binding */ WithRegistration,
/* harmony export */   "SwitchRegistration": () => /* binding */ SwitchRegistration,
/* harmony export */   "CaseRegistration": () => /* binding */ CaseRegistration,
/* harmony export */   "DefaultCaseRegistration": () => /* binding */ DefaultCaseRegistration,
/* harmony export */   "AttrBindingBehaviorRegistration": () => /* binding */ AttrBindingBehaviorRegistration,
/* harmony export */   "SelfBindingBehaviorRegistration": () => /* binding */ SelfBindingBehaviorRegistration,
/* harmony export */   "UpdateTriggerBindingBehaviorRegistration": () => /* binding */ UpdateTriggerBindingBehaviorRegistration,
/* harmony export */   "ComposeRegistration": () => /* binding */ ComposeRegistration,
/* harmony export */   "PortalRegistration": () => /* binding */ PortalRegistration,
/* harmony export */   "FocusRegistration": () => /* binding */ FocusRegistration,
/* harmony export */   "BlurRegistration": () => /* binding */ BlurRegistration,
/* harmony export */   "ShowRegistration": () => /* binding */ ShowRegistration,
/* harmony export */   "DefaultResources": () => /* binding */ DefaultResources,
/* harmony export */   "CallBindingRendererRegistration": () => /* binding */ CallBindingRendererRegistration,
/* harmony export */   "CustomAttributeRendererRegistration": () => /* binding */ CustomAttributeRendererRegistration,
/* harmony export */   "CustomElementRendererRegistration": () => /* binding */ CustomElementRendererRegistration,
/* harmony export */   "InterpolationBindingRendererRegistration": () => /* binding */ InterpolationBindingRendererRegistration,
/* harmony export */   "IteratorBindingRendererRegistration": () => /* binding */ IteratorBindingRendererRegistration,
/* harmony export */   "LetElementRendererRegistration": () => /* binding */ LetElementRendererRegistration,
/* harmony export */   "PropertyBindingRendererRegistration": () => /* binding */ PropertyBindingRendererRegistration,
/* harmony export */   "RefBindingRendererRegistration": () => /* binding */ RefBindingRendererRegistration,
/* harmony export */   "SetPropertyRendererRegistration": () => /* binding */ SetPropertyRendererRegistration,
/* harmony export */   "TemplateControllerRendererRegistration": () => /* binding */ TemplateControllerRendererRegistration,
/* harmony export */   "ListenerBindingRendererRegistration": () => /* binding */ ListenerBindingRendererRegistration,
/* harmony export */   "AttributeBindingRendererRegistration": () => /* binding */ AttributeBindingRendererRegistration,
/* harmony export */   "SetAttributeRendererRegistration": () => /* binding */ SetAttributeRendererRegistration,
/* harmony export */   "SetClassAttributeRendererRegistration": () => /* binding */ SetClassAttributeRendererRegistration,
/* harmony export */   "SetStyleAttributeRendererRegistration": () => /* binding */ SetStyleAttributeRendererRegistration,
/* harmony export */   "StylePropertyBindingRendererRegistration": () => /* binding */ StylePropertyBindingRendererRegistration,
/* harmony export */   "TextBindingRendererRegistration": () => /* binding */ TextBindingRendererRegistration,
/* harmony export */   "DefaultRenderers": () => /* binding */ DefaultRenderers,
/* harmony export */   "StandardConfiguration": () => /* binding */ StandardConfiguration
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/attribute-pattern.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js");
/* harmony import */ var _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/binding-command.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js");
/* harmony import */ var _template_compiler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template-compiler.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-compiler.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding-behaviors/binding-mode.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js");
/* harmony import */ var _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./binding-behaviors/debounce.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js");
/* harmony import */ var _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./binding-behaviors/signals.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js");
/* harmony import */ var _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./binding-behaviors/throttle.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js");
/* harmony import */ var _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./observation/svg-analyzer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js");
/* harmony import */ var _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resources/binding-behaviors/attr.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js");
/* harmony import */ var _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./resources/binding-behaviors/self.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js");
/* harmony import */ var _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./resources/binding-behaviors/update-trigger.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js");
/* harmony import */ var _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resources/custom-attributes/blur.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js");
/* harmony import */ var _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./resources/custom-attributes/focus.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js");
/* harmony import */ var _resources_custom_attributes_show_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./resources/custom-attributes/show.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js");
/* harmony import */ var _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./resources/template-controllers/portal.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js");
/* harmony import */ var _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./resources/template-controllers/flags.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js");
/* harmony import */ var _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./resources/template-controllers/if.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js");
/* harmony import */ var _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./resources/template-controllers/repeat.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js");
/* harmony import */ var _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./resources/template-controllers/with.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js");
/* harmony import */ var _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./resources/template-controllers/switch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js");
/* harmony import */ var _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./resources/custom-elements/compose.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./resources/value-converters/sanitize.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js");
/* harmony import */ var _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./resources/value-converters/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./observation/observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");



























const DebounceBindingBehaviorRegistration = _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__.DebounceBindingBehavior;
const OneTimeBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.OneTimeBindingBehavior;
const ToViewBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.ToViewBindingBehavior;
const FromViewBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.FromViewBindingBehavior;
const SignalBindingBehaviorRegistration = _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__.SignalBindingBehavior;
const ThrottleBindingBehaviorRegistration = _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__.ThrottleBindingBehavior;
const TwoWayBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.TwoWayBindingBehavior;
const ITemplateCompilerRegistration = _template_compiler_js__WEBPACK_IMPORTED_MODULE_3__.TemplateCompiler;
const INodeObserverLocatorRegistration = _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_26__.NodeObserverLocator;
/**
 * Default HTML-specific (but environment-agnostic) implementations for the following interfaces:
 * - `ITemplateCompiler`
 * - `ITargetAccessorLocator`
 * - `ITargetObserverLocator`
 */
const DefaultComponents = [
    ITemplateCompilerRegistration,
    INodeObserverLocatorRegistration,
];
const SVGAnalyzerRegistration = _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_9__.SVGAnalyzer;
const AtPrefixedTriggerAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.AtPrefixedTriggerAttributePattern;
const ColonPrefixedBindAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.ColonPrefixedBindAttributePattern;
const RefAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.RefAttributePattern;
const DotSeparatedAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.DotSeparatedAttributePattern;
/**
 * Default binding syntax for the following attribute name patterns:
 * - `ref`
 * - `target.command` (dot-separated)
 */
const DefaultBindingSyntax = [
    RefAttributePatternRegistration,
    DotSeparatedAttributePatternRegistration
];
/**
 * Binding syntax for short-hand attribute name patterns:
 * - `@target` (short-hand for `target.trigger`)
 * - `:target` (short-hand for `target.bind`)
 */
const ShortHandBindingSyntax = [
    AtPrefixedTriggerAttributePatternRegistration,
    ColonPrefixedBindAttributePatternRegistration
];
const CallBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.CallBindingCommand;
const DefaultBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.DefaultBindingCommand;
const ForBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.ForBindingCommand;
const FromViewBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.FromViewBindingCommand;
const OneTimeBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.OneTimeBindingCommand;
const ToViewBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.ToViewBindingCommand;
const TwoWayBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.TwoWayBindingCommand;
const RefBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.RefBindingCommand;
const TriggerBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.TriggerBindingCommand;
const DelegateBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.DelegateBindingCommand;
const CaptureBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.CaptureBindingCommand;
const AttrBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.AttrBindingCommand;
const ClassBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.ClassBindingCommand;
const StyleBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.StyleBindingCommand;
/**
 * Default HTML-specific (but environment-agnostic) binding commands:
 * - Property observation: `.bind`, `.one-time`, `.from-view`, `.to-view`, `.two-way`
 * - Function call: `.call`
 * - Collection observation: `.for`
 * - Event listeners: `.trigger`, `.delegate`, `.capture`
 */
const DefaultBindingLanguage = [
    DefaultBindingCommandRegistration,
    OneTimeBindingCommandRegistration,
    FromViewBindingCommandRegistration,
    ToViewBindingCommandRegistration,
    TwoWayBindingCommandRegistration,
    CallBindingCommandRegistration,
    ForBindingCommandRegistration,
    RefBindingCommandRegistration,
    TriggerBindingCommandRegistration,
    DelegateBindingCommandRegistration,
    CaptureBindingCommandRegistration,
    ClassBindingCommandRegistration,
    StyleBindingCommandRegistration,
    AttrBindingCommandRegistration,
];
const SanitizeValueConverterRegistration = _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_24__.SanitizeValueConverter;
const ViewValueConverterRegistration = _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_25__.ViewValueConverter;
const FrequentMutationsRegistration = _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_17__.FrequentMutations;
const ObserveShallowRegistration = _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_17__.ObserveShallow;
const IfRegistration = _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_18__.If;
const ElseRegistration = _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_18__.Else;
const RepeatRegistration = _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_19__.Repeat;
const WithRegistration = _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_20__.With;
const SwitchRegistration = _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__.Switch;
const CaseRegistration = _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__.Case;
const DefaultCaseRegistration = _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__.DefaultCase;
const AttrBindingBehaviorRegistration = _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_10__.AttrBindingBehavior;
const SelfBindingBehaviorRegistration = _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_11__.SelfBindingBehavior;
const UpdateTriggerBindingBehaviorRegistration = _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_12__.UpdateTriggerBindingBehavior;
const ComposeRegistration = _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_22__.Compose;
const PortalRegistration = _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_16__.Portal;
const FocusRegistration = _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_14__.Focus;
const BlurRegistration = _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_13__.Blur;
const ShowRegistration = _resources_custom_attributes_show_js__WEBPACK_IMPORTED_MODULE_15__.Show;
/**
 * Default HTML-specific (but environment-agnostic) resources:
 * - Binding Behaviors: `oneTime`, `toView`, `fromView`, `twoWay`, `signal`, `debounce`, `throttle`, `attr`, `self`, `updateTrigger`
 * - Custom Elements: `au-compose`, `au-slot`
 * - Custom Attributes: `blur`, `focus`, `portal`
 * - Template controllers: `if`/`else`, `repeat`, `with`
 * - Value Converters: `sanitize`
 */
const DefaultResources = [
    DebounceBindingBehaviorRegistration,
    OneTimeBindingBehaviorRegistration,
    ToViewBindingBehaviorRegistration,
    FromViewBindingBehaviorRegistration,
    SignalBindingBehaviorRegistration,
    ThrottleBindingBehaviorRegistration,
    TwoWayBindingBehaviorRegistration,
    SanitizeValueConverterRegistration,
    ViewValueConverterRegistration,
    FrequentMutationsRegistration,
    ObserveShallowRegistration,
    IfRegistration,
    ElseRegistration,
    RepeatRegistration,
    WithRegistration,
    SwitchRegistration,
    CaseRegistration,
    DefaultCaseRegistration,
    AttrBindingBehaviorRegistration,
    SelfBindingBehaviorRegistration,
    UpdateTriggerBindingBehaviorRegistration,
    ComposeRegistration,
    PortalRegistration,
    FocusRegistration,
    BlurRegistration,
    ShowRegistration,
    _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_23__.AuSlot,
];
const CallBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.CallBindingRenderer;
const CustomAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.CustomAttributeRenderer;
const CustomElementRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.CustomElementRenderer;
const InterpolationBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBindingRenderer;
const IteratorBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.IteratorBindingRenderer;
const LetElementRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.LetElementRenderer;
const PropertyBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.PropertyBindingRenderer;
const RefBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.RefBindingRenderer;
const SetPropertyRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetPropertyRenderer;
const TemplateControllerRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.TemplateControllerRenderer;
const ListenerBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.ListenerBindingRenderer;
const AttributeBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.AttributeBindingRenderer;
const SetAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetAttributeRenderer;
const SetClassAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetClassAttributeRenderer;
const SetStyleAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetStyleAttributeRenderer;
const StylePropertyBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.StylePropertyBindingRenderer;
const TextBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.TextBindingRenderer;
/**
 * Default renderers for:
 * - PropertyBinding: `bind`, `one-time`, `to-view`, `from-view`, `two-way`
 * - IteratorBinding: `for`
 * - CallBinding: `call`
 * - RefBinding: `ref`
 * - InterpolationBinding: `${}`
 * - SetProperty
 * - `customElement` hydration
 * - `customAttribute` hydration
 * - `templateController` hydration
 * - `let` element hydration
 * - Listener Bindings: `trigger`, `capture`, `delegate`
 * - SetAttribute
 * - StyleProperty: `style`, `css`
 * - TextBinding: `${}`
 */
const DefaultRenderers = [
    PropertyBindingRendererRegistration,
    IteratorBindingRendererRegistration,
    CallBindingRendererRegistration,
    RefBindingRendererRegistration,
    InterpolationBindingRendererRegistration,
    SetPropertyRendererRegistration,
    CustomElementRendererRegistration,
    CustomAttributeRendererRegistration,
    TemplateControllerRendererRegistration,
    LetElementRendererRegistration,
    ListenerBindingRendererRegistration,
    AttributeBindingRendererRegistration,
    SetAttributeRendererRegistration,
    SetClassAttributeRendererRegistration,
    SetStyleAttributeRendererRegistration,
    StylePropertyBindingRendererRegistration,
    TextBindingRendererRegistration,
];
/**
 * A DI configuration object containing html-specific (but environment-agnostic) registrations:
 * - `RuntimeConfiguration` from `@aurelia/runtime`
 * - `DefaultComponents`
 * - `DefaultResources`
 * - `DefaultRenderers`
 */
const StandardConfiguration = {
    /**
     * Apply this configuration to the provided container.
     */
    register(container) {
        return container.register(...DefaultComponents, ...DefaultResources, ...DefaultBindingSyntax, ...DefaultBindingLanguage, ...DefaultRenderers);
    },
    /**
     * Create a new container with this configuration applied to it.
     */
    createContainer() {
        return this.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer());
    }
};
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/create-element.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/create-element.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createElement": () => /* binding */ createElement,
/* harmony export */   "RenderPlan": () => /* binding */ RenderPlan
/* harmony export */ });
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");



function createElement(p, tagOrType, props, children) {
    if (typeof tagOrType === 'string') {
        return createElementForTag(p, tagOrType, props, children);
    }
    else if (_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElement.isType(tagOrType)) {
        return createElementForType(p, tagOrType, props, children);
    }
    else {
        throw new Error(`Invalid tagOrType.`);
    }
}
/**
 * RenderPlan. Todo: describe goal of this class
 */
class RenderPlan {
    constructor(node, instructions, dependencies) {
        this.node = node;
        this.instructions = instructions;
        this.dependencies = dependencies;
        this.lazyDefinition = void 0;
    }
    get definition() {
        if (this.lazyDefinition === void 0) {
            this.lazyDefinition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElementDefinition.create({
                name: _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElement.generateName(),
                template: this.node,
                needsCompile: typeof this.node === 'string',
                instructions: this.instructions,
                dependencies: this.dependencies,
            });
        }
        return this.lazyDefinition;
    }
    getContext(parentContainer) {
        return (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_2__.getRenderContext)(this.definition, parentContainer);
    }
    createView(parentContainer) {
        return this.getViewFactory(parentContainer).create();
    }
    getViewFactory(parentContainer) {
        return this.getContext(parentContainer).getViewFactory();
    }
    /** @internal */
    mergeInto(parent, instructions, dependencies) {
        parent.appendChild(this.node);
        instructions.push(...this.instructions);
        dependencies.push(...this.dependencies);
    }
}
function createElementForTag(p, tagName, props, children) {
    const instructions = [];
    const allInstructions = [];
    const dependencies = [];
    const element = p.document.createElement(tagName);
    let hasInstructions = false;
    if (props) {
        Object.keys(props)
            .forEach(to => {
            const value = props[to];
            if ((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.isInstruction)(value)) {
                hasInstructions = true;
                instructions.push(value);
            }
            else {
                element.setAttribute(to, value);
            }
        });
    }
    if (hasInstructions) {
        element.className = 'au';
        allInstructions.push(instructions);
    }
    if (children) {
        addChildren(p, element, children, allInstructions, dependencies);
    }
    return new RenderPlan(element, allInstructions, dependencies);
}
function createElementForType(p, Type, props, children) {
    const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElement.getDefinition(Type);
    const tagName = definition.name;
    const instructions = [];
    const allInstructions = [instructions];
    const dependencies = [];
    const childInstructions = [];
    const bindables = definition.bindables;
    const element = p.document.createElement(tagName);
    element.className = 'au';
    if (!dependencies.includes(Type)) {
        dependencies.push(Type);
    }
    instructions.push(new _renderer_js__WEBPACK_IMPORTED_MODULE_0__.HydrateElementInstruction(tagName, void 0, childInstructions, null));
    if (props) {
        Object.keys(props)
            .forEach(to => {
            const value = props[to];
            if ((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.isInstruction)(value)) {
                childInstructions.push(value);
            }
            else {
                const bindable = bindables[to];
                if (bindable !== void 0) {
                    childInstructions.push({
                        type: "re" /* setProperty */,
                        to,
                        value
                    });
                }
                else {
                    childInstructions.push(new _renderer_js__WEBPACK_IMPORTED_MODULE_0__.SetAttributeInstruction(value, to));
                }
            }
        });
    }
    if (children) {
        addChildren(p, element, children, allInstructions, dependencies);
    }
    return new RenderPlan(element, allInstructions, dependencies);
}
function addChildren(p, parent, children, allInstructions, dependencies) {
    for (let i = 0, ii = children.length; i < ii; ++i) {
        const current = children[i];
        switch (typeof current) {
            case 'string':
                parent.appendChild(p.document.createTextNode(current));
                break;
            case 'object':
                if (current instanceof p.Node) {
                    parent.appendChild(current);
                }
                else if ('mergeInto' in current) {
                    current.mergeInto(parent, allInstructions, dependencies);
                }
        }
    }
}
//# sourceMappingURL=create-element.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/dom.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INode": () => /* binding */ INode,
/* harmony export */   "IEventTarget": () => /* binding */ IEventTarget,
/* harmony export */   "IRenderLocation": () => /* binding */ IRenderLocation,
/* harmony export */   "NodeType": () => /* binding */ NodeType,
/* harmony export */   "getEffectiveParentNode": () => /* binding */ getEffectiveParentNode,
/* harmony export */   "setEffectiveParentNode": () => /* binding */ setEffectiveParentNode,
/* harmony export */   "convertToRenderLocation": () => /* binding */ convertToRenderLocation,
/* harmony export */   "isRenderLocation": () => /* binding */ isRenderLocation,
/* harmony export */   "FragmentNodeSequence": () => /* binding */ FragmentNodeSequence,
/* harmony export */   "IWindow": () => /* binding */ IWindow,
/* harmony export */   "ILocation": () => /* binding */ ILocation,
/* harmony export */   "IHistory": () => /* binding */ IHistory
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");




const INode = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('INode');
const IEventTarget = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IEventTarget', x => x.cachedCallback(handler => {
    if (handler.has(_app_root_js__WEBPACK_IMPORTED_MODULE_1__.IAppRoot, true)) {
        return handler.get(_app_root_js__WEBPACK_IMPORTED_MODULE_1__.IAppRoot).host;
    }
    return handler.get(_platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform).document;
}));
const IRenderLocation = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IRenderLocation');
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Element"] = 1] = "Element";
    NodeType[NodeType["Attr"] = 2] = "Attr";
    NodeType[NodeType["Text"] = 3] = "Text";
    NodeType[NodeType["CDATASection"] = 4] = "CDATASection";
    NodeType[NodeType["EntityReference"] = 5] = "EntityReference";
    NodeType[NodeType["Entity"] = 6] = "Entity";
    NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    NodeType[NodeType["Comment"] = 8] = "Comment";
    NodeType[NodeType["Document"] = 9] = "Document";
    NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
    NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
    NodeType[NodeType["Notation"] = 12] = "Notation";
})(NodeType || (NodeType = {}));
const effectiveParentNodeOverrides = new WeakMap();
/**
 * Returns the effective parentNode according to Aurelia's component hierarchy.
 *
 * Used by Aurelia to find the closest parent controller relative to a node.
 *
 * This method supports 3 additional scenarios that `node.parentNode` does not support:
 * - Containerless elements. The parentNode in this case is a comment precending the element under specific conditions, rather than a node wrapping the element.
 * - ShadowDOM. If a `ShadowRoot` is encountered, this method retrieves the associated controller via the metadata api to locate the original host.
 * - Portals. If the provided node was moved to a different location in the DOM by a `portal` attribute, then the original parent of the node will be returned.
 *
 * @param node - The node to get the parent for.
 * @returns Either the closest parent node, the closest `IRenderLocation` (comment node that is the containerless host), original portal host, or `null` if this is either the absolute document root or a disconnected node.
 */
function getEffectiveParentNode(node) {
    // TODO: this method needs more tests!
    // First look for any overrides
    if (effectiveParentNodeOverrides.has(node)) {
        return effectiveParentNodeOverrides.get(node);
    }
    // Then try to get the nearest au-start render location, which would be the containerless parent,
    // again looking for any overrides along the way.
    // otherwise return the normal parent node
    let containerlessOffset = 0;
    let next = node.nextSibling;
    while (next !== null) {
        if (next.nodeType === 8 /* Comment */) {
            switch (next.textContent) {
                case 'au-start':
                    // If we see an au-start before we see au-end, it will precede the host of a sibling containerless element rather than a parent.
                    // So we use the offset to ignore the next au-end
                    ++containerlessOffset;
                    break;
                case 'au-end':
                    if (containerlessOffset-- === 0) {
                        return next;
                    }
            }
        }
        next = next.nextSibling;
    }
    if (node.parentNode === null && node.nodeType === 11 /* DocumentFragment */) {
        // Could be a shadow root; see if there's a controller and if so, get the original host via the projector
        const controller = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.for(node);
        if (controller === void 0) {
            // Not a shadow root (or at least, not one created by Aurelia)
            // Nothing more we can try, just return null
            return null;
        }
        if (controller.mountTarget === 2 /* shadowRoot */) {
            return getEffectiveParentNode(controller.host);
        }
    }
    return node.parentNode;
}
function setEffectiveParentNode(childNodeOrNodeSequence, parentNode) {
    if (childNodeOrNodeSequence.platform !== void 0 && !(childNodeOrNodeSequence instanceof childNodeOrNodeSequence.platform.Node)) {
        const nodes = childNodeOrNodeSequence.childNodes;
        for (let i = 0, ii = nodes.length; i < ii; ++i) {
            effectiveParentNodeOverrides.set(nodes[i], parentNode);
        }
    }
    else {
        effectiveParentNodeOverrides.set(childNodeOrNodeSequence, parentNode);
    }
}
function convertToRenderLocation(node) {
    if (isRenderLocation(node)) {
        return node; // it's already a IRenderLocation (converted by FragmentNodeSequence)
    }
    const locationEnd = node.ownerDocument.createComment('au-end');
    const locationStart = node.ownerDocument.createComment('au-start');
    if (node.parentNode !== null) {
        node.parentNode.replaceChild(locationEnd, node);
        locationEnd.parentNode.insertBefore(locationStart, locationEnd);
    }
    locationEnd.$start = locationStart;
    return locationEnd;
}
function isRenderLocation(node) {
    return node.textContent === 'au-end';
}
class FragmentNodeSequence {
    constructor(platform, fragment) {
        this.platform = platform;
        this.fragment = fragment;
        this.isMounted = false;
        this.isLinked = false;
        this.next = void 0;
        this.refNode = void 0;
        const targetNodeList = fragment.querySelectorAll('.au');
        let i = 0;
        let ii = targetNodeList.length;
        const targets = this.targets = Array(ii);
        while (i < ii) {
            // eagerly convert all markers to RenderLocations (otherwise the renderer
            // will do it anyway) and store them in the target list (since the comments
            // can't be queried)
            const target = targetNodeList[i];
            if (target.nodeName === 'AU-M') {
                // note the renderer will still call this method, but it will just return the
                // location if it sees it's already a location
                targets[i] = convertToRenderLocation(target);
            }
            else {
                // also store non-markers for consistent ordering
                targets[i] = target;
            }
            ++i;
        }
        const childNodeList = fragment.childNodes;
        i = 0;
        ii = childNodeList.length;
        const childNodes = this.childNodes = Array(ii);
        while (i < ii) {
            childNodes[i] = childNodeList[i];
            ++i;
        }
        this.firstChild = fragment.firstChild;
        this.lastChild = fragment.lastChild;
    }
    findTargets() {
        return this.targets;
    }
    insertBefore(refNode) {
        if (this.isLinked && !!this.refNode) {
            this.addToLinked();
        }
        else {
            const parent = refNode.parentNode;
            if (this.isMounted) {
                let current = this.firstChild;
                const end = this.lastChild;
                let next;
                while (current != null) {
                    next = current.nextSibling;
                    parent.insertBefore(current, refNode);
                    if (current === end) {
                        break;
                    }
                    current = next;
                }
            }
            else {
                this.isMounted = true;
                refNode.parentNode.insertBefore(this.fragment, refNode);
            }
        }
    }
    appendTo(parent, enhance = false) {
        if (this.isMounted) {
            let current = this.firstChild;
            const end = this.lastChild;
            let next;
            while (current != null) {
                next = current.nextSibling;
                parent.appendChild(current);
                if (current === end) {
                    break;
                }
                current = next;
            }
        }
        else {
            this.isMounted = true;
            if (!enhance) {
                parent.appendChild(this.fragment);
            }
        }
    }
    remove() {
        if (this.isMounted) {
            this.isMounted = false;
            const fragment = this.fragment;
            const end = this.lastChild;
            let next;
            let current = this.firstChild;
            while (current !== null) {
                next = current.nextSibling;
                fragment.appendChild(current);
                if (current === end) {
                    break;
                }
                current = next;
            }
        }
    }
    addToLinked() {
        const refNode = this.refNode;
        const parent = refNode.parentNode;
        if (this.isMounted) {
            let current = this.firstChild;
            const end = this.lastChild;
            let next;
            while (current != null) {
                next = current.nextSibling;
                parent.insertBefore(current, refNode);
                if (current === end) {
                    break;
                }
                current = next;
            }
        }
        else {
            this.isMounted = true;
            parent.insertBefore(this.fragment, refNode);
        }
    }
    unlink() {
        this.isLinked = false;
        this.next = void 0;
        this.refNode = void 0;
    }
    link(next) {
        this.isLinked = true;
        if (isRenderLocation(next)) {
            this.refNode = next;
        }
        else {
            this.next = next;
            this.obtainRefNode();
        }
    }
    obtainRefNode() {
        if (this.next !== void 0) {
            this.refNode = this.next.firstChild;
        }
        else {
            this.refNode = void 0;
        }
    }
}
const IWindow = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IWindow', x => x.callback(handler => handler.get(_platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform).window));
const ILocation = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILocation', x => x.callback(handler => handler.get(IWindow).location));
const IHistory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IHistory', x => x.callback(handler => handler.get(IWindow).history));
//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Platform": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.Platform,
/* harmony export */   "TaskQueue": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueue,
/* harmony export */   "Task": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.Task,
/* harmony export */   "TaskAbortError": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskAbortError,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueuePriority,
/* harmony export */   "TaskStatus": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskStatus,
/* harmony export */   "BrowserPlatform": () => /* reexport safe */ _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserPlatform,
/* harmony export */   "bindable": () => /* reexport safe */ _bindable_js__WEBPACK_IMPORTED_MODULE_2__.bindable,
/* harmony export */   "Bindable": () => /* reexport safe */ _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable,
/* harmony export */   "BindableDefinition": () => /* reexport safe */ _bindable_js__WEBPACK_IMPORTED_MODULE_2__.BindableDefinition,
/* harmony export */   "BindableObserver": () => /* reexport safe */ _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_3__.BindableObserver,
/* harmony export */   "DebounceBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DebounceBindingBehaviorRegistration,
/* harmony export */   "OneTimeBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.OneTimeBindingBehaviorRegistration,
/* harmony export */   "ToViewBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ToViewBindingBehaviorRegistration,
/* harmony export */   "FromViewBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.FromViewBindingBehaviorRegistration,
/* harmony export */   "SignalBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SignalBindingBehaviorRegistration,
/* harmony export */   "ThrottleBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ThrottleBindingBehaviorRegistration,
/* harmony export */   "TwoWayBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TwoWayBindingBehaviorRegistration,
/* harmony export */   "BindingModeBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.BindingModeBehavior,
/* harmony export */   "OneTimeBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.OneTimeBindingBehavior,
/* harmony export */   "ToViewBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.ToViewBindingBehavior,
/* harmony export */   "FromViewBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.FromViewBindingBehavior,
/* harmony export */   "TwoWayBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.TwoWayBindingBehavior,
/* harmony export */   "DebounceBindingBehavior": () => /* reexport safe */ _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__.DebounceBindingBehavior,
/* harmony export */   "SignalBindingBehavior": () => /* reexport safe */ _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__.SignalBindingBehavior,
/* harmony export */   "ThrottleBindingBehavior": () => /* reexport safe */ _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__.ThrottleBindingBehavior,
/* harmony export */   "alias": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.alias,
/* harmony export */   "registerAliases": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.registerAliases,
/* harmony export */   "CallFunctionExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CallFunctionExpression,
/* harmony export */   "CustomExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CustomExpression,
/* harmony export */   "BindingBehaviorExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorExpression,
/* harmony export */   "ValueConverterExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ValueConverterExpression,
/* harmony export */   "AssignExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AssignExpression,
/* harmony export */   "ConditionalExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ConditionalExpression,
/* harmony export */   "AccessThisExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessThisExpression,
/* harmony export */   "AccessScopeExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessScopeExpression,
/* harmony export */   "AccessMemberExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessMemberExpression,
/* harmony export */   "AccessKeyedExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessKeyedExpression,
/* harmony export */   "CallScopeExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CallScopeExpression,
/* harmony export */   "CallMemberExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CallMemberExpression,
/* harmony export */   "BinaryExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BinaryExpression,
/* harmony export */   "UnaryExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.UnaryExpression,
/* harmony export */   "PrimitiveLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.PrimitiveLiteralExpression,
/* harmony export */   "HtmlLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.HtmlLiteralExpression,
/* harmony export */   "ArrayLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayLiteralExpression,
/* harmony export */   "ObjectLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ObjectLiteralExpression,
/* harmony export */   "TemplateExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.TemplateExpression,
/* harmony export */   "TaggedTemplateExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.TaggedTemplateExpression,
/* harmony export */   "ArrayBindingPattern": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayBindingPattern,
/* harmony export */   "ObjectBindingPattern": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ObjectBindingPattern,
/* harmony export */   "BindingIdentifier": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingIdentifier,
/* harmony export */   "ForOfStatement": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ForOfStatement,
/* harmony export */   "Interpolation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Interpolation,
/* harmony export */   "connectable": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.connectable,
/* harmony export */   "BindingMediator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingMediator,
/* harmony export */   "IExpressionParser": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.IExpressionParser,
/* harmony export */   "BindingType": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingType,
/* harmony export */   "parseExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.parseExpression,
/* harmony export */   "Char": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Char,
/* harmony export */   "Access": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Access,
/* harmony export */   "Precedence": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Precedence,
/* harmony export */   "parse": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.parse,
/* harmony export */   "ParserState": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ParserState,
/* harmony export */   "ArrayObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayObserver,
/* harmony export */   "ArrayIndexObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayIndexObserver,
/* harmony export */   "enableArrayObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.enableArrayObservation,
/* harmony export */   "disableArrayObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.disableArrayObservation,
/* harmony export */   "applyMutationsToIndices": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.applyMutationsToIndices,
/* harmony export */   "synchronizeIndices": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.synchronizeIndices,
/* harmony export */   "MapObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.MapObserver,
/* harmony export */   "enableMapObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.enableMapObservation,
/* harmony export */   "disableMapObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.disableMapObservation,
/* harmony export */   "SetObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.SetObserver,
/* harmony export */   "enableSetObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.enableSetObservation,
/* harmony export */   "disableSetObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.disableSetObservation,
/* harmony export */   "BindingContext": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingContext,
/* harmony export */   "Scope": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Scope,
/* harmony export */   "OverrideContext": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.OverrideContext,
/* harmony export */   "CollectionLengthObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CollectionLengthObserver,
/* harmony export */   "CollectionSizeObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CollectionSizeObserver,
/* harmony export */   "IDirtyChecker": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.IDirtyChecker,
/* harmony export */   "DirtyCheckProperty": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.DirtyCheckProperty,
/* harmony export */   "DirtyCheckSettings": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.DirtyCheckSettings,
/* harmony export */   "ComputedObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ComputedObserver,
/* harmony export */   "observable": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.observable,
/* harmony export */   "IObserverLocator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.IObserverLocator,
/* harmony export */   "INodeObserverLocator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.INodeObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.getCollectionObserver,
/* harmony export */   "ObserverLocator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ObserverLocator,
/* harmony export */   "PrimitiveObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.PrimitiveObserver,
/* harmony export */   "PropertyAccessor": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.PropertyAccessor,
/* harmony export */   "SetterObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.SetterObserver,
/* harmony export */   "ISignaler": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ISignaler,
/* harmony export */   "subscriberCollection": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.subscriberCollection,
/* harmony export */   "bindingBehavior": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.bindingBehavior,
/* harmony export */   "BindingBehavior": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehavior,
/* harmony export */   "BindingBehaviorDefinition": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorDefinition,
/* harmony export */   "BindingInterceptor": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingInterceptor,
/* harmony export */   "BindingBehaviorFactory": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorFactory,
/* harmony export */   "BindingBehaviorStrategy": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorStrategy,
/* harmony export */   "ValueConverter": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ValueConverter,
/* harmony export */   "ValueConverterDefinition": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ValueConverterDefinition,
/* harmony export */   "valueConverter": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.valueConverter,
/* harmony export */   "BindingMode": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingMode,
/* harmony export */   "ExpressionKind": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ExpressionKind,
/* harmony export */   "LifecycleFlags": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.LifecycleFlags,
/* harmony export */   "AccessorType": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessorType,
/* harmony export */   "CollectionKind": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CollectionKind,
/* harmony export */   "DelegationStrategy": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.DelegationStrategy,
/* harmony export */   "isIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.isIndexMap,
/* harmony export */   "copyIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.copyIndexMap,
/* harmony export */   "cloneIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.cloneIndexMap,
/* harmony export */   "createIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.createIndexMap,
/* harmony export */   "Aurelia": () => /* reexport safe */ _aurelia_js__WEBPACK_IMPORTED_MODULE_10__.Aurelia,
/* harmony export */   "IAurelia": () => /* reexport safe */ _aurelia_js__WEBPACK_IMPORTED_MODULE_10__.IAurelia,
/* harmony export */   "AppRoot": () => /* reexport safe */ _app_root_js__WEBPACK_IMPORTED_MODULE_11__.AppRoot,
/* harmony export */   "IAppRoot": () => /* reexport safe */ _app_root_js__WEBPACK_IMPORTED_MODULE_11__.IAppRoot,
/* harmony export */   "AppTask": () => /* reexport safe */ _app_task_js__WEBPACK_IMPORTED_MODULE_12__.AppTask,
/* harmony export */   "IAppTask": () => /* reexport safe */ _app_task_js__WEBPACK_IMPORTED_MODULE_12__.IAppTask,
/* harmony export */   "AttrSyntax": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.AttrSyntax,
/* harmony export */   "IAttributeParser": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.IAttributeParser,
/* harmony export */   "attributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.attributePattern,
/* harmony export */   "IAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.IAttributePattern,
/* harmony export */   "AttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.AttributePattern,
/* harmony export */   "Interpretation": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.Interpretation,
/* harmony export */   "ISyntaxInterpreter": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.ISyntaxInterpreter,
/* harmony export */   "AtPrefixedTriggerAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.AtPrefixedTriggerAttributePattern,
/* harmony export */   "ColonPrefixedBindAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.ColonPrefixedBindAttributePattern,
/* harmony export */   "DotSeparatedAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.DotSeparatedAttributePattern,
/* harmony export */   "RefAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.RefAttributePattern,
/* harmony export */   "bindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.bindingCommand,
/* harmony export */   "BindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.BindingCommand,
/* harmony export */   "BindingCommandDefinition": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.BindingCommandDefinition,
/* harmony export */   "getTarget": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.getTarget,
/* harmony export */   "CallBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.CallBindingCommand,
/* harmony export */   "DefaultBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.DefaultBindingCommand,
/* harmony export */   "ForBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.ForBindingCommand,
/* harmony export */   "FromViewBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.FromViewBindingCommand,
/* harmony export */   "OneTimeBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.OneTimeBindingCommand,
/* harmony export */   "ToViewBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.ToViewBindingCommand,
/* harmony export */   "TwoWayBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.TwoWayBindingCommand,
/* harmony export */   "TriggerBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.TriggerBindingCommand,
/* harmony export */   "DelegateBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.DelegateBindingCommand,
/* harmony export */   "CaptureBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.CaptureBindingCommand,
/* harmony export */   "AttrBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.AttrBindingCommand,
/* harmony export */   "ClassBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.ClassBindingCommand,
/* harmony export */   "StyleBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.StyleBindingCommand,
/* harmony export */   "IAttrSyntaxTransformer": () => /* reexport safe */ _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_15__.IAttrSyntaxTransformer,
/* harmony export */   "Listener": () => /* reexport safe */ _binding_listener_js__WEBPACK_IMPORTED_MODULE_16__.Listener,
/* harmony export */   "AttributeBinding": () => /* reexport safe */ _binding_attribute_js__WEBPACK_IMPORTED_MODULE_17__.AttributeBinding,
/* harmony export */   "CallBinding": () => /* reexport safe */ _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_18__.CallBinding,
/* harmony export */   "InterpolationBinding": () => /* reexport safe */ _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_19__.InterpolationBinding,
/* harmony export */   "LetBinding": () => /* reexport safe */ _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_20__.LetBinding,
/* harmony export */   "PropertyBinding": () => /* reexport safe */ _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_21__.PropertyBinding,
/* harmony export */   "RefBinding": () => /* reexport safe */ _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_22__.RefBinding,
/* harmony export */   "IRenderer": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.IRenderer,
/* harmony export */   "ITemplateCompiler": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.ITemplateCompiler,
/* harmony export */   "renderer": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.renderer,
/* harmony export */   "CallBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.CallBindingInstruction,
/* harmony export */   "HydrateAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateAttributeInstruction,
/* harmony export */   "HydrateElementInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateElementInstruction,
/* harmony export */   "HydrateTemplateController": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateTemplateController,
/* harmony export */   "InterpolationInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.InterpolationInstruction,
/* harmony export */   "IteratorBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.IteratorBindingInstruction,
/* harmony export */   "LetBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.LetBindingInstruction,
/* harmony export */   "HydrateLetElementInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateLetElementInstruction,
/* harmony export */   "RefBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.RefBindingInstruction,
/* harmony export */   "SetPropertyInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetPropertyInstruction,
/* harmony export */   "AttributeBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.AttributeBindingInstruction,
/* harmony export */   "ListenerBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.ListenerBindingInstruction,
/* harmony export */   "PropertyBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.PropertyBindingInstruction,
/* harmony export */   "SetAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetAttributeInstruction,
/* harmony export */   "SetClassAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetClassAttributeInstruction,
/* harmony export */   "SetStyleAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetStyleAttributeInstruction,
/* harmony export */   "StylePropertyBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.StylePropertyBindingInstruction,
/* harmony export */   "TextBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.TextBindingInstruction,
/* harmony export */   "isInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.isInstruction,
/* harmony export */   "IInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.IInstruction,
/* harmony export */   "InstructionType": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.InstructionType,
/* harmony export */   "AttributeNSAccessor": () => /* reexport safe */ _observation_attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_24__.AttributeNSAccessor,
/* harmony export */   "CheckedObserver": () => /* reexport safe */ _observation_checked_observer_js__WEBPACK_IMPORTED_MODULE_25__.CheckedObserver,
/* harmony export */   "ClassAttributeAccessor": () => /* reexport safe */ _observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_26__.ClassAttributeAccessor,
/* harmony export */   "DataAttributeAccessor": () => /* reexport safe */ _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_27__.DataAttributeAccessor,
/* harmony export */   "IEventDelegator": () => /* reexport safe */ _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__.IEventDelegator,
/* harmony export */   "EventSubscriber": () => /* reexport safe */ _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__.EventSubscriber,
/* harmony export */   "EventDelegator": () => /* reexport safe */ _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__.EventDelegator,
/* harmony export */   "NodeObserverConfig": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_29__.NodeObserverConfig,
/* harmony export */   "NodeObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_29__.NodeObserverLocator,
/* harmony export */   "SelectValueObserver": () => /* reexport safe */ _observation_select_value_observer_js__WEBPACK_IMPORTED_MODULE_30__.SelectValueObserver,
/* harmony export */   "StyleAttributeAccessor": () => /* reexport safe */ _observation_style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_31__.StyleAttributeAccessor,
/* harmony export */   "ISVGAnalyzer": () => /* reexport safe */ _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__.ISVGAnalyzer,
/* harmony export */   "SVGAnalyzer": () => /* reexport safe */ _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__.SVGAnalyzer,
/* harmony export */   "NoopSVGAnalyzer": () => /* reexport safe */ _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__.NoopSVGAnalyzer,
/* harmony export */   "ValueAttributeObserver": () => /* reexport safe */ _observation_value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_33__.ValueAttributeObserver,
/* harmony export */   "AttrBindingBehavior": () => /* reexport safe */ _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_34__.AttrBindingBehavior,
/* harmony export */   "SelfBindingBehavior": () => /* reexport safe */ _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_35__.SelfBindingBehavior,
/* harmony export */   "UpdateTriggerBindingBehavior": () => /* reexport safe */ _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_36__.UpdateTriggerBindingBehavior,
/* harmony export */   "customAttribute": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.customAttribute,
/* harmony export */   "CustomAttribute": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.CustomAttribute,
/* harmony export */   "CustomAttributeDefinition": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.CustomAttributeDefinition,
/* harmony export */   "templateController": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.templateController,
/* harmony export */   "FrequentMutations": () => /* reexport safe */ _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_38__.FrequentMutations,
/* harmony export */   "ObserveShallow": () => /* reexport safe */ _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_38__.ObserveShallow,
/* harmony export */   "If": () => /* reexport safe */ _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_39__.If,
/* harmony export */   "Else": () => /* reexport safe */ _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_39__.Else,
/* harmony export */   "Repeat": () => /* reexport safe */ _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_40__.Repeat,
/* harmony export */   "With": () => /* reexport safe */ _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_41__.With,
/* harmony export */   "Switch": () => /* reexport safe */ _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__.Switch,
/* harmony export */   "Case": () => /* reexport safe */ _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__.Case,
/* harmony export */   "DefaultCase": () => /* reexport safe */ _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__.DefaultCase,
/* harmony export */   "Blur": () => /* reexport safe */ _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_43__.Blur,
/* harmony export */   "BlurManager": () => /* reexport safe */ _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_43__.BlurManager,
/* harmony export */   "Focus": () => /* reexport safe */ _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_44__.Focus,
/* harmony export */   "Portal": () => /* reexport safe */ _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_45__.Portal,
/* harmony export */   "AuSlot": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.AuSlot,
/* harmony export */   "IProjections": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.IProjections,
/* harmony export */   "SlotInfo": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.SlotInfo,
/* harmony export */   "AuSlotContentType": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.AuSlotContentType,
/* harmony export */   "RegisteredProjections": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.RegisteredProjections,
/* harmony export */   "IProjectionProvider": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.IProjectionProvider,
/* harmony export */   "ProjectionContext": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.ProjectionContext,
/* harmony export */   "containerless": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.containerless,
/* harmony export */   "customElement": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.customElement,
/* harmony export */   "CustomElement": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.CustomElement,
/* harmony export */   "CustomElementDefinition": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.CustomElementDefinition,
/* harmony export */   "useShadowDOM": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.useShadowDOM,
/* harmony export */   "Compose": () => /* reexport safe */ _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_48__.Compose,
/* harmony export */   "ISanitizer": () => /* reexport safe */ _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_49__.ISanitizer,
/* harmony export */   "SanitizeValueConverter": () => /* reexport safe */ _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_49__.SanitizeValueConverter,
/* harmony export */   "ViewValueConverter": () => /* reexport safe */ _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_50__.ViewValueConverter,
/* harmony export */   "ITemplateCompilerRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ITemplateCompilerRegistration,
/* harmony export */   "INodeObserverLocatorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.INodeObserverLocatorRegistration,
/* harmony export */   "DefaultComponents": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultComponents,
/* harmony export */   "RefAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RefAttributePatternRegistration,
/* harmony export */   "DotSeparatedAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DotSeparatedAttributePatternRegistration,
/* harmony export */   "DefaultBindingSyntax": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultBindingSyntax,
/* harmony export */   "AtPrefixedTriggerAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AtPrefixedTriggerAttributePatternRegistration,
/* harmony export */   "ColonPrefixedBindAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ColonPrefixedBindAttributePatternRegistration,
/* harmony export */   "ShortHandBindingSyntax": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ShortHandBindingSyntax,
/* harmony export */   "SVGAnalyzerRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SVGAnalyzerRegistration,
/* harmony export */   "CallBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CallBindingCommandRegistration,
/* harmony export */   "DefaultBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultBindingCommandRegistration,
/* harmony export */   "ForBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ForBindingCommandRegistration,
/* harmony export */   "RefBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RefBindingCommandRegistration,
/* harmony export */   "FromViewBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.FromViewBindingCommandRegistration,
/* harmony export */   "OneTimeBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.OneTimeBindingCommandRegistration,
/* harmony export */   "ToViewBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ToViewBindingCommandRegistration,
/* harmony export */   "TwoWayBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TwoWayBindingCommandRegistration,
/* harmony export */   "TriggerBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TriggerBindingCommandRegistration,
/* harmony export */   "DelegateBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DelegateBindingCommandRegistration,
/* harmony export */   "CaptureBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CaptureBindingCommandRegistration,
/* harmony export */   "AttrBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AttrBindingCommandRegistration,
/* harmony export */   "ClassBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ClassBindingCommandRegistration,
/* harmony export */   "StyleBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.StyleBindingCommandRegistration,
/* harmony export */   "DefaultBindingLanguage": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultBindingLanguage,
/* harmony export */   "ViewValueConverterRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ViewValueConverterRegistration,
/* harmony export */   "SanitizeValueConverterRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SanitizeValueConverterRegistration,
/* harmony export */   "IfRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.IfRegistration,
/* harmony export */   "ElseRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ElseRegistration,
/* harmony export */   "RepeatRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RepeatRegistration,
/* harmony export */   "WithRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.WithRegistration,
/* harmony export */   "AttrBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AttrBindingBehaviorRegistration,
/* harmony export */   "SelfBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SelfBindingBehaviorRegistration,
/* harmony export */   "UpdateTriggerBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.UpdateTriggerBindingBehaviorRegistration,
/* harmony export */   "ComposeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ComposeRegistration,
/* harmony export */   "DefaultResources": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultResources,
/* harmony export */   "AttributeBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AttributeBindingRendererRegistration,
/* harmony export */   "ListenerBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ListenerBindingRendererRegistration,
/* harmony export */   "SetAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetAttributeRendererRegistration,
/* harmony export */   "SetClassAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetClassAttributeRendererRegistration,
/* harmony export */   "SetStyleAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetStyleAttributeRendererRegistration,
/* harmony export */   "StylePropertyBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.StylePropertyBindingRendererRegistration,
/* harmony export */   "TextBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TextBindingRendererRegistration,
/* harmony export */   "RefBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RefBindingRendererRegistration,
/* harmony export */   "CallBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CallBindingRendererRegistration,
/* harmony export */   "CustomAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CustomAttributeRendererRegistration,
/* harmony export */   "CustomElementRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CustomElementRendererRegistration,
/* harmony export */   "InterpolationBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBindingRendererRegistration,
/* harmony export */   "IteratorBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.IteratorBindingRendererRegistration,
/* harmony export */   "LetElementRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.LetElementRendererRegistration,
/* harmony export */   "PropertyBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.PropertyBindingRendererRegistration,
/* harmony export */   "SetPropertyRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetPropertyRendererRegistration,
/* harmony export */   "TemplateControllerRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TemplateControllerRendererRegistration,
/* harmony export */   "DefaultRenderers": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultRenderers,
/* harmony export */   "StandardConfiguration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.StandardConfiguration,
/* harmony export */   "TemplateBinder": () => /* reexport safe */ _template_binder_js__WEBPACK_IMPORTED_MODULE_51__.TemplateBinder,
/* harmony export */   "ITemplateElementFactory": () => /* reexport safe */ _template_element_factory_js__WEBPACK_IMPORTED_MODULE_52__.ITemplateElementFactory,
/* harmony export */   "ChildrenDefinition": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.ChildrenDefinition,
/* harmony export */   "Children": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.Children,
/* harmony export */   "children": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.children,
/* harmony export */   "ChildrenObserver": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.ChildrenObserver,
/* harmony export */   "Controller": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.Controller,
/* harmony export */   "isCustomElementController": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.isCustomElementController,
/* harmony export */   "isCustomElementViewModel": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.isCustomElementViewModel,
/* harmony export */   "ViewModelKind": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.ViewModelKind,
/* harmony export */   "IController": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.IController,
/* harmony export */   "getRenderContext": () => /* reexport safe */ _templating_render_context_js__WEBPACK_IMPORTED_MODULE_55__.getRenderContext,
/* harmony export */   "isRenderContext": () => /* reexport safe */ _templating_render_context_js__WEBPACK_IMPORTED_MODULE_55__.isRenderContext,
/* harmony export */   "ViewFactory": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.ViewFactory,
/* harmony export */   "IViewFactory": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.IViewFactory,
/* harmony export */   "IViewLocator": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.IViewLocator,
/* harmony export */   "ViewLocator": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.ViewLocator,
/* harmony export */   "view": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.view,
/* harmony export */   "Views": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.Views,
/* harmony export */   "createElement": () => /* reexport safe */ _create_element_js__WEBPACK_IMPORTED_MODULE_57__.createElement,
/* harmony export */   "RenderPlan": () => /* reexport safe */ _create_element_js__WEBPACK_IMPORTED_MODULE_57__.RenderPlan,
/* harmony export */   "INode": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.INode,
/* harmony export */   "IEventTarget": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IEventTarget,
/* harmony export */   "IRenderLocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IRenderLocation,
/* harmony export */   "NodeType": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.NodeType,
/* harmony export */   "FragmentNodeSequence": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.FragmentNodeSequence,
/* harmony export */   "IHistory": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IHistory,
/* harmony export */   "IWindow": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IWindow,
/* harmony export */   "ILocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.ILocation,
/* harmony export */   "getEffectiveParentNode": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.getEffectiveParentNode,
/* harmony export */   "setEffectiveParentNode": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.setEffectiveParentNode,
/* harmony export */   "convertToRenderLocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.convertToRenderLocation,
/* harmony export */   "isRenderLocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.isRenderLocation,
/* harmony export */   "IPlatform": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_59__.IPlatform,
/* harmony export */   "BindableInfo": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.BindableInfo,
/* harmony export */   "ElementInfo": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.ElementInfo,
/* harmony export */   "AttrInfo": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.AttrInfo,
/* harmony export */   "BindingSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.BindingSymbol,
/* harmony export */   "CustomAttributeSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.CustomAttributeSymbol,
/* harmony export */   "CustomElementSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.CustomElementSymbol,
/* harmony export */   "LetElementSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.LetElementSymbol,
/* harmony export */   "PlainAttributeSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.PlainAttributeSymbol,
/* harmony export */   "PlainElementSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.PlainElementSymbol,
/* harmony export */   "SymbolFlags": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.SymbolFlags,
/* harmony export */   "TemplateControllerSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.TemplateControllerSymbol,
/* harmony export */   "TextSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.TextSymbol,
/* harmony export */   "ProjectionSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.ProjectionSymbol,
/* harmony export */   "CSSModulesProcessorRegistry": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.CSSModulesProcessorRegistry,
/* harmony export */   "cssModules": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.cssModules,
/* harmony export */   "ShadowDOMRegistry": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.ShadowDOMRegistry,
/* harmony export */   "IShadowDOMStyleFactory": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.IShadowDOMStyleFactory,
/* harmony export */   "shadowCSS": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.shadowCSS,
/* harmony export */   "StyleConfiguration": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.StyleConfiguration,
/* harmony export */   "AdoptedStyleSheetsStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.AdoptedStyleSheetsStyles,
/* harmony export */   "StyleElementStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.StyleElementStyles,
/* harmony export */   "IShadowDOMStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.IShadowDOMStyles,
/* harmony export */   "IShadowDOMGlobalStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.IShadowDOMGlobalStyles,
/* harmony export */   "Watch": () => /* reexport safe */ _watch_js__WEBPACK_IMPORTED_MODULE_62__.Watch,
/* harmony export */   "watch": () => /* reexport safe */ _watch_js__WEBPACK_IMPORTED_MODULE_62__.watch,
/* harmony export */   "ComputedWatcher": () => /* reexport safe */ _templating_watchers_js__WEBPACK_IMPORTED_MODULE_63__.ComputedWatcher,
/* harmony export */   "ExpressionWatcher": () => /* reexport safe */ _templating_watchers_js__WEBPACK_IMPORTED_MODULE_63__.ExpressionWatcher
/* harmony export */ });
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");
/* harmony import */ var _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform-browser */ "./node_modules/@aurelia/platform-browser/dist/esm/index.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observation/bindable-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js");
/* harmony import */ var _configuration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./configuration.js */ "./node_modules/@aurelia/runtime-html/dist/esm/configuration.js");
/* harmony import */ var _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding-behaviors/binding-mode.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js");
/* harmony import */ var _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./binding-behaviors/debounce.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js");
/* harmony import */ var _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./binding-behaviors/signals.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js");
/* harmony import */ var _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./binding-behaviors/throttle.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _aurelia_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./aurelia.js */ "./node_modules/@aurelia/runtime-html/dist/esm/aurelia.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _app_task_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./app-task.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js");
/* harmony import */ var _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resources/attribute-pattern.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js");
/* harmony import */ var _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./resources/binding-command.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js");
/* harmony import */ var _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./attribute-syntax-transformer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js");
/* harmony import */ var _binding_listener_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./binding/listener.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js");
/* harmony import */ var _binding_attribute_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./binding/attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js");
/* harmony import */ var _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./binding/call-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js");
/* harmony import */ var _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./binding/interpolation-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js");
/* harmony import */ var _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./binding/let-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js");
/* harmony import */ var _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./binding/property-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js");
/* harmony import */ var _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./binding/ref-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _observation_attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./observation/attribute-ns-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js");
/* harmony import */ var _observation_checked_observer_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./observation/checked-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js");
/* harmony import */ var _observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./observation/class-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js");
/* harmony import */ var _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./observation/data-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js");
/* harmony import */ var _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./observation/event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./observation/observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");
/* harmony import */ var _observation_select_value_observer_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./observation/select-value-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js");
/* harmony import */ var _observation_style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./observation/style-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js");
/* harmony import */ var _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./observation/svg-analyzer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js");
/* harmony import */ var _observation_value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./observation/value-attribute-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js");
/* harmony import */ var _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./resources/binding-behaviors/attr.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js");
/* harmony import */ var _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./resources/binding-behaviors/self.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js");
/* harmony import */ var _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./resources/binding-behaviors/update-trigger.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./resources/template-controllers/flags.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js");
/* harmony import */ var _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./resources/template-controllers/if.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js");
/* harmony import */ var _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./resources/template-controllers/repeat.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js");
/* harmony import */ var _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./resources/template-controllers/with.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js");
/* harmony import */ var _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./resources/template-controllers/switch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js");
/* harmony import */ var _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./resources/custom-attributes/blur.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js");
/* harmony import */ var _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./resources/custom-attributes/focus.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js");
/* harmony import */ var _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./resources/template-controllers/portal.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./resources/custom-elements/compose.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js");
/* harmony import */ var _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./resources/value-converters/sanitize.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js");
/* harmony import */ var _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./resources/value-converters/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js");
/* harmony import */ var _template_binder_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./template-binder.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js");
/* harmony import */ var _template_element_factory_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./template-element-factory.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js");
/* harmony import */ var _templating_children_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./templating/children.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _create_element_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./create-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/create-element.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./semantic-model.js */ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js");
/* harmony import */ var _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./templating/styles.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js");
/* harmony import */ var _watch_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./watch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js");
/* harmony import */ var _templating_watchers_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./templating/watchers.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js");























































// These exports are temporary until we have a proper way to unit test them










//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeNSAccessor": () => /* binding */ AttributeNSAccessor
/* harmony export */ });
const nsMap = Object.create(null);
/**
 * Attribute accessor in a XML document/element that can be accessed via a namespace.
 * Wraps [`getAttributeNS`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS).
 */
class AttributeNSAccessor {
    constructor(namespace) {
        this.namespace = namespace;
        this.currentValue = null;
        // ObserverType.Layout is not always true, it depends on the property
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    static forNs(ns) {
        return nsMap[ns] ?? (nsMap[ns] = new AttributeNSAccessor(ns));
    }
    getValue(obj, propertyKey) {
        return obj.getAttributeNS(this.namespace, propertyKey);
    }
    setValue(newValue, flags, obj, key) {
        if (newValue == void 0) {
            obj.removeAttributeNS(this.namespace, key);
        }
        else {
            obj.setAttributeNS(this.namespace, key, newValue);
        }
    }
}
//# sourceMappingURL=attribute-ns-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindableObserver": () => /* binding */ BindableObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


class BindableObserver {
    constructor(obj, propertyKey, cbName, set, $controller) {
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.set = set;
        this.$controller = $controller;
        this.currentValue = void 0;
        this.oldValue = void 0;
        const cb = obj[cbName];
        const cbAll = obj.propertyChanged;
        const hasCb = this.hasCb = typeof cb === 'function';
        const hasCbAll = this.hasCbAll = typeof cbAll === 'function';
        const hasSetter = this.hasSetter = set !== _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop;
        this.cb = hasCb ? cb : _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop;
        this.cbAll = this.hasCbAll ? cbAll : _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop;
        // when user declare @bindable({ set })
        // it's expected to work from the start,
        // regardless where the assignment comes from: either direct view model assignment or from binding during render
        // so if either getter/setter config is present, alter the accessor straight await
        if (this.cb === void 0 && !hasCbAll && !hasSetter) {
            this.observing = false;
        }
        else {
            this.observing = true;
            const val = obj[propertyKey];
            this.currentValue = hasSetter && val !== void 0 ? set(val) : val;
            this.createGetterSetter();
        }
    }
    get type() { return 1 /* Observer */; }
    getValue() {
        return this.currentValue;
    }
    setValue(newValue, flags) {
        if (this.hasSetter) {
            newValue = this.set(newValue);
        }
        if (this.observing) {
            const currentValue = this.currentValue;
            if (Object.is(newValue, currentValue)) {
                return;
            }
            this.currentValue = newValue;
            // todo: controller (if any) state should determine the invocation instead
            if ((flags & 32 /* fromBind */) === 0 || (flags & 16 /* updateSource */) > 0) {
                if (this.hasCb) {
                    this.cb.call(this.obj, newValue, currentValue, flags);
                }
                if (this.hasCbAll) {
                    this.cbAll.call(this.obj, this.propertyKey, newValue, currentValue, flags);
                }
            }
            this.subs.notify(newValue, currentValue, flags);
        }
        else {
            // See SetterObserver.setValue for explanation
            this.obj[this.propertyKey] = newValue;
        }
    }
    subscribe(subscriber) {
        if (!this.observing === false) {
            this.observing = true;
            const currentValue = this.obj[this.propertyKey];
            this.currentValue = this.hasSetter
                ? this.set(currentValue)
                : currentValue;
            this.createGetterSetter();
        }
        this.subs.add(subscriber);
    }
    createGetterSetter() {
        Reflect.defineProperty(this.obj, this.propertyKey, {
            enumerable: true,
            configurable: true,
            get: ( /* Bindable Observer */) => this.currentValue,
            set: (/* Bindable Observer */ value) => {
                this.setValue(value, 0 /* none */);
            }
        });
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)(BindableObserver);
//# sourceMappingURL=bindable-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CheckedObserver": () => /* binding */ CheckedObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observer_locator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");


function defaultMatcher(a, b) {
    return a === b;
}
class CheckedObserver {
    constructor(obj, 
    // deepscan-disable-next-line
    _key, handler, observerLocator) {
        this.handler = handler;
        this.observerLocator = observerLocator;
        this.value = void 0;
        this.oldValue = void 0;
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
        this.collectionObserver = void 0;
        this.valueObserver = void 0;
        this.obj = obj;
    }
    getValue() {
        return this.value;
    }
    setValue(newValue, flags) {
        const currentValue = this.value;
        if (newValue === currentValue) {
            return;
        }
        this.value = newValue;
        this.oldValue = currentValue;
        this.observe();
        this.synchronizeElement();
        this.subs.notify(newValue, currentValue, flags);
    }
    handleCollectionChange(indexMap, flags) {
        this.synchronizeElement();
    }
    handleChange(newValue, previousValue, flags) {
        this.synchronizeElement();
    }
    synchronizeElement() {
        const currentValue = this.value;
        const obj = this.obj;
        const elementValue = Object.prototype.hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;
        const isRadio = obj.type === 'radio';
        const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
        if (isRadio) {
            obj.checked = !!matcher(currentValue, elementValue);
        }
        else if (currentValue === true) {
            obj.checked = true;
        }
        else {
            let hasMatch = false;
            if (currentValue instanceof Array) {
                hasMatch = currentValue.findIndex(item => !!matcher(item, elementValue)) !== -1;
            }
            else if (currentValue instanceof Set) {
                for (const v of currentValue) {
                    if (matcher(v, elementValue)) {
                        hasMatch = true;
                        break;
                    }
                }
            }
            else if (currentValue instanceof Map) {
                for (const pair of currentValue) {
                    const existingItem = pair[0];
                    const $isChecked = pair[1];
                    // a potential complain, when only `true` is supported
                    // but it's consistent with array
                    if (matcher(existingItem, elementValue) && $isChecked === true) {
                        hasMatch = true;
                        break;
                    }
                }
            }
            obj.checked = hasMatch;
        }
    }
    handleEvent() {
        let currentValue = this.oldValue = this.value;
        const obj = this.obj;
        const elementValue = Object.prototype.hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;
        const isChecked = obj.checked;
        const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
        if (obj.type === 'checkbox') {
            if (currentValue instanceof Array) {
                // Array binding steps on a change event:
                // 1. find corresponding item INDEX in the Set based on current model/value and matcher
                // 2. is the checkbox checked?
                //    2.1. Yes: is the corresponding item in the Array (index === -1)?
                //        2.1.1 No: push the current model/value to the Array
                //    2.2. No: is the corresponding item in the Array (index !== -1)?
                //        2.2.1: Yes: remove the corresponding item
                // =================================================
                const index = currentValue.findIndex(item => !!matcher(item, elementValue));
                // if the checkbox is checkde, and there's no matching value in the existing array
                // add the checkbox model/value to the array
                if (isChecked && index === -1) {
                    currentValue.push(elementValue);
                }
                else if (!isChecked && index !== -1) {
                    // if the checkbox is not checked, and found a matching item in the array
                    // based on the checkbox model/value
                    // remove the existing item
                    currentValue.splice(index, 1);
                }
                // when existing currentValue is an array,
                // do not invoke callback as only the array obj has changed
                return;
            }
            else if (currentValue instanceof Set) {
                // Set binding steps on a change event:
                // 1. find corresponding item in the Set based on current model/value and matcher
                // 2. is the checkbox checked?
                //    2.1. Yes: is the corresponding item in the Set?
                //        2.1.1 No: add the current model/value to the Set
                //    2.2. No: is the corresponding item in the Set?
                //        2.2.1: Yes: remove the corresponding item
                // =================================================
                // 1. find corresponding item
                const unset = {};
                let existingItem = unset;
                for (const value of currentValue) {
                    if (matcher(value, elementValue) === true) {
                        existingItem = value;
                        break;
                    }
                }
                // 2.1. Checkbox is checked, is the corresponding item in the Set?
                //
                // if checkbox is checked and there's no value in the existing Set
                // add the checkbox model/value to the Set
                if (isChecked && existingItem === unset) {
                    // 2.1.1. add the current model/value to the Set
                    currentValue.add(elementValue);
                }
                else if (!isChecked && existingItem !== unset) {
                    // 2.2.1 Checkbox is unchecked, corresponding is in the Set
                    //
                    // if checkbox is not checked, and found a matching item in the Set
                    // based on the checkbox model/value
                    // remove the existing item
                    currentValue.delete(existingItem);
                }
                // when existing value is a Set,
                // do not invoke callback as only the Set has been mutated
                return;
            }
            else if (currentValue instanceof Map) {
                // Map binding steps on a change event
                // 1. find corresponding item in the Map based on current model/value and matcher
                // 2. Set the value of the corresponding item in the Map based on checked state of the checkbox
                // =================================================
                // 1. find the corresponding item
                let existingItem;
                for (const pair of currentValue) {
                    const currItem = pair[0];
                    if (matcher(currItem, elementValue) === true) {
                        existingItem = currItem;
                        break;
                    }
                }
                // 2. set the value of the corresponding item in the map
                // if checkbox is checked and there's no value in the existing Map
                // add the checkbox model/value to the Map as key,
                // and value will be checked state of the checkbox
                currentValue.set(existingItem, isChecked);
                // when existing value is a Map,
                // do not invoke callback as only the Map has been mutated
                return;
            }
            currentValue = isChecked;
        }
        else if (isChecked) {
            currentValue = elementValue;
        }
        else {
            // if it's a radio and it has been unchecked
            // do nothing, as the radio that was checked will fire change event and it will be handle there
            // a radio cannot be unchecked by user
            return;
        }
        this.value = currentValue;
        this.subs.notify(this.value, this.oldValue, 0 /* none */);
    }
    start() {
        this.handler.subscribe(this.obj, this);
        this.observe();
    }
    stop() {
        this.handler.dispose();
        this.collectionObserver?.unsubscribe(this);
        this.collectionObserver = void 0;
        this.valueObserver?.unsubscribe(this);
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.start();
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.stop();
        }
    }
    observe() {
        const obj = this.obj;
        (this.valueObserver ?? (this.valueObserver = obj.$observers?.model ?? obj.$observers?.value))?.subscribe(this);
        this.collectionObserver?.unsubscribe(this);
        this.collectionObserver = void 0;
        if (obj.type === 'checkbox') {
            (this.collectionObserver = (0,_observer_locator_js__WEBPACK_IMPORTED_MODULE_1__.getCollectionObserver)(this.value, this.observerLocator))?.subscribe(this);
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(CheckedObserver);
//# sourceMappingURL=checked-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClassAttributeAccessor": () => /* binding */ ClassAttributeAccessor,
/* harmony export */   "getClassesToAdd": () => /* binding */ getClassesToAdd
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

class ClassAttributeAccessor {
    constructor(obj) {
        this.obj = obj;
        this.currentValue = '';
        this.oldValue = '';
        this.doNotCache = true;
        this.nameIndex = {};
        this.version = 0;
        this.hasChanges = false;
        this.isActive = false;
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.currentValue;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            const nameIndex = this.nameIndex;
            let version = this.version;
            this.oldValue = currentValue;
            const classesToAdd = getClassesToAdd(currentValue);
            // Get strings split on a space not including empties
            if (classesToAdd.length > 0) {
                this.addClassesAndUpdateIndex(classesToAdd);
            }
            this.version += 1;
            // First call to setValue?  We're done.
            if (version === 0) {
                return;
            }
            // Remove classes from previous version.
            version -= 1;
            for (const name in nameIndex) {
                if (!Object.prototype.hasOwnProperty.call(nameIndex, name) || nameIndex[name] !== version) {
                    continue;
                }
                // TODO: this has the side-effect that classes already present which are added again,
                // will be removed if they're not present in the next update.
                // Better would be do have some configurability for this behavior, allowing the user to
                // decide whether initial classes always need to be kept, always removed, or something in between
                this.obj.classList.remove(name);
            }
        }
    }
    addClassesAndUpdateIndex(classes) {
        const node = this.obj;
        for (let i = 0, ii = classes.length; i < ii; i++) {
            const className = classes[i];
            if (className.length === 0) {
                continue;
            }
            this.nameIndex[className] = this.version;
            node.classList.add(className);
        }
    }
}
function getClassesToAdd(object) {
    if (typeof object === 'string') {
        return splitClassString(object);
    }
    if (typeof object !== 'object') {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    if (object instanceof Array) {
        const len = object.length;
        if (len > 0) {
            const classes = [];
            for (let i = 0; i < len; ++i) {
                classes.push(...getClassesToAdd(object[i]));
            }
            return classes;
        }
        else {
            return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
    }
    const classes = [];
    for (const property in object) {
        // Let non typical values also evaluate true so disable bool check
        if (Boolean(object[property])) {
            // We must do this in case object property has a space in the name which results in two classes
            if (property.includes(' ')) {
                classes.push(...splitClassString(property));
            }
            else {
                classes.push(property);
            }
        }
    }
    return classes;
}
function splitClassString(classString) {
    const matches = classString.match(/\S+/g);
    if (matches === null) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    return matches;
}
//# sourceMappingURL=class-attribute-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataAttributeAccessor": () => /* binding */ DataAttributeAccessor,
/* harmony export */   "attrAccessor": () => /* binding */ attrAccessor
/* harmony export */ });
/**
 * Attribute accessor for HTML elements.
 * Note that Aurelia works with properties, so in all case it will try to assign to property instead of attributes.
 * Unless the property falls into a special set, then it will use attribute for it.
 *
 * @see ElementPropertyAccessor
 */
class DataAttributeAccessor {
    constructor() {
        this.propertyKey = '';
        this.currentValue = null;
        // ObserverType.Layout is not always true, it depends on the property
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    getValue(obj, key) {
        return obj.getAttribute(key);
    }
    setValue(newValue, flags, obj, key) {
        if (newValue == void 0) {
            obj.removeAttribute(key);
        }
        else {
            obj.setAttribute(key, newValue);
        }
    }
}
const attrAccessor = new DataAttributeAccessor();
//# sourceMappingURL=data-attribute-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeObserver": () => /* binding */ AttributeObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

/**
 * Observer for handling two-way binding with attributes
 * Has different strategy for class/style and normal attributes
 * TODO: handle SVG/attributes with namespace
 */
class AttributeObserver {
    constructor(platform, observerLocator, obj, propertyKey, targetAttribute) {
        this.platform = platform;
        this.observerLocator = observerLocator;
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.targetAttribute = targetAttribute;
        this.currentValue = null;
        this.oldValue = null;
        this.hasChanges = false;
        // layout is not certain, depends on the attribute being flushed to owner element
        // but for simple start, always treat as such
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.currentValue;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            this.oldValue = currentValue;
            switch (this.targetAttribute) {
                case 'class': {
                    // Why does class attribute observer setValue look different with class attribute accessor?
                    // ==============
                    // For class list
                    // newValue is simply checked if truthy or falsy
                    // and toggle the class accordingly
                    // -- the rule of this is quite different to normal attribute
                    //
                    // for class attribute, observer is different in a way that it only observes one class at a time
                    // this also comes from syntax, where it would typically be my-class.class="someProperty"
                    //
                    // so there is no need for separating class by space and add all of them like class accessor
                    //
                    // note: not using .toggle API so that environment with broken impl (IE11) won't need to polfyfill by default
                    if (!!currentValue) {
                        this.obj.classList.add(this.propertyKey);
                    }
                    else {
                        this.obj.classList.remove(this.propertyKey);
                    }
                    break;
                }
                case 'style': {
                    let priority = '';
                    let newValue = currentValue;
                    if (typeof newValue === 'string' && newValue.includes('!important')) {
                        priority = 'important';
                        newValue = newValue.replace('!important', '');
                    }
                    this.obj.style.setProperty(this.propertyKey, newValue, priority);
                }
            }
        }
    }
    handleMutation(mutationRecords) {
        let shouldProcess = false;
        for (let i = 0, ii = mutationRecords.length; ii > i; ++i) {
            const record = mutationRecords[i];
            if (record.type === 'attributes' && record.attributeName === this.propertyKey) {
                shouldProcess = true;
                break;
            }
        }
        if (shouldProcess) {
            let newValue;
            switch (this.targetAttribute) {
                case 'class':
                    newValue = this.obj.classList.contains(this.propertyKey);
                    break;
                case 'style':
                    newValue = this.obj.style.getPropertyValue(this.propertyKey);
                    break;
                default:
                    throw new Error(`Unsupported targetAttribute: ${this.targetAttribute}`);
            }
            if (newValue !== this.currentValue) {
                const { currentValue } = this;
                this.currentValue = this.oldValue = newValue;
                this.hasChanges = false;
                this.subs.notify(newValue, currentValue, 0 /* none */);
            }
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.currentValue = this.oldValue = this.obj.getAttribute(this.propertyKey);
            startObservation(this.obj.ownerDocument.defaultView.MutationObserver, this.obj, this);
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            stopObservation(this.obj, this);
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(AttributeObserver);
const startObservation = ($MutationObserver, element, subscription) => {
    if (element.$eMObservers === undefined) {
        element.$eMObservers = new Set();
    }
    if (element.$mObserver === undefined) {
        (element.$mObserver = new $MutationObserver(handleMutation)).observe(element, { attributes: true });
    }
    element.$eMObservers.add(subscription);
};
const stopObservation = (element, subscription) => {
    const $eMObservers = element.$eMObservers;
    if ($eMObservers && $eMObservers.delete(subscription)) {
        if ($eMObservers.size === 0) {
            element.$mObserver.disconnect();
            element.$mObserver = undefined;
        }
        return true;
    }
    return false;
};
const handleMutation = (mutationRecords) => {
    mutationRecords[0].target.$eMObservers.forEach(invokeHandleMutation, mutationRecords);
};
function invokeHandleMutation(s) {
    s.handleMutation(this);
}
//# sourceMappingURL=element-attribute-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DelegateSubscription": () => /* binding */ DelegateSubscription,
/* harmony export */   "EventSubscriber": () => /* binding */ EventSubscriber,
/* harmony export */   "IEventDelegator": () => /* binding */ IEventDelegator,
/* harmony export */   "EventDelegator": () => /* binding */ EventDelegator
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const defaultOptions = {
    capture: false,
};
class ListenerTracker {
    constructor(publisher, eventName, options = defaultOptions) {
        this.publisher = publisher;
        this.eventName = eventName;
        this.options = options;
        this.count = 0;
        this.captureLookups = new Map();
        this.bubbleLookups = new Map();
    }
    increment() {
        if (++this.count === 1) {
            this.publisher.addEventListener(this.eventName, this, this.options);
        }
    }
    decrement() {
        if (--this.count === 0) {
            this.publisher.removeEventListener(this.eventName, this, this.options);
        }
    }
    dispose() {
        if (this.count > 0) {
            this.count = 0;
            this.publisher.removeEventListener(this.eventName, this, this.options);
        }
        this.captureLookups.clear();
        this.bubbleLookups.clear();
    }
    /** @internal */
    getLookup(target) {
        const lookups = this.options.capture === true ? this.captureLookups : this.bubbleLookups;
        let lookup = lookups.get(target);
        if (lookup === void 0) {
            lookups.set(target, lookup = Object.create(null));
        }
        return lookup;
    }
    /** @internal */
    handleEvent(event) {
        const lookups = this.options.capture === true ? this.captureLookups : this.bubbleLookups;
        const path = event.composedPath();
        if (this.options.capture === true) {
            path.reverse();
        }
        for (const target of path) {
            const lookup = lookups.get(target);
            if (lookup === void 0) {
                continue;
            }
            const listener = lookup[this.eventName];
            if (listener === void 0) {
                continue;
            }
            if (typeof listener === 'function') {
                listener(event);
            }
            else {
                listener.handleEvent(event);
            }
            if (event.cancelBubble === true) {
                return;
            }
        }
    }
}
/**
 * Enable dispose() pattern for `delegate` & `capture` commands
 */
class DelegateSubscription {
    constructor(tracker, lookup, eventName, callback) {
        this.tracker = tracker;
        this.lookup = lookup;
        this.eventName = eventName;
        tracker.increment();
        lookup[eventName] = callback;
    }
    dispose() {
        this.tracker.decrement();
        this.lookup[this.eventName] = void 0;
    }
}
class EventSubscriber {
    constructor(config) {
        this.config = config;
        this.target = null;
        this.handler = null;
    }
    subscribe(node, callbackOrListener) {
        this.target = node;
        this.handler = callbackOrListener;
        for (const event of this.config.events) {
            node.addEventListener(event, callbackOrListener);
        }
    }
    dispose() {
        const { target, handler } = this;
        if (target !== null && handler !== null) {
            for (const event of this.config.events) {
                target.removeEventListener(event, handler);
            }
        }
        this.target = this.handler = null;
    }
}
const IEventDelegator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IEventDelegator', x => x.singleton(EventDelegator));
class EventDelegator {
    // eslint-disable-next-line @typescript-eslint/no-useless-constructor
    constructor() {
        this.trackerMaps = Object.create(null);
    }
    addEventListener(publisher, target, eventName, listener, options) {
        var _a;
        const trackerMap = (_a = this.trackerMaps)[eventName] ?? (_a[eventName] = new Map());
        let tracker = trackerMap.get(publisher);
        if (tracker === void 0) {
            trackerMap.set(publisher, tracker = new ListenerTracker(publisher, eventName, options));
        }
        return new DelegateSubscription(tracker, tracker.getLookup(target), eventName, listener);
    }
    dispose() {
        for (const eventName in this.trackerMaps) {
            const trackerMap = this.trackerMaps[eventName];
            for (const tracker of trackerMap.values()) {
                tracker.dispose();
            }
            trackerMap.clear();
        }
    }
}
//# sourceMappingURL=event-delegator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeObserverConfig": () => /* binding */ NodeObserverConfig,
/* harmony export */   "NodeObserverLocator": () => /* binding */ NodeObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* binding */ getCollectionObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attribute-ns-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js");
/* harmony import */ var _checked_observer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./checked-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js");
/* harmony import */ var _class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./class-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js");
/* harmony import */ var _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js");
/* harmony import */ var _event_delegator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _select_value_observer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select-value-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js");
/* harmony import */ var _style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./style-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js");
/* harmony import */ var _svg_analyzer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./svg-analyzer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js");
/* harmony import */ var _value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./value-attribute-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js");












// https://infra.spec.whatwg.org/#namespaces
const htmlNS = 'http://www.w3.org/1999/xhtml';
const mathmlNS = 'http://www.w3.org/1998/Math/MathML';
const svgNS = 'http://www.w3.org/2000/svg';
const xlinkNS = 'http://www.w3.org/1999/xlink';
const xmlNS = 'http://www.w3.org/XML/1998/namespace';
const xmlnsNS = 'http://www.w3.org/2000/xmlns/';
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
const nsAttributes = Object.assign(createLookup(), {
    'xlink:actuate': ['actuate', xlinkNS],
    'xlink:arcrole': ['arcrole', xlinkNS],
    'xlink:href': ['href', xlinkNS],
    'xlink:role': ['role', xlinkNS],
    'xlink:show': ['show', xlinkNS],
    'xlink:title': ['title', xlinkNS],
    'xlink:type': ['type', xlinkNS],
    'xml:lang': ['lang', xmlNS],
    'xml:space': ['space', xmlNS],
    'xmlns': ['xmlns', xmlnsNS],
    'xmlns:xlink': ['xlink', xmlnsNS],
});
const elementPropertyAccessor = new _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.PropertyAccessor();
elementPropertyAccessor.type = 2 /* Node */ | 4 /* Layout */;
class NodeObserverConfig {
    constructor(config) {
        this.type = config.type ?? _value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_11__.ValueAttributeObserver;
        this.events = config.events;
        this.readonly = config.readonly;
        this.default = config.default;
    }
}
class NodeObserverLocator {
    constructor(locator, platform, dirtyChecker, svgAnalyzer) {
        this.locator = locator;
        this.platform = platform;
        this.dirtyChecker = dirtyChecker;
        this.svgAnalyzer = svgAnalyzer;
        this.allowDirtyCheck = true;
        this.events = createLookup();
        this.globalEvents = createLookup();
        this.overrides = createLookup();
        this.globalOverrides = createLookup();
        // todo: atm, platform is required to be resolved too eagerly for the `.handles()` check
        // also a lot of tests assume default availability of observation
        // those 2 assumptions make it not the right time to extract the following line into a
        // default configuration for NodeObserverLocator yet
        // but in the future, they should be, so apps that don't use check box/select, or implement a different
        // observer don't have to pay the of the default implementation
        const inputEvents = ['change', 'input'];
        const inputEventsConfig = { events: inputEvents, default: '' };
        this.useConfig({
            INPUT: {
                value: inputEventsConfig,
                checked: { type: _checked_observer_js__WEBPACK_IMPORTED_MODULE_4__.CheckedObserver, events: inputEvents },
                files: { events: inputEvents, readonly: true },
            },
            SELECT: {
                value: { type: _select_value_observer_js__WEBPACK_IMPORTED_MODULE_8__.SelectValueObserver, events: ['change'], default: '' },
            },
            TEXTAREA: {
                value: inputEventsConfig,
            },
        });
        const contentEventsConfig = { events: ['change', 'input', 'blur', 'keyup', 'paste'], default: '' };
        const scrollEventsConfig = { events: ['scroll'], default: 0 };
        this.useConfigGlobal({
            scrollTop: scrollEventsConfig,
            scrollLeft: scrollEventsConfig,
            textContent: contentEventsConfig,
            innerHTML: contentEventsConfig,
        });
        this.overrideAccessorGlobal('css', 'style', 'class');
        this.overrideAccessor({
            INPUT: ['value', 'checked', 'model'],
            SELECT: ['value'],
            TEXTAREA: ['value'],
        });
    }
    static register(container) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.INodeObserverLocator, NodeObserverLocator).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.INodeObserverLocator, NodeObserverLocator).register(container);
    }
    // deepscan-disable-next-line
    handles(obj, _key) {
        return obj instanceof this.platform.Node;
    }
    useConfig(nodeNameOrConfig, key, eventsConfig) {
        const lookup = this.events;
        let existingMapping;
        if (typeof nodeNameOrConfig === 'string') {
            existingMapping = lookup[nodeNameOrConfig] ?? (lookup[nodeNameOrConfig] = createLookup());
            if (existingMapping[key] == null) {
                existingMapping[key] = new NodeObserverConfig(eventsConfig);
            }
            else {
                throwMappingExisted(nodeNameOrConfig, key);
            }
        }
        else {
            for (const nodeName in nodeNameOrConfig) {
                existingMapping = lookup[nodeName] ?? (lookup[nodeName] = createLookup());
                const newMapping = nodeNameOrConfig[nodeName];
                for (key in newMapping) {
                    if (existingMapping[key] == null) {
                        existingMapping[key] = new NodeObserverConfig(newMapping[key]);
                    }
                    else {
                        throwMappingExisted(nodeName, key);
                    }
                }
            }
        }
    }
    useConfigGlobal(configOrKey, eventsConfig) {
        const lookup = this.globalEvents;
        if (typeof configOrKey === 'object') {
            for (const key in configOrKey) {
                if (lookup[key] == null) {
                    lookup[key] = new NodeObserverConfig(configOrKey[key]);
                }
                else {
                    throwMappingExisted('*', key);
                }
            }
        }
        else {
            if (lookup[configOrKey] == null) {
                lookup[configOrKey] = new NodeObserverConfig(eventsConfig);
            }
            else {
                throwMappingExisted('*', configOrKey);
            }
        }
    }
    // deepscan-disable-nextline
    getAccessor(obj, key, requestor) {
        if (key in this.globalOverrides || (key in (this.overrides[obj.tagName] ?? _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyObject))) {
            return this.getObserver(obj, key, requestor);
        }
        switch (key) {
            // class / style / css attribute will be observed using .getObserver() per overrides
            //
            // TODO: there are (many) more situation where we want to default to DataAttributeAccessor,
            // but for now stick to what vCurrent does
            case 'src':
            case 'href':
            // https://html.spec.whatwg.org/multipage/dom.html#wai-aria
            case 'role':
                return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
            default: {
                const nsProps = nsAttributes[key];
                if (nsProps !== undefined) {
                    return _attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_3__.AttributeNSAccessor.forNs(nsProps[1]);
                }
                if (isDataAttribute(obj, key, this.svgAnalyzer)) {
                    return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
                }
                return elementPropertyAccessor;
            }
        }
    }
    overrideAccessor(tagNameOrOverrides, key) {
        var _a, _b;
        let existingTagOverride;
        if (typeof tagNameOrOverrides === 'string') {
            existingTagOverride = (_a = this.overrides)[tagNameOrOverrides] ?? (_a[tagNameOrOverrides] = createLookup());
            existingTagOverride[key] = true;
        }
        else {
            for (const tagName in tagNameOrOverrides) {
                for (const key of tagNameOrOverrides[tagName]) {
                    existingTagOverride = (_b = this.overrides)[tagName] ?? (_b[tagName] = createLookup());
                    existingTagOverride[key] = true;
                }
            }
        }
    }
    /**
     * For all elements:
     * compose a list of properties,
     * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`
     */
    overrideAccessorGlobal(...keys) {
        for (const key of keys) {
            this.globalOverrides[key] = true;
        }
    }
    getObserver(el, key, requestor) {
        switch (key) {
            case 'role':
                return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
            case 'class':
                return new _class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_5__.ClassAttributeAccessor(el);
            case 'css':
            case 'style':
                return new _style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_9__.StyleAttributeAccessor(el);
        }
        const eventsConfig = this.events[el.tagName]?.[key] ?? this.globalEvents[key];
        if (eventsConfig != null) {
            return new eventsConfig.type(el, key, new _event_delegator_js__WEBPACK_IMPORTED_MODULE_7__.EventSubscriber(eventsConfig), requestor, this.locator);
        }
        const nsProps = nsAttributes[key];
        if (nsProps !== undefined) {
            return _attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_3__.AttributeNSAccessor.forNs(nsProps[1]);
        }
        if (isDataAttribute(el, key, this.svgAnalyzer)) {
            // todo: should observe
            return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
        }
        if (key in el.constructor.prototype) {
            if (this.allowDirtyCheck) {
                return this.dirtyChecker.createProperty(el, key);
            }
            // consider:
            // - maybe add a adapter API to handle unknown obj/key combo
            throw new Error(`Unable to observe property ${String(key)}. Register observation mapping with .useConfig().`);
        }
        else {
            // todo: probably still needs to get the property descriptor via getOwnPropertyDescriptor
            // but let's start with simplest scenario
            return new _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.SetterObserver(el, key);
        }
    }
}
NodeObserverLocator.inject = [_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IServiceLocator, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IDirtyChecker, _svg_analyzer_js__WEBPACK_IMPORTED_MODULE_10__.ISVGAnalyzer];
function getCollectionObserver(collection, observerLocator) {
    if (collection instanceof Array) {
        return observerLocator.getArrayObserver(collection);
    }
    if (collection instanceof Map) {
        return observerLocator.getMapObserver(collection);
    }
    if (collection instanceof Set) {
        return observerLocator.getSetObserver(collection);
    }
}
function throwMappingExisted(nodeName, key) {
    throw new Error(`Mapping for property ${String(key)} of <${nodeName} /> already exists`);
}
const IsDataAttribute = createLookup();
function isDataAttribute(obj, key, svgAnalyzer) {
    if (IsDataAttribute[key] === true) {
        return true;
    }
    if (typeof key !== 'string') {
        return false;
    }
    const prefix = key.slice(0, 5);
    // https://html.spec.whatwg.org/multipage/dom.html#wai-aria
    // https://html.spec.whatwg.org/multipage/dom.html#custom-data-attribute
    return IsDataAttribute[key] =
        prefix === 'aria-' ||
            prefix === 'data-' ||
            svgAnalyzer.isStandardSvgAttribute(obj, key);
}
function createLookup() {
    return Object.create(null);
}
//# sourceMappingURL=observer-locator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectValueObserver": () => /* binding */ SelectValueObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

const hasOwn = Object.prototype.hasOwnProperty;
const childObserverOptions = {
    childList: true,
    subtree: true,
    characterData: true
};
function defaultMatcher(a, b) {
    return a === b;
}
class SelectValueObserver {
    constructor(obj, 
    // deepscan-disable-next-line
    _key, handler, observerLocator) {
        this.handler = handler;
        this.observerLocator = observerLocator;
        this.currentValue = void 0;
        this.oldValue = void 0;
        this.hasChanges = false;
        // ObserverType.Layout is not always true
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
        this.arrayObserver = void 0;
        this.nodeObserver = void 0;
        this.observing = false;
        this.obj = obj;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.observing
            ? this.currentValue
            : this.obj.multiple
                ? Array.from(this.obj.options).map(o => o.value)
                : this.obj.value;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        this.observeArray(newValue instanceof Array ? newValue : null);
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            this.synchronizeOptions();
        }
    }
    handleCollectionChange() {
        // always sync "selected" property of <options/>
        // immediately whenever the array notifies its mutation
        this.synchronizeOptions();
    }
    notify(flags) {
        if ((flags & 32 /* fromBind */) > 0) {
            return;
        }
        const oldValue = this.oldValue;
        const newValue = this.currentValue;
        if (newValue === oldValue) {
            return;
        }
        this.subs.notify(newValue, oldValue, flags);
    }
    handleEvent() {
        const shouldNotify = this.synchronizeValue();
        if (shouldNotify) {
            this.subs.notify(this.currentValue, this.oldValue, 0 /* none */);
        }
    }
    synchronizeOptions(indexMap) {
        const { currentValue, obj } = this;
        const isArray = Array.isArray(currentValue);
        const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
        const options = obj.options;
        let i = options.length;
        while (i-- > 0) {
            const option = options[i];
            const optionValue = hasOwn.call(option, 'model') ? option.model : option.value;
            if (isArray) {
                option.selected = currentValue.findIndex(item => !!matcher(optionValue, item)) !== -1;
                continue;
            }
            option.selected = !!matcher(optionValue, currentValue);
        }
    }
    synchronizeValue() {
        // Spec for synchronizing value from `<select/>`  to `SelectObserver`
        // When synchronizing value to observed <select/> element, do the following steps:
        // A. If `<select/>` is multiple
        //    1. Check if current value, called `currentValue` is an array
        //      a. If not an array, return true to signal value has changed
        //      b. If is an array:
        //        i. gather all current selected <option/>, in to array called `values`
        //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher
        //        iii. loop through the `values` array and add items that are selected based on matcher
        //        iv. Return false to signal value hasn't changed
        // B. If the select is single
        //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`
        //    2. assign `this.currentValue` to `this.oldValue`
        //    3. assign `value` to `this.currentValue`
        //    4. return `true` to signal value has changed
        const obj = this.obj;
        const options = obj.options;
        const len = options.length;
        const currentValue = this.currentValue;
        let i = 0;
        if (obj.multiple) {
            // A.
            if (!(currentValue instanceof Array)) {
                // A.1.a
                return true;
            }
            // A.1.b
            // multi select
            let option;
            const matcher = obj.matcher || defaultMatcher;
            // A.1.b.i
            const values = [];
            while (i < len) {
                option = options[i];
                if (option.selected) {
                    values.push(hasOwn.call(option, 'model')
                        ? option.model
                        : option.value);
                }
                ++i;
            }
            // A.1.b.ii
            i = 0;
            while (i < currentValue.length) {
                const a = currentValue[i];
                // Todo: remove arrow fn
                if (values.findIndex(b => !!matcher(a, b)) === -1) {
                    currentValue.splice(i, 1);
                }
                else {
                    ++i;
                }
            }
            // A.1.b.iii
            i = 0;
            while (i < values.length) {
                const a = values[i];
                // Todo: remove arrow fn
                if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {
                    currentValue.push(a);
                }
                ++i;
            }
            // A.1.b.iv
            return false;
        }
        // B. single select
        // B.1
        let value = null;
        while (i < len) {
            const option = options[i];
            if (option.selected) {
                value = hasOwn.call(option, 'model')
                    ? option.model
                    : option.value;
                break;
            }
            ++i;
        }
        // B.2
        this.oldValue = this.currentValue;
        // B.3
        this.currentValue = value;
        // B.4
        return true;
    }
    start() {
        (this.nodeObserver = new this.obj.ownerDocument.defaultView.MutationObserver(this.handleNodeChange.bind(this)))
            .observe(this.obj, childObserverOptions);
        this.observeArray(this.currentValue instanceof Array ? this.currentValue : null);
        this.observing = true;
    }
    stop() {
        this.nodeObserver.disconnect();
        this.arrayObserver?.unsubscribe(this);
        this.nodeObserver
            = this.arrayObserver
                = void 0;
        this.observing = false;
    }
    // todo: observe all kind of collection
    observeArray(array) {
        this.arrayObserver?.unsubscribe(this);
        this.arrayObserver = void 0;
        if (array != null) {
            if (!this.obj.multiple) {
                throw new Error('Only null or Array instances can be bound to a multi-select.');
            }
            (this.arrayObserver = this.observerLocator.getArrayObserver(array)).subscribe(this);
        }
    }
    handleNodeChange() {
        this.synchronizeOptions();
        const shouldNotify = this.synchronizeValue();
        if (shouldNotify) {
            this.notify(0 /* none */);
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.handler.subscribe(this.obj, this);
            this.start();
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.handler.dispose();
            this.stop();
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(SelectValueObserver);
//# sourceMappingURL=select-value-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleAttributeAccessor": () => /* binding */ StyleAttributeAccessor
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const customPropertyPrefix = '--';
class StyleAttributeAccessor {
    constructor(obj) {
        this.obj = obj;
        this.currentValue = '';
        this.oldValue = '';
        this.styles = {};
        this.version = 0;
        this.hasChanges = false;
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    getValue() {
        return this.obj.style.cssText;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    getStyleTuplesFromString(currentValue) {
        const styleTuples = [];
        const urlRegexTester = /url\([^)]+$/;
        let offset = 0;
        let currentChunk = '';
        let nextSplit;
        let indexOfColon;
        let attribute;
        let value;
        while (offset < currentValue.length) {
            nextSplit = currentValue.indexOf(';', offset);
            if (nextSplit === -1) {
                nextSplit = currentValue.length;
            }
            currentChunk += currentValue.substring(offset, nextSplit);
            offset = nextSplit + 1;
            // Make sure we never split a url so advance to next
            if (urlRegexTester.test(currentChunk)) {
                currentChunk += ';';
                continue;
            }
            indexOfColon = currentChunk.indexOf(':');
            attribute = currentChunk.substring(0, indexOfColon).trim();
            value = currentChunk.substring(indexOfColon + 1).trim();
            styleTuples.push([attribute, value]);
            currentChunk = '';
        }
        return styleTuples;
    }
    getStyleTuplesFromObject(currentValue) {
        let value;
        const styles = [];
        for (const property in currentValue) {
            value = currentValue[property];
            if (value == null) {
                continue;
            }
            if (typeof value === 'string') {
                // Custom properties should not be tampered with
                if (property.startsWith(customPropertyPrefix)) {
                    styles.push([property, value]);
                    continue;
                }
                styles.push([(0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(property), value]);
                continue;
            }
            styles.push(...this.getStyleTuples(value));
        }
        return styles;
    }
    getStyleTuplesFromArray(currentValue) {
        const len = currentValue.length;
        if (len > 0) {
            const styles = [];
            for (let i = 0; i < len; ++i) {
                styles.push(...this.getStyleTuples(currentValue[i]));
            }
            return styles;
        }
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    getStyleTuples(currentValue) {
        if (typeof currentValue === 'string') {
            return this.getStyleTuplesFromString(currentValue);
        }
        if (currentValue instanceof Array) {
            return this.getStyleTuplesFromArray(currentValue);
        }
        if (currentValue instanceof Object) {
            return this.getStyleTuplesFromObject(currentValue);
        }
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            const styles = this.styles;
            const styleTuples = this.getStyleTuples(currentValue);
            let style;
            let version = this.version;
            this.oldValue = currentValue;
            let tuple;
            let name;
            let value;
            const len = styleTuples.length;
            for (let i = 0; i < len; ++i) {
                tuple = styleTuples[i];
                name = tuple[0];
                value = tuple[1];
                this.setProperty(name, value);
                styles[name] = version;
            }
            this.styles = styles;
            this.version += 1;
            if (version === 0) {
                return;
            }
            version -= 1;
            for (style in styles) {
                if (!Object.prototype.hasOwnProperty.call(styles, style) || styles[style] !== version) {
                    continue;
                }
                this.obj.style.removeProperty(style);
            }
        }
    }
    setProperty(style, value) {
        let priority = '';
        if (value != null && typeof value.indexOf === 'function' && value.includes('!important')) {
            priority = 'important';
            value = value.replace('!important', '');
        }
        this.obj.style.setProperty(style, value, priority);
    }
    bind(flags) {
        this.currentValue = this.oldValue = this.obj.style.cssText;
    }
}
//# sourceMappingURL=style-attribute-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISVGAnalyzer": () => /* binding */ ISVGAnalyzer,
/* harmony export */   "NoopSVGAnalyzer": () => /* binding */ NoopSVGAnalyzer,
/* harmony export */   "SVGAnalyzer": () => /* binding */ SVGAnalyzer
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");


const ISVGAnalyzer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISVGAnalyzer', x => x.singleton(NoopSVGAnalyzer));
class NoopSVGAnalyzer {
    isStandardSvgAttribute(node, attributeName) {
        return false;
    }
}
function o(keys) {
    const lookup = Object.create(null);
    for (const key of keys) {
        lookup[key] = true;
    }
    return lookup;
}
class SVGAnalyzer {
    constructor(platform) {
        this.svgElements = Object.assign(Object.create(null), {
            'a': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'altGlyph': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'altglyph': Object.create(null),
            'altGlyphDef': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'altglyphdef': Object.create(null),
            'altGlyphItem': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'altglyphitem': Object.create(null),
            'animate': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'animateColor': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'animateMotion': o(['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'animateTransform': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'circle': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'clipPath': o(['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'color-profile': o(['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'cursor': o(['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'defs': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'desc': o(['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space']),
            'ellipse': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'feBlend': o(['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feColorMatrix': o(['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feComponentTransfer': o(['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feComposite': o(['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feConvolveMatrix': o(['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feDiffuseLighting': o(['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feDisplacementMap': o(['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector']),
            'feDistantLight': o(['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space']),
            'feFlood': o(['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feFuncA': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feFuncB': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feFuncG': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feFuncR': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feGaussianBlur': o(['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feImage': o(['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feMerge': o(['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feMergeNode': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'feMorphology': o(['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feOffset': o(['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'fePointLight': o(['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z']),
            'feSpecularLighting': o(['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feSpotLight': o(['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z']),
            'feTile': o(['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feTurbulence': o(['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'filter': o(['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'font': o(['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face': o(['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-format': o(['id', 'string', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-name': o(['id', 'name', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-src': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-uri': o(['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'foreignObject': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'g': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'glyph': o(['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
            'glyphRef': o(['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'glyphref': Object.create(null),
            'hkern': o(['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']),
            'image': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'line': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2']),
            'linearGradient': o(['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2']),
            'marker': o(['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space']),
            'mask': o(['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'metadata': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'missing-glyph': o(['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
            'mpath': o(['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'path': o(['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'pattern': o(['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'polygon': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'polyline': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'radialGradient': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'rect': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'script': o(['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'set': o(['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'stop': o(['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space']),
            'style': o(['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'svg': o(['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan']),
            'switch': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'symbol': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space']),
            'text': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'textPath': o(['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'title': o(['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space']),
            'tref': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'tspan': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'use': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'view': o(['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan']),
            'vkern': o(['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']),
        });
        this.svgPresentationElements = o([
            'a',
            'altGlyph',
            'animate',
            'animateColor',
            'circle',
            'clipPath',
            'defs',
            'ellipse',
            'feBlend',
            'feColorMatrix',
            'feComponentTransfer',
            'feComposite',
            'feConvolveMatrix',
            'feDiffuseLighting',
            'feDisplacementMap',
            'feFlood',
            'feGaussianBlur',
            'feImage',
            'feMerge',
            'feMorphology',
            'feOffset',
            'feSpecularLighting',
            'feTile',
            'feTurbulence',
            'filter',
            'font',
            'foreignObject',
            'g',
            'glyph',
            'glyphRef',
            'image',
            'line',
            'linearGradient',
            'marker',
            'mask',
            'missing-glyph',
            'path',
            'pattern',
            'polygon',
            'polyline',
            'radialGradient',
            'rect',
            'stop',
            'svg',
            'switch',
            'symbol',
            'text',
            'textPath',
            'tref',
            'tspan',
            'use',
        ]);
        this.svgPresentationAttributes = o([
            'alignment-baseline',
            'baseline-shift',
            'clip-path',
            'clip-rule',
            'clip',
            'color-interpolation-filters',
            'color-interpolation',
            'color-profile',
            'color-rendering',
            'color',
            'cursor',
            'direction',
            'display',
            'dominant-baseline',
            'enable-background',
            'fill-opacity',
            'fill-rule',
            'fill',
            'filter',
            'flood-color',
            'flood-opacity',
            'font-family',
            'font-size-adjust',
            'font-size',
            'font-stretch',
            'font-style',
            'font-variant',
            'font-weight',
            'glyph-orientation-horizontal',
            'glyph-orientation-vertical',
            'image-rendering',
            'kerning',
            'letter-spacing',
            'lighting-color',
            'marker-end',
            'marker-mid',
            'marker-start',
            'mask',
            'opacity',
            'overflow',
            'pointer-events',
            'shape-rendering',
            'stop-color',
            'stop-opacity',
            'stroke-dasharray',
            'stroke-dashoffset',
            'stroke-linecap',
            'stroke-linejoin',
            'stroke-miterlimit',
            'stroke-opacity',
            'stroke-width',
            'stroke',
            'text-anchor',
            'text-decoration',
            'text-rendering',
            'unicode-bidi',
            'visibility',
            'word-spacing',
            'writing-mode',
        ]);
        this.SVGElement = platform.globalThis.SVGElement;
        const div = platform.document.createElement('div');
        div.innerHTML = '<svg><altGlyph /></svg>';
        if (div.firstElementChild.nodeName === 'altglyph') {
            // handle chrome casing inconsistencies.
            const svg = this.svgElements;
            let tmp = svg.altGlyph;
            svg.altGlyph = svg.altglyph;
            svg.altglyph = tmp;
            tmp = svg.altGlyphDef;
            svg.altGlyphDef = svg.altglyphdef;
            svg.altglyphdef = tmp;
            tmp = svg.altGlyphItem;
            svg.altGlyphItem = svg.altglyphitem;
            svg.altglyphitem = tmp;
            tmp = svg.glyphRef;
            svg.glyphRef = svg.glyphref;
            svg.glyphref = tmp;
        }
    }
    static register(container) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(ISVGAnalyzer, this).register(container);
    }
    isStandardSvgAttribute(node, attributeName) {
        if (!(node instanceof this.SVGElement)) {
            return false;
        }
        return (this.svgPresentationElements[node.nodeName] === true && this.svgPresentationAttributes[attributeName] === true ||
            this.svgElements[node.nodeName]?.[attributeName] === true);
    }
}
/**
 * @internal
 */
SVGAnalyzer.inject = [_platform_js__WEBPACK_IMPORTED_MODULE_1__.IPlatform];
//# sourceMappingURL=svg-analyzer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValueAttributeObserver": () => /* binding */ ValueAttributeObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

/**
 * Observer for non-radio, non-checkbox input.
 */
class ValueAttributeObserver {
    constructor(obj, propertyKey, handler) {
        this.propertyKey = propertyKey;
        this.handler = handler;
        this.currentValue = '';
        this.oldValue = '';
        this.hasChanges = false;
        // ObserverType.Layout is not always true, it depends on the element & property combo
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
        this.obj = obj;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.currentValue;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if (!this.handler.config.readonly && (flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            const oldValue = this.oldValue;
            this.oldValue = currentValue;
            this.obj[this.propertyKey] = currentValue ?? this.handler.config.default;
            if ((flags & 32 /* fromBind */) === 0) {
                this.subs.notify(currentValue, oldValue, flags);
            }
        }
    }
    handleEvent() {
        const oldValue = this.oldValue = this.currentValue;
        const currentValue = this.currentValue = this.obj[this.propertyKey];
        if (oldValue !== currentValue) {
            this.oldValue = currentValue;
            this.subs.notify(currentValue, oldValue, 0 /* none */);
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.handler.subscribe(this.obj, this);
            this.currentValue = this.oldValue = this.obj[this.propertyKey];
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.handler.dispose();
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(ValueAttributeObserver);
//# sourceMappingURL=value-attribute-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/platform.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IPlatform": () => /* binding */ IPlatform
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const IPlatform = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform;
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/renderer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstructionType": () => /* binding */ InstructionType,
/* harmony export */   "IInstruction": () => /* binding */ IInstruction,
/* harmony export */   "isInstruction": () => /* binding */ isInstruction,
/* harmony export */   "InterpolationInstruction": () => /* binding */ InterpolationInstruction,
/* harmony export */   "PropertyBindingInstruction": () => /* binding */ PropertyBindingInstruction,
/* harmony export */   "IteratorBindingInstruction": () => /* binding */ IteratorBindingInstruction,
/* harmony export */   "CallBindingInstruction": () => /* binding */ CallBindingInstruction,
/* harmony export */   "RefBindingInstruction": () => /* binding */ RefBindingInstruction,
/* harmony export */   "SetPropertyInstruction": () => /* binding */ SetPropertyInstruction,
/* harmony export */   "HydrateElementInstruction": () => /* binding */ HydrateElementInstruction,
/* harmony export */   "HydrateAttributeInstruction": () => /* binding */ HydrateAttributeInstruction,
/* harmony export */   "HydrateTemplateController": () => /* binding */ HydrateTemplateController,
/* harmony export */   "HydrateLetElementInstruction": () => /* binding */ HydrateLetElementInstruction,
/* harmony export */   "LetBindingInstruction": () => /* binding */ LetBindingInstruction,
/* harmony export */   "TextBindingInstruction": () => /* binding */ TextBindingInstruction,
/* harmony export */   "ListenerBindingInstruction": () => /* binding */ ListenerBindingInstruction,
/* harmony export */   "StylePropertyBindingInstruction": () => /* binding */ StylePropertyBindingInstruction,
/* harmony export */   "SetAttributeInstruction": () => /* binding */ SetAttributeInstruction,
/* harmony export */   "SetClassAttributeInstruction": () => /* binding */ SetClassAttributeInstruction,
/* harmony export */   "SetStyleAttributeInstruction": () => /* binding */ SetStyleAttributeInstruction,
/* harmony export */   "AttributeBindingInstruction": () => /* binding */ AttributeBindingInstruction,
/* harmony export */   "ITemplateCompiler": () => /* binding */ ITemplateCompiler,
/* harmony export */   "IRenderer": () => /* binding */ IRenderer,
/* harmony export */   "renderer": () => /* binding */ renderer,
/* harmony export */   "SetPropertyRenderer": () => /* binding */ SetPropertyRenderer,
/* harmony export */   "CustomElementRenderer": () => /* binding */ CustomElementRenderer,
/* harmony export */   "CustomAttributeRenderer": () => /* binding */ CustomAttributeRenderer,
/* harmony export */   "TemplateControllerRenderer": () => /* binding */ TemplateControllerRenderer,
/* harmony export */   "LetElementRenderer": () => /* binding */ LetElementRenderer,
/* harmony export */   "CallBindingRenderer": () => /* binding */ CallBindingRenderer,
/* harmony export */   "RefBindingRenderer": () => /* binding */ RefBindingRenderer,
/* harmony export */   "InterpolationBindingRenderer": () => /* binding */ InterpolationBindingRenderer,
/* harmony export */   "PropertyBindingRenderer": () => /* binding */ PropertyBindingRenderer,
/* harmony export */   "IteratorBindingRenderer": () => /* binding */ IteratorBindingRenderer,
/* harmony export */   "applyBindingBehavior": () => /* binding */ applyBindingBehavior,
/* harmony export */   "TextBindingRenderer": () => /* binding */ TextBindingRenderer,
/* harmony export */   "ListenerBindingRenderer": () => /* binding */ ListenerBindingRenderer,
/* harmony export */   "SetAttributeRenderer": () => /* binding */ SetAttributeRenderer,
/* harmony export */   "SetClassAttributeRenderer": () => /* binding */ SetClassAttributeRenderer,
/* harmony export */   "SetStyleAttributeRenderer": () => /* binding */ SetStyleAttributeRenderer,
/* harmony export */   "StylePropertyBindingRenderer": () => /* binding */ StylePropertyBindingRenderer,
/* harmony export */   "AttributeBindingRenderer": () => /* binding */ AttributeBindingRenderer
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binding/call-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js");
/* harmony import */ var _binding_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./binding/attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js");
/* harmony import */ var _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binding/interpolation-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js");
/* harmony import */ var _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding/let-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js");
/* harmony import */ var _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./binding/property-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js");
/* harmony import */ var _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./binding/ref-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js");
/* harmony import */ var _binding_listener_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./binding/listener.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js");
/* harmony import */ var _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./observation/event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
















var InstructionType;
(function (InstructionType) {
    InstructionType["hydrateElement"] = "ra";
    InstructionType["hydrateAttribute"] = "rb";
    InstructionType["hydrateTemplateController"] = "rc";
    InstructionType["hydrateLetElement"] = "rd";
    InstructionType["setProperty"] = "re";
    InstructionType["interpolation"] = "rf";
    InstructionType["propertyBinding"] = "rg";
    InstructionType["callBinding"] = "rh";
    InstructionType["letBinding"] = "ri";
    InstructionType["refBinding"] = "rj";
    InstructionType["iteratorBinding"] = "rk";
    InstructionType["textBinding"] = "ha";
    InstructionType["listenerBinding"] = "hb";
    InstructionType["attributeBinding"] = "hc";
    InstructionType["stylePropertyBinding"] = "hd";
    InstructionType["setAttribute"] = "he";
    InstructionType["setClassAttribute"] = "hf";
    InstructionType["setStyleAttribute"] = "hg";
})(InstructionType || (InstructionType = {}));
const IInstruction = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('Instruction');
function isInstruction(value) {
    const type = value.type;
    return typeof type === 'string' && type.length === 2;
}
class InterpolationInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rf" /* interpolation */; }
}
class PropertyBindingInstruction {
    constructor(from, to, mode) {
        this.from = from;
        this.to = to;
        this.mode = mode;
    }
    get type() { return "rg" /* propertyBinding */; }
}
class IteratorBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rk" /* iteratorBinding */; }
}
class CallBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rh" /* callBinding */; }
}
class RefBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rj" /* refBinding */; }
}
class SetPropertyInstruction {
    constructor(value, to) {
        this.value = value;
        this.to = to;
    }
    get type() { return "re" /* setProperty */; }
}
class HydrateElementInstruction {
    constructor(res, alias, instructions, slotInfo) {
        this.res = res;
        this.alias = alias;
        this.instructions = instructions;
        this.slotInfo = slotInfo;
    }
    get type() { return "ra" /* hydrateElement */; }
}
class HydrateAttributeInstruction {
    constructor(res, alias, instructions) {
        this.res = res;
        this.alias = alias;
        this.instructions = instructions;
    }
    get type() { return "rb" /* hydrateAttribute */; }
}
class HydrateTemplateController {
    constructor(def, res, alias, instructions) {
        this.def = def;
        this.res = res;
        this.alias = alias;
        this.instructions = instructions;
    }
    get type() { return "rc" /* hydrateTemplateController */; }
}
class HydrateLetElementInstruction {
    constructor(instructions, toBindingContext) {
        this.instructions = instructions;
        this.toBindingContext = toBindingContext;
    }
    get type() { return "rd" /* hydrateLetElement */; }
}
class LetBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "ri" /* letBinding */; }
}
class TextBindingInstruction {
    constructor(from) {
        this.from = from;
    }
    get type() { return "ha" /* textBinding */; }
}
class ListenerBindingInstruction {
    constructor(from, to, preventDefault, strategy) {
        this.from = from;
        this.to = to;
        this.preventDefault = preventDefault;
        this.strategy = strategy;
    }
    get type() { return "hb" /* listenerBinding */; }
}
class StylePropertyBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "hd" /* stylePropertyBinding */; }
}
class SetAttributeInstruction {
    constructor(value, to) {
        this.value = value;
        this.to = to;
    }
    get type() { return "he" /* setAttribute */; }
}
class SetClassAttributeInstruction {
    constructor(value) {
        this.value = value;
        this.type = "hf" /* setClassAttribute */;
    }
}
class SetStyleAttributeInstruction {
    constructor(value) {
        this.value = value;
        this.type = "hg" /* setStyleAttribute */;
    }
}
class AttributeBindingInstruction {
    constructor(
    /**
     * `attr` and `to` have the same value on a normal attribute
     * Will be different on `class` and `style`
     * on `class`: attr = `class` (from binding command), to = attribute name
     * on `style`: attr = `style` (from binding command), to = attribute name
     */
    attr, from, to) {
        this.attr = attr;
        this.from = from;
        this.to = to;
    }
    get type() { return "hc" /* attributeBinding */; }
}
const ITemplateCompiler = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ITemplateCompiler');
const IRenderer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IRenderer');
function renderer(instructionType) {
    return function decorator(target) {
        // wrap the constructor to set the instructionType to the instance (for better performance than when set on the prototype)
        const decoratedTarget = function (...args) {
            const instance = new target(...args);
            instance.instructionType = instructionType;
            return instance;
        };
        // make sure we register the decorated constructor with DI
        decoratedTarget.register = function register(container) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(IRenderer, decoratedTarget).register(container);
        };
        // copy over any metadata such as annotations (set by preceding decorators) as well as static properties set by the user
        // also copy the name, to be less confusing to users (so they can still use constructor.name for whatever reason)
        // the length (number of ctor arguments) is copied for the same reason
        const metadataKeys = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwnKeys(target);
        for (const key of metadataKeys) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, target), decoratedTarget);
        }
        const ownProperties = Object.getOwnPropertyDescriptors(target);
        Object.keys(ownProperties).filter(prop => prop !== 'prototype').forEach(prop => {
            Reflect.defineProperty(decoratedTarget, prop, ownProperties[prop]);
        });
        return decoratedTarget;
    };
}
function ensureExpression(parser, srcOrExpr, bindingType) {
    if (typeof srcOrExpr === 'string') {
        return parser.parse(srcOrExpr, bindingType);
    }
    return srcOrExpr;
}
function getTarget(potentialTarget) {
    if (potentialTarget.viewModel != null) {
        return potentialTarget.viewModel;
    }
    return potentialTarget;
}
function getRefTarget(refHost, refTargetName) {
    if (refTargetName === 'element') {
        return refHost;
    }
    switch (refTargetName) {
        case 'controller':
            // this means it supports returning undefined
            return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.for(refHost);
        case 'view':
            // todo: returns node sequences for fun?
            throw new Error('Not supported API');
        case 'view-model':
            // this means it supports returning undefined
            return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.for(refHost).viewModel;
        default: {
            const caController = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__.CustomAttribute.for(refHost, refTargetName);
            if (caController !== void 0) {
                return caController.viewModel;
            }
            const ceController = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.for(refHost, { name: refTargetName });
            if (ceController === void 0) {
                throw new Error(`Attempted to reference "${refTargetName}", but it was not found amongst the target's API.`);
            }
            return ceController.viewModel;
        }
    }
}
let SetPropertyRenderer = 
/** @internal */
class SetPropertyRenderer {
    render(flags, context, controller, target, instruction) {
        const obj = getTarget(target);
        if (obj.$observers !== void 0 && obj.$observers[instruction.to] !== void 0) {
            obj.$observers[instruction.to].setValue(instruction.value, 32 /* fromBind */);
        }
        else {
            obj[instruction.to] = instruction.value;
        }
    }
};
SetPropertyRenderer = __decorate([
    renderer("re" /* setProperty */)
    /** @internal */
], SetPropertyRenderer);

let CustomElementRenderer = 
/** @internal */
class CustomElementRenderer {
    render(flags, context, controller, target, instruction) {
        let viewFactory;
        const slotInfo = instruction.slotInfo;
        if (slotInfo !== null) {
            const projectionCtx = slotInfo.projectionContext;
            viewFactory = (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_11__.getRenderContext)(projectionCtx.content, context).getViewFactory(void 0, slotInfo.type, projectionCtx.scope);
        }
        const factory = context.getComponentFactory(
        /* parentController */ controller, 
        /* host             */ target, 
        /* instruction      */ instruction, 
        /* viewFactory      */ viewFactory, 
        /* location         */ target);
        const key = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.keyFrom(instruction.res);
        const component = factory.createComponent(key);
        const childController = _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__.Controller.forCustomElement(
        /* root                */ controller.root, 
        /* container           */ context, 
        /* viewModel           */ component, 
        /* host                */ target, 
        /* targetedProjections */ context.getProjectionFor(instruction), 
        /* flags               */ flags);
        flags = childController.flags;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, childController, target);
        context.renderChildren(
        /* flags        */ flags, 
        /* instructions */ instruction.instructions, 
        /* controller   */ controller, 
        /* target       */ childController);
        controller.addController(childController);
        factory.dispose();
    }
};
CustomElementRenderer = __decorate([
    renderer("ra" /* hydrateElement */)
    /** @internal */
], CustomElementRenderer);

let CustomAttributeRenderer = 
/** @internal */
class CustomAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        const factory = context.getComponentFactory(
        /* parentController */ controller, 
        /* host             */ target, 
        /* instruction      */ instruction, 
        /* viewFactory      */ void 0, 
        /* location         */ void 0);
        const key = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__.CustomAttribute.keyFrom(instruction.res);
        const component = factory.createComponent(key);
        const childController = _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__.Controller.forCustomAttribute(
        /* root      */ controller.root, 
        /* container */ context, 
        /* viewModel */ component, 
        /* host      */ target, 
        /* flags     */ flags);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, childController, target);
        context.renderChildren(
        /* flags        */ flags, 
        /* instructions */ instruction.instructions, 
        /* controller   */ controller, 
        /* target       */ childController);
        controller.addController(childController);
        factory.dispose();
    }
};
CustomAttributeRenderer = __decorate([
    renderer("rb" /* hydrateAttribute */)
    /** @internal */
], CustomAttributeRenderer);

let TemplateControllerRenderer = 
/** @internal */
class TemplateControllerRenderer {
    render(flags, context, controller, target, instruction) {
        const viewFactory = (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_11__.getRenderContext)(instruction.def, context).getViewFactory();
        const renderLocation = (0,_dom_js__WEBPACK_IMPORTED_MODULE_13__.convertToRenderLocation)(target);
        const componentFactory = context.getComponentFactory(
        /* parentController */ controller, 
        /* host             */ target, 
        /* instruction      */ instruction, 
        /* viewFactory      */ viewFactory, 
        /* location         */ renderLocation);
        const key = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__.CustomAttribute.keyFrom(instruction.res);
        const component = componentFactory.createComponent(key);
        const childController = _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__.Controller.forCustomAttribute(
        /* root      */ controller.root, 
        /* container */ context, 
        /* viewModel */ component, 
        /* host      */ target, 
        /* flags     */ flags);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, childController, renderLocation);
        component.link?.(flags, context, controller, childController, target, instruction);
        context.renderChildren(
        /* flags        */ flags, 
        /* instructions */ instruction.instructions, 
        /* controller   */ controller, 
        /* target       */ childController);
        controller.addController(childController);
        componentFactory.dispose();
    }
};
TemplateControllerRenderer = __decorate([
    renderer("rc" /* hydrateTemplateController */)
    /** @internal */
], TemplateControllerRenderer);

let LetElementRenderer = 
/** @internal */
class LetElementRenderer {
    constructor(parser, observerLocator) {
        this.parser = parser;
        this.observerLocator = observerLocator;
    }
    render(flags, context, controller, target, instruction) {
        target.remove();
        const childInstructions = instruction.instructions;
        const toBindingContext = instruction.toBindingContext;
        let childInstruction;
        let expr;
        let binding;
        for (let i = 0, ii = childInstructions.length; i < ii; ++i) {
            childInstruction = childInstructions[i];
            expr = ensureExpression(this.parser, childInstruction.from, 48 /* IsPropertyCommand */);
            binding = applyBindingBehavior(new _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_5__.LetBinding(expr, childInstruction.to, this.observerLocator, context, toBindingContext), expr, context);
            controller.addBinding(binding);
        }
    }
};
LetElementRenderer = __decorate([
    renderer("rd" /* hydrateLetElement */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator)
], LetElementRenderer);

let CallBindingRenderer = 
/** @internal */
class CallBindingRenderer {
    constructor(parser, observerLocator) {
        this.parser = parser;
        this.observerLocator = observerLocator;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 153 /* CallCommand */);
        const binding = applyBindingBehavior(new _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_2__.CallBinding(expr, getTarget(target), instruction.to, this.observerLocator, context), expr, context);
        controller.addBinding(binding);
    }
};
CallBindingRenderer = __decorate([
    renderer("rh" /* callBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator)
], CallBindingRenderer);

let RefBindingRenderer = 
/** @internal */
class RefBindingRenderer {
    constructor(parser) {
        this.parser = parser;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 5376 /* IsRef */);
        const binding = applyBindingBehavior(new _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_7__.RefBinding(expr, getRefTarget(target, instruction.to), context), expr, context);
        controller.addBinding(binding);
    }
};
RefBindingRenderer = __decorate([
    renderer("rj" /* refBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser)
], RefBindingRenderer);

let InterpolationBindingRenderer = 
/** @internal */
class InterpolationBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 2048 /* Interpolation */);
        const binding = new _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBinding(this.observerLocator, expr, getTarget(target), instruction.to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, context, this.platform.domWriteQueue);
        const partBindings = binding.partBindings;
        let partBinding;
        for (let i = 0, ii = partBindings.length; ii > i; ++i) {
            partBinding = partBindings[i];
            partBindings[i] = applyBindingBehavior(partBinding, partBinding.sourceExpression, context);
        }
        controller.addBinding(binding);
    }
};
InterpolationBindingRenderer = __decorate([
    renderer("rf" /* interpolation */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], InterpolationBindingRenderer);

let PropertyBindingRenderer = 
/** @internal */
class PropertyBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 48 /* IsPropertyCommand */ | instruction.mode);
        const binding = applyBindingBehavior(new _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__.PropertyBinding(expr, getTarget(target), instruction.to, instruction.mode, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
        controller.addBinding(binding);
    }
};
PropertyBindingRenderer = __decorate([
    renderer("rg" /* propertyBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], PropertyBindingRenderer);

let IteratorBindingRenderer = 
/** @internal */
class IteratorBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 539 /* ForCommand */);
        const binding = applyBindingBehavior(new _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__.PropertyBinding(expr, getTarget(target), instruction.to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
        controller.addBinding(binding);
    }
};
IteratorBindingRenderer = __decorate([
    renderer("rk" /* iteratorBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], IteratorBindingRenderer);

let behaviorExpressionIndex = 0;
const behaviorExpressions = [];
function applyBindingBehavior(binding, expression, locator) {
    while (expression instanceof _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingBehaviorExpression) {
        behaviorExpressions[behaviorExpressionIndex++] = expression;
        expression = expression.expression;
    }
    while (behaviorExpressionIndex > 0) {
        const behaviorExpression = behaviorExpressions[--behaviorExpressionIndex];
        const behaviorOrFactory = locator.get(behaviorExpression.behaviorKey);
        if (behaviorOrFactory instanceof _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingBehaviorFactory) {
            binding = behaviorOrFactory.construct(binding, behaviorExpression);
        }
    }
    behaviorExpressions.length = 0;
    return binding;
}
let TextBindingRenderer = 
/** @internal */
class TextBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const next = target.nextSibling;
        if (target.nodeName === 'AU-M') {
            target.remove();
        }
        const expr = ensureExpression(this.parser, instruction.from, 2048 /* Interpolation */);
        const binding = new _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBinding(this.observerLocator, expr, next, 'textContent', _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, context, this.platform.domWriteQueue);
        const partBindings = binding.partBindings;
        let partBinding;
        for (let i = 0, ii = partBindings.length; ii > i; ++i) {
            partBinding = partBindings[i];
            partBindings[i] = applyBindingBehavior(partBinding, partBinding.sourceExpression, context);
        }
        controller.addBinding(binding);
    }
};
TextBindingRenderer = __decorate([
    renderer("ha" /* textBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], TextBindingRenderer);

let ListenerBindingRenderer = 
/** @internal */
class ListenerBindingRenderer {
    constructor(parser, eventDelegator) {
        this.parser = parser;
        this.eventDelegator = eventDelegator;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 80 /* IsEventCommand */ | (instruction.strategy + 6 /* DelegationStrategyDelta */));
        const binding = applyBindingBehavior(new _binding_listener_js__WEBPACK_IMPORTED_MODULE_8__.Listener(context.platform, instruction.to, instruction.strategy, expr, target, instruction.preventDefault, this.eventDelegator, context), expr, context);
        controller.addBinding(binding);
    }
};
ListenerBindingRenderer = __decorate([
    renderer("hb" /* listenerBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_9__.IEventDelegator)
], ListenerBindingRenderer);

let SetAttributeRenderer = 
/** @internal */
class SetAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        target.setAttribute(instruction.to, instruction.value);
    }
};
SetAttributeRenderer = __decorate([
    renderer("he" /* setAttribute */)
    /** @internal */
], SetAttributeRenderer);

let SetClassAttributeRenderer = class SetClassAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        addClasses(target.classList, instruction.value);
    }
};
SetClassAttributeRenderer = __decorate([
    renderer("hf" /* setClassAttribute */)
], SetClassAttributeRenderer);

let SetStyleAttributeRenderer = class SetStyleAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        target.style.cssText += instruction.value;
    }
};
SetStyleAttributeRenderer = __decorate([
    renderer("hg" /* setStyleAttribute */)
], SetStyleAttributeRenderer);

let StylePropertyBindingRenderer = 
/** @internal */
class StylePropertyBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 48 /* IsPropertyCommand */ | _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
        const binding = applyBindingBehavior(new _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__.PropertyBinding(expr, target.style, instruction.to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
        controller.addBinding(binding);
    }
};
StylePropertyBindingRenderer = __decorate([
    renderer("hd" /* stylePropertyBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], StylePropertyBindingRenderer);

let AttributeBindingRenderer = 
/** @internal */
class AttributeBindingRenderer {
    constructor(parser, observerLocator) {
        this.parser = parser;
        this.observerLocator = observerLocator;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 48 /* IsPropertyCommand */ | _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
        const binding = applyBindingBehavior(new _binding_attribute_js__WEBPACK_IMPORTED_MODULE_3__.AttributeBinding(expr, target, instruction.attr /* targetAttribute */, instruction.to /* targetKey */, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, this.observerLocator, context), expr, context);
        controller.addBinding(binding);
    }
};
AttributeBindingRenderer = __decorate([
    renderer("hc" /* attributeBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator)
], AttributeBindingRenderer);

// http://jsben.ch/7n5Kt
function addClasses(classList, className) {
    const len = className.length;
    let start = 0;
    for (let i = 0; i < len; ++i) {
        if (className.charCodeAt(i) === 0x20) {
            if (i !== start) {
                classList.add(className.slice(start, i));
            }
            start = i + 1;
        }
        else if (i + 1 === len) {
            classList.add(className.slice(start));
        }
    }
}
//# sourceMappingURL=renderer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharSpec": () => /* binding */ CharSpec,
/* harmony export */   "Interpretation": () => /* binding */ Interpretation,
/* harmony export */   "State": () => /* binding */ State,
/* harmony export */   "StaticSegment": () => /* binding */ StaticSegment,
/* harmony export */   "DynamicSegment": () => /* binding */ DynamicSegment,
/* harmony export */   "SymbolSegment": () => /* binding */ SymbolSegment,
/* harmony export */   "SegmentTypes": () => /* binding */ SegmentTypes,
/* harmony export */   "ISyntaxInterpreter": () => /* binding */ ISyntaxInterpreter,
/* harmony export */   "SyntaxInterpreter": () => /* binding */ SyntaxInterpreter,
/* harmony export */   "AttrSyntax": () => /* binding */ AttrSyntax,
/* harmony export */   "IAttributePattern": () => /* binding */ IAttributePattern,
/* harmony export */   "IAttributeParser": () => /* binding */ IAttributeParser,
/* harmony export */   "AttributeParser": () => /* binding */ AttributeParser,
/* harmony export */   "attributePattern": () => /* binding */ attributePattern,
/* harmony export */   "AttributePatternResourceDefinition": () => /* binding */ AttributePatternResourceDefinition,
/* harmony export */   "AttributePattern": () => /* binding */ AttributePattern,
/* harmony export */   "DotSeparatedAttributePattern": () => /* binding */ DotSeparatedAttributePattern,
/* harmony export */   "RefAttributePattern": () => /* binding */ RefAttributePattern,
/* harmony export */   "ColonPrefixedBindAttributePattern": () => /* binding */ ColonPrefixedBindAttributePattern,
/* harmony export */   "AtPrefixedTriggerAttributePattern": () => /* binding */ AtPrefixedTriggerAttributePattern
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

/** @internal */
class CharSpec {
    constructor(chars, repeat, isSymbol, isInverted) {
        this.chars = chars;
        this.repeat = repeat;
        this.isSymbol = isSymbol;
        this.isInverted = isInverted;
        if (isInverted) {
            switch (chars.length) {
                case 0:
                    this.has = this.hasOfNoneInverse;
                    break;
                case 1:
                    this.has = this.hasOfSingleInverse;
                    break;
                default:
                    this.has = this.hasOfMultipleInverse;
            }
        }
        else {
            switch (chars.length) {
                case 0:
                    this.has = this.hasOfNone;
                    break;
                case 1:
                    this.has = this.hasOfSingle;
                    break;
                default:
                    this.has = this.hasOfMultiple;
            }
        }
    }
    equals(other) {
        return this.chars === other.chars
            && this.repeat === other.repeat
            && this.isSymbol === other.isSymbol
            && this.isInverted === other.isInverted;
    }
    hasOfMultiple(char) {
        return this.chars.includes(char);
    }
    hasOfSingle(char) {
        return this.chars === char;
    }
    hasOfNone(char) {
        return false;
    }
    hasOfMultipleInverse(char) {
        return !this.chars.includes(char);
    }
    hasOfSingleInverse(char) {
        return this.chars !== char;
    }
    hasOfNoneInverse(char) {
        return true;
    }
}
class Interpretation {
    constructor() {
        this.parts = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        this._pattern = '';
        this.currentRecord = {};
        this.partsRecord = {};
    }
    get pattern() {
        const value = this._pattern;
        if (value === '') {
            return null;
        }
        else {
            return value;
        }
    }
    set pattern(value) {
        if (value == null) {
            this._pattern = '';
            this.parts = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        else {
            this._pattern = value;
            this.parts = this.partsRecord[value];
        }
    }
    append(pattern, ch) {
        const { currentRecord } = this;
        if (currentRecord[pattern] === undefined) {
            currentRecord[pattern] = ch;
        }
        else {
            currentRecord[pattern] += ch;
        }
    }
    next(pattern) {
        const { currentRecord } = this;
        if (currentRecord[pattern] !== undefined) {
            const { partsRecord } = this;
            if (partsRecord[pattern] === undefined) {
                partsRecord[pattern] = [currentRecord[pattern]];
            }
            else {
                partsRecord[pattern].push(currentRecord[pattern]);
            }
            currentRecord[pattern] = undefined;
        }
    }
}
/** @internal */
class State {
    constructor(charSpec, ...patterns) {
        this.charSpec = charSpec;
        this.nextStates = [];
        this.types = null;
        this.isEndpoint = false;
        this.patterns = patterns;
    }
    get pattern() {
        return this.isEndpoint ? this.patterns[0] : null;
    }
    findChild(charSpec) {
        const nextStates = this.nextStates;
        const len = nextStates.length;
        let child = null;
        for (let i = 0; i < len; ++i) {
            child = nextStates[i];
            if (charSpec.equals(child.charSpec)) {
                return child;
            }
        }
        return null;
    }
    append(charSpec, pattern) {
        const { patterns } = this;
        if (!patterns.includes(pattern)) {
            patterns.push(pattern);
        }
        let state = this.findChild(charSpec);
        if (state == null) {
            state = new State(charSpec, pattern);
            this.nextStates.push(state);
            if (charSpec.repeat) {
                state.nextStates.push(state);
            }
        }
        return state;
    }
    findMatches(ch, interpretation) {
        // TODO: reuse preallocated arrays
        const results = [];
        const nextStates = this.nextStates;
        const len = nextStates.length;
        let childLen = 0;
        let child = null;
        let i = 0;
        let j = 0;
        for (; i < len; ++i) {
            child = nextStates[i];
            if (child.charSpec.has(ch)) {
                results.push(child);
                childLen = child.patterns.length;
                j = 0;
                if (child.charSpec.isSymbol) {
                    for (; j < childLen; ++j) {
                        interpretation.next(child.patterns[j]);
                    }
                }
                else {
                    for (; j < childLen; ++j) {
                        interpretation.append(child.patterns[j], ch);
                    }
                }
            }
        }
        return results;
    }
}
/** @internal */
class StaticSegment {
    constructor(text) {
        this.text = text;
        const len = this.len = text.length;
        const specs = this.specs = [];
        for (let i = 0; i < len; ++i) {
            specs.push(new CharSpec(text[i], false, false, false));
        }
    }
    eachChar(callback) {
        const { len, specs } = this;
        for (let i = 0; i < len; ++i) {
            callback(specs[i]);
        }
    }
}
/** @internal */
class DynamicSegment {
    constructor(symbols) {
        this.text = 'PART';
        this.spec = new CharSpec(symbols, true, false, true);
    }
    eachChar(callback) {
        callback(this.spec);
    }
}
/** @internal */
class SymbolSegment {
    constructor(text) {
        this.text = text;
        this.spec = new CharSpec(text, false, true, false);
    }
    eachChar(callback) {
        callback(this.spec);
    }
}
/** @internal */
class SegmentTypes {
    constructor() {
        this.statics = 0;
        this.dynamics = 0;
        this.symbols = 0;
    }
}
const ISyntaxInterpreter = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISyntaxInterpreter', x => x.singleton(SyntaxInterpreter));
class SyntaxInterpreter {
    constructor() {
        this.rootState = new State(null);
        this.initialStates = [this.rootState];
    }
    add(defOrDefs) {
        let i = 0;
        if (Array.isArray(defOrDefs)) {
            const ii = defOrDefs.length;
            for (; i < ii; ++i) {
                this.add(defOrDefs[i]);
            }
            return;
        }
        let currentState = this.rootState;
        const def = defOrDefs;
        const pattern = def.pattern;
        const types = new SegmentTypes();
        const segments = this.parse(def, types);
        const len = segments.length;
        const callback = (ch) => {
            currentState = currentState.append(ch, pattern);
        };
        for (i = 0; i < len; ++i) {
            segments[i].eachChar(callback);
        }
        currentState.types = types;
        currentState.isEndpoint = true;
    }
    interpret(name) {
        const interpretation = new Interpretation();
        let states = this.initialStates;
        const len = name.length;
        for (let i = 0; i < len; ++i) {
            states = this.getNextStates(states, name.charAt(i), interpretation);
            if (states.length === 0) {
                break;
            }
        }
        states.sort((a, b) => {
            if (a.isEndpoint) {
                if (!b.isEndpoint) {
                    return -1;
                }
            }
            else if (b.isEndpoint) {
                return 1;
            }
            else {
                return 0;
            }
            const aTypes = a.types;
            const bTypes = b.types;
            if (aTypes.statics !== bTypes.statics) {
                return bTypes.statics - aTypes.statics;
            }
            if (aTypes.dynamics !== bTypes.dynamics) {
                return bTypes.dynamics - aTypes.dynamics;
            }
            if (aTypes.symbols !== bTypes.symbols) {
                return bTypes.symbols - aTypes.symbols;
            }
            return 0;
        });
        if (states.length > 0) {
            const state = states[0];
            if (!state.charSpec.isSymbol) {
                interpretation.next(state.pattern);
            }
            interpretation.pattern = state.pattern;
        }
        return interpretation;
    }
    getNextStates(states, ch, interpretation) {
        // TODO: reuse preallocated arrays
        const nextStates = [];
        let state = null;
        const len = states.length;
        for (let i = 0; i < len; ++i) {
            state = states[i];
            nextStates.push(...state.findMatches(ch, interpretation));
        }
        return nextStates;
    }
    parse(def, types) {
        const result = [];
        const pattern = def.pattern;
        const len = pattern.length;
        let i = 0;
        let start = 0;
        let c = '';
        while (i < len) {
            c = pattern.charAt(i);
            if (!def.symbols.includes(c)) {
                if (i === start) {
                    if (c === 'P' && pattern.slice(i, i + 4) === 'PART') {
                        start = i = (i + 4);
                        result.push(new DynamicSegment(def.symbols));
                        ++types.dynamics;
                    }
                    else {
                        ++i;
                    }
                }
                else {
                    ++i;
                }
            }
            else if (i !== start) {
                result.push(new StaticSegment(pattern.slice(start, i)));
                ++types.statics;
                start = i;
            }
            else {
                result.push(new SymbolSegment(pattern.slice(start, i + 1)));
                ++types.symbols;
                start = ++i;
            }
        }
        if (start !== i) {
            result.push(new StaticSegment(pattern.slice(start, i)));
            ++types.statics;
        }
        return result;
    }
}
class AttrSyntax {
    constructor(rawName, rawValue, target, command) {
        this.rawName = rawName;
        this.rawValue = rawValue;
        this.target = target;
        this.command = command;
    }
}
const IAttributePattern = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAttributePattern');
const IAttributeParser = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAttributeParser', x => x.singleton(AttributeParser));
let AttributeParser = class AttributeParser {
    constructor(interpreter, attrPatterns) {
        this.interpreter = interpreter;
        this.cache = {};
        const patterns = this.patterns = {};
        attrPatterns.forEach(attrPattern => {
            const defs = AttributePattern.getPatternDefinitions(attrPattern.constructor);
            interpreter.add(defs);
            defs.forEach(def => {
                patterns[def.pattern] = attrPattern;
            });
        });
    }
    parse(name, value) {
        let interpretation = this.cache[name];
        if (interpretation == null) {
            interpretation = this.cache[name] = this.interpreter.interpret(name);
        }
        const pattern = interpretation.pattern;
        if (pattern == null) {
            return new AttrSyntax(name, value, name, null);
        }
        else {
            return this.patterns[pattern][pattern](name, value, interpretation.parts);
        }
    }
};
AttributeParser = __decorate([
    __param(0, ISyntaxInterpreter),
    __param(1, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.all)(IAttributePattern))
], AttributeParser);

function attributePattern(...patternDefs) {
    return function decorator(target) {
        return AttributePattern.define(patternDefs, target);
    };
}
class AttributePatternResourceDefinition {
    constructor(Type) {
        this.Type = Type;
        this.name = (void 0);
    }
    register(container) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(IAttributePattern, this.Type).register(container);
    }
}
const AttributePattern = Object.freeze({
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('attribute-pattern'),
    definitionAnnotationKey: 'attribute-pattern-definitions',
    define(patternDefs, Type) {
        const definition = new AttributePatternResourceDefinition(Type);
        const { name, definitionAnnotationKey } = AttributePattern;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(name, definition, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, name);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.set(Type, definitionAnnotationKey, patternDefs);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo(Type, definitionAnnotationKey);
        return Type;
    },
    getPatternDefinitions(Type) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.get(Type, AttributePattern.definitionAnnotationKey);
    }
});
let DotSeparatedAttributePattern = class DotSeparatedAttributePattern {
    'PART.PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);
    }
    'PART.PART.PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], parts[2]);
    }
};
DotSeparatedAttributePattern = __decorate([
    attributePattern({ pattern: 'PART.PART', symbols: '.' }, { pattern: 'PART.PART.PART', symbols: '.' })
], DotSeparatedAttributePattern);

let RefAttributePattern = class RefAttributePattern {
    'ref'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, 'element', 'ref');
    }
    'PART.ref'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], 'ref');
    }
};
RefAttributePattern = __decorate([
    attributePattern({ pattern: 'ref', symbols: '' }, { pattern: 'PART.ref', symbols: '.' })
], RefAttributePattern);

let ColonPrefixedBindAttributePattern = class ColonPrefixedBindAttributePattern {
    ':PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], 'bind');
    }
};
ColonPrefixedBindAttributePattern = __decorate([
    attributePattern({ pattern: ':PART', symbols: ':' })
], ColonPrefixedBindAttributePattern);

let AtPrefixedTriggerAttributePattern = class AtPrefixedTriggerAttributePattern {
    '@PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], 'trigger');
    }
};
AtPrefixedTriggerAttributePattern = __decorate([
    attributePattern({ pattern: '@PART', symbols: '@' })
], AtPrefixedTriggerAttributePattern);

//# sourceMappingURL=attribute-pattern.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttrBindingBehavior": () => /* binding */ AttrBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../observation/data-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let AttrBindingBehavior = class AttrBindingBehavior {
    bind(flags, _scope, _hostScope, binding) {
        binding.targetObserver = _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_1__.attrAccessor;
    }
    unbind(flags, _scope, _hostScope, binding) {
        return;
    }
};
AttrBindingBehavior = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('attr')
], AttrBindingBehavior);

//# sourceMappingURL=attr.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "handleSelfEvent": () => /* binding */ handleSelfEvent,
/* harmony export */   "SelfBindingBehavior": () => /* binding */ SelfBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/** @internal */
function handleSelfEvent(event) {
    const target = event.composedPath()[0];
    if (this.target !== target) {
        return;
    }
    return this.selfEventCallSource(event);
}
let SelfBindingBehavior = class SelfBindingBehavior {
    bind(flags, _scope, _hostScope, binding) {
        if (!binding.callSource || !binding.targetEvent) {
            throw new Error('Self binding behavior only supports events.');
        }
        binding.selfEventCallSource = binding.callSource;
        binding.callSource = handleSelfEvent;
    }
    unbind(flags, _scope, _hostScope, binding) {
        binding.callSource = binding.selfEventCallSource;
        binding.selfEventCallSource = null;
    }
};
SelfBindingBehavior = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('self')
], SelfBindingBehavior);

//# sourceMappingURL=self.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UpdateTriggerBindingBehavior": () => /* binding */ UpdateTriggerBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../observation/event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../observation/observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



let UpdateTriggerBindingBehavior = class UpdateTriggerBindingBehavior {
    constructor(observerLocator) {
        this.observerLocator = observerLocator;
    }
    bind(flags, _scope, _hostScope, binding, ...events) {
        if (events.length === 0) {
            throw new Error('The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">');
        }
        if (binding.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.twoWay && binding.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.fromView) {
            throw new Error('The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.');
        }
        // ensure the binding's target observer has been set.
        const targetObserver = this.observerLocator.getObserver(binding.target, binding.targetProperty);
        if (!targetObserver.handler) {
            throw new Error('The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.');
        }
        binding.targetObserver = targetObserver;
        // stash the original element subscribe function.
        const originalHandler = targetObserver.handler;
        targetObserver.originalHandler = originalHandler;
        // replace the element subscribe function with one that uses the correct events.
        targetObserver.handler = new _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_1__.EventSubscriber(new _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_2__.NodeObserverConfig({
            default: originalHandler.config.default,
            events,
            readonly: originalHandler.config.readonly
        }));
    }
    unbind(flags, _scope, _hostScope, binding) {
        // restore the state of the binding.
        binding.targetObserver.handler.dispose();
        binding.targetObserver.handler = binding.targetObserver.originalHandler;
        binding.targetObserver.originalHandler = null;
    }
};
UpdateTriggerBindingBehavior = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('updateTrigger'),
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.IObserverLocator)
], UpdateTriggerBindingBehavior);

//# sourceMappingURL=update-trigger.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bindingCommand": () => /* binding */ bindingCommand,
/* harmony export */   "BindingCommandDefinition": () => /* binding */ BindingCommandDefinition,
/* harmony export */   "BindingCommand": () => /* binding */ BindingCommand,
/* harmony export */   "getTarget": () => /* binding */ getTarget,
/* harmony export */   "OneTimeBindingCommand": () => /* binding */ OneTimeBindingCommand,
/* harmony export */   "ToViewBindingCommand": () => /* binding */ ToViewBindingCommand,
/* harmony export */   "FromViewBindingCommand": () => /* binding */ FromViewBindingCommand,
/* harmony export */   "TwoWayBindingCommand": () => /* binding */ TwoWayBindingCommand,
/* harmony export */   "DefaultBindingCommand": () => /* binding */ DefaultBindingCommand,
/* harmony export */   "CallBindingCommand": () => /* binding */ CallBindingCommand,
/* harmony export */   "ForBindingCommand": () => /* binding */ ForBindingCommand,
/* harmony export */   "TriggerBindingCommand": () => /* binding */ TriggerBindingCommand,
/* harmony export */   "DelegateBindingCommand": () => /* binding */ DelegateBindingCommand,
/* harmony export */   "CaptureBindingCommand": () => /* binding */ CaptureBindingCommand,
/* harmony export */   "AttrBindingCommand": () => /* binding */ AttrBindingCommand,
/* harmony export */   "StyleBindingCommand": () => /* binding */ StyleBindingCommand,
/* harmony export */   "ClassBindingCommand": () => /* binding */ ClassBindingCommand,
/* harmony export */   "RefBindingCommand": () => /* binding */ RefBindingCommand
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _semantic_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../semantic-model.js */ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




function bindingCommand(nameOrDefinition) {
    return function (target) {
        return BindingCommand.define(nameOrDefinition, target);
    };
}
class BindingCommandDefinition {
    constructor(Type, name, aliases, key, type) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.type = type;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        return new BindingCommandDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(BindingCommand.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(BindingCommand.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), BindingCommand.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(BindingCommand.getAnnotation(Type, 'type'), def.type, Type.type, null));
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, BindingCommand, key, container);
    }
}
const BindingCommand = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('binding-command'),
    keyFrom(name) {
        return `${BindingCommand.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(BindingCommand.name, value);
    },
    define(nameOrDef, Type) {
        const definition = BindingCommandDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingCommand.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingCommand.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, BindingCommand.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(BindingCommand.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
function getTarget(binding, makeCamelCase) {
    if (binding.flags & 256 /* isBinding */) {
        return binding.bindable.propName;
    }
    else if (makeCamelCase) {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(binding.syntax.target);
    }
    else {
        return binding.syntax.target;
    }
}
let OneTimeBindingCommand = class OneTimeBindingCommand {
    constructor() {
        this.bindingType = 49 /* OneTimeCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime);
    }
};
OneTimeBindingCommand = __decorate([
    bindingCommand('one-time')
], OneTimeBindingCommand);

let ToViewBindingCommand = class ToViewBindingCommand {
    constructor() {
        this.bindingType = 50 /* ToViewCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
    }
};
ToViewBindingCommand = __decorate([
    bindingCommand('to-view')
], ToViewBindingCommand);

let FromViewBindingCommand = class FromViewBindingCommand {
    constructor() {
        this.bindingType = 51 /* FromViewCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView);
    }
};
FromViewBindingCommand = __decorate([
    bindingCommand('from-view')
], FromViewBindingCommand);

let TwoWayBindingCommand = class TwoWayBindingCommand {
    constructor() {
        this.bindingType = 52 /* TwoWayCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay);
    }
};
TwoWayBindingCommand = __decorate([
    bindingCommand('two-way')
], TwoWayBindingCommand);

let DefaultBindingCommand = class DefaultBindingCommand {
    constructor() {
        this.bindingType = 53 /* BindCommand */;
    }
    compile(binding) {
        let mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default;
        if (binding instanceof _semantic_model_js__WEBPACK_IMPORTED_MODULE_3__.BindingSymbol) {
            mode = binding.bindable.mode;
        }
        else {
            const command = binding.syntax.command;
            switch (command) {
                case 'bind':
                case 'to-view':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
                    break;
                case 'one-time':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime;
                    break;
                case 'from-view':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView;
                    break;
                case 'two-way':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay;
                    break;
            }
        }
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), mode === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default ? _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView : mode);
    }
};
DefaultBindingCommand = __decorate([
    bindingCommand('bind')
], DefaultBindingCommand);

let CallBindingCommand = class CallBindingCommand {
    constructor() {
        this.bindingType = 153 /* CallCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.CallBindingInstruction(binding.expression, getTarget(binding, true));
    }
};
CallBindingCommand = __decorate([
    bindingCommand('call')
], CallBindingCommand);

let ForBindingCommand = class ForBindingCommand {
    constructor() {
        this.bindingType = 539 /* ForCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.IteratorBindingInstruction(binding.expression, getTarget(binding, false));
    }
};
ForBindingCommand = __decorate([
    bindingCommand('for')
], ForBindingCommand);

let TriggerBindingCommand = class TriggerBindingCommand {
    constructor() {
        this.bindingType = 4182 /* TriggerCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.ListenerBindingInstruction(binding.expression, getTarget(binding, false), true, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.DelegationStrategy.none);
    }
};
TriggerBindingCommand = __decorate([
    bindingCommand('trigger')
], TriggerBindingCommand);

let DelegateBindingCommand = class DelegateBindingCommand {
    constructor() {
        this.bindingType = 4184 /* DelegateCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.ListenerBindingInstruction(binding.expression, getTarget(binding, false), false, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.DelegationStrategy.bubbling);
    }
};
DelegateBindingCommand = __decorate([
    bindingCommand('delegate')
], DelegateBindingCommand);

let CaptureBindingCommand = class CaptureBindingCommand {
    constructor() {
        this.bindingType = 4183 /* CaptureCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.ListenerBindingInstruction(binding.expression, getTarget(binding, false), false, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.DelegationStrategy.capturing);
    }
};
CaptureBindingCommand = __decorate([
    bindingCommand('capture')
], CaptureBindingCommand);

/**
 * Attr binding command. Compile attr with binding symbol with command `attr` to `AttributeBindingInstruction`
 */
let AttrBindingCommand = class AttrBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */;
    }
    compile(binding) {
        const target = getTarget(binding, false);
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.AttributeBindingInstruction(target, binding.expression, target);
    }
};
AttrBindingCommand = __decorate([
    bindingCommand('attr')
], AttrBindingCommand);

/**
 * Style binding command. Compile attr with binding symbol with command `style` to `AttributeBindingInstruction`
 */
let StyleBindingCommand = class StyleBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.AttributeBindingInstruction('style', binding.expression, getTarget(binding, false));
    }
};
StyleBindingCommand = __decorate([
    bindingCommand('style')
], StyleBindingCommand);

/**
 * Class binding command. Compile attr with binding symbol with command `class` to `AttributeBindingInstruction`
 */
let ClassBindingCommand = class ClassBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.AttributeBindingInstruction('class', binding.expression, getTarget(binding, false));
    }
};
ClassBindingCommand = __decorate([
    bindingCommand('class')
], ClassBindingCommand);

/**
 * Binding command to refer different targets (element, custom element/attribute view models, controller) attached to an element
 */
let RefBindingCommand = class RefBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */ | 4096 /* IgnoreCustomAttr */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.RefBindingInstruction(binding.expression, getTarget(binding, false));
    }
};
RefBindingCommand = __decorate([
    bindingCommand('ref')
], RefBindingCommand);

//# sourceMappingURL=binding-command.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customAttribute": () => /* binding */ customAttribute,
/* harmony export */   "templateController": () => /* binding */ templateController,
/* harmony export */   "CustomAttributeDefinition": () => /* binding */ CustomAttributeDefinition,
/* harmony export */   "CustomAttribute": () => /* binding */ CustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _watch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../watch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js");




function customAttribute(nameOrDef) {
    return function (target) {
        return CustomAttribute.define(nameOrDef, target);
    };
}
function templateController(nameOrDef) {
    return function (target) {
        return CustomAttribute.define(typeof nameOrDef === 'string'
            ? { isTemplateController: true, name: nameOrDef }
            : { isTemplateController: true, ...nameOrDef }, target);
    };
}
class CustomAttributeDefinition {
    constructor(Type, name, aliases, key, defaultBindingMode, isTemplateController, bindables, noMultiBindings, watches) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.defaultBindingMode = defaultBindingMode;
        this.isTemplateController = isTemplateController;
        this.bindables = bindables;
        this.noMultiBindings = noMultiBindings;
        this.watches = watches;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        return new CustomAttributeDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomAttribute.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), CustomAttribute.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'defaultBindingMode'), def.defaultBindingMode, Type.defaultBindingMode, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'isTemplateController'), def.isTemplateController, Type.isTemplateController, false), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(..._bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.getAll(Type), CustomAttribute.getAnnotation(Type, 'bindables'), Type.bindables, def.bindables), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'noMultiBindings'), def.noMultiBindings, Type.noMultiBindings, false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(_watch_js__WEBPACK_IMPORTED_MODULE_3__.Watch.getAnnotation(Type), Type.watches));
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.transient(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, CustomAttribute, key, container);
    }
}
const CustomAttribute = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('custom-attribute'),
    keyFrom(name) {
        return `${CustomAttribute.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(CustomAttribute.name, value);
    },
    for(node, name) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomAttribute.keyFrom(name), node);
    },
    define(nameOrDef, Type) {
        const definition = CustomAttributeDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomAttribute.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomAttribute.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, CustomAttribute.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomAttribute.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
//# sourceMappingURL=custom-attribute.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlurManager": () => /* binding */ BlurManager,
/* harmony export */   "Blur": () => /* binding */ Blur
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





const unset = Symbol();
// Using passive to help with performance
const defaultCaptureEventInit = {
    passive: true,
    capture: true
};
// Using passive to help with performance
const defaultBubbleEventInit = {
    passive: true
};
// weakly connect a document to a blur manager
// to avoid polluting the document properties
const blurDocMap = new WeakMap();
class BlurManager {
    constructor(platform) {
        this.platform = platform;
        this.blurs = [];
        blurDocMap.set(platform.document, this);
        this.handler = createHandler(this, this.blurs);
    }
    static createFor(platform) {
        return blurDocMap.get(platform.document) || new BlurManager(platform);
    }
    register(blur) {
        const blurs = this.blurs;
        if (!blurs.includes(blur) && blurs.push(blur) === 1) {
            this.addListeners();
        }
    }
    unregister(blur) {
        const blurs = this.blurs;
        const index = blurs.indexOf(blur);
        if (index > -1) {
            blurs.splice(index, 1);
        }
        if (blurs.length === 0) {
            this.removeListeners();
        }
    }
    addListeners() {
        const p = this.platform;
        const doc = p.document;
        const win = p.window;
        const handler = this.handler;
        if (win.navigator.pointerEnabled) {
            doc.addEventListener('pointerdown', handler, defaultCaptureEventInit);
        }
        doc.addEventListener('touchstart', handler, defaultCaptureEventInit);
        doc.addEventListener('mousedown', handler, defaultCaptureEventInit);
        doc.addEventListener('focus', handler, defaultCaptureEventInit);
        win.addEventListener('blur', handler, defaultBubbleEventInit);
    }
    removeListeners() {
        const p = this.platform;
        const doc = p.document;
        const win = p.window;
        const handler = this.handler;
        if (win.navigator.pointerEnabled) {
            doc.removeEventListener('pointerdown', handler, defaultCaptureEventInit);
        }
        doc.removeEventListener('touchstart', handler, defaultCaptureEventInit);
        doc.removeEventListener('mousedown', handler, defaultCaptureEventInit);
        doc.removeEventListener('focus', handler, defaultCaptureEventInit);
        win.removeEventListener('blur', handler, defaultBubbleEventInit);
    }
}
let Blur = class Blur {
    constructor(element, p) {
        this.element = element;
        this.p = p;
        /**
         * By default, the behavior should be least surprise possible, that:
         *
         * it searches for anything from root context,
         * and root context is document body
         */
        this.linkedMultiple = true;
        this.searchSubTree = true;
        this.linkingContext = null;
        this.value = unset;
        this.manager = BlurManager.createFor(p);
    }
    attached() {
        this.manager.register(this);
    }
    detaching() {
        this.manager.unregister(this);
    }
    handleEventTarget(target) {
        if (this.value === false) {
            return;
        }
        const p = this.p;
        if (target === p.window || target === p.document || !this.contains(target)) {
            this.triggerBlur();
        }
    }
    contains(target) {
        if (!this.value) {
            return false;
        }
        let els;
        let i;
        let j, jj;
        let link;
        const element = this.element;
        if (containsElementOrShadowRoot(element, target)) {
            return true;
        }
        if (!this.linkedWith) {
            return false;
        }
        const doc = this.p.document;
        const linkedWith = this.linkedWith;
        const linkingContext = this.linkingContext;
        const searchSubTree = this.searchSubTree;
        const linkedMultiple = this.linkedMultiple;
        const links = Array.isArray(linkedWith) ? linkedWith : [linkedWith];
        const contextNode = (typeof linkingContext === 'string'
            ? doc.querySelector(linkingContext)
            : linkingContext)
            || doc.body;
        const ii = links.length;
        for (i = 0; ii > i; ++i) {
            link = links[i];
            // When user specify to link with something by a string, it acts as a CSS selector
            // We need to do some querying stuff to determine if target above is contained.
            if (typeof link === 'string') {
                // Default behavior, search the whole tree, from context that user specified, which default to document body
                if (searchSubTree) {
                    // todo: are there too many knobs?? Consider remove "linkedMultiple"??
                    if (!linkedMultiple) {
                        const el = contextNode.querySelector(link);
                        els = el !== null ? [el] : _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
                    }
                    else {
                        els = contextNode.querySelectorAll(link);
                    }
                    jj = els.length;
                    for (j = 0; jj > j; ++j) {
                        if (els[j].contains(target)) {
                            return true;
                        }
                    }
                }
                else {
                    // default to document body, if user didn't define a linking context, and wanted to ignore subtree.
                    // This is specifically performant and useful for dialogs, plugins
                    // that usually generate contents to document body
                    els = contextNode.children;
                    jj = els.length;
                    for (j = 0; jj > j; ++j) {
                        if (els[j].matches(link)) {
                            return true;
                        }
                    }
                }
            }
            else {
                // When user passed in something that is not a string,
                // simply check if has method `contains` (allow duck typing)
                // and call it against target.
                // This enables flexible usages
                if (link && link.contains(target)) {
                    return true;
                }
            }
        }
        return false;
    }
    triggerBlur() {
        this.value = false;
        if (typeof this.onBlur === 'function') {
            this.onBlur.call(null);
        }
    }
};
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "value", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "onBlur", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "linkedWith", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "linkedMultiple", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "searchSubTree", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "linkingContext", void 0);
Blur = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('blur'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(1, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform)
], Blur);

const containsElementOrShadowRoot = (container, target) => {
    if (container.contains(target)) {
        return true;
    }
    let parentNode = null;
    while (target != null) {
        if (target === container) {
            return true;
        }
        parentNode = target.parentNode;
        if (parentNode === null && target.nodeType === 11 /* DocumentFragment */) {
            target = target.host;
            continue;
        }
        target = parentNode;
    }
    return false;
};
const createHandler = (manager, checkTargets) => {
    // *******************************
    // EVENTS ORDER
    // -----------------------------
    // pointerdown
    // touchstart
    // pointerup
    // touchend
    // mousedown
    // --------------
    // BLUR
    // FOCUS
    // --------------
    // mouseup
    // click
    //
    // ******************************
    //
    // There are cases focus happens without mouse interaction (keyboard)
    // So it needs to capture both mouse / focus movement
    //
    // ******************************
    let hasChecked = false;
    const revertCheckage = () => {
        hasChecked = false;
    };
    const markChecked = () => {
        hasChecked = true;
        manager.platform.domWriteQueue.queueTask(revertCheckage, { preempt: true });
    };
    const handleMousedown = (e) => {
        if (!hasChecked) {
            handleEvent(e);
            markChecked();
        }
    };
    /**
     * Handle globally captured focus event
     * This can happen via a few way:
     * User clicks on a focusable element
     * User uses keyboard to navigate to a focusable element
     * User goes back to the window from another browser tab
     * User clicks on a non-focusable element
     * User clicks on the window, outside of the document
     */
    const handleFocus = (e) => {
        if (hasChecked) {
            return;
        }
        // there are two way a focus gets captured on window
        // when the windows itself got focus
        // and when an element in the document gets focus
        // when the window itself got focus, reacting to it is quite unnecessary
        // as it doesn't really affect element inside the document
        // Do a simple check and bail immediately
        const isWindow = e.target === manager.platform.window;
        if (isWindow) {
            for (let i = 0, ii = checkTargets.length; ii > i; ++i) {
                checkTargets[i].triggerBlur();
            }
        }
        else {
            handleEvent(e);
        }
        markChecked();
    };
    const handleWindowBlur = () => {
        hasChecked = false;
        for (let i = 0, ii = checkTargets.length; i < ii; ++i) {
            checkTargets[i].triggerBlur();
        }
    };
    const handleEvent = (e) => {
        const target = e.composed ? e.composedPath()[0] : e.target;
        if (target === null) {
            return;
        }
        for (let i = 0, ii = checkTargets.length; i < ii; ++i) {
            checkTargets[i].handleEventTarget(target);
        }
    };
    return {
        onpointerdown: handleMousedown,
        ontouchstart: handleMousedown,
        onmousedown: handleMousedown,
        onfocus: handleFocus,
        onblur: handleWindowBlur,
        handleEvent(e) {
            this[`on${e.type}`](e);
        }
    };
};
//# sourceMappingURL=blur.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Focus": () => /* binding */ Focus
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





/**
 * Focus attribute for element focus binding
 */
let Focus = class Focus {
    constructor(element, p) {
        this.element = element;
        this.p = p;
        /**
         * Indicates whether `apply` should be called when `attached` callback is invoked
         */
        this.needsApply = false;
    }
    binding() {
        this.valueChanged();
    }
    /**
     * Invoked everytime the bound value changes.
     *
     * @param newValue - The new value.
     */
    valueChanged() {
        // In theory, we could/should react immediately
        // but focus state of an element cannot be achieved
        // while it's disconnected from the document
        // thus, there neesd to be a check if it's currently connected or not
        // before applying the value to the element
        if (this.$controller.isActive) {
            this.apply();
        }
        else {
            // If the element is not currently connect
            // toggle the flag to add pending work for later
            // in attached lifecycle
            this.needsApply = true;
        }
    }
    /**
     * Invoked when the attribute is attached to the DOM.
     */
    attached() {
        if (this.needsApply) {
            this.needsApply = false;
            this.apply();
        }
        const el = this.element;
        el.addEventListener('focus', this);
        el.addEventListener('blur', this);
    }
    /**
     * Invoked when the attribute is afterDetachChildren from the DOM.
     */
    afterDetachChildren() {
        const el = this.element;
        el.removeEventListener('focus', this);
        el.removeEventListener('blur', this);
    }
    /**
     * EventTarget interface handler for better memory usage
     */
    handleEvent(e) {
        // there are only two event listened to
        // if the even is focus, it menans the element is focused
        // only need to switch the value to true
        if (e.type === 'focus') {
            this.value = true;
        }
        else if (!this.isElFocused) {
            // else, it's blur event
            // when a blur event happens, there are two situations
            // 1. the element itself lost the focus
            // 2. window lost the focus
            // To handle both (1) and (2), only need to check if
            // current active element is still the same element of this focus custom attribute
            // If it's not, it's a blur event happened on Window because the browser tab lost focus
            this.value = false;
        }
    }
    /**
     * Focus/blur based on current value
     */
    apply() {
        const el = this.element;
        const isFocused = this.isElFocused;
        const shouldFocus = this.value;
        if (shouldFocus && !isFocused) {
            el.focus();
        }
        else if (!shouldFocus && isFocused) {
            el.blur();
        }
    }
    get isElFocused() {
        return this.element === this.p.document.activeElement;
    }
};
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)({ mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.twoWay })
], Focus.prototype, "value", void 0);
Focus = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('focus'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(1, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform)
], Focus);

//# sourceMappingURL=focus.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Show": () => /* binding */ Show
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let Show = class Show {
    constructor(el, p, instr) {
        this.el = el;
        this.p = p;
        this.isActive = false;
        this.task = null;
        this.$val = '';
        this.$prio = '';
        this.update = () => {
            this.task = null;
            // Only compare at the synchronous moment when we're about to update, because the value might have changed since the update was queued.
            if (Boolean(this.value) !== this.isToggled) {
                if (this.isToggled === this.base) {
                    this.isToggled = !this.base;
                    // Note: in v1 we used the 'au-hide' class, but in v2 it's so trivial to conditionally apply classes (e.g. 'hide.class="someCondition"'),
                    // that it's probably better to avoid the CSS inject infra involvement and keep this CA as simple as possible.
                    // Instead, just store and restore the property values (with each mutation, to account for in-between updates), to cover the common cases, until there is convincing feedback to do otherwise.
                    this.$val = this.el.style.getPropertyValue('display');
                    this.$prio = this.el.style.getPropertyPriority('display');
                    this.el.style.setProperty('display', 'none', 'important');
                }
                else {
                    this.isToggled = this.base;
                    this.el.style.setProperty('display', this.$val, this.$prio);
                    // If the style attribute is now empty, remove it.
                    if (this.el.getAttribute('style') === '') {
                        this.el.removeAttribute('style');
                    }
                }
            }
        };
        // if this is declared as a 'hide' attribute, then this.base will be false, inverting everything.
        this.isToggled = this.base = instr.alias !== 'hide';
    }
    binding() {
        this.isActive = true;
        this.update();
    }
    detaching() {
        this.isActive = false;
        this.task?.cancel();
        this.task = null;
    }
    valueChanged() {
        if (this.isActive && this.task === null) {
            this.task = this.p.domWriteQueue.queueTask(this.update);
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable
], Show.prototype, "value", void 0);
Show = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('show'),
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.alias)('hide'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(1, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform),
    __param(2, _renderer_js__WEBPACK_IMPORTED_MODULE_5__.IInstruction)
], Show);

//# sourceMappingURL=show.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customElement": () => /* binding */ customElement,
/* harmony export */   "useShadowDOM": () => /* binding */ useShadowDOM,
/* harmony export */   "containerless": () => /* binding */ containerless,
/* harmony export */   "strict": () => /* binding */ strict,
/* harmony export */   "CustomElementDefinition": () => /* binding */ CustomElementDefinition,
/* harmony export */   "CustomElement": () => /* binding */ CustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_children_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../templating/children.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js");
/* harmony import */ var _watch_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../watch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js");






function customElement(nameOrDef) {
    return function (target) {
        return CustomElement.define(nameOrDef, target);
    };
}
function useShadowDOM(targetOrOptions) {
    if (targetOrOptions === void 0) {
        return function ($target) {
            CustomElement.annotate($target, 'shadowOptions', { mode: 'open' });
        };
    }
    if (typeof targetOrOptions !== 'function') {
        return function ($target) {
            CustomElement.annotate($target, 'shadowOptions', targetOrOptions);
        };
    }
    CustomElement.annotate(targetOrOptions, 'shadowOptions', { mode: 'open' });
}
function containerless(target) {
    if (target === void 0) {
        return function ($target) {
            CustomElement.annotate($target, 'containerless', true);
        };
    }
    CustomElement.annotate(target, 'containerless', true);
}
function strict(target) {
    if (target === void 0) {
        return function ($target) {
            CustomElement.annotate($target, 'isStrictBinding', true);
        };
    }
    CustomElement.annotate(target, 'isStrictBinding', true);
}
const definitionLookup = new WeakMap();
class CustomElementDefinition {
    constructor(Type, name, aliases, key, cache, template, instructions, dependencies, injectable, needsCompile, surrogates, bindables, childrenObservers, containerless, isStrictBinding, shadowOptions, hasSlots, enhance, projectionsMap, watches) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.cache = cache;
        this.template = template;
        this.instructions = instructions;
        this.dependencies = dependencies;
        this.injectable = injectable;
        this.needsCompile = needsCompile;
        this.surrogates = surrogates;
        this.bindables = bindables;
        this.childrenObservers = childrenObservers;
        this.containerless = containerless;
        this.isStrictBinding = isStrictBinding;
        this.shadowOptions = shadowOptions;
        this.hasSlots = hasSlots;
        this.enhance = enhance;
        this.projectionsMap = projectionsMap;
        this.watches = watches;
    }
    static create(nameOrDef, Type = null) {
        if (Type === null) {
            const def = nameOrDef;
            if (typeof def === 'string') {
                throw new Error(`Cannot create a custom element definition with only a name and no type: ${nameOrDef}`);
            }
            const name = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('name', def, CustomElement.generateName);
            if (typeof def.Type === 'function') {
                // This needs to be a clone (it will usually be the compiler calling this signature)
                // TODO: we need to make sure it's documented that passing in the type via the definition (while passing in null
                // as the "Type" parameter) effectively skips type analysis, so it should only be used this way for cloning purposes.
                Type = def.Type;
            }
            else {
                Type = CustomElement.generateType((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.pascalCase)(name));
            }
            return new CustomElementDefinition(Type, name, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.aliases), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('key', def, () => CustomElement.keyFrom(name)), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('cache', def, () => 0), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('template', def, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.instructions), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.dependencies), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('injectable', def, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('needsCompile', def, () => true), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.surrogates), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(def.bindables), _templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.from(def.childrenObservers), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('containerless', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('isStrictBinding', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('shadowOptions', def, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('hasSlots', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('enhance', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('projectionsMap', def, () => new Map()), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('watches', def, () => _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray));
        }
        // If a type is passed in, we ignore the Type property on the definition if it exists.
        // TODO: document this behavior
        if (typeof nameOrDef === 'string') {
            return new CustomElementDefinition(Type, nameOrDef, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'aliases'), Type.aliases), CustomElement.keyFrom(nameOrDef), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('cache', Type, () => 0), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('template', Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'instructions'), Type.instructions), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'dependencies'), Type.dependencies), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('injectable', Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('needsCompile', Type, () => true), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'surrogates'), Type.surrogates), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(..._bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.getAll(Type), CustomElement.getAnnotation(Type, 'bindables'), Type.bindables), _templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.from(..._templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.getAll(Type), CustomElement.getAnnotation(Type, 'childrenObservers'), Type.childrenObservers), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('containerless', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('isStrictBinding', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('shadowOptions', Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('hasSlots', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('enhance', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('projectionsMap', Type, () => new Map()), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(_watch_js__WEBPACK_IMPORTED_MODULE_5__.Watch.getAnnotation(Type), Type.watches));
        }
        // This is the typical default behavior, e.g. from regular CustomElement.define invocations or from @customElement deco
        // The ViewValueConverter also uses this signature and passes in a definition where everything except for the 'hooks'
        // property needs to be copied. So we have that exception for 'hooks', but we may need to revisit that default behavior
        // if this turns out to be too opinionated.
        const name = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('name', nameOrDef, CustomElement.generateName);
        return new CustomElementDefinition(Type, name, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'aliases'), nameOrDef.aliases, Type.aliases), CustomElement.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('cache', nameOrDef, Type, () => 0), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('template', nameOrDef, Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'instructions'), nameOrDef.instructions, Type.instructions), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'dependencies'), nameOrDef.dependencies, Type.dependencies), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('injectable', nameOrDef, Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('needsCompile', nameOrDef, Type, () => true), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'surrogates'), nameOrDef.surrogates, Type.surrogates), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(..._bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.getAll(Type), CustomElement.getAnnotation(Type, 'bindables'), Type.bindables, nameOrDef.bindables), _templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.from(..._templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.getAll(Type), CustomElement.getAnnotation(Type, 'childrenObservers'), Type.childrenObservers, nameOrDef.childrenObservers), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('containerless', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('isStrictBinding', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('shadowOptions', nameOrDef, Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('hasSlots', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('enhance', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('projectionsMap', nameOrDef, Type, () => new Map()), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(nameOrDef.watches, _watch_js__WEBPACK_IMPORTED_MODULE_5__.Watch.getAnnotation(Type), Type.watches));
    }
    static getOrCreate(partialDefinition) {
        if (partialDefinition instanceof CustomElementDefinition) {
            return partialDefinition;
        }
        if (definitionLookup.has(partialDefinition)) {
            return definitionLookup.get(partialDefinition);
        }
        const definition = CustomElementDefinition.create(partialDefinition);
        definitionLookup.set(partialDefinition, definition);
        // Make sure the full definition can be retrieved from dynamically created classes as well
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomElement.name, definition, definition.Type);
        return definition;
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.transient(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, CustomElement, key, container);
    }
}
const defaultForOpts = {
    name: undefined,
    searchParents: false,
    optional: false,
};
const CustomElement = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('custom-element'),
    keyFrom(name) {
        return `${CustomElement.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(CustomElement.name, value);
    },
    for(node, opts = defaultForOpts) {
        if (opts.name === void 0 && opts.searchParents !== true) {
            const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, node);
            if (controller === void 0) {
                if (opts.optional === true) {
                    return null;
                }
                throw new Error(`The provided node is not a custom element or containerless host.`);
            }
            return controller;
        }
        if (opts.name !== void 0) {
            if (opts.searchParents !== true) {
                const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, node);
                if (controller === void 0) {
                    throw new Error(`The provided node is not a custom element or containerless host.`);
                }
                if (controller.is(opts.name)) {
                    return controller;
                }
                return (void 0);
            }
            let cur = node;
            let foundAController = false;
            while (cur !== null) {
                const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, cur);
                if (controller !== void 0) {
                    foundAController = true;
                    if (controller.is(opts.name)) {
                        return controller;
                    }
                }
                cur = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.getEffectiveParentNode)(cur);
            }
            if (foundAController) {
                return (void 0);
            }
            throw new Error(`The provided node does does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`);
        }
        let cur = node;
        while (cur !== null) {
            const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, cur);
            if (controller !== void 0) {
                return controller;
            }
            cur = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.getEffectiveParentNode)(cur);
        }
        throw new Error(`The provided node does does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`);
    },
    define(nameOrDef, Type) {
        const definition = CustomElementDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomElement.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomElement.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(definition.Type, CustomElement.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
    generateName: (function () {
        let id = 0;
        return function () {
            return `unnamed-${++id}`;
        };
    })(),
    createInjectable() {
        const $injectable = function (target, property, index) {
            const annotationParamtypes = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.getOrCreateAnnotationParamTypes(target);
            annotationParamtypes[index] = $injectable;
            return target;
        };
        $injectable.register = function (container) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {
                resolve(container, requestor) {
                    if (requestor.has($injectable, true)) {
                        return requestor.get($injectable);
                    }
                    else {
                        return null;
                    }
                },
            };
        };
        return $injectable;
    },
    generateType: (function () {
        const nameDescriptor = {
            value: '',
            writable: false,
            enumerable: false,
            configurable: true,
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const defaultProto = {};
        return function (name, proto = defaultProto) {
            // Anonymous class ensures that minification cannot cause unintended side-effects, and keeps the class
            // looking similarly from the outside (when inspected via debugger, etc).
            const Type = class {
            };
            // Define the name property so that Type.name can be used by end users / plugin authors if they really need to,
            // even when minified.
            nameDescriptor.value = name;
            Reflect.defineProperty(Type, 'name', nameDescriptor);
            // Assign anything from the prototype that was passed in
            if (proto !== defaultProto) {
                Object.assign(Type.prototype, proto);
            }
            return Type;
        };
    })(),
};
//# sourceMappingURL=custom-element.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IProjections": () => /* binding */ IProjections,
/* harmony export */   "AuSlotContentType": () => /* binding */ AuSlotContentType,
/* harmony export */   "SlotInfo": () => /* binding */ SlotInfo,
/* harmony export */   "ProjectionContext": () => /* binding */ ProjectionContext,
/* harmony export */   "RegisteredProjections": () => /* binding */ RegisteredProjections,
/* harmony export */   "IProjectionProvider": () => /* binding */ IProjectionProvider,
/* harmony export */   "ProjectionProvider": () => /* binding */ ProjectionProvider,
/* harmony export */   "AuSlot": () => /* binding */ AuSlot
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _custom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");




const IProjections = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface("IProjections");
var AuSlotContentType;
(function (AuSlotContentType) {
    AuSlotContentType[AuSlotContentType["Projection"] = 0] = "Projection";
    AuSlotContentType[AuSlotContentType["Fallback"] = 1] = "Fallback";
})(AuSlotContentType || (AuSlotContentType = {}));
class SlotInfo {
    constructor(name, type, projectionContext) {
        this.name = name;
        this.type = type;
        this.projectionContext = projectionContext;
    }
}
class ProjectionContext {
    constructor(content, scope = null) {
        this.content = content;
        this.scope = scope;
    }
}
class RegisteredProjections {
    constructor(scope, projections) {
        this.scope = scope;
        this.projections = projections;
    }
}
const IProjectionProvider = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IProjectionProvider', x => x.singleton(ProjectionProvider));
const projectionMap = new WeakMap();
class ProjectionProvider {
    registerProjections(projections, scope) {
        for (const [instruction, $projections] of projections) {
            projectionMap.set(instruction, new RegisteredProjections(scope, $projections));
        }
    }
    getProjectionFor(instruction) {
        return projectionMap.get(instruction) ?? null;
    }
}
class AuSlot {
    constructor(factory, location) {
        this.factory = factory;
        this.hostScope = null;
        this.view = factory.create().setLocation(location);
        this.isProjection = factory.contentType === AuSlotContentType.Projection;
        this.outerScope = factory.projectionScope;
    }
    /**
     * @internal
     */
    static get inject() { return [_templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation]; }
    binding(initiator, parent, flags) {
        this.hostScope = this.$controller.scope.parentScope;
    }
    attaching(initiator, parent, flags) {
        const { $controller } = this;
        return this.view.activate(initiator, $controller, flags, this.outerScope ?? this.hostScope, this.hostScope);
    }
    detaching(initiator, parent, flags) {
        return this.view.deactivate(initiator, this.$controller, flags);
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
}
(0,_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.customElement)({ name: 'au-slot', template: null, containerless: true })(AuSlot);
//# sourceMappingURL=au-slot.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Compose": () => /* binding */ Compose
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _create_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../create-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/create-element.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _custom_element_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








function toLookup(acc, item) {
    const to = item.to;
    if (to !== void 0 && to !== 'subject' && to !== 'composing') {
        acc[to] = item;
    }
    return acc;
}
let Compose = class Compose {
    constructor(p, instruction) {
        this.p = p;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.subject = void 0;
        this.composing = false;
        this.view = void 0;
        this.lastSubject = void 0;
        this.properties = instruction.instructions.reduce(toLookup, {});
    }
    attaching(initiator, parent, flags) {
        const { subject, view } = this;
        if (view === void 0 || this.lastSubject !== subject) {
            this.lastSubject = subject;
            this.composing = true;
            return this.compose(void 0, subject, initiator, flags);
        }
        return this.compose(view, subject, initiator, flags);
    }
    detaching(initiator, parent, flags) {
        return this.deactivate(this.view, initiator, flags);
    }
    subjectChanged(newValue, previousValue, flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        if (this.lastSubject === newValue) {
            return;
        }
        this.lastSubject = newValue;
        this.composing = true;
        flags |= $controller.flags;
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivate(this.view, null, flags), () => {
            // TODO(fkleuver): handle & test race condition
            return this.compose(void 0, newValue, null, flags);
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    compose(view, subject, initiator, flags) {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view === void 0
            ? (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(subject, resolvedSubject => {
                return this.resolveView(resolvedSubject, flags);
            })
            : view, resolvedView => {
            return this.activate(resolvedView, initiator, flags);
        });
    }
    deactivate(view, initiator, flags) {
        return view?.deactivate(initiator ?? view, this.$controller, flags);
    }
    activate(view, initiator, flags) {
        const { $controller } = this;
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view?.activate(initiator ?? view, $controller, flags, $controller.scope, $controller.hostScope), () => {
            this.composing = false;
        });
    }
    resolveView(subject, flags) {
        const view = this.provideViewFor(subject, flags);
        if (view) {
            view.setLocation(this.$controller.location);
            view.lockScope(this.$controller.scope);
            return view;
        }
        return void 0;
    }
    provideViewFor(subject, flags) {
        if (!subject) {
            return void 0;
        }
        if (isController(subject)) { // IController
            return subject;
        }
        if ('createView' in subject) { // RenderPlan
            return subject.createView(this.$controller.context);
        }
        if ('create' in subject) { // IViewFactory
            return subject.create(flags);
        }
        if ('template' in subject) { // Raw Template Definition
            const definition = _custom_element_js__WEBPACK_IMPORTED_MODULE_6__.CustomElementDefinition.getOrCreate(subject);
            return (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_5__.getRenderContext)(definition, this.$controller.context).getViewFactory().create(flags);
        }
        // Constructable (Custom Element Constructor)
        return (0,_create_element_js__WEBPACK_IMPORTED_MODULE_2__.createElement)(this.p, subject, this.properties, this.$controller.host.childNodes).createView(this.$controller.context);
    }
    dispose() {
        this.view?.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_7__.bindable
], Compose.prototype, "subject", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_7__.bindable)({ mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView })
], Compose.prototype, "composing", void 0);
Compose = __decorate([
    (0,_custom_element_js__WEBPACK_IMPORTED_MODULE_6__.customElement)({ name: 'au-compose', template: null, containerless: true }),
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform),
    __param(1, _renderer_js__WEBPACK_IMPORTED_MODULE_3__.IInstruction)
], Compose);

function isController(subject) {
    return 'lockScope' in subject;
}
//# sourceMappingURL=compose.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FrequentMutations": () => /* binding */ FrequentMutations,
/* harmony export */   "ObserveShallow": () => /* binding */ ObserveShallow
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");




class FlagsTemplateController {
    constructor(factory, location, flags) {
        this.factory = factory;
        this.flags = flags;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.view = this.factory.create().setLocation(location);
    }
    attaching(initiator, parent, flags) {
        const { $controller } = this;
        return this.view.activate(initiator, $controller, flags | this.flags, $controller.scope, $controller.hostScope);
    }
    detaching(initiator, parent, flags) {
        return this.view.deactivate(initiator, this.$controller, flags);
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
}
class FrequentMutations extends FlagsTemplateController {
    constructor(factory, location) {
        super(factory, location, 8192 /* persistentTargetObserverQueue */);
    }
}
/**
 * @internal
 */
FrequentMutations.inject = [_templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation];
class ObserveShallow extends FlagsTemplateController {
    constructor(factory, location) {
        super(factory, location, 2048 /* observeLeafPropertiesOnly */);
    }
}
/**
 * @internal
 */
ObserveShallow.inject = [_templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation];
(0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('frequent-mutations')(FrequentMutations);
(0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('observe-shallow')(ObserveShallow);
//# sourceMappingURL=flags.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "If": () => /* binding */ If,
/* harmony export */   "Else": () => /* binding */ Else
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





let If = class If {
    constructor(ifFactory, location) {
        this.ifFactory = ifFactory;
        this.location = location;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.elseFactory = void 0;
        this.elseView = void 0;
        this.ifView = void 0;
        this.view = void 0;
        this.value = false;
    }
    attaching(initiator, parent, flags) {
        const view = this.view = this.updateView(this.value, flags);
        if (view !== void 0) {
            const { $controller } = this;
            return view.activate(initiator, $controller, flags, $controller.scope, $controller.hostScope);
        }
    }
    detaching(initiator, parent, flags) {
        if (this.view !== void 0) {
            return this.view.deactivate(initiator, this.$controller, flags);
        }
    }
    valueChanged(newValue, oldValue, flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.view?.deactivate(this.view, $controller, flags), () => {
            const view = this.view = this.updateView(this.value, flags);
            if (view !== void 0) {
                // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
                return view.activate(view, $controller, flags, $controller.scope, $controller.hostScope);
            }
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    /** @internal */
    updateView(value, flags) {
        if (value) {
            return this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);
        }
        if (this.elseFactory != void 0) {
            return this.elseView = this.ensureView(this.elseView, this.elseFactory, flags);
        }
        return void 0;
    }
    /** @internal */
    ensureView(view, factory, flags) {
        if (view === void 0) {
            view = factory.create(flags);
        }
        view.setLocation(this.location);
        return view;
    }
    dispose() {
        if (this.ifView !== void 0) {
            this.ifView.dispose();
            this.ifView = void 0;
        }
        if (this.elseView !== void 0) {
            this.elseView.dispose();
            this.elseView = void 0;
        }
        this.view = void 0;
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable
], If.prototype, "value", void 0);
If = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('if'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation)
], If);

let Else = class Else {
    constructor(factory) {
        this.factory = factory;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
    }
    link(flags, parentContext, controller, _childController, _target, _instruction) {
        const children = controller.children;
        const ifBehavior = children[children.length - 1];
        if (ifBehavior instanceof If) {
            ifBehavior.elseFactory = this.factory;
        }
        else if (ifBehavior.viewModel instanceof If) {
            ifBehavior.viewModel.elseFactory = this.factory;
        }
        else {
            throw new Error(`Unsupported IfBehavior`); // TODO: create error code
        }
    }
};
Else = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)({ name: 'else' }),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory)
], Else);

//# sourceMappingURL=if.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Portal": () => /* binding */ Portal
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let Portal = class Portal {
    constructor(factory, originalLoc, p) {
        this.factory = factory;
        this.originalLoc = originalLoc;
        this.p = p;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.strict = false;
        // to make the shape of this object consistent.
        // todo: is this necessary
        this.currentTarget = p.document.createElement('div');
        this.view = this.factory.create();
        (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.setEffectiveParentNode)(this.view.nodes, originalLoc);
    }
    attaching(initiator, parent, flags) {
        if (this.callbackContext == null) {
            this.callbackContext = this.$controller.scope.bindingContext;
        }
        const newTarget = this.currentTarget = this.resolveTarget();
        this.view.setHost(newTarget);
        return this.$activating(initiator, newTarget, flags);
    }
    detaching(initiator, parent, flags) {
        return this.$deactivating(initiator, this.currentTarget, flags);
    }
    targetChanged() {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        const oldTarget = this.currentTarget;
        const newTarget = this.currentTarget = this.resolveTarget();
        if (oldTarget === newTarget) {
            return;
        }
        this.view.setHost(newTarget);
        // TODO(fkleuver): fix and test possible race condition
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.$deactivating(null, newTarget, $controller.flags), () => {
            return this.$activating(null, newTarget, $controller.flags);
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    $activating(initiator, target, flags) {
        const { activating, callbackContext, view } = this;
        view.setHost(target);
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(activating?.call(callbackContext, target, view), () => {
            return this.activate(initiator, target, flags);
        });
    }
    activate(initiator, target, flags) {
        const { $controller, view } = this;
        if (initiator === null) {
            view.nodes.appendTo(target);
        }
        else {
            // TODO(fkleuver): fix and test possible race condition
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view.activate(initiator ?? view, $controller, flags, $controller.scope), () => {
                return this.$activated(target);
            });
        }
        return this.$activated(target);
    }
    $activated(target) {
        const { activated, callbackContext, view } = this;
        return activated?.call(callbackContext, target, view);
    }
    $deactivating(initiator, target, flags) {
        const { deactivating, callbackContext, view } = this;
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(deactivating?.call(callbackContext, target, view), () => {
            return this.deactivate(initiator, target, flags);
        });
    }
    deactivate(initiator, target, flags) {
        const { $controller, view } = this;
        if (initiator === null) {
            view.nodes.remove();
        }
        else {
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view.deactivate(initiator, $controller, flags), () => {
                return this.$deactivated(target);
            });
        }
        return this.$deactivated(target);
    }
    $deactivated(target) {
        const { deactivated, callbackContext, view } = this;
        return deactivated?.call(callbackContext, target, view);
    }
    resolveTarget() {
        const p = this.p;
        // with a $ in front to make it less confusing/error prone
        const $document = p.document;
        let target = this.target;
        let context = this.renderContext;
        if (target === '') {
            if (this.strict) {
                throw new Error('Empty querySelector');
            }
            return $document.body;
        }
        if (typeof target === 'string') {
            let queryContext = $document;
            if (typeof context === 'string') {
                context = $document.querySelector(context);
            }
            if (context instanceof p.Node) {
                queryContext = context;
            }
            target = queryContext.querySelector(target);
        }
        if (target instanceof p.Node) {
            return target;
        }
        if (target == null) {
            if (this.strict) {
                throw new Error('Portal target not found');
            }
            return $document.body;
        }
        return target;
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
        this.callbackContext = null;
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)({ primary: true })
], Portal.prototype, "target", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)({ callback: 'targetChanged' })
], Portal.prototype, "renderContext", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "strict", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "deactivating", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "activating", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "deactivated", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "activated", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "callbackContext", void 0);
Portal = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__.templateController)('portal'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform)
], Portal);

//# sourceMappingURL=portal.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Repeat": () => /* binding */ Repeat,
/* harmony export */   "longestIncreasingSubsequence": () => /* binding */ longestIncreasingSubsequence
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};







function dispose(disposable) {
    disposable.dispose();
}
let Repeat = class Repeat {
    constructor(location, parent, factory) {
        this.location = location;
        this.parent = parent;
        this.factory = factory;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.hasPendingInstanceMutation = false;
        this.observer = void 0;
        this.views = [];
        this.key = void 0;
        this.normalizedItems = void 0;
    }
    binding(initiator, parent, flags) {
        this.checkCollectionObserver(flags);
        const bindings = this.parent.bindings;
        let binding = (void 0);
        for (let i = 0, ii = bindings.length; i < ii; ++i) {
            binding = bindings[i];
            if (binding.target === this && binding.targetProperty === 'items') {
                this.forOf = binding.sourceExpression;
                break;
            }
        }
        this.local = this.forOf.declaration.evaluate(flags, this.$controller.scope, null, binding.locator, null);
    }
    attaching(initiator, parent, flags) {
        this.normalizeToArray(flags);
        return this.activateAllViews(initiator, flags);
    }
    detaching(initiator, parent, flags) {
        this.checkCollectionObserver(flags);
        return this.deactivateAllViews(initiator, flags);
    }
    // called by SetterObserver
    itemsChanged(flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        flags |= $controller.flags;
        this.checkCollectionObserver(flags);
        flags |= 8 /* updateTarget */;
        this.normalizeToArray(flags);
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivateAllViews(null, flags), () => {
            // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
            return this.activateAllViews(null, flags);
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    // called by a CollectionObserver
    handleCollectionChange(indexMap, flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        flags |= $controller.flags;
        flags |= 8 /* updateTarget */;
        this.normalizeToArray(flags);
        if (indexMap === void 0) {
            const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivateAllViews(null, flags), () => {
                // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
                return this.activateAllViews(null, flags);
            });
            if (ret instanceof Promise) {
                ret.catch(err => { throw err; });
            }
        }
        else {
            const oldLength = this.views.length;
            (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.applyMutationsToIndices)(indexMap);
            // first detach+unbind+(remove from array) the deleted view indices
            if (indexMap.deletedItems.length > 0) {
                indexMap.deletedItems.sort(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.compareNumber);
                const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivateAndRemoveViewsByKey(indexMap, flags), () => {
                    // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
                    return this.createAndActivateAndSortViewsByKey(oldLength, indexMap, flags);
                });
                if (ret instanceof Promise) {
                    ret.catch(err => { throw err; });
                }
            }
            else {
                // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.createAndActivateAndSortViewsByKey(oldLength, indexMap, flags);
            }
        }
    }
    // todo: subscribe to collection from inner expression
    checkCollectionObserver(flags) {
        const oldObserver = this.observer;
        if ((flags & 64 /* fromUnbind */)) {
            if (oldObserver !== void 0) {
                oldObserver.unsubscribe(this);
            }
        }
        else if (this.$controller.isActive) {
            const newObserver = this.observer = (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.getCollectionObserver)(this.items);
            if (oldObserver !== newObserver && oldObserver) {
                oldObserver.unsubscribe(this);
            }
            if (newObserver) {
                newObserver.subscribe(this);
            }
        }
    }
    normalizeToArray(flags) {
        const items = this.items;
        if (items instanceof Array) {
            this.normalizedItems = items;
            return;
        }
        const forOf = this.forOf;
        if (forOf === void 0) {
            return;
        }
        const normalizedItems = [];
        this.forOf.iterate(flags, items, (arr, index, item) => {
            normalizedItems[index] = item;
        });
        this.normalizedItems = normalizedItems;
    }
    activateAllViews(initiator, flags) {
        let promises = void 0;
        let ret;
        let view;
        let viewScope;
        const { $controller, factory, local, location, items } = this;
        const parentScope = $controller.scope;
        const hostScope = $controller.hostScope;
        const newLen = this.forOf.count(flags, items);
        const views = this.views = Array(newLen);
        this.forOf.iterate(flags, items, (arr, i, item) => {
            view = views[i] = factory.create(flags).setLocation(location);
            view.nodes.unlink();
            viewScope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent(parentScope, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingContext.create(local, item));
            setContextualProperties(viewScope.overrideContext, i, newLen);
            ret = view.activate(initiator ?? view, $controller, flags, viewScope, hostScope);
            if (ret instanceof Promise) {
                (promises ?? (promises = [])).push(ret);
            }
        });
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    deactivateAllViews(initiator, flags) {
        let promises = void 0;
        let ret;
        let view;
        const { views, $controller } = this;
        for (let i = 0, ii = views.length; i < ii; ++i) {
            view = views[i];
            view.release();
            ret = view.deactivate(initiator ?? view, $controller, flags);
            if (ret instanceof Promise) {
                (promises ?? (promises = [])).push(ret);
            }
        }
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    deactivateAndRemoveViewsByKey(indexMap, flags) {
        let promises = void 0;
        let ret;
        let view;
        const { $controller, views } = this;
        const deleted = indexMap.deletedItems;
        const deletedLen = deleted.length;
        let i = 0;
        for (; i < deletedLen; ++i) {
            view = views[deleted[i]];
            view.release();
            ret = view.deactivate(view, $controller, flags);
            if (ret instanceof Promise) {
                (promises ?? (promises = [])).push(ret);
            }
        }
        i = 0;
        let j = 0;
        for (; i < deletedLen; ++i) {
            j = deleted[i] - i;
            views.splice(j, 1);
        }
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    createAndActivateAndSortViewsByKey(oldLength, indexMap, flags) {
        let promises = void 0;
        let ret;
        let view;
        let viewScope;
        const { $controller, factory, local, normalizedItems, location, views } = this;
        const mapLen = indexMap.length;
        for (let i = 0; i < mapLen; ++i) {
            if (indexMap[i] === -2) {
                view = factory.create(flags);
                views.splice(i, 0, view);
            }
        }
        if (views.length !== mapLen) {
            // TODO: create error code and use reporter with more informative message
            throw new Error(`viewsLen=${views.length}, mapLen=${mapLen}`);
        }
        const parentScope = $controller.scope;
        const hostScope = $controller.hostScope;
        const newLen = indexMap.length;
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.synchronizeIndices)(views, indexMap);
        // this algorithm retrieves the indices of the longest increasing subsequence of items in the repeater
        // the items on those indices are not moved; this minimizes the number of DOM operations that need to be performed
        const seq = longestIncreasingSubsequence(indexMap);
        const seqLen = seq.length;
        let next;
        let j = seqLen - 1;
        let i = newLen - 1;
        for (; i >= 0; --i) {
            view = views[i];
            next = views[i + 1];
            view.nodes.link(next?.nodes ?? location);
            if (indexMap[i] === -2) {
                viewScope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent(parentScope, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingContext.create(local, normalizedItems[i]));
                setContextualProperties(viewScope.overrideContext, i, newLen);
                view.setLocation(location);
                ret = view.activate(view, $controller, flags, viewScope, hostScope);
                if (ret instanceof Promise) {
                    (promises ?? (promises = [])).push(ret);
                }
            }
            else if (j < 0 || seqLen === 1 || i !== seq[j]) {
                setContextualProperties(view.scope.overrideContext, i, newLen);
                view.nodes.insertBefore(view.location);
            }
            else {
                if (oldLength !== newLen) {
                    setContextualProperties(view.scope.overrideContext, i, newLen);
                }
                --j;
            }
        }
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    dispose() {
        this.views.forEach(dispose);
        this.views = (void 0);
    }
    accept(visitor) {
        const { views } = this;
        if (views !== void 0) {
            for (let i = 0, ii = views.length; i < ii; ++i) {
                if (views[i].accept(visitor) === true) {
                    return true;
                }
            }
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_6__.bindable
], Repeat.prototype, "items", void 0);
Repeat = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__.templateController)('repeat'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation),
    __param(1, _templating_controller_js__WEBPACK_IMPORTED_MODULE_5__.IController),
    __param(2, _templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory)
], Repeat);

let maxLen = 16;
let prevIndices = new Int32Array(maxLen);
let tailIndices = new Int32Array(maxLen);
// Based on inferno's lis_algorithm @ https://github.com/infernojs/inferno/blob/master/packages/inferno/src/DOM/patching.ts#L732
// with some tweaks to make it just a bit faster + account for IndexMap (and some names changes for readability)
/** @internal */
function longestIncreasingSubsequence(indexMap) {
    const len = indexMap.length;
    if (len > maxLen) {
        maxLen = len;
        prevIndices = new Int32Array(len);
        tailIndices = new Int32Array(len);
    }
    let cursor = 0;
    let cur = 0;
    let prev = 0;
    let i = 0;
    let j = 0;
    let low = 0;
    let high = 0;
    let mid = 0;
    for (; i < len; i++) {
        cur = indexMap[i];
        if (cur !== -2) {
            j = prevIndices[cursor];
            prev = indexMap[j];
            if (prev !== -2 && prev < cur) {
                tailIndices[i] = j;
                prevIndices[++cursor] = i;
                continue;
            }
            low = 0;
            high = cursor;
            while (low < high) {
                mid = (low + high) >> 1;
                prev = indexMap[prevIndices[mid]];
                if (prev !== -2 && prev < cur) {
                    low = mid + 1;
                }
                else {
                    high = mid;
                }
            }
            prev = indexMap[prevIndices[low]];
            if (cur < prev || prev === -2) {
                if (low > 0) {
                    tailIndices[i] = prevIndices[low - 1];
                }
                prevIndices[low] = i;
            }
        }
    }
    i = ++cursor;
    const result = new Int32Array(i);
    cur = prevIndices[cursor - 1];
    while (cursor-- > 0) {
        result[cursor] = cur;
        cur = tailIndices[cur];
    }
    while (i-- > 0)
        prevIndices[i] = 0;
    return result;
}
function setContextualProperties(oc, index, length) {
    const isFirst = index === 0;
    const isLast = index === length - 1;
    const isEven = index % 2 === 0;
    oc.$index = index;
    oc.$first = isFirst;
    oc.$last = isLast;
    oc.$middle = !isFirst && !isLast;
    oc.$even = isEven;
    oc.$odd = !isEven;
    oc.$length = length;
}
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Switch": () => /* binding */ Switch,
/* harmony export */   "Case": () => /* binding */ Case,
/* harmony export */   "DefaultCase": () => /* binding */ DefaultCase
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let Switch = class Switch {
    constructor(factory, location) {
        this.factory = factory;
        this.location = location;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        /** @internal */
        this.cases = [];
        this.activeCases = [];
        /**
         * This is kept around here so that changes can be awaited from the tests.
         * This needs to be removed after the scheduler is ready to handle/queue the floating promises.
         */
        this.promise = void 0;
    }
    link(flags, _parentContext, _controller, _childController, _target, _instruction) {
        this.view = this.factory.create(flags, this.$controller).setLocation(this.location);
    }
    attaching(initiator, parent, flags) {
        const view = this.view;
        const $controller = this.$controller;
        this.queue(() => view.activate(initiator, $controller, flags, $controller.scope, $controller.hostScope));
        this.queue(() => this.swap(initiator, flags, this.value));
        return this.promise;
    }
    detaching(initiator, parent, flags) {
        this.queue(() => {
            const view = this.view;
            return view.deactivate(initiator, this.$controller, flags);
        });
        return this.promise;
    }
    dispose() {
        this.view?.dispose();
        this.view = (void 0);
    }
    valueChanged(_newValue, _oldValue, flags) {
        if (!this.$controller.isActive) {
            return;
        }
        this.queue(() => this.swap(null, flags, this.value));
    }
    caseChanged($case, flags) {
        this.queue(() => this.handleCaseChange($case, flags));
    }
    handleCaseChange($case, flags) {
        const isMatch = $case.isMatch(this.value, flags);
        const activeCases = this.activeCases;
        const numActiveCases = activeCases.length;
        // Early termination #1
        if (!isMatch) {
            /** The previous match started with this; thus clear. */
            if (numActiveCases > 0 && activeCases[0].id === $case.id) {
                return this.clearActiveCases(null, flags);
            }
            /**
             * There are 2 different scenarios here:
             * 1. $case in activeCases: Indicates by-product of fallthrough. The starting case still satisfies. Return.
             * 2. $case not in activeCases: It was previously not active, and currently also not a match. Return.
             */
            return;
        }
        // Early termination #2
        if (numActiveCases > 0 && activeCases[0].id < $case.id) {
            // Even if this case now a match, the previous case still wins by as that has lower ordinal.
            return;
        }
        // compute the new active cases
        const newActiveCases = [];
        let fallThrough = $case.fallThrough;
        if (!fallThrough) {
            newActiveCases.push($case);
        }
        else {
            const cases = this.cases;
            const idx = cases.indexOf($case);
            for (let i = idx, ii = cases.length; i < ii && fallThrough; i++) {
                const c = cases[i];
                newActiveCases.push(c);
                fallThrough = c.fallThrough;
            }
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.clearActiveCases(null, flags, newActiveCases), () => {
            this.activeCases = newActiveCases;
            return this.activateCases(null, flags);
        });
    }
    swap(initiator, flags, value) {
        const newActiveCases = [];
        let fallThrough = false;
        for (const $case of this.cases) {
            if (fallThrough || $case.isMatch(value, flags)) {
                newActiveCases.push($case);
                fallThrough = $case.fallThrough;
            }
            if (newActiveCases.length > 0 && !fallThrough) {
                break;
            }
        }
        const defaultCase = this.defaultCase;
        if (newActiveCases.length === 0 && defaultCase !== void 0) {
            newActiveCases.push(defaultCase);
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.activeCases.length > 0
            ? this.clearActiveCases(initiator, flags, newActiveCases)
            : void 0, () => {
            this.activeCases = newActiveCases;
            if (newActiveCases.length === 0) {
                return;
            }
            return this.activateCases(initiator, flags);
        });
    }
    activateCases(initiator, flags) {
        const controller = this.$controller;
        if (!controller.isActive) {
            return;
        }
        const cases = this.activeCases;
        const length = cases.length;
        if (length === 0) {
            return;
        }
        const scope = controller.scope;
        const hostScope = controller.hostScope;
        // most common case
        if (length === 1) {
            return cases[0].activate(initiator, flags, scope, hostScope);
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.resolveAll)(...cases.map(($case) => $case.activate(initiator, flags, scope, hostScope)));
    }
    clearActiveCases(initiator, flags, newActiveCases = []) {
        const cases = this.activeCases;
        const numCases = cases.length;
        if (numCases === 0) {
            return;
        }
        if (numCases === 1) {
            const firstCase = cases[0];
            if (!newActiveCases.includes(firstCase)) {
                cases.length = 0;
                return firstCase.deactivate(initiator, flags);
            }
            return;
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.resolveAll)(...cases.reduce((acc, $case) => {
            if (!newActiveCases.includes($case)) {
                acc.push($case.deactivate(initiator, flags));
            }
            return acc;
        }, [])), () => {
            cases.length = 0;
        });
    }
    queue(action) {
        const previousPromise = this.promise;
        let promise = void 0;
        promise = this.promise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(previousPromise, action), () => {
            if (this.promise === promise) {
                this.promise = void 0;
            }
        });
    }
    accept(visitor) {
        if (this.$controller.accept(visitor) === true) {
            return true;
        }
        if (this.activeCases.some(x => x.accept(visitor))) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable
], Switch.prototype, "value", void 0);
Switch = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('switch'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_4__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation)
], Switch);

let Case = class Case {
    constructor(factory, locator, location, logger) {
        this.factory = factory;
        this.locator = locator;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.fallThrough = false;
        this.debug = logger.config.level <= 1 /* debug */;
        this.logger = logger.scopeTo(`${this.constructor.name}-#${this.id}`);
        this.view = this.factory.create().setLocation(location);
    }
    link(flags, parentContext, controller, _childController, _target, _instruction) {
        const switchController = controller.parent;
        const $switch = switchController?.viewModel;
        if ($switch instanceof Switch) {
            this.$switch = $switch;
            this.linkToSwitch($switch);
        }
        else {
            throw new Error('The parent switch not found; only `*[switch] > *[case|default-case]` relation is supported.');
        }
    }
    detaching(initiator, parent, flags) {
        return this.deactivate(initiator, flags);
    }
    isMatch(value, flags) {
        if (this.debug) {
            this.logger.debug('isMatch()');
        }
        const $value = this.value;
        if (Array.isArray($value)) {
            if (this.observer === void 0) {
                this.observer = this.observeCollection(flags, $value);
            }
            return $value.includes(value);
        }
        return $value === value;
    }
    valueChanged(newValue, _oldValue, flags) {
        if (Array.isArray(newValue)) {
            this.observer?.unsubscribe(this);
            this.observer = this.observeCollection(flags, newValue);
        }
        else if (this.observer !== void 0) {
            this.observer.unsubscribe(this);
        }
        this.$switch.caseChanged(this, flags);
    }
    handleCollectionChange(_indexMap, flags) {
        this.$switch.caseChanged(this, flags);
    }
    activate(initiator, flags, scope, hostScope) {
        const view = this.view;
        if (view.isActive) {
            return;
        }
        return view.activate(initiator ?? view, this.$controller, flags, scope, hostScope);
    }
    deactivate(initiator, flags) {
        const view = this.view;
        if (!view.isActive) {
            return;
        }
        return view.deactivate(initiator ?? view, this.$controller, flags);
    }
    dispose() {
        this.observer?.unsubscribe(this);
        this.view?.dispose();
        this.view = (void 0);
    }
    linkToSwitch(auSwitch) {
        auSwitch.cases.push(this);
    }
    observeCollection(flags, $value) {
        const observer = this.locator.getArrayObserver($value);
        observer.subscribe(this);
        return observer;
    }
    accept(visitor) {
        if (this.$controller.accept(visitor) === true) {
            return true;
        }
        return this.view?.accept(visitor);
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable
], Case.prototype, "value", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)({
        set: v => {
            switch (v) {
                case 'true': return true;
                case 'false': return false;
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                default: return !!v;
            }
        },
        mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime
    })
], Case.prototype, "fallThrough", void 0);
Case = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('case'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_4__.IViewFactory),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation),
    __param(3, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger)
], Case);

let DefaultCase = class DefaultCase extends Case {
    linkToSwitch($switch) {
        if ($switch.defaultCase !== void 0) {
            throw new Error('Multiple \'default-case\'s are not allowed.');
        }
        $switch.defaultCase = this;
    }
};
DefaultCase = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('default-case')
], DefaultCase);

//# sourceMappingURL=switch.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "With": () => /* binding */ With
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let With = class With {
    constructor(factory, location) {
        this.factory = factory;
        this.location = location;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.view = this.factory.create().setLocation(location);
    }
    valueChanged(newValue, oldValue, flags) {
        if (this.$controller.isActive) {
            // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.activateView(this.view, 32 /* fromBind */);
        }
    }
    attaching(initiator, parent, flags) {
        return this.activateView(initiator, flags);
    }
    detaching(initiator, parent, flags) {
        return this.view.deactivate(initiator, this.$controller, flags);
    }
    activateView(initiator, flags) {
        const { $controller, value } = this;
        const scope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent($controller.scope, value === void 0 ? {} : value);
        return this.view.activate(initiator, $controller, flags, scope, $controller.hostScope);
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable
], With.prototype, "value", void 0);
With = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__.templateController)('with'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation)
], With);

//# sourceMappingURL=with.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISanitizer": () => /* binding */ ISanitizer,
/* harmony export */   "SanitizeValueConverter": () => /* binding */ SanitizeValueConverter
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


const SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
const ISanitizer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISanitizer', x => x.singleton(class {
    sanitize(input) {
        return input.replace(SCRIPT_REGEX, '');
    }
}));
/**
 * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.
 */
let SanitizeValueConverter = class SanitizeValueConverter {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * Process the provided markup that flows to the view.
     *
     * @param untrustedMarkup - The untrusted markup to be sanitized.
     */
    toView(untrustedMarkup) {
        if (untrustedMarkup == null) {
            return null;
        }
        return this.sanitizer.sanitize(untrustedMarkup);
    }
};
SanitizeValueConverter = __decorate([
    __param(0, ISanitizer)
], SanitizeValueConverter);

(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.valueConverter)('sanitize')(SanitizeValueConverter);
//# sourceMappingURL=sanitize.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewValueConverter": () => /* binding */ ViewValueConverter
/* harmony export */ });
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


let ViewValueConverter = class ViewValueConverter {
    constructor(viewLocator) {
        this.viewLocator = viewLocator;
    }
    toView(object, viewNameOrSelector) {
        return this.viewLocator.getViewComponentForObject(object, viewNameOrSelector);
    }
};
ViewValueConverter = __decorate([
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_0__.IViewLocator)
], ViewValueConverter);

(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.valueConverter)('view')(ViewValueConverter);
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SymbolFlags": () => /* binding */ SymbolFlags,
/* harmony export */   "TemplateControllerSymbol": () => /* binding */ TemplateControllerSymbol,
/* harmony export */   "ProjectionSymbol": () => /* binding */ ProjectionSymbol,
/* harmony export */   "CustomAttributeSymbol": () => /* binding */ CustomAttributeSymbol,
/* harmony export */   "PlainAttributeSymbol": () => /* binding */ PlainAttributeSymbol,
/* harmony export */   "BindingSymbol": () => /* binding */ BindingSymbol,
/* harmony export */   "CustomElementSymbol": () => /* binding */ CustomElementSymbol,
/* harmony export */   "LetElementSymbol": () => /* binding */ LetElementSymbol,
/* harmony export */   "PlainElementSymbol": () => /* binding */ PlainElementSymbol,
/* harmony export */   "TextSymbol": () => /* binding */ TextSymbol,
/* harmony export */   "BindableInfo": () => /* binding */ BindableInfo,
/* harmony export */   "ElementInfo": () => /* binding */ ElementInfo,
/* harmony export */   "AttrInfo": () => /* binding */ AttrInfo
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


var SymbolFlags;
(function (SymbolFlags) {
    SymbolFlags[SymbolFlags["type"] = 1023] = "type";
    SymbolFlags[SymbolFlags["isTemplateController"] = 1] = "isTemplateController";
    SymbolFlags[SymbolFlags["isProjection"] = 2] = "isProjection";
    SymbolFlags[SymbolFlags["isCustomAttribute"] = 4] = "isCustomAttribute";
    SymbolFlags[SymbolFlags["isPlainAttribute"] = 8] = "isPlainAttribute";
    SymbolFlags[SymbolFlags["isCustomElement"] = 16] = "isCustomElement";
    SymbolFlags[SymbolFlags["isLetElement"] = 32] = "isLetElement";
    SymbolFlags[SymbolFlags["isPlainElement"] = 64] = "isPlainElement";
    SymbolFlags[SymbolFlags["isText"] = 128] = "isText";
    SymbolFlags[SymbolFlags["isBinding"] = 256] = "isBinding";
    SymbolFlags[SymbolFlags["isAuSlot"] = 512] = "isAuSlot";
    SymbolFlags[SymbolFlags["hasMarker"] = 1024] = "hasMarker";
    SymbolFlags[SymbolFlags["hasTemplate"] = 2048] = "hasTemplate";
    SymbolFlags[SymbolFlags["hasAttributes"] = 4096] = "hasAttributes";
    SymbolFlags[SymbolFlags["hasBindings"] = 8192] = "hasBindings";
    SymbolFlags[SymbolFlags["hasChildNodes"] = 16384] = "hasChildNodes";
    SymbolFlags[SymbolFlags["hasProjections"] = 32768] = "hasProjections";
})(SymbolFlags || (SymbolFlags = {}));
function createMarker(p) {
    const marker = p.document.createElement('au-m');
    marker.className = 'au';
    return marker;
}
/**
 * A html attribute that is associated with a registered resource, specifically a template controller.
 */
class TemplateControllerSymbol {
    constructor(p, syntax, info, res = info.name) {
        this.syntax = syntax;
        this.info = info;
        this.res = res;
        this.flags = 1 /* isTemplateController */ | 1024 /* hasMarker */;
        this.physicalNode = null;
        this.template = null;
        this.templateController = null;
        this._bindings = null;
        this.marker = createMarker(p);
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
}
class ProjectionSymbol {
    constructor(name, template) {
        this.name = name;
        this.template = template;
        this.flags = 2 /* isProjection */;
    }
}
/**
 * A html attribute that is associated with a registered resource, but not a template controller.
 */
class CustomAttributeSymbol {
    constructor(syntax, info, res = info.name) {
        this.syntax = syntax;
        this.info = info;
        this.res = res;
        this.flags = 4 /* isCustomAttribute */;
        this._bindings = null;
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
}
/**
 * An attribute, with either a binding command or an interpolation, whose target is the html
 * attribute of the element.
 *
 * This will never target a bindable property of a custom attribute or element;
 */
class PlainAttributeSymbol {
    constructor(syntax, command, expression) {
        this.syntax = syntax;
        this.command = command;
        this.expression = expression;
        this.flags = 8 /* isPlainAttribute */;
    }
}
/**
 * Either an attribute on an custom element that maps to a declared bindable property of that element,
 * a single-value bound custom attribute, or one of several bindables that were extracted from the attribute
 * value of a custom attribute with multiple bindings usage.
 *
 * This will always target a bindable property of a custom attribute or element;
 */
class BindingSymbol {
    constructor(command, bindable, expression, rawValue, target) {
        this.command = command;
        this.bindable = bindable;
        this.expression = expression;
        this.rawValue = rawValue;
        this.target = target;
        this.flags = 256 /* isBinding */;
    }
}
/**
 * A html element that is associated with a registered resource either via its (lowerCase) `nodeName`
 * or the value of its `as-element` attribute.
 */
class CustomElementSymbol {
    constructor(p, physicalNode, info, res = info.name, bindables = info.bindables) {
        this.physicalNode = physicalNode;
        this.info = info;
        this.res = res;
        this.bindables = bindables;
        this.flags = 16 /* isCustomElement */;
        this.isTarget = true;
        this.templateController = null;
        this._customAttributes = null;
        this._plainAttributes = null;
        this._bindings = null;
        this._childNodes = null;
        this._projections = null;
        if (info.containerless) {
            this.isContainerless = true;
            this.marker = createMarker(p);
            this.flags |= 1024 /* hasMarker */;
        }
        else {
            this.isContainerless = false;
            this.marker = null;
        }
    }
    get customAttributes() {
        if (this._customAttributes === null) {
            this._customAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._customAttributes;
    }
    get plainAttributes() {
        if (this._plainAttributes === null) {
            this._plainAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._plainAttributes;
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
    get childNodes() {
        if (this._childNodes === null) {
            this._childNodes = [];
            this.flags |= 16384 /* hasChildNodes */;
        }
        return this._childNodes;
    }
    get projections() {
        if (this._projections === null) {
            this._projections = [];
            this.flags |= 32768 /* hasProjections */;
        }
        return this._projections;
    }
}
class LetElementSymbol {
    constructor(p, physicalNode, marker = createMarker(p)) {
        this.physicalNode = physicalNode;
        this.marker = marker;
        this.flags = 32 /* isLetElement */ | 1024 /* hasMarker */;
        this.toBindingContext = false;
        this._bindings = null;
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
}
/**
 * A normal html element that may or may not have attribute behaviors and/or child node behaviors.
 *
 * It is possible for a PlainElementSymbol to not yield any instructions during compilation.
 */
class PlainElementSymbol {
    constructor(physicalNode) {
        this.physicalNode = physicalNode;
        this.flags = 64 /* isPlainElement */;
        this.isTarget = false;
        this.templateController = null;
        this.hasSlots = false;
        this._customAttributes = null;
        this._plainAttributes = null;
        this._childNodes = null;
    }
    get customAttributes() {
        if (this._customAttributes === null) {
            this._customAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._customAttributes;
    }
    get plainAttributes() {
        if (this._plainAttributes === null) {
            this._plainAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._plainAttributes;
    }
    get childNodes() {
        if (this._childNodes === null) {
            this._childNodes = [];
            this.flags |= 16384 /* hasChildNodes */;
        }
        return this._childNodes;
    }
}
/**
 * A standalone text node that has an interpolation.
 */
class TextSymbol {
    constructor(p, physicalNode, interpolation, marker = createMarker(p)) {
        this.physicalNode = physicalNode;
        this.interpolation = interpolation;
        this.marker = marker;
        this.flags = 128 /* isText */ | 1024 /* hasMarker */;
    }
}
/**
 * A pre-processed piece of information about a defined bindable property on a custom
 * element or attribute, optimized for consumption by the template compiler.
 */
class BindableInfo {
    constructor(
    /**
     * The pre-processed *property* (not attribute) name of the bindable, which is
     * (in order of priority):
     *
     * 1. The `property` from the description (if defined)
     * 2. The name of the property of the bindable itself
     */
    propName, 
    /**
     * The pre-processed (default) bindingMode of the bindable, which is (in order of priority):
     *
     * 1. The `mode` from the bindable (if defined and not bindingMode.default)
     * 2. The `defaultBindingMode` (if it's an attribute, defined, and not bindingMode.default)
     * 3. `bindingMode.toView`
     */
    mode) {
        this.propName = propName;
        this.mode = mode;
    }
}
const elementInfoLookup = new WeakMap();
/**
 * Pre-processed information about a custom element resource, optimized
 * for consumption by the template compiler.
 */
class ElementInfo {
    constructor(name, alias, containerless) {
        this.name = name;
        this.alias = alias;
        this.containerless = containerless;
        /**
         * A lookup of the bindables of this element, indexed by the (pre-processed)
         * attribute names as they would be found in parsed markup.
         */
        this.bindables = Object.create(null);
    }
    static from(def, alias) {
        if (def === null) {
            return null;
        }
        let rec = elementInfoLookup.get(def);
        if (rec === void 0) {
            elementInfoLookup.set(def, rec = Object.create(null));
        }
        let info = rec[alias];
        if (info === void 0) {
            info = rec[alias] = new ElementInfo(def.name, alias === def.name ? void 0 : alias, def.containerless);
            const bindables = def.bindables;
            const defaultBindingMode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
            let bindable;
            let prop;
            let attr;
            let mode;
            for (prop in bindables) {
                bindable = bindables[prop];
                // explicitly provided property name has priority over the implicit property name
                if (bindable.property !== void 0) {
                    prop = bindable.property;
                }
                // explicitly provided attribute name has priority over the derived implicit attribute name
                if (bindable.attribute !== void 0) {
                    attr = bindable.attribute;
                }
                else {
                    // derive the attribute name from the resolved property name
                    attr = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(prop);
                }
                if (bindable.mode !== void 0 && bindable.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default) {
                    mode = bindable.mode;
                }
                else {
                    mode = defaultBindingMode;
                }
                info.bindables[attr] = new BindableInfo(prop, mode);
            }
        }
        return info;
    }
}
const attrInfoLookup = new WeakMap();
/**
 * Pre-processed information about a custom attribute resource, optimized
 * for consumption by the template compiler.
 */
class AttrInfo {
    constructor(name, alias, isTemplateController, noMultiBindings) {
        this.name = name;
        this.alias = alias;
        this.isTemplateController = isTemplateController;
        this.noMultiBindings = noMultiBindings;
        /**
         * A lookup of the bindables of this attribute, indexed by the (pre-processed)
         * bindable names as they would be found in the attribute value.
         *
         * Only applicable to multi attribute bindings (semicolon-separated).
         */
        this.bindables = Object.create(null);
        /**
         * The single or first bindable of this attribute, or a default 'value'
         * bindable if no bindables were defined on the attribute.
         *
         * Only applicable to single attribute bindings (where the attribute value
         * contains no semicolons)
         */
        this.bindable = null;
    }
    static from(def, alias) {
        if (def === null) {
            return null;
        }
        let rec = attrInfoLookup.get(def);
        if (rec === void 0) {
            attrInfoLookup.set(def, rec = Object.create(null));
        }
        let info = rec[alias];
        if (info === void 0) {
            info = rec[alias] = new AttrInfo(def.name, alias === def.name ? void 0 : alias, def.isTemplateController, def.noMultiBindings);
            const bindables = def.bindables;
            const defaultBindingMode = def.defaultBindingMode !== void 0 && def.defaultBindingMode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default
                ? def.defaultBindingMode
                : _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
            let bindable;
            let prop;
            let mode;
            let hasPrimary = false;
            let isPrimary = false;
            let bindableInfo;
            for (prop in bindables) {
                bindable = bindables[prop];
                // explicitly provided property name has priority over the implicit property name
                if (bindable.property !== void 0) {
                    prop = bindable.property;
                }
                if (bindable.mode !== void 0 && bindable.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default) {
                    mode = bindable.mode;
                }
                else {
                    mode = defaultBindingMode;
                }
                isPrimary = bindable.primary === true;
                bindableInfo = info.bindables[prop] = new BindableInfo(prop, mode);
                if (isPrimary) {
                    if (hasPrimary) {
                        throw new Error('primary already exists');
                    }
                    hasPrimary = true;
                    info.bindable = bindableInfo;
                }
                // set to first bindable by convention
                if (info.bindable === null) {
                    info.bindable = bindableInfo;
                }
            }
            // if no bindables are present, default to "value"
            if (info.bindable === null) {
                info.bindable = new BindableInfo('value', defaultBindingMode);
            }
        }
        return info;
    }
}
//# sourceMappingURL=semantic-model.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TemplateBinder": () => /* binding */ TemplateBinder
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/binding-command.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./semantic-model.js */ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js");






const invalidSurrogateAttribute = Object.assign(Object.create(null), {
    'id': true,
    'au-slot': true,
});
const attributesToIgnore = Object.assign(Object.create(null), {
    'as-element': true,
});
function hasInlineBindings(rawValue) {
    const len = rawValue.length;
    let ch = 0;
    for (let i = 0; i < len; ++i) {
        ch = rawValue.charCodeAt(i);
        if (ch === 92 /* Backslash */) {
            ++i;
            // Ignore whatever comes next because it's escaped
        }
        else if (ch === 58 /* Colon */) {
            return true;
        }
        else if (ch === 36 /* Dollar */ && rawValue.charCodeAt(i + 1) === 123 /* OpenBrace */) {
            return false;
        }
    }
    return false;
}
function processInterpolationText(symbol) {
    const node = symbol.physicalNode;
    const parentNode = node.parentNode;
    while (node.nextSibling !== null && node.nextSibling.nodeType === 3 /* Text */) {
        parentNode.removeChild(node.nextSibling);
    }
    node.textContent = '';
    parentNode.insertBefore(symbol.marker, node);
}
function isTemplateControllerOf(proxy, manifest) {
    return proxy !== manifest;
}
/**
 * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.
 * It's a first refactoring step towards separating DOM parsing/binding from mutations.
 */
function processTemplateControllers(p, manifestProxy, manifest) {
    const manifestNode = manifest.physicalNode;
    let current = manifestProxy;
    let currentTemplate;
    while (isTemplateControllerOf(current, manifest)) {
        if (current.template === manifest) {
            // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null
            manifestNode.parentNode.replaceChild(current.marker, manifestNode);
            // if the manifest is a template element (e.g. <template repeat.for="...">) then we can skip one lift operation
            // and simply use the template directly, saving a bit of work
            if (manifestNode.nodeName === 'TEMPLATE') {
                current.physicalNode = manifestNode;
                // the template could safely stay without affecting anything visible, but let's keep the DOM tidy
                manifestNode.remove();
            }
            else {
                // the manifest is not a template element so we need to wrap it in one
                currentTemplate = current.physicalNode = p.document.createElement('template');
                currentTemplate.content.appendChild(manifestNode);
            }
        }
        else {
            currentTemplate = current.physicalNode = p.document.createElement('template');
            currentTemplate.content.appendChild(current.marker);
        }
        manifestNode.removeAttribute(current.syntax.rawName);
        current = current.template;
    }
}
/**
 * TemplateBinder. Todo: describe goal of this class
 */
class TemplateBinder {
    constructor(platform, container, attrParser, exprParser, attrSyntaxTransformer) {
        this.platform = platform;
        this.container = container;
        this.attrParser = attrParser;
        this.exprParser = exprParser;
        this.attrSyntaxTransformer = attrSyntaxTransformer;
        this.commandLookup = Object.create(null);
    }
    bind(node) {
        const surrogate = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainElementSymbol(node);
        const attrSyntaxTransformer = this.attrSyntaxTransformer;
        const attributes = node.attributes;
        let i = 0;
        while (i < attributes.length) {
            const attr = attributes[i];
            const attrSyntax = this.attrParser.parse(attr.name, attr.value);
            if (invalidSurrogateAttribute[attrSyntax.target] === true) {
                throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`);
                // TODO: use reporter
            }
            const bindingCommand = this.getBindingCommand(attrSyntax, true);
            if (bindingCommand === null || (bindingCommand.bindingType & 4096 /* IgnoreCustomAttr */) === 0) {
                const attrInfo = _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.AttrInfo.from(this.container.find(_resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.CustomAttribute, attrSyntax.target), attrSyntax.target);
                if (attrInfo === null) {
                    // map special html attributes to their corresponding properties
                    attrSyntaxTransformer.transform(node, attrSyntax);
                    // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                    this.bindPlainAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attr       */ attr, 
                    /* surrogate  */ surrogate, 
                    /* manifest   */ surrogate);
                }
                else if (attrInfo.isTemplateController) {
                    throw new Error('Cannot have template controller on surrogate element.');
                    // TODO: use reporter
                }
                else {
                    this.bindCustomAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attrInfo   */ attrInfo, 
                    /* command    */ bindingCommand, 
                    /* manifest   */ surrogate);
                }
            }
            else {
                // map special html attributes to their corresponding properties
                attrSyntaxTransformer.transform(node, attrSyntax);
                // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                this.bindPlainAttribute(
                /* attrSyntax */ attrSyntax, 
                /* attr       */ attr, 
                /* surrogate  */ surrogate, 
                /* manifest   */ surrogate);
            }
            ++i;
        }
        this.bindChildNodes(
        /* node               */ node, 
        /* surrogate          */ surrogate, 
        /* manifest           */ surrogate, 
        /* manifestRoot       */ null, 
        /* parentManifestRoot */ null);
        return surrogate;
    }
    bindManifest(parentManifest, node, surrogate, manifest, manifestRoot, parentManifestRoot) {
        let isAuSlot = false;
        switch (node.nodeName) {
            case 'LET':
                // let cannot have children and has some different processing rules, so return early
                this.bindLetElement(
                /* parentManifest */ parentManifest, 
                /* node           */ node);
                return;
            case 'SLOT':
                surrogate.hasSlots = true;
                break;
            case 'AU-SLOT':
                isAuSlot = true;
                break;
        }
        let name = node.getAttribute('as-element');
        if (name === null) {
            name = node.nodeName.toLowerCase();
        }
        const elementInfo = _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.ElementInfo.from(this.container.find(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement, name), name);
        if (elementInfo === null) {
            // there is no registered custom element with this name
            manifest = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainElementSymbol(node);
        }
        else {
            // it's a custom element so we set the manifestRoot as well (for storing replaces)
            parentManifestRoot = manifestRoot;
            const ceSymbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.CustomElementSymbol(this.platform, node, elementInfo);
            if (isAuSlot) {
                ceSymbol.flags = 512 /* isAuSlot */;
                ceSymbol.slotName = node.getAttribute("name") ?? "default";
            }
            manifestRoot = manifest = ceSymbol;
        }
        // lifting operations done by template controllers and replaces effectively unlink the nodes, so start at the bottom
        this.bindChildNodes(
        /* node               */ node, 
        /* surrogate          */ surrogate, 
        /* manifest           */ manifest, 
        /* manifestRoot       */ manifestRoot, 
        /* parentManifestRoot */ parentManifestRoot);
        // the parentManifest will receive either the direct child nodes, or the template controllers / replaces
        // wrapping them
        this.bindAttributes(
        /* node               */ node, 
        /* parentManifest     */ parentManifest, 
        /* surrogate          */ surrogate, 
        /* manifest           */ manifest, 
        /* manifestRoot       */ manifestRoot, 
        /* parentManifestRoot */ parentManifestRoot);
        if (manifestRoot === manifest && manifest.isContainerless) {
            node.parentNode.replaceChild(manifest.marker, node);
        }
        else if (manifest.isTarget) {
            node.classList.add('au');
        }
    }
    bindLetElement(parentManifest, node) {
        const symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.LetElementSymbol(this.platform, node);
        parentManifest.childNodes.push(symbol);
        const attributes = node.attributes;
        let i = 0;
        while (i < attributes.length) {
            const attr = attributes[i];
            if (attr.name === 'to-binding-context') {
                node.removeAttribute('to-binding-context');
                symbol.toBindingContext = true;
                continue;
            }
            const attrSyntax = this.attrParser.parse(attr.name, attr.value);
            const command = this.getBindingCommand(attrSyntax, false);
            const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
            const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);
            const to = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(attrSyntax.target);
            const info = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindableInfo(to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
            symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, info, expr, attrSyntax.rawValue, to));
            ++i;
        }
        node.parentNode.replaceChild(symbol.marker, node);
    }
    bindAttributes(node, parentManifest, surrogate, manifest, manifestRoot, parentManifestRoot) {
        // This is the top-level symbol for the current depth.
        // If there are no template controllers or replaces, it is always the manifest itself.
        // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.
        let manifestProxy = manifest;
        let previousController = (void 0);
        let currentController = (void 0);
        const attributes = node.attributes;
        let i = 0;
        while (i < attributes.length) {
            const attr = attributes[i];
            ++i;
            if (attributesToIgnore[attr.name] === true) {
                continue;
            }
            const attrSyntax = this.attrParser.parse(attr.name, attr.value);
            const bindingCommand = this.getBindingCommand(attrSyntax, true);
            if (bindingCommand === null || (bindingCommand.bindingType & 4096 /* IgnoreCustomAttr */) === 0) {
                const attrInfo = _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.AttrInfo.from(this.container.find(_resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.CustomAttribute, attrSyntax.target), attrSyntax.target);
                if (attrInfo === null) {
                    // map special html attributes to their corresponding properties
                    this.attrSyntaxTransformer.transform(node, attrSyntax);
                    // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                    this.bindPlainAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attr       */ attr, 
                    /* surrogate  */ surrogate, 
                    /* manifest   */ manifest);
                }
                else if (attrInfo.isTemplateController) {
                    // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)
                    // so keep setting manifest.templateController to the latest template controller we find
                    currentController = manifest.templateController = this.declareTemplateController(
                    /* attrSyntax */ attrSyntax, 
                    /* attrInfo   */ attrInfo);
                    // the proxy and the manifest are only identical when we're at the first template controller (since the controller
                    // is assigned to the proxy), so this evaluates to true at most once per node
                    if (manifestProxy === manifest) {
                        currentController.template = manifest;
                        manifestProxy = currentController;
                    }
                    else {
                        currentController.templateController = previousController;
                        currentController.template = previousController.template;
                        previousController.template = currentController;
                    }
                    previousController = currentController;
                }
                else {
                    // a regular custom attribute
                    this.bindCustomAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attrInfo   */ attrInfo, 
                    /* command    */ bindingCommand, 
                    /* manifest   */ manifest);
                }
            }
            else {
                // map special html attributes to their corresponding properties
                this.attrSyntaxTransformer.transform(node, attrSyntax);
                // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                this.bindPlainAttribute(
                /* attrSyntax */ attrSyntax, 
                /* attr       */ attr, 
                /* surrogate  */ surrogate, 
                /* manifest   */ manifest);
            }
        }
        if (node.tagName === 'INPUT') {
            const type = node.type;
            if (type === 'checkbox' || type === 'radio') {
                this.ensureAttributeOrder(manifest);
            }
        }
        let projection = node.getAttribute('au-slot');
        if (projection === '') {
            projection = 'default';
        }
        const hasProjection = projection !== null;
        if (hasProjection && isTemplateControllerOf(manifestProxy, manifest)) {
            // prevents <some-el au-slot TEMPLATE.CONTROLLER></some-el>.
            throw new Error(`Unsupported usage of [au-slot="${projection}"] along with a template controller (if, else, repeat.for etc.) found (example: <some-el au-slot if.bind="true"></some-el>).`);
            /**
             * TODO: prevent <template TEMPLATE.CONTROLLER><some-el au-slot></some-el></template>.
             * But there is not easy way for now, as the attribute binding is done after binding the child nodes.
             * This means by the time the template controller in the ancestor is processed, the projection is already registered.
             */
        }
        const parentName = node.parentNode?.nodeName.toLowerCase();
        if (hasProjection
            && (manifestRoot === null
                || parentName === void 0
                || this.container.find(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement, parentName) === null)) {
            /**
             * Prevents the following cases:
             * - <template><div au-slot></div></template>
             * - <my-ce><div><div au-slot></div></div></my-ce>
             * - <my-ce><div au-slot="s1"><div au-slot="s2"></div></div></my-ce>
             */
            throw new Error(`Unsupported usage of [au-slot="${projection}"]. It seems that projection is attempted, but not for a custom element.`);
        }
        processTemplateControllers(this.platform, manifestProxy, manifest);
        const projectionOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;
        if (!hasProjection || projectionOwner === null) {
            // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent
            parentManifest.childNodes.push(manifestProxy);
        }
        else if (hasProjection) {
            projectionOwner.projections.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.ProjectionSymbol(projection, manifestProxy));
            node.removeAttribute('au-slot');
            node.remove();
        }
    }
    // TODO: refactor to use render priority slots (this logic shouldn't be in the template binder)
    ensureAttributeOrder(manifest) {
        // swap the order of checked and model/value attribute, so that the required observers are prepared for checked-observer
        const attributes = manifest.plainAttributes;
        let modelOrValueIndex = void 0;
        let checkedIndex = void 0;
        let found = 0;
        for (let i = 0; i < attributes.length && found < 3; i++) {
            switch (attributes[i].syntax.target) {
                case 'model':
                case 'value':
                case 'matcher':
                    modelOrValueIndex = i;
                    found++;
                    break;
                case 'checked':
                    checkedIndex = i;
                    found++;
                    break;
            }
        }
        if (checkedIndex !== void 0 && modelOrValueIndex !== void 0 && checkedIndex < modelOrValueIndex) {
            [attributes[modelOrValueIndex], attributes[checkedIndex]] = [attributes[checkedIndex], attributes[modelOrValueIndex]];
        }
    }
    bindChildNodes(node, surrogate, manifest, manifestRoot, parentManifestRoot) {
        let childNode;
        if (node.nodeName === 'TEMPLATE') {
            childNode = node.content.firstChild;
        }
        else {
            childNode = node.firstChild;
        }
        let nextChild;
        while (childNode !== null) {
            switch (childNode.nodeType) {
                case 1 /* Element */:
                    nextChild = childNode.nextSibling;
                    this.bindManifest(
                    /* parentManifest     */ manifest, 
                    /* node               */ childNode, 
                    /* surrogate          */ surrogate, 
                    /* manifest           */ manifest, 
                    /* manifestRoot       */ manifestRoot, 
                    /* parentManifestRoot */ parentManifestRoot);
                    childNode = nextChild;
                    break;
                case 3 /* Text */:
                    childNode = this.bindText(
                    /* textNode */ childNode, 
                    /* manifest */ manifest).nextSibling;
                    break;
                case 4 /* CDATASection */:
                case 7 /* ProcessingInstruction */:
                case 8 /* Comment */:
                case 10 /* DocumentType */:
                    childNode = childNode.nextSibling;
                    break;
                case 9 /* Document */:
                case 11 /* DocumentFragment */:
                    childNode = childNode.firstChild;
            }
        }
    }
    bindText(textNode, manifest) {
        const interpolation = this.exprParser.parse(textNode.wholeText, 2048 /* Interpolation */);
        if (interpolation !== null) {
            const symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.TextSymbol(this.platform, textNode, interpolation);
            manifest.childNodes.push(symbol);
            processInterpolationText(symbol);
        }
        let next = textNode;
        while (next.nextSibling !== null && next.nextSibling.nodeType === 3 /* Text */) {
            next = next.nextSibling;
        }
        return next;
    }
    declareTemplateController(attrSyntax, attrInfo) {
        let symbol;
        const attrRawValue = attrSyntax.rawValue;
        const command = this.getBindingCommand(attrSyntax, false);
        // multi-bindings logic here is similar to (and explained in) bindCustomAttribute
        const isMultiBindings = attrInfo.noMultiBindings === false && command === null && hasInlineBindings(attrRawValue);
        if (isMultiBindings) {
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.TemplateControllerSymbol(this.platform, attrSyntax, attrInfo);
            this.bindMultiAttribute(symbol, attrInfo, attrRawValue);
        }
        else {
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.TemplateControllerSymbol(this.platform, attrSyntax, attrInfo);
            const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
            const expr = this.exprParser.parse(attrRawValue, bindingType);
            symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, attrInfo.bindable, expr, attrRawValue, attrSyntax.target));
        }
        return symbol;
    }
    bindCustomAttribute(attrSyntax, attrInfo, command, manifest) {
        let symbol;
        const attrRawValue = attrSyntax.rawValue;
        // Custom attributes are always in multiple binding mode,
        // except when they can't be
        // When they cannot be:
        //        * has explicit configuration noMultiBindings: false
        //        * has binding command, ie: <div my-attr.bind="...">.
        //          In this scenario, the value of the custom attributes is required to be a valid expression
        //        * has no colon: ie: <div my-attr="abcd">
        //          In this scenario, it's simply invalid syntax. Consider style attribute rule-value pair: <div style="rule: ruleValue">
        const isMultiBindings = attrInfo.noMultiBindings === false && command === null && hasInlineBindings(attrRawValue);
        if (isMultiBindings) {
            // a multiple-bindings attribute usage (semicolon separated binding) is only valid without a binding command;
            // the binding commands must be declared in each of the property bindings
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttributeSymbol(attrSyntax, attrInfo);
            this.bindMultiAttribute(symbol, attrInfo, attrRawValue);
        }
        else {
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttributeSymbol(attrSyntax, attrInfo);
            const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
            const expr = this.exprParser.parse(attrRawValue, bindingType);
            symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, attrInfo.bindable, expr, attrRawValue, attrSyntax.target));
        }
        manifest.customAttributes.push(symbol);
        manifest.isTarget = true;
    }
    bindMultiAttribute(symbol, attrInfo, value) {
        const bindables = attrInfo.bindables;
        const valueLength = value.length;
        let attrName = void 0;
        let attrValue = void 0;
        let start = 0;
        let ch = 0;
        for (let i = 0; i < valueLength; ++i) {
            ch = value.charCodeAt(i);
            if (ch === 92 /* Backslash */) {
                ++i;
                // Ignore whatever comes next because it's escaped
            }
            else if (ch === 58 /* Colon */) {
                attrName = value.slice(start, i);
                // Skip whitespace after colon
                while (value.charCodeAt(++i) <= 32 /* Space */)
                    ;
                start = i;
                for (; i < valueLength; ++i) {
                    ch = value.charCodeAt(i);
                    if (ch === 92 /* Backslash */) {
                        ++i;
                        // Ignore whatever comes next because it's escaped
                    }
                    else if (ch === 59 /* Semicolon */) {
                        attrValue = value.slice(start, i);
                        break;
                    }
                }
                if (attrValue === void 0) {
                    // No semicolon found, so just grab the rest of the value
                    attrValue = value.slice(start);
                }
                const attrSyntax = this.attrParser.parse(attrName, attrValue);
                const attrTarget = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(attrSyntax.target);
                const command = this.getBindingCommand(attrSyntax, false);
                const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
                const expr = this.exprParser.parse(attrValue, bindingType);
                let bindable = bindables[attrTarget];
                if (bindable === undefined) {
                    // everything in a multi-bindings expression must be used,
                    // so if it's not a bindable then we create one on the spot
                    bindable = bindables[attrTarget] = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindableInfo(attrTarget, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
                }
                symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, bindable, expr, attrValue, attrTarget));
                // Skip whitespace after semicolon
                while (i < valueLength && value.charCodeAt(++i) <= 32 /* Space */)
                    ;
                start = i;
                attrName = void 0;
                attrValue = void 0;
            }
        }
    }
    bindPlainAttribute(attrSyntax, attr, surrogate, manifest) {
        const command = this.getBindingCommand(attrSyntax, false);
        const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
        const attrTarget = attrSyntax.target;
        const attrRawValue = attrSyntax.rawValue;
        let expr;
        if (attrRawValue.length === 0
            && (bindingType & 53 /* BindCommand */ | 49 /* OneTimeCommand */ | 50 /* ToViewCommand */ | 52 /* TwoWayCommand */) > 0) {
            if ((bindingType & 53 /* BindCommand */ | 49 /* OneTimeCommand */ | 50 /* ToViewCommand */ | 52 /* TwoWayCommand */) > 0) {
                // Default to the name of the attr for empty binding commands
                expr = this.exprParser.parse((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(attrTarget), bindingType);
            }
            else {
                return;
            }
        }
        else {
            expr = this.exprParser.parse(attrRawValue, bindingType);
        }
        if ((manifest.flags & 16 /* isCustomElement */) > 0) {
            const bindable = manifest.bindables[attrTarget];
            if (bindable != null) {
                // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;
                // the template compiler will translate it to the correct instruction
                manifest.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, bindable, expr, attrRawValue, attrTarget));
                manifest.isTarget = true;
            }
            else if (expr != null) {
                // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)
                manifest.plainAttributes.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainAttributeSymbol(attrSyntax, command, expr));
                manifest.isTarget = true;
            }
        }
        else if (expr != null) {
            // either a binding command, an interpolation, or a ref
            manifest.plainAttributes.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainAttributeSymbol(attrSyntax, command, expr));
            manifest.isTarget = true;
        }
        else if (manifest === surrogate) {
            // any attributes, even if they are plain (no command/interpolation etc), should be added if they
            // are on the surrogate element
            manifest.plainAttributes.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainAttributeSymbol(attrSyntax, command, expr));
        }
        if (command == null && expr != null) {
            // if it's an interpolation, clear the attribute value
            attr.value = '';
        }
    }
    /**
     * Retrieve a binding command resource.
     *
     * @param name - The parsed `AttrSyntax`
     *
     * @returns An instance of the command if it exists, or `null` if it does not exist.
     */
    getBindingCommand(syntax, optional) {
        const name = syntax.command;
        if (name === null) {
            return null;
        }
        let result = this.commandLookup[name];
        if (result === void 0) {
            result = this.container.create(_resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.BindingCommand, name);
            if (result === null) {
                if (optional) {
                    return null;
                }
                throw new Error(`Unknown binding command: ${name}`);
            }
            this.commandLookup[name] = result;
        }
        return result;
    }
}
//# sourceMappingURL=template-binder.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/template-compiler.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/template-compiler.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TemplateCompiler": () => /* binding */ TemplateCompiler
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attribute-syntax-transformer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js");
/* harmony import */ var _template_binder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template-binder.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js");
/* harmony import */ var _template_element_factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./template-element-factory.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./resources/attribute-pattern.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};











class CustomElementCompilationUnit {
    constructor(partialDefinition, surrogate, template) {
        this.partialDefinition = partialDefinition;
        this.surrogate = surrogate;
        this.template = template;
        this.instructions = [];
        this.surrogates = [];
        this.projectionsMap = new Map();
    }
    toDefinition() {
        const def = this.partialDefinition;
        return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({
            ...def,
            instructions: (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.instructions, this.instructions),
            surrogates: (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.surrogates, this.surrogates),
            template: this.template,
            needsCompile: false,
            hasSlots: this.surrogate.hasSlots,
            projectionsMap: this.projectionsMap,
        });
    }
}
var LocalTemplateBindableAttributes;
(function (LocalTemplateBindableAttributes) {
    LocalTemplateBindableAttributes["property"] = "property";
    LocalTemplateBindableAttributes["attribute"] = "attribute";
    LocalTemplateBindableAttributes["mode"] = "mode";
})(LocalTemplateBindableAttributes || (LocalTemplateBindableAttributes = {}));
const allowedLocalTemplateBindableAttributes = Object.freeze([
    "property" /* property */,
    "attribute" /* attribute */,
    "mode" /* mode */
]);
const localTemplateIdentifier = 'as-custom-element';
/**
 * Default (runtime-agnostic) implementation for `ITemplateCompiler`.
 *
 * @internal
 */
let TemplateCompiler = class TemplateCompiler {
    constructor(factory, attrParser, exprParser, attrSyntaxModifier, logger, p) {
        this.factory = factory;
        this.attrParser = attrParser;
        this.exprParser = exprParser;
        this.attrSyntaxModifier = attrSyntaxModifier;
        this.p = p;
        this.logger = logger.scopeTo('TemplateCompiler');
    }
    get name() {
        return 'default';
    }
    static register(container) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(_renderer_js__WEBPACK_IMPORTED_MODULE_5__.ITemplateCompiler, this).register(container);
    }
    compile(partialDefinition, context, targetedProjections) {
        const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.getOrCreate(partialDefinition);
        if (definition.template === null || definition.template === void 0) {
            return definition;
        }
        const { attrParser, exprParser, attrSyntaxModifier, factory } = this;
        const p = context.get(_platform_js__WEBPACK_IMPORTED_MODULE_6__.IPlatform);
        const binder = new _template_binder_js__WEBPACK_IMPORTED_MODULE_3__.TemplateBinder(p, context, attrParser, exprParser, attrSyntaxModifier);
        const template = definition.enhance === true
            ? definition.template
            : factory.createTemplate(definition.template);
        processLocalTemplates(template, definition, context, p, this.logger);
        const surrogate = binder.bind(template);
        const compilation = this.compilation = new CustomElementCompilationUnit(definition, surrogate, template);
        const customAttributes = surrogate.customAttributes;
        const plainAttributes = surrogate.plainAttributes;
        const customAttributeLength = customAttributes.length;
        const plainAttributeLength = plainAttributes.length;
        if (customAttributeLength + plainAttributeLength > 0) {
            let offset = 0;
            for (let i = 0; customAttributeLength > i; ++i) {
                compilation.surrogates[offset] = this.compileCustomAttribute(customAttributes[i]);
                offset++;
            }
            for (let i = 0; i < plainAttributeLength; ++i) {
                compilation.surrogates[offset] = this.compilePlainAttribute(plainAttributes[i], true);
                offset++;
            }
        }
        this.compileChildNodes(surrogate, compilation.instructions, compilation.projectionsMap, targetedProjections);
        const compiledDefinition = compilation.toDefinition();
        this.compilation = null;
        return compiledDefinition;
    }
    compileChildNodes(parent, instructionRows, projections, targetedProjections) {
        if ((parent.flags & 16384 /* hasChildNodes */) > 0) {
            const childNodes = parent.childNodes;
            const ii = childNodes.length;
            let childNode;
            for (let i = 0; i < ii; ++i) {
                childNode = childNodes[i];
                if ((childNode.flags & 128 /* isText */) > 0) {
                    instructionRows.push([new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.TextBindingInstruction(childNode.interpolation)]);
                }
                else if ((childNode.flags & 32 /* isLetElement */) > 0) {
                    const bindings = childNode.bindings;
                    const instructions = [];
                    let binding;
                    const jj = bindings.length;
                    for (let j = 0; j < jj; ++j) {
                        binding = bindings[j];
                        instructions[j] = new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.LetBindingInstruction(binding.expression, binding.target);
                    }
                    instructionRows.push([new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateLetElementInstruction(instructions, childNode.toBindingContext)]);
                }
                else {
                    this.compileParentNode(childNode, instructionRows, projections, targetedProjections);
                }
            }
        }
    }
    compileCustomElement(symbol, instructionRows, projections, targetedProjections) {
        const isAuSlot = (symbol.flags & 512 /* isAuSlot */) > 0;
        // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc
        const instructionRow = this.compileAttributes(symbol, 1);
        const slotName = symbol.slotName;
        let slotInfo = null;
        if (isAuSlot) {
            const targetedProjection = targetedProjections?.projections?.[slotName];
            slotInfo = targetedProjection !== void 0
                ? new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.SlotInfo(slotName, _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.AuSlotContentType.Projection, new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.ProjectionContext(targetedProjection, targetedProjections?.scope))
                : new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.SlotInfo(slotName, _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.AuSlotContentType.Fallback, new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.ProjectionContext(this.compileProjectionFallback(symbol, projections, targetedProjections)));
        }
        const instruction = instructionRow[0] = new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateElementInstruction(symbol.res, symbol.info.alias, this.compileBindings(symbol), slotInfo);
        const compiledProjections = this.compileProjections(symbol, projections, targetedProjections);
        if (compiledProjections !== null) {
            projections.set(instruction, compiledProjections);
        }
        instructionRows.push(instructionRow);
        if (!isAuSlot) {
            this.compileChildNodes(symbol, instructionRows, projections, targetedProjections);
        }
    }
    compilePlainElement(symbol, instructionRows, projections, targetedProjections) {
        const attributes = this.compileAttributes(symbol, 0);
        if (attributes.length > 0) {
            instructionRows.push(attributes);
        }
        this.compileChildNodes(symbol, instructionRows, projections, targetedProjections);
    }
    compileParentNode(symbol, instructionRows, projections, targetedProjections) {
        switch (symbol.flags & 1023 /* type */) {
            case 16 /* isCustomElement */:
            case 512 /* isAuSlot */:
                this.compileCustomElement(symbol, instructionRows, projections, targetedProjections);
                break;
            case 64 /* isPlainElement */:
                this.compilePlainElement(symbol, instructionRows, projections, targetedProjections);
                break;
            case 1 /* isTemplateController */:
                this.compileTemplateController(symbol, instructionRows, projections, targetedProjections);
        }
    }
    compileTemplateController(symbol, instructionRows, projections, targetedProjections) {
        const bindings = this.compileBindings(symbol);
        const controllerInstructionRows = [];
        this.compileParentNode(symbol.template, controllerInstructionRows, projections, targetedProjections);
        const def = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({
            name: symbol.info.alias ?? symbol.info.name,
            template: symbol.physicalNode,
            instructions: controllerInstructionRows,
            needsCompile: false,
        });
        instructionRows.push([new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateTemplateController(def, symbol.res, symbol.info.alias, bindings)]);
    }
    compileBindings(symbol) {
        let bindingInstructions;
        if ((symbol.flags & 8192 /* hasBindings */) > 0) {
            // either a custom element with bindings, a custom attribute / template controller with dynamic options,
            // or a single value custom attribute binding
            const { bindings } = symbol;
            const len = bindings.length;
            bindingInstructions = Array(len);
            let i = 0;
            for (; i < len; ++i) {
                bindingInstructions[i] = this.compileBinding(bindings[i]);
            }
        }
        else {
            bindingInstructions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        return bindingInstructions;
    }
    compileBinding(symbol) {
        if (symbol.command === null) {
            // either an interpolation or a normal string value assigned to an element or attribute binding
            if (symbol.expression === null) {
                // the template binder already filtered out non-bindables, so we know we need a setProperty here
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);
            }
            else {
                // either an element binding interpolation or a dynamic options attribute binding interpolation
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.InterpolationInstruction(symbol.expression, symbol.bindable.propName);
            }
        }
        else {
            // either an element binding command, dynamic options attribute binding command,
            // or custom attribute / template controller (single value) binding command
            return symbol.command.compile(symbol);
        }
    }
    compileAttributes(symbol, offset) {
        let attributeInstructions;
        if ((symbol.flags & 4096 /* hasAttributes */) > 0) {
            // any attributes on a custom element (which are not bindables) or a plain element
            const customAttributes = symbol.customAttributes;
            const plainAttributes = symbol.plainAttributes;
            const customAttributeLength = customAttributes.length;
            const plainAttributesLength = plainAttributes.length;
            attributeInstructions = Array(offset + customAttributeLength + plainAttributesLength);
            for (let i = 0; customAttributeLength > i; ++i) {
                attributeInstructions[offset] = this.compileCustomAttribute(customAttributes[i]);
                offset++;
            }
            for (let i = 0; plainAttributesLength > i; ++i) {
                attributeInstructions[offset] = this.compilePlainAttribute(plainAttributes[i], false);
                offset++;
            }
        }
        else if (offset > 0) {
            attributeInstructions = Array(offset);
        }
        else {
            attributeInstructions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        return attributeInstructions;
    }
    compileCustomAttribute(symbol) {
        // a normal custom attribute (not template controller)
        const bindings = this.compileBindings(symbol);
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateAttributeInstruction(symbol.res, symbol.info.alias, bindings);
    }
    compilePlainAttribute(symbol, isOnSurrogate) {
        if (symbol.command === null) {
            const syntax = symbol.syntax;
            if (symbol.expression === null) {
                const attrRawValue = syntax.rawValue;
                if (isOnSurrogate) {
                    switch (syntax.target) {
                        case 'class':
                            return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetClassAttributeInstruction(attrRawValue);
                        case 'style':
                            return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetStyleAttributeInstruction(attrRawValue);
                        // todo:  define how to merge other attribute peacefully
                        //        this is an existing feature request
                    }
                }
                // a plain attribute on a surrogate
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetAttributeInstruction(attrRawValue, syntax.target);
            }
            else {
                // a plain attribute with an interpolation
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.InterpolationInstruction(symbol.expression, syntax.target);
            }
        }
        else {
            // a plain attribute with a binding command
            return symbol.command.compile(symbol);
        }
    }
    // private compileAttribute(symbol: IAttributeSymbol): AttributeInstruction {
    //   // any attribute on a custom element (which is not a bindable) or a plain element
    //   if (symbol.flags & SymbolFlags.isCustomAttribute) {
    //     return this.compileCustomAttribute(symbol as CustomAttributeSymbol);
    //   } else {
    //     return this.compilePlainAttribute(symbol as PlainAttributeSymbol);
    //   }
    // }
    compileProjections(symbol, projectionMap, targetedProjections) {
        if ((symbol.flags & 32768 /* hasProjections */) === 0) {
            return null;
        }
        const p = this.p;
        const projections = Object.create(null);
        const $projections = symbol.projections;
        const len = $projections.length;
        for (let i = 0; i < len; ++i) {
            const projection = $projections[i];
            const name = projection.name;
            const instructions = [];
            this.compileParentNode(projection.template, instructions, projectionMap, targetedProjections);
            const definition = projections[name];
            if (definition === void 0) {
                let template = projection.template.physicalNode;
                if (template.tagName !== 'TEMPLATE') {
                    const _template = p.document.createElement('template');
                    _template.content.appendChild(template);
                    template = _template;
                }
                projections[name] = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({ name, template, instructions, needsCompile: false });
            }
            else {
                // consolidate the projections to same slot
                definition.template.content.appendChild(projection.template.physicalNode);
                definition.instructions.push(...instructions);
            }
        }
        return projections;
    }
    compileProjectionFallback(symbol, projections, targetedProjections) {
        const instructions = [];
        this.compileChildNodes(symbol, instructions, projections, targetedProjections);
        const template = this.p.document.createElement('template');
        template.content.append(...(0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray)(symbol.physicalNode.childNodes));
        return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({ name: _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.generateName(), template, instructions, needsCompile: false });
    }
};
TemplateCompiler = __decorate([
    __param(0, _template_element_factory_js__WEBPACK_IMPORTED_MODULE_4__.ITemplateElementFactory),
    __param(1, _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_8__.IAttributeParser),
    __param(2, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(3, _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_2__.IAttrSyntaxTransformer),
    __param(4, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger),
    __param(5, _platform_js__WEBPACK_IMPORTED_MODULE_6__.IPlatform)
], TemplateCompiler);

function processTemplateName(localTemplate, localTemplateNames) {
    const name = localTemplate.getAttribute(localTemplateIdentifier);
    if (name === null || name === '') {
        throw new Error('The value of "as-custom-element" attribute cannot be empty for local template');
    }
    if (localTemplateNames.has(name)) {
        throw new Error(`Duplicate definition of the local template named ${name}`);
    }
    else {
        localTemplateNames.add(name);
        localTemplate.removeAttribute(localTemplateIdentifier);
    }
    return name;
}
function getBindingMode(bindable) {
    switch (bindable.getAttribute("mode" /* mode */)) {
        case 'oneTime':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime;
        case 'toView':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
        case 'fromView':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView;
        case 'twoWay':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay;
        case 'default':
        default:
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default;
    }
}
function processLocalTemplates(template, definition, context, p, logger) {
    let root;
    if (template.nodeName === 'TEMPLATE') {
        if (template.hasAttribute(localTemplateIdentifier)) {
            throw new Error('The root cannot be a local template itself.');
        }
        root = template.content;
    }
    else {
        root = template;
    }
    const localTemplates = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray)(root.querySelectorAll('template[as-custom-element]'));
    const numLocalTemplates = localTemplates.length;
    if (numLocalTemplates === 0) {
        return;
    }
    if (numLocalTemplates === root.childElementCount) {
        throw new Error('The custom element does not have any content other than local template(s).');
    }
    const localTemplateNames = new Set();
    for (const localTemplate of localTemplates) {
        if (localTemplate.parentNode !== root) {
            throw new Error('Local templates needs to be defined directly under root.');
        }
        const name = processTemplateName(localTemplate, localTemplateNames);
        const localTemplateType = class LocalTemplate {
        };
        const content = localTemplate.content;
        const bindableEls = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray)(content.querySelectorAll('bindable'));
        const bindableInstructions = _bindable_js__WEBPACK_IMPORTED_MODULE_7__.Bindable.for(localTemplateType);
        const properties = new Set();
        const attributes = new Set();
        for (const bindableEl of bindableEls) {
            if (bindableEl.parentNode !== content) {
                throw new Error('Bindable properties of local templates needs to be defined directly under root.');
            }
            const property = bindableEl.getAttribute("property" /* property */);
            if (property === null) {
                throw new Error(`The attribute 'property' is missing in ${bindableEl.outerHTML}`);
            }
            const attribute = bindableEl.getAttribute("attribute" /* attribute */);
            if (attribute !== null
                && attributes.has(attribute)
                || properties.has(property)) {
                throw new Error(`Bindable property and attribute needs to be unique; found property: ${property}, attribute: ${attribute}`);
            }
            else {
                if (attribute !== null) {
                    attributes.add(attribute);
                }
                properties.add(property);
            }
            bindableInstructions.add({
                property,
                attribute: attribute ?? void 0,
                mode: getBindingMode(bindableEl),
            });
            const ignoredAttributes = bindableEl.getAttributeNames().filter((attrName) => !allowedLocalTemplateBindableAttributes.includes(attrName));
            if (ignoredAttributes.length > 0) {
                logger.warn(`The attribute(s) ${ignoredAttributes.join(', ')} will be ignored for ${bindableEl.outerHTML}. Only ${allowedLocalTemplateBindableAttributes.join(', ')} are processed.`);
            }
            content.removeChild(bindableEl);
        }
        const localTemplateDefinition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.define({ name, template: localTemplate }, localTemplateType);
        // the casting is needed here as the dependencies are typed as readonly array
        definition.dependencies.push(localTemplateDefinition);
        context.register(localTemplateDefinition);
        root.removeChild(localTemplate);
    }
}
//# sourceMappingURL=template-compiler.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ITemplateElementFactory": () => /* binding */ ITemplateElementFactory,
/* harmony export */   "TemplateElementFactory": () => /* binding */ TemplateElementFactory
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


const ITemplateElementFactory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ITemplateElementFactory', x => x.singleton(TemplateElementFactory));
const markupCache = {};
let TemplateElementFactory = class TemplateElementFactory {
    constructor(p) {
        this.p = p;
        this.template = p.document.createElement('template');
    }
    createTemplate(input) {
        if (typeof input === 'string') {
            let result = markupCache[input];
            if (result === void 0) {
                const template = this.template;
                template.innerHTML = input;
                const node = template.content.firstElementChild;
                // if the input is either not wrapped in a template or there is more than one node,
                // return the whole template that wraps it/them (and create a new one for the next input)
                if (node == null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling != null) {
                    this.template = this.p.document.createElement('template');
                    result = template;
                }
                else {
                    // the node to return is both a template and the only node, so return just the node
                    // and clean up the template for the next input
                    template.content.removeChild(node);
                    result = node;
                }
                markupCache[input] = result;
            }
            return result.cloneNode(true);
        }
        if (input.nodeName !== 'TEMPLATE') {
            // if we get one node that is not a template, wrap it in one
            const template = this.p.document.createElement('template');
            template.content.appendChild(input);
            return template;
        }
        // we got a template element, remove it from the DOM if it's present there and don't
        // do any other processing
        input.parentNode?.removeChild(input);
        return input.cloneNode(true);
    }
};
TemplateElementFactory = __decorate([
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_1__.IPlatform)
], TemplateElementFactory);

//# sourceMappingURL=template-element-factory.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "children": () => /* binding */ children,
/* harmony export */   "Children": () => /* binding */ Children,
/* harmony export */   "ChildrenDefinition": () => /* binding */ ChildrenDefinition,
/* harmony export */   "ChildrenObserver": () => /* binding */ ChildrenObserver,
/* harmony export */   "filterChildren": () => /* binding */ filterChildren
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChildrenObserver_1;



function children(configOrTarget, prop) {
    let config;
    function decorator($target, $prop) {
        if (arguments.length > 1) {
            // Non invocation:
            // - @children
            // Invocation with or w/o opts:
            // - @children()
            // - @children({...opts})
            config.property = $prop;
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Children.name, ChildrenDefinition.create($prop, config), $target.constructor, $prop);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo($target.constructor, Children.keyFrom($prop));
    }
    if (arguments.length > 1) {
        // Non invocation:
        // - @children
        config = {};
        decorator(configOrTarget, prop);
        return;
    }
    else if (typeof configOrTarget === 'string') {
        // ClassDecorator
        // - @children('bar')
        // Direct call:
        // - @children('bar')(Foo)
        config = {};
        return decorator;
    }
    // Invocation with or w/o opts:
    // - @children()
    // - @children({...opts})
    config = configOrTarget === void 0 ? {} : configOrTarget;
    return decorator;
}
function isChildrenObserverAnnotation(key) {
    return key.startsWith(Children.name);
}
const Children = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('children-observer'),
    keyFrom(name) {
        return `${Children.name}:${name}`;
    },
    from(...childrenObserverLists) {
        const childrenObservers = {};
        const isArray = Array.isArray;
        function addName(name) {
            childrenObservers[name] = ChildrenDefinition.create(name);
        }
        function addDescription(name, def) {
            childrenObservers[name] = ChildrenDefinition.create(name, def);
        }
        function addList(maybeList) {
            if (isArray(maybeList)) {
                maybeList.forEach(addName);
            }
            else if (maybeList instanceof ChildrenDefinition) {
                childrenObservers[maybeList.property] = maybeList;
            }
            else if (maybeList !== void 0) {
                Object.keys(maybeList).forEach(name => addDescription(name, maybeList));
            }
        }
        childrenObserverLists.forEach(addList);
        return childrenObservers;
    },
    getAll(Type) {
        const propStart = Children.name.length + 1;
        const defs = [];
        const prototypeChain = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.getPrototypeChain)(Type);
        let iProto = prototypeChain.length;
        let iDefs = 0;
        let keys;
        let keysLen;
        let Class;
        while (--iProto >= 0) {
            Class = prototypeChain[iProto];
            keys = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.getKeys(Class).filter(isChildrenObserverAnnotation);
            keysLen = keys.length;
            for (let i = 0; i < keysLen; ++i) {
                defs[iDefs++] = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Children.name, Class, keys[i].slice(propStart));
            }
        }
        return defs;
    },
};
const childObserverOptions = { childList: true };
class ChildrenDefinition {
    constructor(callback, property, options, query, filter, map) {
        this.callback = callback;
        this.property = property;
        this.options = options;
        this.query = query;
        this.filter = filter;
        this.map = map;
    }
    static create(prop, def = {}) {
        return new ChildrenDefinition((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.callback, `${prop}Changed`), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.property, prop), def.options ?? childObserverOptions, def.query, def.filter, def.map);
    }
}
/** @internal */
let ChildrenObserver = ChildrenObserver_1 = class ChildrenObserver {
    constructor(controller, obj, propertyKey, cbName, query = defaultChildQuery, filter = defaultChildFilter, map = defaultChildMap, options) {
        this.controller = controller;
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.query = query;
        this.filter = filter;
        this.map = map;
        this.options = options;
        this.observing = false;
        this.children = (void 0);
        this.callback = obj[cbName];
        Reflect.defineProperty(this.obj, this.propertyKey, {
            enumerable: true,
            configurable: true,
            get: () => this.getValue(),
            set: () => { return; },
        });
    }
    getValue() {
        this.tryStartObserving();
        return this.children;
    }
    setValue(newValue) { }
    subscribe(subscriber) {
        this.tryStartObserving();
        this.subs.add(subscriber);
    }
    tryStartObserving() {
        if (!this.observing) {
            this.observing = true;
            this.children = filterChildren(this.controller, this.query, this.filter, this.map);
            const obs = new this.controller.host.ownerDocument.defaultView.MutationObserver(() => { this.onChildrenChanged(); });
            obs.observe(this.controller.host, this.options);
        }
    }
    onChildrenChanged() {
        this.children = filterChildren(this.controller, this.query, this.filter, this.map);
        if (this.callback !== void 0) {
            this.callback.call(this.obj);
        }
        this.subs.notify(this.children, undefined, 8 /* updateTarget */);
    }
};
ChildrenObserver = ChildrenObserver_1 = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)()
], ChildrenObserver);

function defaultChildQuery(controller) {
    return controller.host.childNodes;
}
function defaultChildFilter(node, controller, viewModel) {
    return !!viewModel;
}
function defaultChildMap(node, controller, viewModel) {
    return viewModel;
}
const forOpts = { optional: true };
/** @internal */
function filterChildren(controller, query, filter, map) {
    const nodes = query(controller);
    const children = [];
    for (let i = 0, ii = nodes.length; i < ii; ++i) {
        const node = nodes[i];
        const $controller = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.for(node, forOpts);
        const viewModel = $controller?.viewModel ?? null;
        if (filter(node, $controller, viewModel)) {
            children.push(map(node, $controller, viewModel));
        }
    }
    return children;
}
//# sourceMappingURL=children.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MountTarget": () => /* binding */ MountTarget,
/* harmony export */   "Controller": () => /* binding */ Controller,
/* harmony export */   "isCustomElementController": () => /* binding */ isCustomElementController,
/* harmony export */   "isCustomElementViewModel": () => /* binding */ isCustomElementViewModel,
/* harmony export */   "HooksDefinition": () => /* binding */ HooksDefinition,
/* harmony export */   "ViewModelKind": () => /* binding */ ViewModelKind,
/* harmony export */   "State": () => /* binding */ State,
/* harmony export */   "stringifyState": () => /* binding */ stringifyState,
/* harmony export */   "IController": () => /* binding */ IController
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observation/bindable-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _render_context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _children_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./children.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _styles_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./styles.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js");
/* harmony import */ var _watchers_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./watchers.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js");
/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */












function callDispose(disposable) {
    disposable.dispose();
}
var MountTarget;
(function (MountTarget) {
    MountTarget[MountTarget["none"] = 0] = "none";
    MountTarget[MountTarget["host"] = 1] = "host";
    MountTarget[MountTarget["shadowRoot"] = 2] = "shadowRoot";
    MountTarget[MountTarget["location"] = 3] = "location";
})(MountTarget || (MountTarget = {}));
const optional = { optional: true };
const controllerLookup = new WeakMap();
class Controller {
    constructor(root, container, vmKind, flags, definition, 
    /**
     * The viewFactory. Only present for synthetic views.
     */
    viewFactory, 
    /**
     * The backing viewModel. Only present for custom attributes and elements.
     */
    viewModel, 
    /**
     * The physical host dom node.
     *
     * For containerless elements, this node will be removed from the DOM and replaced by a comment, which is assigned to the `location` property.
     *
     * For ShadowDOM elements, this will be the original declaring element, NOT the shadow root (the shadow root is stored on the `shadowRoot` property)
     */
    host) {
        this.root = root;
        this.container = container;
        this.vmKind = vmKind;
        this.flags = flags;
        this.definition = definition;
        this.viewFactory = viewFactory;
        this.viewModel = viewModel;
        this.host = host;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.head = null;
        this.tail = null;
        this.next = null;
        this.parent = null;
        this.bindings = null;
        this.children = null;
        this.hasLockedScope = false;
        this.isStrictBinding = false;
        this.scope = null;
        this.hostScope = null;
        // If a host from another custom element was passed in, then this will be the controller for that custom element (could be `au-viewport` for example).
        // In that case, this controller will create a new host node (with the definition's name) and use that as the target host for the nodes instead.
        // That host node is separately mounted to the host controller's original host node.
        this.hostController = null;
        this.mountTarget = 0 /* none */;
        this.shadowRoot = null;
        this.nodes = null;
        this.context = null;
        this.location = null;
        this.state = 0 /* none */;
        this.logger = null;
        this.debug = false;
        this.fullyNamed = false;
        this.$initiator = null;
        this.$flags = 0 /* none */;
        this.$resolve = void 0;
        this.$reject = void 0;
        this.$promise = void 0;
        this.activatingStack = 0;
        this.detachingStack = 0;
        this.unbindingStack = 0;
        if (root === null && container.has(_app_root_js__WEBPACK_IMPORTED_MODULE_8__.IAppRoot, true)) {
            this.root = container.get(_app_root_js__WEBPACK_IMPORTED_MODULE_8__.IAppRoot);
        }
        this.platform = container.get(_platform_js__WEBPACK_IMPORTED_MODULE_9__.IPlatform);
        switch (vmKind) {
            case 1 /* customAttribute */:
            case 0 /* customElement */:
                this.hooks = new HooksDefinition(viewModel);
                break;
            case 2 /* synthetic */:
                this.hooks = HooksDefinition.none;
                break;
        }
    }
    get isActive() {
        return (this.state & (1 /* activating */ | 2 /* activated */)) > 0 && (this.state & 4 /* deactivating */) === 0;
    }
    get name() {
        if (this.parent === null) {
            switch (this.vmKind) {
                case 1 /* customAttribute */:
                    return `[${this.definition.name}]`;
                case 0 /* customElement */:
                    return this.definition.name;
                case 2 /* synthetic */:
                    return this.viewFactory.name;
            }
        }
        switch (this.vmKind) {
            case 1 /* customAttribute */:
                return `${this.parent.name}>[${this.definition.name}]`;
            case 0 /* customElement */:
                return `${this.parent.name}>${this.definition.name}`;
            case 2 /* synthetic */:
                return this.viewFactory.name === this.parent.definition?.name
                    ? `${this.parent.name}[view]`
                    : `${this.parent.name}[view:${this.viewFactory.name}]`;
        }
    }
    static getCached(viewModel) {
        return controllerLookup.get(viewModel);
    }
    static getCachedOrThrow(viewModel) {
        const controller = Controller.getCached(viewModel);
        if (controller === void 0) {
            throw new Error(`There is no cached controller for the provided ViewModel: ${String(viewModel)}`);
        }
        return controller;
    }
    static forCustomElement(root, container, viewModel, host, 
    // projections *targeted* for this custom element. these are not the projections *provided* by this custom element.
    targetedProjections, flags = 0 /* none */, hydrate = true, 
    // Use this when `instance.constructor` is not a custom element type to pass on the CustomElement definition
    definition = void 0) {
        if (controllerLookup.has(viewModel)) {
            return controllerLookup.get(viewModel);
        }
        definition = definition ?? _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.getDefinition(viewModel.constructor);
        const controller = new Controller(
        /* root           */ root, 
        /* container      */ container, 0 /* customElement */, 
        /* flags          */ flags, 
        /* definition     */ definition, 
        /* viewFactory    */ null, 
        /* viewModel      */ viewModel, 
        /* host           */ host);
        controllerLookup.set(viewModel, controller);
        if (hydrate) {
            controller.hydrateCustomElement(container, targetedProjections);
        }
        return controller;
    }
    static forCustomAttribute(root, container, viewModel, host, flags = 0 /* none */) {
        if (controllerLookup.has(viewModel)) {
            return controllerLookup.get(viewModel);
        }
        const definition = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttribute.getDefinition(viewModel.constructor);
        const controller = new Controller(
        /* root           */ root, 
        /* container      */ container, 1 /* customAttribute */, 
        /* flags          */ flags, 
        /* definition     */ definition, 
        /* viewFactory    */ null, 
        /* viewModel      */ viewModel, 
        /* host           */ host);
        controllerLookup.set(viewModel, controller);
        controller.hydrateCustomAttribute();
        return controller;
    }
    static forSyntheticView(root, context, viewFactory, flags = 0 /* none */, parentController = void 0) {
        const controller = new Controller(
        /* root           */ root, 
        /* container      */ context, 2 /* synthetic */, 
        /* flags          */ flags, 
        /* definition     */ null, 
        /* viewFactory    */ viewFactory, 
        /* viewModel      */ null, 
        /* host           */ null);
        controller.parent = parentController ?? null;
        controller.hydrateSynthetic(context);
        return controller;
    }
    /** @internal */
    hydrateCustomElement(parentContainer, targetedProjections) {
        this.logger = parentContainer.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger).root;
        this.debug = this.logger.config.level <= 1 /* debug */;
        if (this.debug) {
            this.logger = this.logger.scopeTo(this.name);
        }
        let definition = this.definition;
        const flags = this.flags;
        const instance = this.viewModel;
        this.scope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.create(instance, null, true);
        if (definition.watches.length > 0) {
            createWatchers(this, this.container, definition, instance);
        }
        createObservers(this, definition, flags, instance);
        createChildrenObservers(this, definition, flags, instance);
        if (this.hooks.hasDefine) {
            if (this.debug) {
                this.logger.trace(`invoking define() hook`);
            }
            const result = instance.define(
            /* controller      */ this, 
            /* parentContainer */ parentContainer, 
            /* definition      */ definition);
            if (result !== void 0 && result !== definition) {
                definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElementDefinition.getOrCreate(result);
            }
        }
        const context = this.context = (0,_render_context_js__WEBPACK_IMPORTED_MODULE_6__.getRenderContext)(definition, parentContainer, targetedProjections?.projections);
        // Support Recursive Components by adding self to own context
        definition.register(context);
        if (definition.injectable !== null) {
            // If the element is registered as injectable, support injecting the instance into children
            context.beginChildComponentOperation(instance);
        }
        // If this is the root controller, then the AppRoot will invoke things in the following order:
        // - Controller.hydrateCustomElement
        // - runAppTasks('hydrating') // may return a promise
        // - Controller.compile
        // - runAppTasks('hydrated') // may return a promise
        // - Controller.compileChildren
        // This keeps hydration synchronous while still allowing the composition root compile hooks to do async work.
        if (this.root?.controller !== this) {
            this.hydrate(targetedProjections);
            this.hydrateChildren();
        }
    }
    /** @internal */
    hydrate(targetedProjections) {
        if (this.hooks.hasHydrating) {
            if (this.debug) {
                this.logger.trace(`invoking hasHydrating() hook`);
            }
            this.viewModel.hydrating(this);
        }
        const compiledContext = this.context.compile(targetedProjections);
        const { projectionsMap, shadowOptions, isStrictBinding, hasSlots, containerless } = compiledContext.compiledDefinition;
        compiledContext.registerProjections(projectionsMap, this.scope);
        // once the projections are registered, we can cleanup the projection map to prevent memory leaks.
        projectionsMap.clear();
        this.isStrictBinding = isStrictBinding;
        if ((this.hostController = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.for(this.host, optional)) !== null) {
            this.host = this.platform.document.createElement(this.context.definition.name);
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, this.host);
        if (shadowOptions !== null || hasSlots) {
            if (containerless) {
                throw new Error('You cannot combine the containerless custom element option with Shadow DOM.');
            }
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, this.shadowRoot = this.host.attachShadow(shadowOptions ?? defaultShadowOptions));
            this.mountTarget = 2 /* shadowRoot */;
        }
        else if (containerless) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, this.location = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.convertToRenderLocation)(this.host));
            this.mountTarget = 3 /* location */;
        }
        else {
            this.mountTarget = 1 /* host */;
        }
        this.viewModel.$controller = this;
        this.nodes = compiledContext.createNodes();
        if (this.hooks.hasHydrated) {
            if (this.debug) {
                this.logger.trace(`invoking hasHydrated() hook`);
            }
            this.viewModel.hydrated(this);
        }
    }
    /** @internal */
    hydrateChildren() {
        const targets = this.nodes.findTargets();
        this.context.render(
        /* flags      */ this.flags, 
        /* controller */ this, 
        /* targets    */ targets, 
        /* definition */ this.context.compiledDefinition, 
        /* host       */ this.host);
        if (this.hooks.hasCreated) {
            if (this.debug) {
                this.logger.trace(`invoking created() hook`);
            }
            this.viewModel.created(this);
        }
    }
    hydrateCustomAttribute() {
        const definition = this.definition;
        const instance = this.viewModel;
        if (definition.watches.length > 0) {
            createWatchers(this, this.container, definition, instance);
        }
        createObservers(this, definition, this.flags, instance);
        instance.$controller = this;
    }
    hydrateSynthetic(context) {
        this.context = context;
        const compiledContext = context.compile(null);
        const compiledDefinition = compiledContext.compiledDefinition;
        this.isStrictBinding = compiledDefinition.isStrictBinding;
        const nodes = this.nodes = compiledContext.createNodes();
        const targets = nodes.findTargets();
        compiledContext.render(
        /* flags      */ this.flags, 
        /* controller */ this, 
        /* targets    */ targets, 
        /* definition */ compiledDefinition, 
        /* host       */ void 0);
    }
    activate(initiator, parent, flags, scope, hostScope) {
        switch (this.state) {
            case 0 /* none */:
            case 8 /* deactivated */:
                if (!(parent === null || parent.isActive)) {
                    // If this is not the root, and the parent is either:
                    // 1. Not activated, or activating children OR
                    // 2. Deactivating itself
                    // abort.
                    return;
                }
                // Otherwise, proceed normally.
                // 'deactivated' and 'none' are treated the same because, from an activation perspective, they mean the same thing.
                this.state = 1 /* activating */;
                break;
            case 2 /* activated */:
                // If we're already activated, no need to do anything.
                return;
            case 32 /* disposed */:
                throw new Error(`${this.name} trying to activate a controller that is disposed.`);
            default:
                throw new Error(`${this.name} unexpected state: ${stringifyState(this.state)}.`);
        }
        this.parent = parent;
        if (this.debug && !this.fullyNamed) {
            this.fullyNamed = true;
            this.logger = this.context.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger).root.scopeTo(this.name);
            this.logger.trace(`activate()`);
        }
        this.hostScope = hostScope ?? null;
        flags |= 32 /* fromBind */;
        switch (this.vmKind) {
            case 0 /* customElement */:
                // Custom element scope is created and assigned during hydration
                this.scope.parentScope = scope ?? null;
                break;
            case 1 /* customAttribute */:
                this.scope = scope ?? null;
                break;
            case 2 /* synthetic */:
                if (scope === void 0 || scope === null) {
                    throw new Error(`Scope is null or undefined`);
                }
                if (!this.hasLockedScope) {
                    this.scope = scope;
                }
                break;
        }
        if (this.isStrictBinding) {
            flags |= 4 /* isStrictBindingStrategy */;
        }
        this.$initiator = initiator;
        this.$flags = flags;
        // opposing leave is called in attach() (which will trigger attached())
        this.enterActivating();
        if (this.hooks.hasBinding) {
            if (this.debug) {
                this.logger.trace(`binding()`);
            }
            const ret = this.viewModel.binding(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                ret.then(() => {
                    this.bind();
                }).catch(err => {
                    this.reject(err);
                });
                return this.$promise;
            }
        }
        this.bind();
        return this.$promise;
    }
    bind() {
        if (this.debug) {
            this.logger.trace(`bind()`);
        }
        if (this.bindings !== null) {
            for (let i = 0; i < this.bindings.length; ++i) {
                this.bindings[i].$bind(this.$flags, this.scope, this.hostScope);
            }
        }
        if (this.hooks.hasBound) {
            if (this.debug) {
                this.logger.trace(`bound()`);
            }
            const ret = this.viewModel.bound(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                ret.then(() => {
                    this.attach();
                }).catch(err => {
                    this.reject(err);
                });
                return;
            }
        }
        this.attach();
    }
    append(...nodes) {
        switch (this.mountTarget) {
            case 1 /* host */:
                this.host.append(...nodes);
                break;
            case 2 /* shadowRoot */:
                this.shadowRoot.append(...nodes);
                break;
            case 3 /* location */:
                for (let i = 0; i < nodes.length; ++i) {
                    this.location.parentNode.insertBefore(nodes[i], this.location);
                }
                break;
        }
    }
    attach() {
        if (this.debug) {
            this.logger.trace(`attach()`);
        }
        if (this.hostController !== null) {
            switch (this.mountTarget) {
                case 1 /* host */:
                case 2 /* shadowRoot */:
                    this.hostController.append(this.host);
                    break;
                case 3 /* location */:
                    this.hostController.append(this.location.$start, this.location);
                    break;
            }
        }
        switch (this.mountTarget) {
            case 1 /* host */:
                this.nodes.appendTo(this.host, this.definition?.enhance);
                break;
            case 2 /* shadowRoot */: {
                const styles = this.context.has(_styles_js__WEBPACK_IMPORTED_MODULE_10__.IShadowDOMStyles, false)
                    ? this.context.get(_styles_js__WEBPACK_IMPORTED_MODULE_10__.IShadowDOMStyles)
                    : this.context.get(_styles_js__WEBPACK_IMPORTED_MODULE_10__.IShadowDOMGlobalStyles);
                styles.applyTo(this.shadowRoot);
                this.nodes.appendTo(this.shadowRoot);
                break;
            }
            case 3 /* location */:
                this.nodes.insertBefore(this.location);
                break;
        }
        if (this.hooks.hasAttaching) {
            if (this.debug) {
                this.logger.trace(`attaching()`);
            }
            const ret = this.viewModel.attaching(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                this.enterActivating();
                ret.then(() => {
                    this.leaveActivating();
                }).catch(err => {
                    this.reject(err);
                });
            }
        }
        // attaching() and child activation run in parallel, and attached() is called when both are finished
        if (this.children !== null) {
            for (let i = 0; i < this.children.length; ++i) {
                // Any promises returned from child activation are cumulatively awaited before this.$promise resolves
                void this.children[i].activate(this.$initiator, this, this.$flags, this.scope, this.hostScope);
            }
        }
        // attached() is invoked by Controller#leaveActivating when `activatingStack` reaches 0
        this.leaveActivating();
    }
    deactivate(initiator, parent, flags) {
        switch ((this.state & ~16 /* released */)) {
            case 2 /* activated */:
                // We're fully activated, so proceed with normal deactivation.
                this.state = 4 /* deactivating */;
                break;
            case 0 /* none */:
            case 8 /* deactivated */:
            case 32 /* disposed */:
            case 8 /* deactivated */ | 32 /* disposed */:
                // If we're already deactivated (or even disposed), or never activated in the first place, no need to do anything.
                return;
            default:
                throw new Error(`${this.name} unexpected state: ${stringifyState(this.state)}.`);
        }
        if (this.debug) {
            this.logger.trace(`deactivate()`);
        }
        this.$initiator = initiator;
        this.$flags = flags;
        if (initiator === this) {
            this.enterDetaching();
        }
        if (this.children !== null) {
            for (let i = 0; i < this.children.length; ++i) {
                // Child promise results are tracked by enter/leave combo's
                void this.children[i].deactivate(initiator, this, flags);
            }
        }
        if (this.hooks.hasDetaching) {
            if (this.debug) {
                this.logger.trace(`detaching()`);
            }
            const ret = this.viewModel.detaching(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                initiator.enterDetaching();
                ret.then(() => {
                    initiator.leaveDetaching();
                }).catch(err => {
                    initiator.reject(err);
                });
            }
        }
        // Note: if a 3rd party plugin happens to do any async stuff in a template controller before calling deactivate on its view,
        // then the linking will become out of order.
        // For framework components, this shouldn't cause issues.
        // We can only prevent that by linking up after awaiting the detaching promise, which would add an extra tick + a fair bit of
        // overhead on this hot path, so it's (for now) a deliberate choice to not account for such situation.
        // Just leaving the note here so that we know to look here if a weird detaching-related timing issue is ever reported.
        if (initiator.head === null) {
            initiator.head = this;
        }
        else {
            initiator.tail.next = this;
        }
        initiator.tail = this;
        if (initiator !== this) {
            // Only detaching is called + the linked list is built when any controller that is not the initiator, is deactivated.
            // The rest is handled by the initiator.
            // This means that descendant controllers have to make sure to await the initiator's promise before doing any subsequent
            // controller api calls, or race conditions might occur.
            return;
        }
        this.leaveDetaching();
        return this.$promise;
    }
    removeNodes() {
        switch (this.vmKind) {
            case 0 /* customElement */:
            case 2 /* synthetic */:
                this.nodes.remove();
                this.nodes.unlink();
        }
        if (this.hostController !== null) {
            switch (this.mountTarget) {
                case 1 /* host */:
                case 2 /* shadowRoot */:
                    this.host.remove();
                    break;
                case 3 /* location */:
                    this.location.$start.remove();
                    this.location.remove();
                    break;
            }
        }
    }
    unbind() {
        if (this.debug) {
            this.logger.trace(`unbind()`);
        }
        const flags = this.$flags | 64 /* fromUnbind */;
        if (this.bindings !== null) {
            for (let i = 0; i < this.bindings.length; ++i) {
                this.bindings[i].$unbind(flags);
            }
        }
        this.parent = null;
        switch (this.vmKind) {
            case 1 /* customAttribute */:
                this.scope = null;
                break;
            case 2 /* synthetic */:
                if (!this.hasLockedScope) {
                    this.scope = null;
                }
                if ((this.state & 16 /* released */) === 16 /* released */ &&
                    !this.viewFactory.tryReturnToCache(this)) {
                    this.dispose();
                }
                break;
            case 0 /* customElement */:
                this.scope.parentScope = null;
                break;
        }
        if ((flags & 512 /* dispose */) === 512 /* dispose */) {
            this.dispose();
        }
        this.state = (this.state & 32 /* disposed */) | 8 /* deactivated */;
        this.$initiator = null;
        this.resolve();
    }
    ensurePromise() {
        if (this.$promise === void 0) {
            this.$promise = new Promise((resolve, reject) => {
                this.$resolve = resolve;
                this.$reject = reject;
            });
            if (this.$initiator !== this) {
                this.parent.ensurePromise();
            }
        }
    }
    resolve() {
        if (this.$promise !== void 0) {
            const resolve = this.$resolve;
            this.$resolve = this.$reject = this.$promise = void 0;
            resolve();
        }
    }
    reject(err) {
        if (this.$promise !== void 0) {
            const reject = this.$reject;
            this.$resolve = this.$reject = this.$promise = void 0;
            reject(err);
        }
        if (this.$initiator !== this) {
            this.parent.reject(err);
        }
    }
    enterActivating() {
        ++this.activatingStack;
        if (this.$initiator !== this) {
            this.parent.enterActivating();
        }
    }
    leaveActivating() {
        if (--this.activatingStack === 0) {
            if (this.hooks.hasAttached) {
                if (this.debug) {
                    this.logger.trace(`attached()`);
                }
                const ret = this.viewModel.attached(this.$initiator, this.$flags);
                if (ret instanceof Promise) {
                    this.ensurePromise();
                    ret.then(() => {
                        this.state = 2 /* activated */;
                        // Resolve this.$promise, signaling that activation is done (path 1 of 2)
                        this.resolve();
                        if (this.$initiator !== this) {
                            this.parent.leaveActivating();
                        }
                    }).catch(err => {
                        this.reject(err);
                    });
                    return;
                }
            }
            this.state = 2 /* activated */;
            // Resolve this.$promise (if present), signaling that activation is done (path 2 of 2)
            this.resolve();
        }
        if (this.$initiator !== this) {
            this.parent.leaveActivating();
        }
    }
    enterDetaching() {
        ++this.detachingStack;
    }
    leaveDetaching() {
        if (--this.detachingStack === 0) {
            // Note: this controller is the initiator (detach is only ever called on the initiator)
            if (this.debug) {
                this.logger.trace(`detach()`);
            }
            this.enterUnbinding();
            this.removeNodes();
            let cur = this.$initiator.head;
            while (cur !== null) {
                if (cur !== this) {
                    if (cur.debug) {
                        cur.logger.trace(`detach()`);
                    }
                    cur.removeNodes();
                }
                if (cur.hooks.hasUnbinding) {
                    if (cur.debug) {
                        cur.logger.trace('unbinding()');
                    }
                    const ret = cur.viewModel.unbinding(cur.$initiator, cur.parent, cur.$flags);
                    if (ret instanceof Promise) {
                        this.ensurePromise();
                        this.enterUnbinding();
                        ret.then(() => {
                            this.leaveUnbinding();
                        }).catch(err => {
                            this.reject(err);
                        });
                    }
                }
                cur = cur.next;
            }
            this.leaveUnbinding();
        }
    }
    enterUnbinding() {
        ++this.unbindingStack;
    }
    leaveUnbinding() {
        if (--this.unbindingStack === 0) {
            if (this.debug) {
                this.logger.trace(`unbind()`);
            }
            let cur = this.$initiator.head;
            let next = null;
            while (cur !== null) {
                if (cur !== this) {
                    cur.unbind();
                }
                next = cur.next;
                cur.next = null;
                cur = next;
            }
            this.head = this.tail = null;
            this.unbind();
        }
    }
    addBinding(binding) {
        if (this.bindings === null) {
            this.bindings = [binding];
        }
        else {
            this.bindings[this.bindings.length] = binding;
        }
    }
    addController(controller) {
        if (this.children === null) {
            this.children = [controller];
        }
        else {
            this.children[this.children.length] = controller;
        }
    }
    is(name) {
        switch (this.vmKind) {
            case 1 /* customAttribute */: {
                const def = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttribute.getDefinition(this.viewModel.constructor);
                return def.name === name;
            }
            case 0 /* customElement */: {
                const def = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.getDefinition(this.viewModel.constructor);
                return def.name === name;
            }
            case 2 /* synthetic */:
                return this.viewFactory.name === name;
        }
    }
    lockScope(scope) {
        this.scope = scope;
        this.hasLockedScope = true;
    }
    setHost(host) {
        if (this.vmKind === 0 /* customElement */) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, host);
        }
        this.host = host;
        this.mountTarget = 1 /* host */;
        return this;
    }
    setShadowRoot(shadowRoot) {
        if (this.vmKind === 0 /* customElement */) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, shadowRoot);
        }
        this.shadowRoot = shadowRoot;
        this.mountTarget = 2 /* shadowRoot */;
        return this;
    }
    setLocation(location) {
        if (this.vmKind === 0 /* customElement */) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, location);
        }
        this.location = location;
        this.mountTarget = 3 /* location */;
        return this;
    }
    release() {
        this.state |= 16 /* released */;
    }
    dispose() {
        if (this.debug) {
            this.logger.trace(`dispose()`);
        }
        if ((this.state & 32 /* disposed */) === 32 /* disposed */) {
            return;
        }
        this.state |= 32 /* disposed */;
        if (this.hooks.hasDispose) {
            this.viewModel.dispose();
        }
        if (this.children !== null) {
            this.children.forEach(callDispose);
            this.children = null;
        }
        this.hostController = null;
        this.scope = null;
        this.nodes = null;
        this.context = null;
        this.location = null;
        this.viewFactory = null;
        if (this.viewModel !== null) {
            controllerLookup.delete(this.viewModel);
            this.viewModel = null;
        }
        this.viewModel = null;
        this.host = null;
        this.shadowRoot = null;
        this.root = null;
    }
    accept(visitor) {
        if (visitor(this) === true) {
            return true;
        }
        if (this.hooks.hasAccept && this.viewModel.accept(visitor) === true) {
            return true;
        }
        if (this.children !== null) {
            const { children } = this;
            for (let i = 0, ii = children.length; i < ii; ++i) {
                if (children[i].accept(visitor) === true) {
                    return true;
                }
            }
        }
    }
    getTargetAccessor(propertyName) {
        const { bindings } = this;
        if (bindings !== null) {
            const binding = bindings.find(b => b.targetProperty === propertyName);
            if (binding !== void 0) {
                return binding.targetObserver;
            }
        }
        return void 0;
    }
}
function getLookup(instance) {
    let lookup = instance.$observers;
    if (lookup === void 0) {
        Reflect.defineProperty(instance, '$observers', {
            enumerable: false,
            value: lookup = {},
        });
    }
    return lookup;
}
function createObservers(controller, definition, 
// deepscan-disable-next-line
_flags, instance) {
    const bindables = definition.bindables;
    const observableNames = Object.getOwnPropertyNames(bindables);
    const length = observableNames.length;
    if (length > 0) {
        let name;
        let bindable;
        const observers = getLookup(instance);
        for (let i = 0; i < length; ++i) {
            name = observableNames[i];
            if (observers[name] === void 0) {
                bindable = bindables[name];
                observers[name] = new _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_2__.BindableObserver(instance, name, bindable.callback, bindable.set, controller);
            }
        }
    }
}
function createChildrenObservers(controller, definition, 
// deepscan-disable-next-line
_flags, instance) {
    const childrenObservers = definition.childrenObservers;
    const childObserverNames = Object.getOwnPropertyNames(childrenObservers);
    const length = childObserverNames.length;
    if (length > 0) {
        const observers = getLookup(instance);
        let name;
        for (let i = 0; i < length; ++i) {
            name = childObserverNames[i];
            if (observers[name] == void 0) {
                const childrenDescription = childrenObservers[name];
                observers[name] = new _children_js__WEBPACK_IMPORTED_MODULE_7__.ChildrenObserver(controller, instance, name, childrenDescription.callback, childrenDescription.query, childrenDescription.filter, childrenDescription.map, childrenDescription.options);
            }
        }
    }
}
const AccessScopeAst = {
    map: new Map(),
    for(key) {
        let ast = AccessScopeAst.map.get(key);
        if (ast == null) {
            ast = new _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.AccessScopeExpression(key, 0);
            AccessScopeAst.map.set(key, ast);
        }
        return ast;
    },
};
function createWatchers(controller, context, definition, instance) {
    const observerLocator = context.get(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator);
    const expressionParser = context.get(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser);
    const watches = definition.watches;
    let expression;
    let callback;
    for (let i = 0, ii = watches.length; ii > i; ++i) {
        ({ expression, callback } = watches[i]);
        callback = typeof callback === 'function'
            ? callback
            : Reflect.get(instance, callback);
        if (typeof callback !== 'function') {
            throw new Error(`Invalid callback for @watch decorator: ${String(callback)}`);
        }
        if (typeof expression === 'function') {
            controller.addBinding(new _watchers_js__WEBPACK_IMPORTED_MODULE_11__.ComputedWatcher(instance, observerLocator, expression, callback, 
            // there should be a flag to purposely disable proxy
            // AOT: not true for IE11
            true));
        }
        else {
            const ast = typeof expression === 'string'
                ? expressionParser.parse(expression, 53 /* BindCommand */)
                : AccessScopeAst.for(expression);
            controller.addBinding(new _watchers_js__WEBPACK_IMPORTED_MODULE_11__.ExpressionWatcher(controller.scope, context, observerLocator, ast, callback));
        }
    }
}
function isCustomElementController(value) {
    return value instanceof Controller && value.vmKind === 0 /* customElement */;
}
function isCustomElementViewModel(value) {
    return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.isType(value.constructor);
}
class HooksDefinition {
    constructor(target) {
        this.hasDefine = 'define' in target;
        this.hasHydrating = 'hydrating' in target;
        this.hasHydrated = 'hydrated' in target;
        this.hasCreated = 'created' in target;
        this.hasBinding = 'binding' in target;
        this.hasBound = 'bound' in target;
        this.hasAttaching = 'attaching' in target;
        this.hasAttached = 'attached' in target;
        this.hasDetaching = 'detaching' in target;
        this.hasUnbinding = 'unbinding' in target;
        this.hasDispose = 'dispose' in target;
        this.hasAccept = 'accept' in target;
    }
}
HooksDefinition.none = new HooksDefinition({});
const defaultShadowOptions = {
    mode: 'open'
};
var ViewModelKind;
(function (ViewModelKind) {
    ViewModelKind[ViewModelKind["customElement"] = 0] = "customElement";
    ViewModelKind[ViewModelKind["customAttribute"] = 1] = "customAttribute";
    ViewModelKind[ViewModelKind["synthetic"] = 2] = "synthetic";
})(ViewModelKind || (ViewModelKind = {}));
var State;
(function (State) {
    State[State["none"] = 0] = "none";
    State[State["activating"] = 1] = "activating";
    State[State["activated"] = 2] = "activated";
    State[State["deactivating"] = 4] = "deactivating";
    State[State["deactivated"] = 8] = "deactivated";
    State[State["released"] = 16] = "released";
    State[State["disposed"] = 32] = "disposed";
})(State || (State = {}));
function stringifyState(state) {
    const names = [];
    if ((state & 1 /* activating */) === 1 /* activating */) {
        names.push('activating');
    }
    if ((state & 2 /* activated */) === 2 /* activated */) {
        names.push('activated');
    }
    if ((state & 4 /* deactivating */) === 4 /* deactivating */) {
        names.push('deactivating');
    }
    if ((state & 8 /* deactivated */) === 8 /* deactivated */) {
        names.push('deactivated');
    }
    if ((state & 16 /* released */) === 16 /* released */) {
        names.push('released');
    }
    if ((state & 32 /* disposed */) === 32 /* disposed */) {
        names.push('disposed');
    }
    return names.length === 0 ? 'none' : names.join('|');
}
const IController = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IController');
//# sourceMappingURL=controller.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isRenderContext": () => /* binding */ isRenderContext,
/* harmony export */   "getRenderContext": () => /* binding */ getRenderContext,
/* harmony export */   "RenderContext": () => /* binding */ RenderContext,
/* harmony export */   "ViewFactoryProvider": () => /* binding */ ViewFactoryProvider
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _controller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");








const definitionContainerLookup = new WeakMap();
const definitionContainerProjectionsLookup = new WeakMap();
const fragmentCache = new WeakMap();
function isRenderContext(value) {
    return value instanceof RenderContext;
}
function getRenderContext(partialDefinition, parentContainer, projections) {
    const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElementDefinition.getOrCreate(partialDefinition);
    // injectable completely prevents caching, ensuring that each instance gets a new context context
    if (definition.injectable !== null) {
        return new RenderContext(definition, parentContainer);
    }
    if (projections == null) {
        let containerLookup = definitionContainerLookup.get(definition);
        if (containerLookup === void 0) {
            definitionContainerLookup.set(definition, containerLookup = new WeakMap());
        }
        let context = containerLookup.get(parentContainer);
        if (context === void 0) {
            containerLookup.set(parentContainer, context = new RenderContext(definition, parentContainer));
        }
        return context;
    }
    let containerProjectionsLookup = definitionContainerProjectionsLookup.get(definition);
    if (containerProjectionsLookup === void 0) {
        definitionContainerProjectionsLookup.set(definition, containerProjectionsLookup = new WeakMap());
    }
    let projectionsLookup = containerProjectionsLookup.get(parentContainer);
    if (projectionsLookup === void 0) {
        containerProjectionsLookup.set(parentContainer, projectionsLookup = new WeakMap());
    }
    let context = projectionsLookup.get(projections);
    if (context === void 0) {
        projectionsLookup.set(projections, context = new RenderContext(definition, parentContainer));
    }
    return context;
}
const emptyNodeCache = new WeakMap();
class RenderContext {
    constructor(definition, parentContainer) {
        this.definition = definition;
        this.parentContainer = parentContainer;
        this.viewModelProvider = void 0;
        this.fragment = null;
        this.factory = void 0;
        this.isCompiled = false;
        this.renderers = Object.create(null);
        this.compiledDefinition = (void 0);
        const container = this.container = parentContainer.createChild();
        // TODO(fkleuver): get contextual + root renderers
        const renderers = container.getAll(_renderer_js__WEBPACK_IMPORTED_MODULE_2__.IRenderer);
        for (let i = 0; i < renderers.length; ++i) {
            const renderer = renderers[i];
            this.renderers[renderer.instructionType] = renderer;
        }
        this.projectionProvider = container.get(_resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_5__.IProjectionProvider);
        const p = this.platform = container.get(_platform_js__WEBPACK_IMPORTED_MODULE_6__.IPlatform);
        container.registerResolver(_view_js__WEBPACK_IMPORTED_MODULE_4__.IViewFactory, this.factoryProvider = new ViewFactoryProvider(), true);
        container.registerResolver(_controller_js__WEBPACK_IMPORTED_MODULE_7__.IController, this.parentControllerProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IController'), true);
        container.registerResolver(_renderer_js__WEBPACK_IMPORTED_MODULE_2__.IInstruction, this.instructionProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IInstruction'), true);
        container.registerResolver(_dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation, this.renderLocationProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IRenderLocation'), true);
        const ep = this.elementProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('ElementResolver');
        container.registerResolver(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode, ep);
        container.registerResolver(p.Node, ep);
        container.registerResolver(p.Element, ep);
        container.registerResolver(p.HTMLElement, ep);
        container.register(...definition.dependencies);
    }
    // #region IServiceLocator api
    has(key, searchAncestors) {
        return this.container.has(key, searchAncestors);
    }
    get(key) {
        return this.container.get(key);
    }
    getAll(key) {
        return this.container.getAll(key);
    }
    // #endregion
    // #region IContainer api
    register(...params) {
        return this.container.register(...params);
    }
    registerResolver(key, resolver) {
        return this.container.registerResolver(key, resolver);
    }
    // public deregisterResolverFor<K extends Key, T = K>(key: K): void {
    //   this.container.deregisterResolverFor(key);
    // }
    registerTransformer(key, transformer) {
        return this.container.registerTransformer(key, transformer);
    }
    getResolver(key, autoRegister) {
        return this.container.getResolver(key, autoRegister);
    }
    getFactory(key) {
        return this.container.getFactory(key);
    }
    registerFactory(key, factory) {
        this.container.registerFactory(key, factory);
    }
    createChild() {
        return this.container.createChild();
    }
    find(kind, name) {
        return this.container.find(kind, name);
    }
    create(kind, name) {
        return this.container.create(kind, name);
    }
    disposeResolvers() {
        this.container.disposeResolvers();
    }
    // #endregion
    // #region IRenderContext api
    compile(targetedProjections) {
        let compiledDefinition;
        if (this.isCompiled) {
            return this;
        }
        this.isCompiled = true;
        const definition = this.definition;
        if (definition.needsCompile) {
            const container = this.container;
            const compiler = container.get(_renderer_js__WEBPACK_IMPORTED_MODULE_2__.ITemplateCompiler);
            compiledDefinition = this.compiledDefinition = compiler.compile(definition, container, targetedProjections);
        }
        else {
            compiledDefinition = this.compiledDefinition = definition;
        }
        // Support Recursive Components by adding self to own context
        compiledDefinition.register(this);
        if (fragmentCache.has(compiledDefinition)) {
            this.fragment = fragmentCache.get(compiledDefinition);
        }
        else {
            const doc = this.platform.document;
            const template = compiledDefinition.template;
            if (template === null || this.definition.enhance === true) {
                this.fragment = null;
            }
            else if (template instanceof this.platform.Node) {
                if (template.nodeName === 'TEMPLATE') {
                    this.fragment = doc.adoptNode(template.content);
                }
                else {
                    (this.fragment = doc.adoptNode(doc.createDocumentFragment())).appendChild(template);
                }
            }
            else {
                const tpl = doc.createElement('template');
                doc.adoptNode(tpl.content);
                if (typeof template === 'string') {
                    tpl.innerHTML = template;
                }
                this.fragment = tpl.content;
            }
            fragmentCache.set(compiledDefinition, this.fragment);
        }
        return this;
    }
    getViewFactory(name, contentType, projectionScope) {
        let factory = this.factory;
        if (factory === void 0) {
            if (name === void 0) {
                name = this.definition.name;
            }
            factory = this.factory = new _view_js__WEBPACK_IMPORTED_MODULE_4__.ViewFactory(name, this, contentType, projectionScope);
        }
        return factory;
    }
    beginChildComponentOperation(instance) {
        const definition = this.definition;
        if (definition.injectable !== null) {
            if (this.viewModelProvider === void 0) {
                this.container.registerResolver(definition.injectable, this.viewModelProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('definition.injectable'));
            }
            this.viewModelProvider.prepare(instance);
        }
        return this;
    }
    // #endregion
    // #region ICompiledRenderContext api
    createNodes() {
        if (this.compiledDefinition.enhance === true) {
            return new _dom_js__WEBPACK_IMPORTED_MODULE_1__.FragmentNodeSequence(this.platform, this.compiledDefinition.template);
        }
        if (this.fragment === null) {
            let emptyNodes = emptyNodeCache.get(this.platform);
            if (emptyNodes === void 0) {
                emptyNodeCache.set(this.platform, emptyNodes = new _dom_js__WEBPACK_IMPORTED_MODULE_1__.FragmentNodeSequence(this.platform, this.platform.document.createDocumentFragment()));
            }
            return emptyNodes;
        }
        return new _dom_js__WEBPACK_IMPORTED_MODULE_1__.FragmentNodeSequence(this.platform, this.fragment.cloneNode(true));
    }
    // TODO: split up into 2 methods? getComponentFactory + getSyntheticFactory or something
    getComponentFactory(parentController, host, instruction, viewFactory, location) {
        if (parentController !== void 0) {
            this.parentControllerProvider.prepare(parentController);
        }
        if (host !== void 0) {
            // TODO: fix provider input type, Key is probably not a good constraint
            this.elementProvider.prepare(host);
        }
        if (instruction !== void 0) {
            this.instructionProvider.prepare(instruction);
        }
        if (location !== void 0) {
            this.renderLocationProvider.prepare(location);
        }
        if (viewFactory !== void 0) {
            this.factoryProvider.prepare(viewFactory);
        }
        return this;
    }
    // #endregion
    // #region IComponentFactory api
    createComponent(resourceKey) {
        return this.container.get(resourceKey);
    }
    render(flags, controller, targets, definition, host) {
        if (targets.length !== definition.instructions.length) {
            throw new Error(`The compiled template is not aligned with the render instructions. There are ${targets.length} targets and ${definition.instructions.length} instructions.`);
        }
        for (let i = 0; i < targets.length; ++i) {
            this.renderChildren(
            /* flags        */ flags, 
            /* instructions */ definition.instructions[i], 
            /* controller   */ controller, 
            /* target       */ targets[i]);
        }
        if (host !== void 0 && host !== null) {
            this.renderChildren(
            /* flags        */ flags, 
            /* instructions */ definition.surrogates, 
            /* controller   */ controller, 
            /* target       */ host);
        }
    }
    renderChildren(flags, instructions, controller, target) {
        for (let i = 0; i < instructions.length; ++i) {
            const current = instructions[i];
            this.renderers[current.type].render(flags, this, controller, target, current);
        }
    }
    dispose() {
        this.elementProvider.dispose();
    }
    // #endregion
    // #region IProjectionProvider api
    registerProjections(projections, scope) {
        this.projectionProvider.registerProjections(projections, scope);
    }
    getProjectionFor(instruction) {
        return this.projectionProvider.getProjectionFor(instruction);
    }
}
/** @internal */
class ViewFactoryProvider {
    constructor() {
        this.factory = null;
    }
    prepare(factory) {
        this.factory = factory;
    }
    get $isResolver() { return true; }
    resolve(_handler, _requestor) {
        const factory = this.factory;
        if (factory === null) {
            throw new Error('Cannot resolve ViewFactory before the provider was prepared.');
        }
        if (typeof factory.name !== 'string' || factory.name.length === 0) {
            throw new Error('Cannot resolve ViewFactory without a (valid) name.');
        }
        return factory;
    }
    dispose() {
        this.factory = null;
    }
}
//# sourceMappingURL=render-context.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cssModules": () => /* binding */ cssModules,
/* harmony export */   "CSSModulesProcessorRegistry": () => /* binding */ CSSModulesProcessorRegistry,
/* harmony export */   "shadowCSS": () => /* binding */ shadowCSS,
/* harmony export */   "IShadowDOMStyleFactory": () => /* binding */ IShadowDOMStyleFactory,
/* harmony export */   "ShadowDOMRegistry": () => /* binding */ ShadowDOMRegistry,
/* harmony export */   "IShadowDOMStyles": () => /* binding */ IShadowDOMStyles,
/* harmony export */   "IShadowDOMGlobalStyles": () => /* binding */ IShadowDOMGlobalStyles,
/* harmony export */   "AdoptedStyleSheetsStyles": () => /* binding */ AdoptedStyleSheetsStyles,
/* harmony export */   "StyleElementStyles": () => /* binding */ StyleElementStyles,
/* harmony export */   "StyleConfiguration": () => /* binding */ StyleConfiguration
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _app_task_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app-task.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observation/class-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






function cssModules(...modules) {
    return new CSSModulesProcessorRegistry(modules);
}
class CSSModulesProcessorRegistry {
    constructor(modules) {
        this.modules = modules;
    }
    register(container) {
        var _a;
        const classLookup = Object.assign({}, ...this.modules);
        const ClassCustomAttribute = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttribute.define({
            name: 'class',
            bindables: ['value'],
        }, (_a = class CustomAttributeClass {
                constructor(element) {
                    this.element = element;
                }
                binding() {
                    this.valueChanged();
                }
                valueChanged() {
                    if (!this.value) {
                        this.element.className = '';
                        return;
                    }
                    this.element.className = (0,_observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_3__.getClassesToAdd)(this.value).map(x => classLookup[x] || x).join(' ');
                }
            },
            _a.inject = [_dom_js__WEBPACK_IMPORTED_MODULE_2__.INode],
            _a));
        container.register(ClassCustomAttribute);
    }
}
function shadowCSS(...css) {
    return new ShadowDOMRegistry(css);
}
const IShadowDOMStyleFactory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IShadowDOMStyleFactory', x => x.cachedCallback(handler => {
    if (AdoptedStyleSheetsStyles.supported(handler.get(_platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform))) {
        return handler.get(AdoptedStyleSheetsStylesFactory);
    }
    return handler.get(StyleElementStylesFactory);
}));
class ShadowDOMRegistry {
    constructor(css) {
        this.css = css;
    }
    register(container) {
        const sharedStyles = container.get(IShadowDOMGlobalStyles);
        const factory = container.get(IShadowDOMStyleFactory);
        container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IShadowDOMStyles, factory.createStyles(this.css, sharedStyles)));
    }
}
let AdoptedStyleSheetsStylesFactory = class AdoptedStyleSheetsStylesFactory {
    constructor(p) {
        this.p = p;
        this.cache = new Map();
    }
    createStyles(localStyles, sharedStyles) {
        return new AdoptedStyleSheetsStyles(this.p, localStyles, this.cache, sharedStyles);
    }
};
AdoptedStyleSheetsStylesFactory = __decorate([
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform)
], AdoptedStyleSheetsStylesFactory);
let StyleElementStylesFactory = class StyleElementStylesFactory {
    constructor(p) {
        this.p = p;
    }
    createStyles(localStyles, sharedStyles) {
        return new StyleElementStyles(this.p, localStyles, sharedStyles);
    }
};
StyleElementStylesFactory = __decorate([
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform)
], StyleElementStylesFactory);
const IShadowDOMStyles = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IShadowDOMStyles');
const IShadowDOMGlobalStyles = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IShadowDOMGlobalStyles', x => x.instance({ applyTo: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop }));
class AdoptedStyleSheetsStyles {
    constructor(p, localStyles, styleSheetCache, sharedStyles = null) {
        this.sharedStyles = sharedStyles;
        this.styleSheets = localStyles.map(x => {
            let sheet;
            if (x instanceof p.CSSStyleSheet) {
                sheet = x;
            }
            else {
                sheet = styleSheetCache.get(x);
                if (sheet === void 0) {
                    sheet = new p.CSSStyleSheet();
                    sheet.replaceSync(x);
                    styleSheetCache.set(x, sheet);
                }
            }
            return sheet;
        });
    }
    static supported(p) {
        return 'adoptedStyleSheets' in p.ShadowRoot.prototype;
    }
    applyTo(shadowRoot) {
        if (this.sharedStyles !== null) {
            this.sharedStyles.applyTo(shadowRoot);
        }
        // https://wicg.github.io/construct-stylesheets/
        // https://developers.google.com/web/updates/2019/02/constructable-stylesheets
        shadowRoot.adoptedStyleSheets = [
            ...shadowRoot.adoptedStyleSheets,
            ...this.styleSheets
        ];
    }
}
class StyleElementStyles {
    constructor(p, localStyles, sharedStyles = null) {
        this.p = p;
        this.localStyles = localStyles;
        this.sharedStyles = sharedStyles;
    }
    applyTo(shadowRoot) {
        const styles = this.localStyles;
        const p = this.p;
        for (let i = styles.length - 1; i > -1; --i) {
            const element = p.document.createElement('style');
            element.innerHTML = styles[i];
            shadowRoot.prepend(element);
        }
        if (this.sharedStyles !== null) {
            this.sharedStyles.applyTo(shadowRoot);
        }
    }
}
const StyleConfiguration = {
    shadowDOM(config) {
        return _app_task_js__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer).beforeCreate().call(container => {
            if (config.sharedStyles != null) {
                const factory = container.get(IShadowDOMStyleFactory);
                container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IShadowDOMGlobalStyles, factory.createStyles(config.sharedStyles, null)));
            }
        });
    }
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IViewFactory": () => /* binding */ IViewFactory,
/* harmony export */   "ViewFactory": () => /* binding */ ViewFactory,
/* harmony export */   "Views": () => /* binding */ Views,
/* harmony export */   "view": () => /* binding */ view,
/* harmony export */   "IViewLocator": () => /* binding */ IViewLocator,
/* harmony export */   "ViewLocator": () => /* binding */ ViewLocator
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _controller_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");




const IViewFactory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IViewFactory');
class ViewFactory {
    constructor(name, context, contentType, projectionScope = null) {
        this.name = name;
        this.context = context;
        this.contentType = contentType;
        this.projectionScope = projectionScope;
        this.isCaching = false;
        this.cache = null;
        this.cacheSize = -1;
    }
    setCacheSize(size, doNotOverrideIfAlreadySet) {
        if (size) {
            if (size === '*') {
                size = ViewFactory.maxCacheSize;
            }
            else if (typeof size === 'string') {
                size = parseInt(size, 10);
            }
            if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
                this.cacheSize = size;
            }
        }
        if (this.cacheSize > 0) {
            this.cache = [];
        }
        else {
            this.cache = null;
        }
        this.isCaching = this.cacheSize > 0;
    }
    canReturnToCache(controller) {
        return this.cache != null && this.cache.length < this.cacheSize;
    }
    tryReturnToCache(controller) {
        if (this.canReturnToCache(controller)) {
            this.cache.push(controller);
            return true;
        }
        return false;
    }
    create(flags, parentController) {
        const cache = this.cache;
        let controller;
        if (cache != null && cache.length > 0) {
            controller = cache.pop();
            return controller;
        }
        controller = _controller_js__WEBPACK_IMPORTED_MODULE_3__.Controller.forSyntheticView(null, this.context, this, flags, parentController);
        return controller;
    }
}
ViewFactory.maxCacheSize = 0xFFFF;
const seenViews = new WeakSet();
function notYetSeen($view) {
    return !seenViews.has($view);
}
function toCustomElementDefinition($view) {
    seenViews.add($view);
    return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElementDefinition.create($view);
}
const Views = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('views'),
    has(value) {
        return typeof value === 'function' && (_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(Views.name, value) || '$views' in value);
    },
    get(value) {
        if (typeof value === 'function' && '$views' in value) {
            // TODO: a `get` operation with side effects is not a good thing. Should refactor this to a proper resource kind.
            const $views = value.$views;
            const definitions = $views.filter(notYetSeen).map(toCustomElementDefinition);
            for (const def of definitions) {
                Views.add(value, def);
            }
        }
        let views = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Views.name, value);
        if (views === void 0) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Views.name, views = [], value);
        }
        return views;
    },
    add(Type, partialDefinition) {
        const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElementDefinition.create(partialDefinition);
        let views = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Views.name, Type);
        if (views === void 0) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Views.name, views = [definition], Type);
        }
        else {
            views.push(definition);
        }
        return views;
    },
};
function view(v) {
    return function (target) {
        Views.add(target, v);
    };
}
const IViewLocator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IViewLocator', x => x.singleton(ViewLocator));
class ViewLocator {
    constructor() {
        this.modelInstanceToBoundComponent = new WeakMap();
        this.modelTypeToUnboundComponent = new Map();
    }
    getViewComponentForObject(object, viewNameOrSelector) {
        if (object) {
            const availableViews = Views.has(object.constructor) ? Views.get(object.constructor) : [];
            const resolvedViewName = typeof viewNameOrSelector === 'function'
                ? viewNameOrSelector(object, availableViews)
                : this.getViewName(availableViews, viewNameOrSelector);
            return this.getOrCreateBoundComponent(object, availableViews, resolvedViewName);
        }
        return null;
    }
    getOrCreateBoundComponent(object, availableViews, resolvedViewName) {
        let lookup = this.modelInstanceToBoundComponent.get(object);
        let BoundComponent;
        if (lookup === void 0) {
            lookup = {};
            this.modelInstanceToBoundComponent.set(object, lookup);
        }
        else {
            BoundComponent = lookup[resolvedViewName];
        }
        if (BoundComponent === void 0) {
            const UnboundComponent = this.getOrCreateUnboundComponent(object, availableViews, resolvedViewName);
            BoundComponent = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.getDefinition(UnboundComponent), class extends UnboundComponent {
                constructor() {
                    super(object);
                }
            });
            lookup[resolvedViewName] = BoundComponent;
        }
        return BoundComponent;
    }
    getOrCreateUnboundComponent(object, availableViews, resolvedViewName) {
        let lookup = this.modelTypeToUnboundComponent.get(object.constructor);
        let UnboundComponent;
        if (lookup === void 0) {
            lookup = {};
            this.modelTypeToUnboundComponent.set(object.constructor, lookup);
        }
        else {
            UnboundComponent = lookup[resolvedViewName];
        }
        if (UnboundComponent === void 0) {
            UnboundComponent = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.define(this.getView(availableViews, resolvedViewName), class {
                constructor(viewModel) {
                    this.viewModel = viewModel;
                }
                define(controller, parentContainer, definition) {
                    const vm = this.viewModel;
                    controller.scope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent(controller.scope, vm);
                    if (vm.define !== void 0) {
                        return vm.define(controller, parentContainer, definition);
                    }
                }
            });
            const proto = UnboundComponent.prototype;
            if ('hydrating' in object) {
                proto.hydrating = function hydrating(controller) {
                    this.viewModel.hydrating(controller);
                };
            }
            if ('hydrated' in object) {
                proto.hydrated = function hydrated(controller) {
                    this.viewModel.hydrated(controller);
                };
            }
            if ('created' in object) {
                proto.created = function created(controller) {
                    this.viewModel.created(controller);
                };
            }
            if ('binding' in object) {
                proto.binding = function binding(initiator, parent, flags) {
                    return this.viewModel.binding(initiator, parent, flags);
                };
            }
            if ('bound' in object) {
                proto.bound = function bound(initiator, parent, flags) {
                    return this.viewModel.bound(initiator, parent, flags);
                };
            }
            if ('attaching' in object) {
                proto.attaching = function attaching(initiator, parent, flags) {
                    return this.viewModel.attaching(initiator, parent, flags);
                };
            }
            if ('attached' in object) {
                proto.attached = function attached(initiator, flags) {
                    return this.viewModel.attached(initiator, flags);
                };
            }
            if ('detaching' in object) {
                proto.detaching = function detaching(initiator, parent, flags) {
                    return this.viewModel.detaching(initiator, parent, flags);
                };
            }
            if ('unbinding' in object) {
                proto.unbinding = function unbinding(initiator, parent, flags) {
                    return this.viewModel.unbinding(initiator, parent, flags);
                };
            }
            if ('dispose' in object) {
                proto.dispose = function dispose() {
                    this.viewModel.dispose();
                };
            }
            lookup[resolvedViewName] = UnboundComponent;
        }
        return UnboundComponent;
    }
    getViewName(views, requestedName) {
        if (requestedName) {
            return requestedName;
        }
        if (views.length === 1) {
            return views[0].name;
        }
        return 'default-view';
    }
    getView(views, name) {
        const v = views.find(x => x.name === name);
        if (v === void 0) {
            throw new Error(`Could not find view: ${name}`);
        }
        return v;
    }
}
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComputedWatcher": () => /* binding */ ComputedWatcher,
/* harmony export */   "ExpressionWatcher": () => /* binding */ ExpressionWatcher
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

const { enter, exit } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.ConnectableSwitcher;
const { wrap, unwrap } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.ProxyObservable;
class ComputedWatcher {
    constructor(obj, observerLocator, get, cb, useProxy) {
        this.obj = obj;
        this.observerLocator = observerLocator;
        this.get = get;
        this.cb = cb;
        this.useProxy = useProxy;
        this.interceptor = this;
        this.value = void 0;
        this.isBound = false;
        // todo: maybe use a counter allow recursive call to a certain level
        this.running = false;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    handleChange() {
        this.run();
    }
    handleCollectionChange() {
        this.run();
    }
    $bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        this.compute();
    }
    $unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.obs.clear(true);
    }
    run() {
        if (!this.isBound || this.running) {
            return;
        }
        const obj = this.obj;
        const oldValue = this.value;
        const newValue = this.compute();
        if (!Object.is(newValue, oldValue)) {
            // should optionally queue
            this.cb.call(obj, newValue, oldValue, obj);
        }
    }
    compute() {
        this.running = true;
        this.obs.version++;
        try {
            enter(this);
            return this.value = unwrap(this.get.call(void 0, this.useProxy ? wrap(this.obj) : this.obj, this));
        }
        finally {
            this.obs.clear(false);
            this.running = false;
            exit(this);
        }
    }
}
class ExpressionWatcher {
    constructor(scope, locator, observerLocator, expression, callback) {
        this.scope = scope;
        this.locator = locator;
        this.observerLocator = observerLocator;
        this.expression = expression;
        this.callback = callback;
        this.interceptor = this;
        this.isBound = false;
        this.obj = scope.bindingContext;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    handleChange(value) {
        const expr = this.expression;
        const obj = this.obj;
        const oldValue = this.value;
        const canOptimize = expr.$kind === 10082 /* AccessScope */ && this.obs.count === 1;
        if (!canOptimize) {
            this.obs.version++;
            value = expr.evaluate(0, this.scope, null, this.locator, this);
            this.obs.clear(false);
        }
        if (!Object.is(value, oldValue)) {
            this.value = value;
            // should optionally queue for batch synchronous
            this.callback.call(obj, value, oldValue, obj);
        }
    }
    $bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        this.obs.version++;
        this.value = this.expression.evaluate(0 /* none */, this.scope, null, this.locator, this);
        this.obs.clear(false);
    }
    $unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.obs.clear(true);
        this.value = void 0;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(ComputedWatcher);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(ExpressionWatcher);
//# sourceMappingURL=watchers.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/watch.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "watch": () => /* binding */ watch,
/* harmony export */   "Watch": () => /* binding */ Watch
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

function watch(expressionOrPropertyAccessFn, changeHandlerOrCallback) {
    if (!expressionOrPropertyAccessFn) {
        throw new Error('Invalid watch config. Expected an expression or a fn');
    }
    return function decorator(target, key, descriptor) {
        const isClassDecorator = key == null;
        const Type = isClassDecorator ? target : target.constructor;
        // basic validation
        if (isClassDecorator) {
            if (typeof changeHandlerOrCallback !== 'function'
                && (changeHandlerOrCallback == null || !(changeHandlerOrCallback in Type.prototype))) {
                throw new Error(`Invalid change handler config. Method "${String(changeHandlerOrCallback)}" not found in class ${Type.name}`);
            }
        }
        else if (typeof descriptor?.value !== 'function') {
            throw new Error(`decorated target ${String(key)} is not a class method.`);
        }
        Watch.add(Type, new WatchDefinition(expressionOrPropertyAccessFn, isClassDecorator ? changeHandlerOrCallback : descriptor.value));
    };
}
class WatchDefinition {
    constructor(expression, callback) {
        this.expression = expression;
        this.callback = callback;
    }
}
const noDefinitions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
const Watch = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('watch'),
    add(Type, definition) {
        let watchDefinitions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Watch.name, Type);
        if (watchDefinitions == null) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Watch.name, watchDefinitions = [], Type);
        }
        watchDefinitions.push(definition);
    },
    getAnnotation(Type) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Watch.name, Type) ?? noDefinitions;
    },
};
//# sourceMappingURL=watch.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/alias.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/alias.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alias": () => /* binding */ alias,
/* harmony export */   "registerAliases": () => /* binding */ registerAliases
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

function alias(...aliases) {
    return function (target) {
        const key = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('aliases');
        const existing = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, target);
        if (existing === void 0) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, aliases, target);
        }
        else {
            existing.push(...aliases);
        }
    };
}
function registerAliases(aliases, resource, key, container) {
    for (let i = 0, ii = aliases.length; i < ii; ++i) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, resource.keyFrom(aliases[i])).register(container);
    }
}
//# sourceMappingURL=alias.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingBehaviorStrategy": () => /* binding */ BindingBehaviorStrategy,
/* harmony export */   "bindingBehavior": () => /* binding */ bindingBehavior,
/* harmony export */   "BindingBehaviorDefinition": () => /* binding */ BindingBehaviorDefinition,
/* harmony export */   "BindingBehaviorFactory": () => /* binding */ BindingBehaviorFactory,
/* harmony export */   "BindingInterceptor": () => /* binding */ BindingInterceptor,
/* harmony export */   "BindingBehavior": () => /* binding */ BindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _alias_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alias.js */ "./node_modules/@aurelia/runtime/dist/esm/alias.js");


var BindingBehaviorStrategy;
(function (BindingBehaviorStrategy) {
    BindingBehaviorStrategy[BindingBehaviorStrategy["singleton"] = 1] = "singleton";
    BindingBehaviorStrategy[BindingBehaviorStrategy["interceptor"] = 2] = "interceptor";
})(BindingBehaviorStrategy || (BindingBehaviorStrategy = {}));
function bindingBehavior(nameOrDef) {
    return function (target) {
        return BindingBehavior.define(nameOrDef, target);
    };
}
class BindingBehaviorDefinition {
    constructor(Type, name, aliases, key, strategy) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.strategy = strategy;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        const inheritsFromInterceptor = Object.getPrototypeOf(Type) === BindingInterceptor;
        return new BindingBehaviorDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(BindingBehavior.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(BindingBehavior.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), BindingBehavior.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('strategy', def, Type, () => inheritsFromInterceptor ? 2 /* interceptor */ : 1 /* singleton */));
    }
    register(container) {
        const { Type, key, aliases, strategy } = this;
        switch (strategy) {
            case 1 /* singleton */:
                _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(key, Type).register(container);
                break;
            case 2 /* interceptor */:
                _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(key, new BindingBehaviorFactory(container, Type)).register(container);
                break;
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_alias_js__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, BindingBehavior, key, container);
    }
}
class BindingBehaviorFactory {
    constructor(container, Type) {
        this.container = container;
        this.Type = Type;
        this.deps = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.getDependencies(Type);
    }
    construct(binding, expr) {
        const container = this.container;
        const deps = this.deps;
        switch (deps.length) {
            case 0:
            case 1:
            case 2:
                // TODO(fkleuver): fix this cast
                return new this.Type(binding, expr);
            case 3:
                return new this.Type(container.get(deps[0]), binding, expr);
            case 4:
                return new this.Type(container.get(deps[0]), container.get(deps[1]), binding, expr);
            default:
                return new this.Type(...deps.map(d => container.get(d)), binding, expr);
        }
    }
}
class BindingInterceptor {
    constructor(binding, expr) {
        this.binding = binding;
        this.expr = expr;
        this.interceptor = this;
        let interceptor;
        while (binding.interceptor !== this) {
            interceptor = binding.interceptor;
            binding.interceptor = this;
            binding = interceptor;
        }
    }
    get id() {
        return this.binding.id;
    }
    get observerLocator() {
        return this.binding.observerLocator;
    }
    get locator() {
        return this.binding.locator;
    }
    get $scope() {
        return this.binding.$scope;
    }
    get $hostScope() {
        return this.binding.$hostScope;
    }
    get isBound() {
        return this.binding.isBound;
    }
    get obs() {
        return this.binding.obs;
    }
    updateTarget(value, flags) {
        this.binding.updateTarget(value, flags);
    }
    updateSource(value, flags) {
        this.binding.updateSource(value, flags);
    }
    callSource(args) {
        return this.binding.callSource(args);
    }
    handleChange(newValue, previousValue, flags) {
        this.binding.handleChange(newValue, previousValue, flags);
    }
    handleCollectionChange(indexMap, flags) {
        this.binding.handleCollectionChange(indexMap, flags);
    }
    observeProperty(obj, key) {
        this.binding.observeProperty(obj, key);
    }
    observeCollection(observer) {
        this.binding.observeCollection(observer);
    }
    $bind(flags, scope, hostScope) {
        this.binding.$bind(flags, scope, hostScope);
    }
    $unbind(flags) {
        this.binding.$unbind(flags);
    }
}
const BindingBehavior = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('binding-behavior'),
    keyFrom(name) {
        return `${BindingBehavior.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(BindingBehavior.name, value);
    },
    define(nameOrDef, Type) {
        const definition = BindingBehaviorDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingBehavior.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingBehavior.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, BindingBehavior.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(BindingBehavior.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
//# sourceMappingURL=binding-behavior.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding/ast.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding/ast.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExpressionKind": () => /* binding */ ExpressionKind,
/* harmony export */   "Unparser": () => /* binding */ Unparser,
/* harmony export */   "CustomExpression": () => /* binding */ CustomExpression,
/* harmony export */   "BindingBehaviorExpression": () => /* binding */ BindingBehaviorExpression,
/* harmony export */   "ValueConverterExpression": () => /* binding */ ValueConverterExpression,
/* harmony export */   "AssignExpression": () => /* binding */ AssignExpression,
/* harmony export */   "ConditionalExpression": () => /* binding */ ConditionalExpression,
/* harmony export */   "AccessThisExpression": () => /* binding */ AccessThisExpression,
/* harmony export */   "AccessScopeExpression": () => /* binding */ AccessScopeExpression,
/* harmony export */   "AccessMemberExpression": () => /* binding */ AccessMemberExpression,
/* harmony export */   "AccessKeyedExpression": () => /* binding */ AccessKeyedExpression,
/* harmony export */   "CallScopeExpression": () => /* binding */ CallScopeExpression,
/* harmony export */   "CallMemberExpression": () => /* binding */ CallMemberExpression,
/* harmony export */   "CallFunctionExpression": () => /* binding */ CallFunctionExpression,
/* harmony export */   "BinaryExpression": () => /* binding */ BinaryExpression,
/* harmony export */   "UnaryExpression": () => /* binding */ UnaryExpression,
/* harmony export */   "PrimitiveLiteralExpression": () => /* binding */ PrimitiveLiteralExpression,
/* harmony export */   "HtmlLiteralExpression": () => /* binding */ HtmlLiteralExpression,
/* harmony export */   "ArrayLiteralExpression": () => /* binding */ ArrayLiteralExpression,
/* harmony export */   "ObjectLiteralExpression": () => /* binding */ ObjectLiteralExpression,
/* harmony export */   "TemplateExpression": () => /* binding */ TemplateExpression,
/* harmony export */   "TaggedTemplateExpression": () => /* binding */ TaggedTemplateExpression,
/* harmony export */   "ArrayBindingPattern": () => /* binding */ ArrayBindingPattern,
/* harmony export */   "ObjectBindingPattern": () => /* binding */ ObjectBindingPattern,
/* harmony export */   "BindingIdentifier": () => /* binding */ BindingIdentifier,
/* harmony export */   "ForOfStatement": () => /* binding */ ForOfStatement,
/* harmony export */   "Interpolation": () => /* binding */ Interpolation
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/binding-context.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js");
/* harmony import */ var _observation_signaler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observation/signaler.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js");
/* harmony import */ var _binding_behavior_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../binding-behavior.js */ "./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js");
/* harmony import */ var _value_converter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../value-converter.js */ "./node_modules/@aurelia/runtime/dist/esm/value-converter.js");
/* eslint-disable eqeqeq */
/* eslint-disable @typescript-eslint/restrict-template-expressions */





var ExpressionKind;
(function (ExpressionKind) {
    ExpressionKind[ExpressionKind["Connects"] = 32] = "Connects";
    ExpressionKind[ExpressionKind["Observes"] = 64] = "Observes";
    ExpressionKind[ExpressionKind["CallsFunction"] = 128] = "CallsFunction";
    ExpressionKind[ExpressionKind["HasAncestor"] = 256] = "HasAncestor";
    ExpressionKind[ExpressionKind["IsPrimary"] = 512] = "IsPrimary";
    ExpressionKind[ExpressionKind["IsLeftHandSide"] = 1024] = "IsLeftHandSide";
    ExpressionKind[ExpressionKind["HasBind"] = 2048] = "HasBind";
    ExpressionKind[ExpressionKind["HasUnbind"] = 4096] = "HasUnbind";
    ExpressionKind[ExpressionKind["IsAssignable"] = 8192] = "IsAssignable";
    ExpressionKind[ExpressionKind["IsLiteral"] = 16384] = "IsLiteral";
    ExpressionKind[ExpressionKind["IsResource"] = 32768] = "IsResource";
    ExpressionKind[ExpressionKind["IsForDeclaration"] = 65536] = "IsForDeclaration";
    ExpressionKind[ExpressionKind["Type"] = 31] = "Type";
    // ---------------------------------------------------------------------------------------------------------------------------
    ExpressionKind[ExpressionKind["AccessThis"] = 1793] = "AccessThis";
    ExpressionKind[ExpressionKind["AccessScope"] = 10082] = "AccessScope";
    ExpressionKind[ExpressionKind["ArrayLiteral"] = 17955] = "ArrayLiteral";
    ExpressionKind[ExpressionKind["ObjectLiteral"] = 17956] = "ObjectLiteral";
    ExpressionKind[ExpressionKind["PrimitiveLiteral"] = 17925] = "PrimitiveLiteral";
    ExpressionKind[ExpressionKind["Template"] = 17958] = "Template";
    ExpressionKind[ExpressionKind["Unary"] = 39] = "Unary";
    ExpressionKind[ExpressionKind["CallScope"] = 1448] = "CallScope";
    ExpressionKind[ExpressionKind["CallMember"] = 1161] = "CallMember";
    ExpressionKind[ExpressionKind["CallFunction"] = 1162] = "CallFunction";
    ExpressionKind[ExpressionKind["AccessMember"] = 9323] = "AccessMember";
    ExpressionKind[ExpressionKind["AccessKeyed"] = 9324] = "AccessKeyed";
    ExpressionKind[ExpressionKind["TaggedTemplate"] = 1197] = "TaggedTemplate";
    ExpressionKind[ExpressionKind["Binary"] = 46] = "Binary";
    ExpressionKind[ExpressionKind["Conditional"] = 63] = "Conditional";
    ExpressionKind[ExpressionKind["Assign"] = 8208] = "Assign";
    ExpressionKind[ExpressionKind["ValueConverter"] = 36913] = "ValueConverter";
    ExpressionKind[ExpressionKind["BindingBehavior"] = 38962] = "BindingBehavior";
    ExpressionKind[ExpressionKind["HtmlLiteral"] = 51] = "HtmlLiteral";
    ExpressionKind[ExpressionKind["ArrayBindingPattern"] = 65556] = "ArrayBindingPattern";
    ExpressionKind[ExpressionKind["ObjectBindingPattern"] = 65557] = "ObjectBindingPattern";
    ExpressionKind[ExpressionKind["BindingIdentifier"] = 65558] = "BindingIdentifier";
    ExpressionKind[ExpressionKind["ForOfStatement"] = 6199] = "ForOfStatement";
    ExpressionKind[ExpressionKind["Interpolation"] = 24] = "Interpolation"; //
})(ExpressionKind || (ExpressionKind = {}));
class Unparser {
    constructor() {
        this.text = '';
    }
    static unparse(expr) {
        const visitor = new Unparser();
        expr.accept(visitor);
        return visitor.text;
    }
    visitAccessMember(expr) {
        expr.object.accept(this);
        this.text += `.${expr.name}`;
    }
    visitAccessKeyed(expr) {
        expr.object.accept(this);
        this.text += '[';
        expr.key.accept(this);
        this.text += ']';
    }
    visitAccessThis(expr) {
        if (expr.ancestor === 0) {
            this.text += '$this';
            return;
        }
        this.text += '$parent';
        let i = expr.ancestor - 1;
        while (i--) {
            this.text += '.$parent';
        }
    }
    visitAccessScope(expr) {
        let i = expr.ancestor;
        while (i--) {
            this.text += '$parent.';
        }
        this.text += expr.name;
    }
    visitArrayLiteral(expr) {
        const elements = expr.elements;
        this.text += '[';
        for (let i = 0, length = elements.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            elements[i].accept(this);
        }
        this.text += ']';
    }
    visitObjectLiteral(expr) {
        const keys = expr.keys;
        const values = expr.values;
        this.text += '{';
        for (let i = 0, length = keys.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            this.text += `'${keys[i]}':`;
            values[i].accept(this);
        }
        this.text += '}';
    }
    visitPrimitiveLiteral(expr) {
        this.text += '(';
        if (typeof expr.value === 'string') {
            const escaped = expr.value.replace(/'/g, '\\\'');
            this.text += `'${escaped}'`;
        }
        else {
            this.text += `${expr.value}`;
        }
        this.text += ')';
    }
    visitCallFunction(expr) {
        this.text += '(';
        expr.func.accept(this);
        this.writeArgs(expr.args);
        this.text += ')';
    }
    visitCallMember(expr) {
        this.text += '(';
        expr.object.accept(this);
        this.text += `.${expr.name}`;
        this.writeArgs(expr.args);
        this.text += ')';
    }
    visitCallScope(expr) {
        this.text += '(';
        let i = expr.ancestor;
        while (i--) {
            this.text += '$parent.';
        }
        this.text += expr.name;
        this.writeArgs(expr.args);
        this.text += ')';
    }
    visitTemplate(expr) {
        const { cooked, expressions } = expr;
        const length = expressions.length;
        this.text += '`';
        this.text += cooked[0];
        for (let i = 0; i < length; i++) {
            expressions[i].accept(this);
            this.text += cooked[i + 1];
        }
        this.text += '`';
    }
    visitTaggedTemplate(expr) {
        const { cooked, expressions } = expr;
        const length = expressions.length;
        expr.func.accept(this);
        this.text += '`';
        this.text += cooked[0];
        for (let i = 0; i < length; i++) {
            expressions[i].accept(this);
            this.text += cooked[i + 1];
        }
        this.text += '`';
    }
    visitUnary(expr) {
        this.text += `(${expr.operation}`;
        if (expr.operation.charCodeAt(0) >= /* a */ 97) {
            this.text += ' ';
        }
        expr.expression.accept(this);
        this.text += ')';
    }
    visitBinary(expr) {
        this.text += '(';
        expr.left.accept(this);
        if (expr.operation.charCodeAt(0) === /* i */ 105) {
            this.text += ` ${expr.operation} `;
        }
        else {
            this.text += expr.operation;
        }
        expr.right.accept(this);
        this.text += ')';
    }
    visitConditional(expr) {
        this.text += '(';
        expr.condition.accept(this);
        this.text += '?';
        expr.yes.accept(this);
        this.text += ':';
        expr.no.accept(this);
        this.text += ')';
    }
    visitAssign(expr) {
        this.text += '(';
        expr.target.accept(this);
        this.text += '=';
        expr.value.accept(this);
        this.text += ')';
    }
    visitValueConverter(expr) {
        const args = expr.args;
        expr.expression.accept(this);
        this.text += `|${expr.name}`;
        for (let i = 0, length = args.length; i < length; ++i) {
            this.text += ':';
            args[i].accept(this);
        }
    }
    visitBindingBehavior(expr) {
        const args = expr.args;
        expr.expression.accept(this);
        this.text += `&${expr.name}`;
        for (let i = 0, length = args.length; i < length; ++i) {
            this.text += ':';
            args[i].accept(this);
        }
    }
    visitArrayBindingPattern(expr) {
        const elements = expr.elements;
        this.text += '[';
        for (let i = 0, length = elements.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            elements[i].accept(this);
        }
        this.text += ']';
    }
    visitObjectBindingPattern(expr) {
        const keys = expr.keys;
        const values = expr.values;
        this.text += '{';
        for (let i = 0, length = keys.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            this.text += `'${keys[i]}':`;
            values[i].accept(this);
        }
        this.text += '}';
    }
    visitBindingIdentifier(expr) {
        this.text += expr.name;
    }
    visitHtmlLiteral(expr) { throw new Error('visitHtmlLiteral'); }
    visitForOfStatement(expr) {
        expr.declaration.accept(this);
        this.text += ' of ';
        expr.iterable.accept(this);
    }
    visitInterpolation(expr) {
        const { parts, expressions } = expr;
        const length = expressions.length;
        this.text += '${';
        this.text += parts[0];
        for (let i = 0; i < length; i++) {
            expressions[i].accept(this);
            this.text += parts[i + 1];
        }
        this.text += '}';
    }
    writeArgs(args) {
        this.text += '(';
        for (let i = 0, length = args.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            args[i].accept(this);
        }
        this.text += ')';
    }
}
function chooseScope(accessHostScope, s, hs) {
    if (accessHostScope) {
        if (hs === null || hs === void 0) {
            throw new Error('Host scope is missing. Are you using `$host` outside the `au-slot`? Or missing the `au-slot` attribute?');
        }
        return hs;
    }
    return s;
}
class CustomExpression {
    constructor(value) {
        this.value = value;
    }
    evaluate(_f, _s, _hs, _l, _c) {
        return this.value;
    }
}
class BindingBehaviorExpression {
    constructor(expression, name, args) {
        this.expression = expression;
        this.name = name;
        this.args = args;
        this.behaviorKey = _binding_behavior_js__WEBPACK_IMPORTED_MODULE_3__.BindingBehavior.keyFrom(name);
    }
    get $kind() { return 38962 /* BindingBehavior */; }
    get hasBind() { return true; }
    get hasUnbind() { return true; }
    evaluate(f, s, hs, l, c) {
        return this.expression.evaluate(f, s, hs, l, c);
    }
    assign(f, s, hs, l, val) {
        return this.expression.assign(f, s, hs, l, val);
    }
    bind(f, s, hs, b) {
        if (this.expression.hasBind) {
            this.expression.bind(f, s, hs, b);
        }
        const behavior = b.locator.get(this.behaviorKey);
        if (behavior == null) {
            throw new Error(`BindingBehavior named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
        }
        if (!(behavior instanceof _binding_behavior_js__WEBPACK_IMPORTED_MODULE_3__.BindingBehaviorFactory)) {
            if (b[this.behaviorKey] === void 0) {
                b[this.behaviorKey] = behavior;
                behavior.bind.call(behavior, f, s, hs, b, ...this.args.map(a => a.evaluate(f, s, hs, b.locator, null)));
            }
            else {
                throw new Error(`BindingBehavior named '${this.name}' already applied.`);
            }
        }
    }
    unbind(f, s, hs, b) {
        const key = this.behaviorKey;
        const $b = b;
        if ($b[key] !== void 0) {
            if (typeof $b[key].unbind === 'function') {
                $b[key].unbind(f, s, hs, b);
            }
            $b[key] = void 0;
        }
        if (this.expression.hasUnbind) {
            this.expression.unbind(f, s, hs, b);
        }
    }
    accept(visitor) {
        return visitor.visitBindingBehavior(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ValueConverterExpression {
    constructor(expression, name, args) {
        this.expression = expression;
        this.name = name;
        this.args = args;
        this.converterKey = _value_converter_js__WEBPACK_IMPORTED_MODULE_4__.ValueConverter.keyFrom(name);
    }
    get $kind() { return 36913 /* ValueConverter */; }
    get hasBind() { return false; }
    get hasUnbind() { return true; }
    evaluate(f, s, hs, l, c) {
        const vc = l.get(this.converterKey);
        if (vc == null) {
            throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
        }
        // note: the cast is expected. To connect, it just needs to be a IConnectable
        // though to work with signal, it needs to have `handleChange`
        // so having `handleChange` as a guard in the connectable as a safe measure is needed
        // to make sure signaler works
        if (c !== null && ('handleChange' in c)) {
            const signals = vc.signals;
            if (signals != null) {
                const signaler = l.get(_observation_signaler_js__WEBPACK_IMPORTED_MODULE_2__.ISignaler);
                for (let i = 0, ii = signals.length; i < ii; ++i) {
                    signaler.addSignalListener(signals[i], c);
                }
            }
        }
        if ('toView' in vc) {
            return vc.toView(this.expression.evaluate(f, s, hs, l, c), ...this.args.map(a => a.evaluate(f, s, hs, l, c)));
        }
        return this.expression.evaluate(f, s, hs, l, c);
    }
    assign(f, s, hs, l, val) {
        const vc = l.get(this.converterKey);
        if (vc == null) {
            throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
        }
        if ('fromView' in vc) {
            val = vc.fromView(val, ...this.args.map(a => a.evaluate(f, s, hs, l, null)));
        }
        return this.expression.assign(f, s, hs, l, val);
    }
    unbind(_f, _s, _hs, b) {
        const vc = b.locator.get(this.converterKey);
        if (vc.signals === void 0) {
            return;
        }
        const signaler = b.locator.get(_observation_signaler_js__WEBPACK_IMPORTED_MODULE_2__.ISignaler);
        for (let i = 0; i < vc.signals.length; ++i) {
            // the cast is correct, as the value converter expression would only add
            // a IConnectable that also implements `ISubscriber` interface to the signaler
            signaler.removeSignalListener(vc.signals[i], b);
        }
    }
    accept(visitor) {
        return visitor.visitValueConverter(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AssignExpression {
    constructor(target, value) {
        this.target = target;
        this.value = value;
    }
    get $kind() { return 8208 /* Assign */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.target.assign(f, s, hs, l, this.value.evaluate(f, s, hs, l, c));
    }
    assign(f, s, hs, l, val) {
        this.value.assign(f, s, hs, l, val);
        return this.target.assign(f, s, hs, l, val);
    }
    accept(visitor) {
        return visitor.visitAssign(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ConditionalExpression {
    constructor(condition, yes, no) {
        this.condition = condition;
        this.yes = yes;
        this.no = no;
    }
    get $kind() { return 63 /* Conditional */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.condition.evaluate(f, s, hs, l, c) ? this.yes.evaluate(f, s, hs, l, c) : this.no.evaluate(f, s, hs, l, c);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitConditional(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AccessThisExpression {
    constructor(ancestor = 0) {
        this.ancestor = ancestor;
    }
    get $kind() { return 1793 /* AccessThis */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, s, hs, _l, _c) {
        if (this === AccessThisExpression.$host) {
            s = chooseScope(true, s, hs);
        }
        let oc = s.overrideContext;
        let currentScope = s;
        let i = this.ancestor;
        while (i-- && oc) {
            currentScope = currentScope.parentScope;
            oc = currentScope?.overrideContext ?? null;
        }
        return i < 1 && oc ? oc.bindingContext : void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitAccessThis(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
AccessThisExpression.$this = new AccessThisExpression(0);
// $host and $this are loosely the same thing. $host is used in the context of `au-slot` with the primary objective of determining the s.
AccessThisExpression.$host = new AccessThisExpression(0);
AccessThisExpression.$parent = new AccessThisExpression(1);
class AccessScopeExpression {
    constructor(name, ancestor = 0, accessHostScope = false) {
        this.name = name;
        this.ancestor = ancestor;
        this.accessHostScope = accessHostScope;
    }
    get $kind() { return 10082 /* AccessScope */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, _l, c) {
        const obj = _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__.BindingContext.get(chooseScope(this.accessHostScope, s, hs), this.name, this.ancestor, f, hs);
        if (c !== null) {
            c.observeProperty(obj, this.name);
        }
        const evaluatedValue = obj[this.name];
        if (f & 4 /* isStrictBindingStrategy */) {
            return evaluatedValue;
        }
        return evaluatedValue == null ? '' : evaluatedValue;
    }
    assign(f, s, hs, _l, val) {
        const obj = _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__.BindingContext.get(chooseScope(this.accessHostScope, s, hs), this.name, this.ancestor, f, hs);
        if (obj instanceof Object) {
            if (obj.$observers?.[this.name] !== void 0) {
                obj.$observers[this.name].setValue(val, f);
                return val;
            }
            else {
                return obj[this.name] = val;
            }
        }
        return void 0;
    }
    accept(visitor) {
        return visitor.visitAccessScope(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AccessMemberExpression {
    constructor(object, name) {
        this.object = object;
        this.name = name;
    }
    get $kind() { return 9323 /* AccessMember */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = this.object.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
        if (f & 4 /* isStrictBindingStrategy */) {
            if (instance == null) {
                return instance;
            }
            if (c !== null) {
                c.observeProperty(instance, this.name);
            }
            return instance[this.name];
        }
        if (c !== null && instance instanceof Object) {
            c.observeProperty(instance, this.name);
        }
        return instance ? instance[this.name] : '';
    }
    assign(f, s, hs, l, val) {
        const obj = this.object.evaluate(f, s, hs, l, null);
        if (obj instanceof Object) {
            if (obj.$observers !== void 0 && obj.$observers[this.name] !== void 0) {
                obj.$observers[this.name].setValue(val, f);
            }
            else {
                obj[this.name] = val;
            }
        }
        else {
            this.object.assign(f, s, hs, l, { [this.name]: val });
        }
        return val;
    }
    accept(visitor) {
        return visitor.visitAccessMember(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AccessKeyedExpression {
    constructor(object, key) {
        this.object = object;
        this.key = key;
    }
    get $kind() { return 9324 /* AccessKeyed */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = this.object.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
        if (instance instanceof Object) {
            const key = this.key.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
            if (c !== null) {
                c.observeProperty(instance, key);
            }
            return instance[key];
        }
        return void 0;
    }
    assign(f, s, hs, l, val) {
        const instance = this.object.evaluate(f, s, hs, l, null);
        const key = this.key.evaluate(f, s, hs, l, null);
        return instance[key] = val;
    }
    accept(visitor) {
        return visitor.visitAccessKeyed(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class CallScopeExpression {
    constructor(name, args, ancestor = 0, accessHostScope = false) {
        this.name = name;
        this.args = args;
        this.ancestor = ancestor;
        this.accessHostScope = accessHostScope;
    }
    get $kind() { return 1448 /* CallScope */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        s = chooseScope(this.accessHostScope, s, hs);
        const args = this.args.map(a => a.evaluate(f, s, hs, l, c));
        const context = _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__.BindingContext.get(s, this.name, this.ancestor, f, hs);
        // ideally, should observe property represents by this.name as well
        // because it could be changed
        // todo: did it ever surprise anyone?
        const func = getFunction(f, context, this.name);
        if (func) {
            return func.apply(context, args);
        }
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitCallScope(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class CallMemberExpression {
    constructor(object, name, args) {
        this.object = object;
        this.name = name;
        this.args = args;
    }
    get $kind() { return 1161 /* CallMember */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = this.object.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
        const args = this.args.map(a => a.evaluate(f, s, hs, l, c));
        const func = getFunction(f, instance, this.name);
        if (func) {
            return func.apply(instance, args);
        }
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitCallMember(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class CallFunctionExpression {
    constructor(func, args) {
        this.func = func;
        this.args = args;
    }
    get $kind() { return 1162 /* CallFunction */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const func = this.func.evaluate(f, s, hs, l, c);
        if (typeof func === 'function') {
            return func(...this.args.map(a => a.evaluate(f, s, hs, l, c)));
        }
        if (!(f & 128 /* mustEvaluate */) && (func == null)) {
            return void 0;
        }
        throw new Error(`Expression is not a function.`);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitCallFunction(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class BinaryExpression {
    constructor(operation, left, right) {
        this.operation = operation;
        this.left = left;
        this.right = right;
    }
    get $kind() { return 46 /* Binary */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        switch (this.operation) {
            case '&&':
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                return this.left.evaluate(f, s, hs, l, c) && this.right.evaluate(f, s, hs, l, c);
            case '||':
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                return this.left.evaluate(f, s, hs, l, c) || this.right.evaluate(f, s, hs, l, c);
            case '==':
                return this.left.evaluate(f, s, hs, l, c) == this.right.evaluate(f, s, hs, l, c);
            case '===':
                return this.left.evaluate(f, s, hs, l, c) === this.right.evaluate(f, s, hs, l, c);
            case '!=':
                return this.left.evaluate(f, s, hs, l, c) != this.right.evaluate(f, s, hs, l, c);
            case '!==':
                return this.left.evaluate(f, s, hs, l, c) !== this.right.evaluate(f, s, hs, l, c);
            case 'instanceof': {
                const right = this.right.evaluate(f, s, hs, l, c);
                if (typeof right === 'function') {
                    return this.left.evaluate(f, s, hs, l, c) instanceof right;
                }
                return false;
            }
            case 'in': {
                const right = this.right.evaluate(f, s, hs, l, c);
                if (right instanceof Object) {
                    return this.left.evaluate(f, s, hs, l, c) in right;
                }
                return false;
            }
            // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar
            // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)
            // this makes bugs in user code easier to track down for end users
            // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code
            case '+': {
                const left = this.left.evaluate(f, s, hs, l, c);
                const right = this.right.evaluate(f, s, hs, l, c);
                if ((f & 4 /* isStrictBindingStrategy */) > 0) {
                    return left + right;
                }
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                if (!left || !right) {
                    if ((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isNumberOrBigInt)(left) || (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isNumberOrBigInt)(right)) {
                        return (left || 0) + (right || 0);
                    }
                    if ((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isStringOrDate)(left) || (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isStringOrDate)(right)) {
                        return (left || '') + (right || '');
                    }
                }
                return left + right;
            }
            case '-':
                return this.left.evaluate(f, s, hs, l, c) - this.right.evaluate(f, s, hs, l, c);
            case '*':
                return this.left.evaluate(f, s, hs, l, c) * this.right.evaluate(f, s, hs, l, c);
            case '/':
                return this.left.evaluate(f, s, hs, l, c) / this.right.evaluate(f, s, hs, l, c);
            case '%':
                return this.left.evaluate(f, s, hs, l, c) % this.right.evaluate(f, s, hs, l, c);
            case '<':
                return this.left.evaluate(f, s, hs, l, c) < this.right.evaluate(f, s, hs, l, c);
            case '>':
                return this.left.evaluate(f, s, hs, l, c) > this.right.evaluate(f, s, hs, l, c);
            case '<=':
                return this.left.evaluate(f, s, hs, l, c) <= this.right.evaluate(f, s, hs, l, c);
            case '>=':
                return this.left.evaluate(f, s, hs, l, c) >= this.right.evaluate(f, s, hs, l, c);
            default:
                throw new Error(`Unknown binary operator: '${this.operation}'`);
        }
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitBinary(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class UnaryExpression {
    constructor(operation, expression) {
        this.operation = operation;
        this.expression = expression;
    }
    get $kind() { return 39 /* Unary */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        switch (this.operation) {
            case 'void':
                return void this.expression.evaluate(f, s, hs, l, c);
            case 'typeof':
                return typeof this.expression.evaluate(f | 4 /* isStrictBindingStrategy */, s, hs, l, c);
            case '!':
                return !this.expression.evaluate(f, s, hs, l, c);
            case '-':
                return -this.expression.evaluate(f, s, hs, l, c);
            case '+':
                return +this.expression.evaluate(f, s, hs, l, c);
            default:
                throw new Error(`Unknown unary operator: '${this.operation}'`);
        }
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitUnary(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class PrimitiveLiteralExpression {
    constructor(value) {
        this.value = value;
    }
    get $kind() { return 17925 /* PrimitiveLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        return this.value;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitPrimitiveLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
PrimitiveLiteralExpression.$undefined = new PrimitiveLiteralExpression(void 0);
PrimitiveLiteralExpression.$null = new PrimitiveLiteralExpression(null);
PrimitiveLiteralExpression.$true = new PrimitiveLiteralExpression(true);
PrimitiveLiteralExpression.$false = new PrimitiveLiteralExpression(false);
PrimitiveLiteralExpression.$empty = new PrimitiveLiteralExpression('');
class HtmlLiteralExpression {
    constructor(parts) {
        this.parts = parts;
    }
    get $kind() { return 51 /* HtmlLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        let result = '';
        for (let i = 0; i < this.parts.length; ++i) {
            const v = this.parts[i].evaluate(f, s, hs, l, c);
            if (v == null) {
                continue;
            }
            result += v;
        }
        return result;
    }
    assign(_f, _s, _hs, _l, _obj, _projection) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitHtmlLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ArrayLiteralExpression {
    constructor(elements) {
        this.elements = elements;
    }
    get $kind() { return 17955 /* ArrayLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.elements.map(e => e.evaluate(f, s, hs, l, c));
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitArrayLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
ArrayLiteralExpression.$empty = new ArrayLiteralExpression(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray);
class ObjectLiteralExpression {
    constructor(keys, values) {
        this.keys = keys;
        this.values = values;
    }
    get $kind() { return 17956 /* ObjectLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = {};
        for (let i = 0; i < this.keys.length; ++i) {
            instance[this.keys[i]] = this.values[i].evaluate(f, s, hs, l, c);
        }
        return instance;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitObjectLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
ObjectLiteralExpression.$empty = new ObjectLiteralExpression(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray);
class TemplateExpression {
    constructor(cooked, expressions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        this.cooked = cooked;
        this.expressions = expressions;
    }
    get $kind() { return 17958 /* Template */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        let result = this.cooked[0];
        for (let i = 0; i < this.expressions.length; ++i) {
            result += String(this.expressions[i].evaluate(f, s, hs, l, c));
            result += this.cooked[i + 1];
        }
        return result;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitTemplate(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
TemplateExpression.$empty = new TemplateExpression(['']);
class TaggedTemplateExpression {
    constructor(cooked, raw, func, expressions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        this.cooked = cooked;
        this.func = func;
        this.expressions = expressions;
        cooked.raw = raw;
    }
    get $kind() { return 1197 /* TaggedTemplate */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const results = this.expressions.map(e => e.evaluate(f, s, hs, l, c));
        const func = this.func.evaluate(f, s, hs, l, c);
        if (typeof func !== 'function') {
            throw new Error(`Left-hand side of tagged template expression is not a function.`);
        }
        return func(this.cooked, ...results);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitTaggedTemplate(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ArrayBindingPattern {
    // We'll either have elements, or keys+values, but never all 3
    constructor(elements) {
        this.elements = elements;
    }
    get $kind() { return 65556 /* ArrayBindingPattern */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        // TODO: this should come after batch
        // as a destructuring expression like [x, y] = value
        //
        // should only trigger change only once:
        // batch(() => {
        //   object.x = value[0]
        //   object.y = value[1]
        // })
        //
        // instead of twice:
        // object.x = value[0]
        // object.y = value[1]
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        // TODO
        return void 0;
    }
    accept(visitor) {
        return visitor.visitArrayBindingPattern(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ObjectBindingPattern {
    // We'll either have elements, or keys+values, but never all 3
    constructor(keys, values) {
        this.keys = keys;
        this.values = values;
    }
    get $kind() { return 65557 /* ObjectBindingPattern */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        // TODO
        // similar to array binding ast, this should only come after batch
        // for a single notification per destructing,
        // regardless number of property assignments on the scope binding context
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        // TODO
        return void 0;
    }
    accept(visitor) {
        return visitor.visitObjectBindingPattern(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class BindingIdentifier {
    constructor(name) {
        this.name = name;
    }
    get $kind() { return 65558 /* BindingIdentifier */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        return this.name;
    }
    accept(visitor) {
        return visitor.visitBindingIdentifier(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
const toStringTag = Object.prototype.toString;
// https://tc39.github.io/ecma262/#sec-iteration-statements
// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
class ForOfStatement {
    constructor(declaration, iterable) {
        this.declaration = declaration;
        this.iterable = iterable;
    }
    get $kind() { return 6199 /* ForOfStatement */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.iterable.evaluate(f, s, hs, l, c);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    count(_f, result) {
        switch (toStringTag.call(result)) {
            case '[object Array]': return result.length;
            case '[object Map]': return result.size;
            case '[object Set]': return result.size;
            case '[object Number]': return result;
            case '[object Null]': return 0;
            case '[object Undefined]': return 0;
            default: throw new Error(`Cannot count ${toStringTag.call(result)}`);
        }
    }
    // deepscan-disable-next-line
    iterate(f, result, func) {
        switch (toStringTag.call(result)) {
            case '[object Array]': return $array(result, func);
            case '[object Map]': return $map(result, func);
            case '[object Set]': return $set(result, func);
            case '[object Number]': return $number(result, func);
            case '[object Null]': return;
            case '[object Undefined]': return;
            default: throw new Error(`Cannot iterate over ${toStringTag.call(result)}`);
        }
    }
    bind(f, s, hs, b) {
        if (this.iterable.hasBind) {
            this.iterable.bind(f, s, hs, b);
        }
    }
    unbind(f, s, hs, b) {
        if (this.iterable.hasUnbind) {
            this.iterable.unbind(f, s, hs, b);
        }
    }
    accept(visitor) {
        return visitor.visitForOfStatement(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
/*
* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)
* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction
* but this class might be a candidate for removal if it turns out it does provide all we need
*/
class Interpolation {
    constructor(parts, expressions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        this.parts = parts;
        this.expressions = expressions;
        this.isMulti = expressions.length > 1;
        this.firstExpression = expressions[0];
    }
    get $kind() { return 24 /* Interpolation */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        if (this.isMulti) {
            let result = this.parts[0];
            for (let i = 0; i < this.expressions.length; ++i) {
                result += String(this.expressions[i].evaluate(f, s, hs, l, c));
                result += this.parts[i + 1];
            }
            return result;
        }
        else {
            return `${this.parts[0]}${this.firstExpression.evaluate(f, s, hs, l, c)}${this.parts[1]}`;
        }
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitInterpolation(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
function getFunction(f, obj, name) {
    const func = obj == null ? null : obj[name];
    if (typeof func === 'function') {
        return func;
    }
    if (!(f & 128 /* mustEvaluate */) && func == null) {
        return null;
    }
    throw new Error(`Expected '${name}' to be a function`);
}
function $array(result, func) {
    for (let i = 0, ii = result.length; i < ii; ++i) {
        func(result, i, result[i]);
    }
}
function $map(result, func) {
    const arr = Array(result.size);
    let i = -1;
    for (const entry of result.entries()) {
        arr[++i] = entry;
    }
    $array(arr, func);
}
function $set(result, func) {
    const arr = Array(result.size);
    let i = -1;
    for (const key of result.keys()) {
        arr[++i] = key;
    }
    $array(arr, func);
}
function $number(result, func) {
    const arr = Array(result);
    for (let i = 0; i < result; ++i) {
        arr[i] = i;
    }
    $array(arr, func);
}
//# sourceMappingURL=ast.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingObserverRecord": () => /* binding */ BindingObserverRecord,
/* harmony export */   "connectable": () => /* binding */ connectable,
/* harmony export */   "BindingMediator": () => /* binding */ BindingMediator
/* harmony export */ });
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");
/* harmony import */ var _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/array-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js");
/* harmony import */ var _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observation/set-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js");
/* harmony import */ var _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observation/map-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js");




// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time
const slotNames = [];
const versionSlotNames = [];
let lastSlot = -1;
function ensureEnoughSlotNames(currentSlot) {
    if (currentSlot === lastSlot) {
        lastSlot += 5;
        const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;
        for (let i = currentSlot + 1; i < ii; ++i) {
            slotNames[i] = `_o${i}`;
            versionSlotNames[i] = `_v${i}`;
        }
    }
}
ensureEnoughSlotNames(-1);
function observeProperty(obj, key) {
    const observer = this.observerLocator.getObserver(obj, key);
    /* Note: we need to cast here because we can indeed get an accessor instead of an observer,
     *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:
     *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)
     *  2. Fail silently (without throwing): give all accessors a no-op subscribe method
     *
     * We'll probably want to implement some global configuration (like a "strict" toggle) so users can pick between enforced correctness vs. ease-of-use
     */
    this.obs.add(observer);
}
function getObserverRecord() {
    const record = new BindingObserverRecord(this);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.defineHiddenProp)(this, 'obs', record);
    return record;
}
function observeCollection(collection) {
    let obs;
    if (collection instanceof Array) {
        obs = (0,_observation_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(collection);
    }
    else if (collection instanceof Set) {
        obs = (0,_observation_set_observer_js__WEBPACK_IMPORTED_MODULE_2__.getSetObserver)(collection);
    }
    else if (collection instanceof Map) {
        obs = (0,_observation_map_observer_js__WEBPACK_IMPORTED_MODULE_3__.getMapObserver)(collection);
    }
    else {
        throw new Error('Unrecognised collection type.');
    }
    this.obs.add(obs);
}
function noopHandleChange() {
    throw new Error('method "handleChange" not implemented');
}
function noopHandleCollectionChange() {
    throw new Error('method "handleCollectionChange" not implemented');
}
class BindingObserverRecord {
    constructor(binding) {
        this.binding = binding;
        this.version = 0;
        this.count = 0;
        connectable.assignIdTo(this);
    }
    handleChange(value, oldValue, flags) {
        return this.binding.interceptor.handleChange(value, oldValue, flags);
    }
    handleCollectionChange(indexMap, flags) {
        this.binding.interceptor.handleCollectionChange(indexMap, flags);
    }
    /**
     * Add, and subscribe to a given observer
     */
    add(observer) {
        // find the observer.
        const observerSlots = this.count == null ? 0 : this.count;
        let i = observerSlots;
        while (i-- && this[slotNames[i]] !== observer)
            ;
        // if we are not already observing, put the observer in an open slot and subscribe.
        if (i === -1) {
            i = 0;
            while (this[slotNames[i]]) {
                i++;
            }
            this[slotNames[i]] = observer;
            observer.subscribe(this);
            observer[this.id] |= 8 /* updateTarget */;
            // increment the slot count.
            if (i === observerSlots) {
                this.count = i + 1;
            }
        }
        this[versionSlotNames[i]] = this.version;
        ensureEnoughSlotNames(i);
    }
    /**
     * Unsubscribe the observers that are not up to date with the record version
     */
    clear(all) {
        const slotCount = this.count;
        let slotName;
        let observer;
        let i = 0;
        if (all === true) {
            for (; i < slotCount; ++i) {
                slotName = slotNames[i];
                observer = this[slotName];
                if (observer != null) {
                    this[slotName] = void 0;
                    observer.unsubscribe(this);
                    observer[this.id] &= ~8 /* updateTarget */;
                }
            }
            this.count = 0;
        }
        else {
            for (; i < slotCount; ++i) {
                if (this[versionSlotNames[i]] !== this.version) {
                    slotName = slotNames[i];
                    observer = this[slotName];
                    if (observer != null) {
                        this[slotName] = void 0;
                        observer.unsubscribe(this);
                        observer[this.id] &= ~8 /* updateTarget */;
                        this.count--;
                    }
                }
            }
        }
    }
}
function connectableDecorator(target) {
    const proto = target.prototype;
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'observeProperty', observeProperty, true);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'observeCollection', observeCollection, true);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.def)(proto, 'obs', { get: getObserverRecord });
    // optionally add these two methods to normalize a connectable impl
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'handleChange', noopHandleChange);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'handleCollectionChange', noopHandleCollectionChange);
    return target;
}
function connectable(target) {
    return target == null ? connectableDecorator : connectableDecorator(target);
}
let idValue = 0;
connectable.assignIdTo = (instance) => {
    instance.id = ++idValue;
};
// @connectable
class BindingMediator {
    constructor(key, binding, observerLocator, locator) {
        this.key = key;
        this.binding = binding;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.interceptor = this;
        connectable.assignIdTo(this);
    }
    $bind(flags, scope, hostScope, projection) {
        throw new Error('Method not implemented.');
    }
    $unbind(flags) {
        throw new Error('Method not implemented.');
    }
    handleChange(newValue, previousValue, flags) {
        this.binding[this.key](newValue, previousValue, flags);
    }
}
connectableDecorator(BindingMediator);
//# sourceMappingURL=connectable.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding/expression-parser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding/expression-parser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IExpressionParser": () => /* binding */ IExpressionParser,
/* harmony export */   "ExpressionParser": () => /* binding */ ExpressionParser,
/* harmony export */   "Char": () => /* binding */ Char,
/* harmony export */   "Access": () => /* binding */ Access,
/* harmony export */   "Precedence": () => /* binding */ Precedence,
/* harmony export */   "BindingType": () => /* binding */ BindingType,
/* harmony export */   "ParserState": () => /* binding */ ParserState,
/* harmony export */   "parseExpression": () => /* binding */ parseExpression,
/* harmony export */   "parse": () => /* binding */ parse
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/ast.js");


const IExpressionParser = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IExpressionParser', x => x.singleton(ExpressionParser));
class ExpressionParser {
    constructor() {
        this.expressionLookup = Object.create(null);
        this.forOfLookup = Object.create(null);
        this.interpolationLookup = Object.create(null);
    }
    parse(expression, bindingType) {
        switch (bindingType) {
            case 2048 /* Interpolation */: {
                let found = this.interpolationLookup[expression];
                if (found === void 0) {
                    found = this.interpolationLookup[expression] = this.$parse(expression, bindingType);
                }
                return found;
            }
            case 539 /* ForCommand */: {
                let found = this.forOfLookup[expression];
                if (found === void 0) {
                    found = this.forOfLookup[expression] = this.$parse(expression, bindingType);
                }
                return found;
            }
            default: {
                // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)
                // But don't cache it, because empty strings are always invalid for any other type of binding
                if (expression.length === 0 && (bindingType & (53 /* BindCommand */ | 49 /* OneTimeCommand */ | 50 /* ToViewCommand */))) {
                    return _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$empty;
                }
                let found = this.expressionLookup[expression];
                if (found === void 0) {
                    found = this.expressionLookup[expression] = this.$parse(expression, bindingType);
                }
                return found;
            }
        }
    }
    $parse(expression, bindingType) {
        $state.input = expression;
        $state.length = expression.length;
        $state.index = 0;
        $state.currentChar = expression.charCodeAt(0);
        return parse($state, 0 /* Reset */, 61 /* Variadic */, bindingType === void 0 ? 53 /* BindCommand */ : bindingType);
    }
}
var Char;
(function (Char) {
    Char[Char["Null"] = 0] = "Null";
    Char[Char["Backspace"] = 8] = "Backspace";
    Char[Char["Tab"] = 9] = "Tab";
    Char[Char["LineFeed"] = 10] = "LineFeed";
    Char[Char["VerticalTab"] = 11] = "VerticalTab";
    Char[Char["FormFeed"] = 12] = "FormFeed";
    Char[Char["CarriageReturn"] = 13] = "CarriageReturn";
    Char[Char["Space"] = 32] = "Space";
    Char[Char["Exclamation"] = 33] = "Exclamation";
    Char[Char["DoubleQuote"] = 34] = "DoubleQuote";
    Char[Char["Dollar"] = 36] = "Dollar";
    Char[Char["Percent"] = 37] = "Percent";
    Char[Char["Ampersand"] = 38] = "Ampersand";
    Char[Char["SingleQuote"] = 39] = "SingleQuote";
    Char[Char["OpenParen"] = 40] = "OpenParen";
    Char[Char["CloseParen"] = 41] = "CloseParen";
    Char[Char["Asterisk"] = 42] = "Asterisk";
    Char[Char["Plus"] = 43] = "Plus";
    Char[Char["Comma"] = 44] = "Comma";
    Char[Char["Minus"] = 45] = "Minus";
    Char[Char["Dot"] = 46] = "Dot";
    Char[Char["Slash"] = 47] = "Slash";
    Char[Char["Semicolon"] = 59] = "Semicolon";
    Char[Char["Backtick"] = 96] = "Backtick";
    Char[Char["OpenBracket"] = 91] = "OpenBracket";
    Char[Char["Backslash"] = 92] = "Backslash";
    Char[Char["CloseBracket"] = 93] = "CloseBracket";
    Char[Char["Caret"] = 94] = "Caret";
    Char[Char["Underscore"] = 95] = "Underscore";
    Char[Char["OpenBrace"] = 123] = "OpenBrace";
    Char[Char["Bar"] = 124] = "Bar";
    Char[Char["CloseBrace"] = 125] = "CloseBrace";
    Char[Char["Colon"] = 58] = "Colon";
    Char[Char["LessThan"] = 60] = "LessThan";
    Char[Char["Equals"] = 61] = "Equals";
    Char[Char["GreaterThan"] = 62] = "GreaterThan";
    Char[Char["Question"] = 63] = "Question";
    Char[Char["Zero"] = 48] = "Zero";
    Char[Char["One"] = 49] = "One";
    Char[Char["Two"] = 50] = "Two";
    Char[Char["Three"] = 51] = "Three";
    Char[Char["Four"] = 52] = "Four";
    Char[Char["Five"] = 53] = "Five";
    Char[Char["Six"] = 54] = "Six";
    Char[Char["Seven"] = 55] = "Seven";
    Char[Char["Eight"] = 56] = "Eight";
    Char[Char["Nine"] = 57] = "Nine";
    Char[Char["UpperA"] = 65] = "UpperA";
    Char[Char["UpperB"] = 66] = "UpperB";
    Char[Char["UpperC"] = 67] = "UpperC";
    Char[Char["UpperD"] = 68] = "UpperD";
    Char[Char["UpperE"] = 69] = "UpperE";
    Char[Char["UpperF"] = 70] = "UpperF";
    Char[Char["UpperG"] = 71] = "UpperG";
    Char[Char["UpperH"] = 72] = "UpperH";
    Char[Char["UpperI"] = 73] = "UpperI";
    Char[Char["UpperJ"] = 74] = "UpperJ";
    Char[Char["UpperK"] = 75] = "UpperK";
    Char[Char["UpperL"] = 76] = "UpperL";
    Char[Char["UpperM"] = 77] = "UpperM";
    Char[Char["UpperN"] = 78] = "UpperN";
    Char[Char["UpperO"] = 79] = "UpperO";
    Char[Char["UpperP"] = 80] = "UpperP";
    Char[Char["UpperQ"] = 81] = "UpperQ";
    Char[Char["UpperR"] = 82] = "UpperR";
    Char[Char["UpperS"] = 83] = "UpperS";
    Char[Char["UpperT"] = 84] = "UpperT";
    Char[Char["UpperU"] = 85] = "UpperU";
    Char[Char["UpperV"] = 86] = "UpperV";
    Char[Char["UpperW"] = 87] = "UpperW";
    Char[Char["UpperX"] = 88] = "UpperX";
    Char[Char["UpperY"] = 89] = "UpperY";
    Char[Char["UpperZ"] = 90] = "UpperZ";
    Char[Char["LowerA"] = 97] = "LowerA";
    Char[Char["LowerB"] = 98] = "LowerB";
    Char[Char["LowerC"] = 99] = "LowerC";
    Char[Char["LowerD"] = 100] = "LowerD";
    Char[Char["LowerE"] = 101] = "LowerE";
    Char[Char["LowerF"] = 102] = "LowerF";
    Char[Char["LowerG"] = 103] = "LowerG";
    Char[Char["LowerH"] = 104] = "LowerH";
    Char[Char["LowerI"] = 105] = "LowerI";
    Char[Char["LowerJ"] = 106] = "LowerJ";
    Char[Char["LowerK"] = 107] = "LowerK";
    Char[Char["LowerL"] = 108] = "LowerL";
    Char[Char["LowerM"] = 109] = "LowerM";
    Char[Char["LowerN"] = 110] = "LowerN";
    Char[Char["LowerO"] = 111] = "LowerO";
    Char[Char["LowerP"] = 112] = "LowerP";
    Char[Char["LowerQ"] = 113] = "LowerQ";
    Char[Char["LowerR"] = 114] = "LowerR";
    Char[Char["LowerS"] = 115] = "LowerS";
    Char[Char["LowerT"] = 116] = "LowerT";
    Char[Char["LowerU"] = 117] = "LowerU";
    Char[Char["LowerV"] = 118] = "LowerV";
    Char[Char["LowerW"] = 119] = "LowerW";
    Char[Char["LowerX"] = 120] = "LowerX";
    Char[Char["LowerY"] = 121] = "LowerY";
    Char[Char["LowerZ"] = 122] = "LowerZ";
})(Char || (Char = {}));
function unescapeCode(code) {
    switch (code) {
        case 98 /* LowerB */: return 8 /* Backspace */;
        case 116 /* LowerT */: return 9 /* Tab */;
        case 110 /* LowerN */: return 10 /* LineFeed */;
        case 118 /* LowerV */: return 11 /* VerticalTab */;
        case 102 /* LowerF */: return 12 /* FormFeed */;
        case 114 /* LowerR */: return 13 /* CarriageReturn */;
        case 34 /* DoubleQuote */: return 34 /* DoubleQuote */;
        case 39 /* SingleQuote */: return 39 /* SingleQuote */;
        case 92 /* Backslash */: return 92 /* Backslash */;
        default: return code;
    }
}
var Access;
(function (Access) {
    Access[Access["Reset"] = 0] = "Reset";
    Access[Access["Ancestor"] = 511] = "Ancestor";
    Access[Access["This"] = 512] = "This";
    Access[Access["Scope"] = 1024] = "Scope";
    Access[Access["Member"] = 2048] = "Member";
    Access[Access["Keyed"] = 4096] = "Keyed";
})(Access || (Access = {}));
var Precedence;
(function (Precedence) {
    Precedence[Precedence["Variadic"] = 61] = "Variadic";
    Precedence[Precedence["Assign"] = 62] = "Assign";
    Precedence[Precedence["Conditional"] = 63] = "Conditional";
    Precedence[Precedence["LogicalOR"] = 64] = "LogicalOR";
    Precedence[Precedence["LogicalAND"] = 128] = "LogicalAND";
    Precedence[Precedence["Equality"] = 192] = "Equality";
    Precedence[Precedence["Relational"] = 256] = "Relational";
    Precedence[Precedence["Additive"] = 320] = "Additive";
    Precedence[Precedence["Multiplicative"] = 384] = "Multiplicative";
    Precedence[Precedence["Binary"] = 448] = "Binary";
    Precedence[Precedence["LeftHandSide"] = 449] = "LeftHandSide";
    Precedence[Precedence["Primary"] = 450] = "Primary";
    Precedence[Precedence["Unary"] = 451] = "Unary";
})(Precedence || (Precedence = {}));
var Token;
(function (Token) {
    Token[Token["EOF"] = 1572864] = "EOF";
    Token[Token["ExpressionTerminal"] = 1048576] = "ExpressionTerminal";
    Token[Token["AccessScopeTerminal"] = 524288] = "AccessScopeTerminal";
    Token[Token["ClosingToken"] = 262144] = "ClosingToken";
    Token[Token["OpeningToken"] = 131072] = "OpeningToken";
    Token[Token["BinaryOp"] = 65536] = "BinaryOp";
    Token[Token["UnaryOp"] = 32768] = "UnaryOp";
    Token[Token["LeftHandSide"] = 16384] = "LeftHandSide";
    Token[Token["StringOrNumericLiteral"] = 12288] = "StringOrNumericLiteral";
    Token[Token["NumericLiteral"] = 8192] = "NumericLiteral";
    Token[Token["StringLiteral"] = 4096] = "StringLiteral";
    Token[Token["IdentifierName"] = 3072] = "IdentifierName";
    Token[Token["Keyword"] = 2048] = "Keyword";
    Token[Token["Identifier"] = 1024] = "Identifier";
    Token[Token["Contextual"] = 512] = "Contextual";
    Token[Token["Precedence"] = 448] = "Precedence";
    Token[Token["Type"] = 63] = "Type";
    Token[Token["FalseKeyword"] = 2048] = "FalseKeyword";
    Token[Token["TrueKeyword"] = 2049] = "TrueKeyword";
    Token[Token["NullKeyword"] = 2050] = "NullKeyword";
    Token[Token["UndefinedKeyword"] = 2051] = "UndefinedKeyword";
    Token[Token["ThisScope"] = 3076] = "ThisScope";
    Token[Token["HostScope"] = 3077] = "HostScope";
    Token[Token["ParentScope"] = 3078] = "ParentScope";
    Token[Token["OpenParen"] = 671751] = "OpenParen";
    Token[Token["OpenBrace"] = 131080] = "OpenBrace";
    Token[Token["Dot"] = 16393] = "Dot";
    Token[Token["CloseBrace"] = 1835018] = "CloseBrace";
    Token[Token["CloseParen"] = 1835019] = "CloseParen";
    Token[Token["Comma"] = 1572876] = "Comma";
    Token[Token["OpenBracket"] = 671757] = "OpenBracket";
    Token[Token["CloseBracket"] = 1835022] = "CloseBracket";
    Token[Token["Colon"] = 1572879] = "Colon";
    Token[Token["Question"] = 1572880] = "Question";
    Token[Token["Ampersand"] = 1572883] = "Ampersand";
    Token[Token["Bar"] = 1572884] = "Bar";
    Token[Token["BarBar"] = 1638549] = "BarBar";
    Token[Token["AmpersandAmpersand"] = 1638614] = "AmpersandAmpersand";
    Token[Token["EqualsEquals"] = 1638679] = "EqualsEquals";
    Token[Token["ExclamationEquals"] = 1638680] = "ExclamationEquals";
    Token[Token["EqualsEqualsEquals"] = 1638681] = "EqualsEqualsEquals";
    Token[Token["ExclamationEqualsEquals"] = 1638682] = "ExclamationEqualsEquals";
    Token[Token["LessThan"] = 1638747] = "LessThan";
    Token[Token["GreaterThan"] = 1638748] = "GreaterThan";
    Token[Token["LessThanEquals"] = 1638749] = "LessThanEquals";
    Token[Token["GreaterThanEquals"] = 1638750] = "GreaterThanEquals";
    Token[Token["InKeyword"] = 1640799] = "InKeyword";
    Token[Token["InstanceOfKeyword"] = 1640800] = "InstanceOfKeyword";
    Token[Token["Plus"] = 623009] = "Plus";
    Token[Token["Minus"] = 623010] = "Minus";
    Token[Token["TypeofKeyword"] = 34851] = "TypeofKeyword";
    Token[Token["VoidKeyword"] = 34852] = "VoidKeyword";
    Token[Token["Asterisk"] = 1638885] = "Asterisk";
    Token[Token["Percent"] = 1638886] = "Percent";
    Token[Token["Slash"] = 1638887] = "Slash";
    Token[Token["Equals"] = 1048616] = "Equals";
    Token[Token["Exclamation"] = 32809] = "Exclamation";
    Token[Token["TemplateTail"] = 540714] = "TemplateTail";
    Token[Token["TemplateContinuation"] = 540715] = "TemplateContinuation";
    Token[Token["OfKeyword"] = 1051180] = "OfKeyword";
})(Token || (Token = {}));
const $false = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$false;
const $true = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$true;
const $null = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$null;
const $undefined = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$undefined;
const $this = _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression.$this;
const $host = _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression.$host;
const $parent = _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression.$parent;
var BindingType;
(function (BindingType) {
    BindingType[BindingType["None"] = 0] = "None";
    BindingType[BindingType["IgnoreCustomAttr"] = 4096] = "IgnoreCustomAttr";
    BindingType[BindingType["Interpolation"] = 2048] = "Interpolation";
    BindingType[BindingType["IsRef"] = 5376] = "IsRef";
    BindingType[BindingType["IsIterator"] = 512] = "IsIterator";
    BindingType[BindingType["IsCustom"] = 256] = "IsCustom";
    BindingType[BindingType["IsFunction"] = 128] = "IsFunction";
    BindingType[BindingType["IsEvent"] = 64] = "IsEvent";
    BindingType[BindingType["IsProperty"] = 32] = "IsProperty";
    BindingType[BindingType["IsCommand"] = 16] = "IsCommand";
    BindingType[BindingType["IsPropertyCommand"] = 48] = "IsPropertyCommand";
    BindingType[BindingType["IsEventCommand"] = 80] = "IsEventCommand";
    BindingType[BindingType["DelegationStrategyDelta"] = 6] = "DelegationStrategyDelta";
    BindingType[BindingType["Command"] = 15] = "Command";
    BindingType[BindingType["OneTimeCommand"] = 49] = "OneTimeCommand";
    BindingType[BindingType["ToViewCommand"] = 50] = "ToViewCommand";
    BindingType[BindingType["FromViewCommand"] = 51] = "FromViewCommand";
    BindingType[BindingType["TwoWayCommand"] = 52] = "TwoWayCommand";
    BindingType[BindingType["BindCommand"] = 53] = "BindCommand";
    BindingType[BindingType["TriggerCommand"] = 4182] = "TriggerCommand";
    BindingType[BindingType["CaptureCommand"] = 4183] = "CaptureCommand";
    BindingType[BindingType["DelegateCommand"] = 4184] = "DelegateCommand";
    BindingType[BindingType["CallCommand"] = 153] = "CallCommand";
    BindingType[BindingType["OptionsCommand"] = 26] = "OptionsCommand";
    BindingType[BindingType["ForCommand"] = 539] = "ForCommand";
    BindingType[BindingType["CustomCommand"] = 284] = "CustomCommand";
})(BindingType || (BindingType = {}));
/* eslint-enable @typescript-eslint/indent */
/** @internal */
class ParserState {
    constructor(input) {
        this.input = input;
        this.index = 0;
        this.startIndex = 0;
        this.lastIndex = 0;
        this.currentToken = 1572864 /* EOF */;
        this.tokenValue = '';
        this.assignable = true;
        this.length = input.length;
        this.currentChar = input.charCodeAt(0);
    }
    get tokenRaw() {
        return this.input.slice(this.startIndex, this.index);
    }
}
const $state = new ParserState('');
/** @internal */
function parseExpression(input, bindingType) {
    $state.input = input;
    $state.length = input.length;
    $state.index = 0;
    $state.currentChar = input.charCodeAt(0);
    return parse($state, 0 /* Reset */, 61 /* Variadic */, bindingType === void 0 ? 53 /* BindCommand */ : bindingType);
}
/** @internal */
// This is performance-critical code which follows a subset of the well-known ES spec.
// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the
// single source of information for being able to figure it out.
// It generally does not need to change unless the spec changes or spec violations are found, or optimization
// opportunities are found (which would likely not fix these warnings in any case).
// It's therefore not considered to have any tangible impact on the maintainability of the code base.
// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions
// eslint-disable-next-line max-lines-per-function
function parse(state, access, minPrecedence, bindingType) {
    if (bindingType === 284 /* CustomCommand */) {
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CustomExpression(state.input);
    }
    if (state.index === 0) {
        if (bindingType & 2048 /* Interpolation */) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return parseInterpolation(state);
        }
        nextToken(state);
        if (state.currentToken & 1048576 /* ExpressionTerminal */) {
            throw new Error(`Invalid start of expression: '${state.input}'`);
        }
    }
    state.assignable = 448 /* Binary */ > minPrecedence;
    let result = void 0;
    if (state.currentToken & 32768 /* UnaryOp */) {
        /** parseUnaryExpression
         * https://tc39.github.io/ecma262/#sec-unary-operators
         *
         * UnaryExpression :
         * 1. LeftHandSideExpression
         * 2. void UnaryExpression
         * 3. typeof UnaryExpression
         * 4. + UnaryExpression
         * 5. - UnaryExpression
         * 6. ! UnaryExpression
         *
         * IsValidAssignmentTarget
         * 2,3,4,5,6 = false
         * 1 = see parseLeftHandSideExpression
         *
         * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that
         */
        const op = TokenValues[state.currentToken & 63 /* Type */];
        nextToken(state);
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.UnaryExpression(op, parse(state, access, 449 /* LeftHandSide */, bindingType));
        state.assignable = false;
    }
    else {
        /** parsePrimaryExpression
         * https://tc39.github.io/ecma262/#sec-primary-expression
         *
         * PrimaryExpression :
         * 1. this
         * 2. IdentifierName
         * 3. Literal
         * 4. ArrayLiteralExpression
         * 5. ObjectLiteralExpression
         * 6. TemplateLiteral
         * 7. ParenthesizedExpression
         *
         * Literal :
         * NullLiteral
         * BooleanLiteral
         * NumericLiteral
         * StringLiteral
         *
         * ParenthesizedExpression :
         * ( AssignmentExpression )
         *
         * IsValidAssignmentTarget
         * 1,3,4,5,6,7 = false
         * 2 = true
         */
        primary: switch (state.currentToken) {
            case 3078 /* ParentScope */: // $parent
                state.assignable = false;
                do {
                    nextToken(state);
                    access++; // ancestor
                    if (consumeOpt(state, 16393 /* Dot */)) {
                        if (state.currentToken === 16393 /* Dot */) {
                            throw new Error(`Double dot and spread operators are not supported: '${state.input}'`);
                        }
                        else if (state.currentToken === 1572864 /* EOF */) {
                            throw new Error(`Expected identifier: '${state.input}'`);
                        }
                    }
                    else if (state.currentToken & 524288 /* AccessScopeTerminal */) {
                        const ancestor = access & 511 /* Ancestor */;
                        result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression(ancestor);
                        access = 512 /* This */;
                        break primary;
                    }
                    else {
                        throw new Error(`Invalid member expression: '${state.input}'`);
                    }
                } while (state.currentToken === 3078 /* ParentScope */);
            // falls through
            case 1024 /* Identifier */: // identifier
                if (bindingType & 512 /* IsIterator */) {
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.BindingIdentifier(state.tokenValue);
                }
                else {
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessScopeExpression(state.tokenValue, access & 511 /* Ancestor */);
                    access = 1024 /* Scope */;
                }
                state.assignable = true;
                nextToken(state);
                break;
            case 3076 /* ThisScope */: // $this
                state.assignable = false;
                nextToken(state);
                result = $this;
                access = 512 /* This */;
                break;
            case 3077 /* HostScope */: // $host
                state.assignable = false;
                nextToken(state);
                result = $host;
                access = 512 /* This */;
                break;
            case 671751 /* OpenParen */: // parenthesized expression
                nextToken(state);
                result = parse(state, 0 /* Reset */, 62 /* Assign */, bindingType);
                consume(state, 1835019 /* CloseParen */);
                access = 0 /* Reset */;
                break;
            case 671757 /* OpenBracket */:
                result = parseArrayLiteralExpression(state, access, bindingType);
                access = 0 /* Reset */;
                break;
            case 131080 /* OpenBrace */:
                result = parseObjectLiteralExpression(state, bindingType);
                access = 0 /* Reset */;
                break;
            case 540714 /* TemplateTail */:
                result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TemplateExpression([state.tokenValue]);
                state.assignable = false;
                nextToken(state);
                access = 0 /* Reset */;
                break;
            case 540715 /* TemplateContinuation */:
                result = parseTemplate(state, access, bindingType, result, false);
                access = 0 /* Reset */;
                break;
            case 4096 /* StringLiteral */:
            case 8192 /* NumericLiteral */:
                result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression(state.tokenValue);
                state.assignable = false;
                nextToken(state);
                access = 0 /* Reset */;
                break;
            case 2050 /* NullKeyword */:
            case 2051 /* UndefinedKeyword */:
            case 2049 /* TrueKeyword */:
            case 2048 /* FalseKeyword */:
                result = TokenValues[state.currentToken & 63 /* Type */];
                state.assignable = false;
                nextToken(state);
                access = 0 /* Reset */;
                break;
            default:
                if (state.index >= state.length) {
                    throw new Error(`Unexpected end of expression: '${state.input}'`);
                }
                else {
                    throw new Error(`Unconsumed token: '${state.input}'`);
                }
        }
        if (bindingType & 512 /* IsIterator */) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return parseForOfStatement(state, result);
        }
        if (449 /* LeftHandSide */ < minPrecedence) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return result;
        }
        /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)
         * MemberExpression :
         * 1. PrimaryExpression
         * 2. MemberExpression [ AssignmentExpression ]
         * 3. MemberExpression . IdentifierName
         * 4. MemberExpression TemplateLiteral
         *
         * IsValidAssignmentTarget
         * 1,4 = false
         * 2,3 = true
         *
         *
         * parseCallExpression (Token.OpenParen)
         * CallExpression :
         * 1. MemberExpression Arguments
         * 2. CallExpression Arguments
         * 3. CallExpression [ AssignmentExpression ]
         * 4. CallExpression . IdentifierName
         * 5. CallExpression TemplateLiteral
         *
         * IsValidAssignmentTarget
         * 1,2,5 = false
         * 3,4 = true
         */
        let name = state.tokenValue;
        while ((state.currentToken & 16384 /* LeftHandSide */) > 0) {
            const args = [];
            let strings;
            switch (state.currentToken) {
                case 16393 /* Dot */:
                    state.assignable = true;
                    nextToken(state);
                    if ((state.currentToken & 3072 /* IdentifierName */) === 0) {
                        throw new Error(`Expected identifier: '${state.input}'`);
                    }
                    name = state.tokenValue;
                    nextToken(state);
                    // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags
                    access = ((access & (512 /* This */ | 1024 /* Scope */)) << 1) | (access & 2048 /* Member */) | ((access & 4096 /* Keyed */) >> 1);
                    if (state.currentToken === 671751 /* OpenParen */) {
                        if (access === 0 /* Reset */) { // if the left hand side is a literal, make sure we parse a CallMemberExpression
                            access = 2048 /* Member */;
                        }
                        continue;
                    }
                    if (access & 1024 /* Scope */) {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessScopeExpression(name, result.ancestor, result === $host);
                    }
                    else { // if it's not $Scope, it's $Member
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessMemberExpression(result, name);
                    }
                    continue;
                case 671757 /* OpenBracket */:
                    state.assignable = true;
                    nextToken(state);
                    access = 4096 /* Keyed */;
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessKeyedExpression(result, parse(state, 0 /* Reset */, 62 /* Assign */, bindingType));
                    consume(state, 1835022 /* CloseBracket */);
                    break;
                case 671751 /* OpenParen */:
                    state.assignable = false;
                    nextToken(state);
                    while (state.currentToken !== 1835019 /* CloseParen */) {
                        args.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType));
                        if (!consumeOpt(state, 1572876 /* Comma */)) {
                            break;
                        }
                    }
                    consume(state, 1835019 /* CloseParen */);
                    if (access & 1024 /* Scope */) {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CallScopeExpression(name, args, result.ancestor, result === $host);
                    }
                    else if (access & 2048 /* Member */) {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CallMemberExpression(result, name, args);
                    }
                    else {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CallFunctionExpression(result, args);
                    }
                    access = 0;
                    break;
                case 540714 /* TemplateTail */:
                    state.assignable = false;
                    strings = [state.tokenValue];
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TaggedTemplateExpression(strings, strings, result);
                    nextToken(state);
                    break;
                case 540715 /* TemplateContinuation */:
                    result = parseTemplate(state, access, bindingType, result, true);
                default:
            }
        }
    }
    if (448 /* Binary */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /** parseBinaryExpression
     * https://tc39.github.io/ecma262/#sec-multiplicative-operators
     *
     * MultiplicativeExpression : (local precedence 6)
     * UnaryExpression
     * MultiplicativeExpression * / % UnaryExpression
     *
     * AdditiveExpression : (local precedence 5)
     * MultiplicativeExpression
     * AdditiveExpression + - MultiplicativeExpression
     *
     * RelationalExpression : (local precedence 4)
     * AdditiveExpression
     * RelationalExpression < > <= >= instanceof in AdditiveExpression
     *
     * EqualityExpression : (local precedence 3)
     * RelationalExpression
     * EqualityExpression == != === !== RelationalExpression
     *
     * LogicalANDExpression : (local precedence 2)
     * EqualityExpression
     * LogicalANDExpression && EqualityExpression
     *
     * LogicalORExpression : (local precedence 1)
     * LogicalANDExpression
     * LogicalORExpression || LogicalANDExpression
     */
    while ((state.currentToken & 65536 /* BinaryOp */) > 0) {
        const opToken = state.currentToken;
        if ((opToken & 448 /* Precedence */) <= minPrecedence) {
            break;
        }
        nextToken(state);
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.BinaryExpression(TokenValues[opToken & 63 /* Type */], result, parse(state, access, opToken & 448 /* Precedence */, bindingType));
        state.assignable = false;
    }
    if (63 /* Conditional */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /**
     * parseConditionalExpression
     * https://tc39.github.io/ecma262/#prod-ConditionalExpression
     *
     * ConditionalExpression :
     * 1. BinaryExpression
     * 2. BinaryExpression ? AssignmentExpression : AssignmentExpression
     *
     * IsValidAssignmentTarget
     * 1,2 = false
     */
    if (consumeOpt(state, 1572880 /* Question */)) {
        const yes = parse(state, access, 62 /* Assign */, bindingType);
        consume(state, 1572879 /* Colon */);
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ConditionalExpression(result, yes, parse(state, access, 62 /* Assign */, bindingType));
        state.assignable = false;
    }
    if (62 /* Assign */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /** parseAssignmentExpression
     * https://tc39.github.io/ecma262/#prod-AssignmentExpression
     * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator
     *
     * AssignmentExpression :
     * 1. ConditionalExpression
     * 2. LeftHandSideExpression = AssignmentExpression
     *
     * IsValidAssignmentTarget
     * 1,2 = false
     */
    if (consumeOpt(state, 1048616 /* Equals */)) {
        if (!state.assignable) {
            throw new Error(`Left hand side of expression is not assignable: '${state.input}'`);
        }
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AssignExpression(result, parse(state, access, 62 /* Assign */, bindingType));
    }
    if (61 /* Variadic */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /** parseValueConverter
     */
    while (consumeOpt(state, 1572884 /* Bar */)) {
        if (state.currentToken === 1572864 /* EOF */) {
            throw new Error(`Expected identifier to come after ValueConverter operator: '${state.input}'`);
        }
        const name = state.tokenValue;
        nextToken(state);
        const args = new Array();
        while (consumeOpt(state, 1572879 /* Colon */)) {
            args.push(parse(state, access, 62 /* Assign */, bindingType));
        }
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ValueConverterExpression(result, name, args);
    }
    /** parseBindingBehavior
     */
    while (consumeOpt(state, 1572883 /* Ampersand */)) {
        if (state.currentToken === 1572864 /* EOF */) {
            throw new Error(`Expected identifier to come after BindingBehavior operator: '${state.input}'`);
        }
        const name = state.tokenValue;
        nextToken(state);
        const args = new Array();
        while (consumeOpt(state, 1572879 /* Colon */)) {
            args.push(parse(state, access, 62 /* Assign */, bindingType));
        }
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.BindingBehaviorExpression(result, name, args);
    }
    if (state.currentToken !== 1572864 /* EOF */) {
        if (bindingType & 2048 /* Interpolation */) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return result;
        }
        if (state.tokenRaw === 'of') {
            throw new Error(`Unexpected keyword "of": '${state.input}'`);
        }
        throw new Error(`Unconsumed token: '${state.input}'`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return result;
}
/**
 * parseArrayLiteralExpression
 * https://tc39.github.io/ecma262/#prod-ArrayLiteralExpression
 *
 * ArrayLiteralExpression :
 * [ Elision(opt) ]
 * [ ElementList ]
 * [ ElementList, Elision(opt) ]
 *
 * ElementList :
 * Elision(opt) AssignmentExpression
 * ElementList, Elision(opt) AssignmentExpression
 *
 * Elision :
 * ,
 * Elision ,
 */
function parseArrayLiteralExpression(state, access, bindingType) {
    nextToken(state);
    const elements = new Array();
    while (state.currentToken !== 1835022 /* CloseBracket */) {
        if (consumeOpt(state, 1572876 /* Comma */)) {
            elements.push($undefined);
            if (state.currentToken === 1835022 /* CloseBracket */) {
                break;
            }
        }
        else {
            elements.push(parse(state, access, 62 /* Assign */, bindingType & ~512 /* IsIterator */));
            if (consumeOpt(state, 1572876 /* Comma */)) {
                if (state.currentToken === 1835022 /* CloseBracket */) {
                    break;
                }
            }
            else {
                break;
            }
        }
    }
    consume(state, 1835022 /* CloseBracket */);
    if (bindingType & 512 /* IsIterator */) {
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ArrayBindingPattern(elements);
    }
    else {
        state.assignable = false;
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ArrayLiteralExpression(elements);
    }
}
function parseForOfStatement(state, result) {
    if ((result.$kind & 65536 /* IsForDeclaration */) === 0) {
        throw new Error(`Invalid BindingIdentifier at left hand side of "of": '${state.input}'`);
    }
    if (state.currentToken !== 1051180 /* OfKeyword */) {
        throw new Error(`Invalid BindingIdentifier at left hand side of "of": '${state.input}'`);
    }
    nextToken(state);
    const declaration = result;
    const statement = parse(state, 0 /* Reset */, 61 /* Variadic */, 0 /* None */);
    return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ForOfStatement(declaration, statement);
}
/**
 * parseObjectLiteralExpression
 * https://tc39.github.io/ecma262/#prod-Literal
 *
 * ObjectLiteralExpression :
 * { }
 * { PropertyDefinitionList }
 *
 * PropertyDefinitionList :
 * PropertyDefinition
 * PropertyDefinitionList, PropertyDefinition
 *
 * PropertyDefinition :
 * IdentifierName
 * PropertyName : AssignmentExpression
 *
 * PropertyName :
 * IdentifierName
 * StringLiteral
 * NumericLiteral
 */
function parseObjectLiteralExpression(state, bindingType) {
    const keys = new Array();
    const values = new Array();
    nextToken(state);
    while (state.currentToken !== 1835018 /* CloseBrace */) {
        keys.push(state.tokenValue);
        // Literal = mandatory colon
        if (state.currentToken & 12288 /* StringOrNumericLiteral */) {
            nextToken(state);
            consume(state, 1572879 /* Colon */);
            values.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType & ~512 /* IsIterator */));
        }
        else if (state.currentToken & 3072 /* IdentifierName */) {
            // IdentifierName = optional colon
            const { currentChar, currentToken, index } = state;
            nextToken(state);
            if (consumeOpt(state, 1572879 /* Colon */)) {
                values.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType & ~512 /* IsIterator */));
            }
            else {
                // Shorthand
                state.currentChar = currentChar;
                state.currentToken = currentToken;
                state.index = index;
                values.push(parse(state, 0 /* Reset */, 450 /* Primary */, bindingType & ~512 /* IsIterator */));
            }
        }
        else {
            throw new Error(`Invalid or unsupported property definition in object literal: '${state.input}'`);
        }
        if (state.currentToken !== 1835018 /* CloseBrace */) {
            consume(state, 1572876 /* Comma */);
        }
    }
    consume(state, 1835018 /* CloseBrace */);
    if (bindingType & 512 /* IsIterator */) {
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ObjectBindingPattern(keys, values);
    }
    else {
        state.assignable = false;
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ObjectLiteralExpression(keys, values);
    }
}
function parseInterpolation(state) {
    const parts = [];
    const expressions = [];
    const length = state.length;
    let result = '';
    while (state.index < length) {
        switch (state.currentChar) {
            case 36 /* Dollar */:
                if (state.input.charCodeAt(state.index + 1) === 123 /* OpenBrace */) {
                    parts.push(result);
                    result = '';
                    state.index += 2;
                    state.currentChar = state.input.charCodeAt(state.index);
                    nextToken(state);
                    const expression = parse(state, 0 /* Reset */, 61 /* Variadic */, 2048 /* Interpolation */);
                    expressions.push(expression);
                    continue;
                }
                else {
                    result += '$';
                }
                break;
            case 92 /* Backslash */:
                result += String.fromCharCode(unescapeCode(nextChar(state)));
                break;
            default:
                result += String.fromCharCode(state.currentChar);
        }
        nextChar(state);
    }
    if (expressions.length) {
        parts.push(result);
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.Interpolation(parts, expressions);
    }
    return null;
}
/**
 * parseTemplateLiteralExpression
 * https://tc39.github.io/ecma262/#prod-Literal
 *
 * TemplateExpression :
 * NoSubstitutionTemplate
 * TemplateHead
 *
 * NoSubstitutionTemplate :
 * ` TemplateCharacters(opt) `
 *
 * TemplateHead :
 * ` TemplateCharacters(opt) ${
 *
 * TemplateSubstitutionTail :
 * TemplateMiddle
 * TemplateTail
 *
 * TemplateMiddle :
 * } TemplateCharacters(opt) ${
 *
 * TemplateTail :
 * } TemplateCharacters(opt) `
 *
 * TemplateCharacters :
 * TemplateCharacter TemplateCharacters(opt)
 *
 * TemplateCharacter :
 * $ [lookahead  {]
 * \ EscapeSequence
 * SourceCharacter (but not one of ` or \ or $)
 */
function parseTemplate(state, access, bindingType, result, tagged) {
    const cooked = [state.tokenValue];
    // TODO: properly implement raw parts / decide whether we want this
    consume(state, 540715 /* TemplateContinuation */);
    const expressions = [parse(state, access, 62 /* Assign */, bindingType)];
    while ((state.currentToken = scanTemplateTail(state)) !== 540714 /* TemplateTail */) {
        cooked.push(state.tokenValue);
        consume(state, 540715 /* TemplateContinuation */);
        expressions.push(parse(state, access, 62 /* Assign */, bindingType));
    }
    cooked.push(state.tokenValue);
    state.assignable = false;
    if (tagged) {
        nextToken(state);
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TaggedTemplateExpression(cooked, cooked, result, expressions);
    }
    else {
        nextToken(state);
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TemplateExpression(cooked, expressions);
    }
}
function nextToken(state) {
    while (state.index < state.length) {
        state.startIndex = state.index;
        if ((state.currentToken = (CharScanners[state.currentChar](state))) != null) { // a null token means the character must be skipped
            return;
        }
    }
    state.currentToken = 1572864 /* EOF */;
}
function nextChar(state) {
    return state.currentChar = state.input.charCodeAt(++state.index);
}
function scanIdentifier(state) {
    // run to the next non-idPart
    while (IdParts[nextChar(state)])
        ;
    const token = KeywordLookup[state.tokenValue = state.tokenRaw];
    return token === undefined ? 1024 /* Identifier */ : token;
}
function scanNumber(state, isFloat) {
    let char = state.currentChar;
    if (isFloat === false) {
        do {
            char = nextChar(state);
        } while (char <= 57 /* Nine */ && char >= 48 /* Zero */);
        if (char !== 46 /* Dot */) {
            state.tokenValue = parseInt(state.tokenRaw, 10);
            return 8192 /* NumericLiteral */;
        }
        // past this point it's always a float
        char = nextChar(state);
        if (state.index >= state.length) {
            // unless the number ends with a dot - that behaves a little different in native ES expressions
            // but in our AST that behavior has no effect because numbers are always stored in variables
            state.tokenValue = parseInt(state.tokenRaw.slice(0, -1), 10);
            return 8192 /* NumericLiteral */;
        }
    }
    if (char <= 57 /* Nine */ && char >= 48 /* Zero */) {
        do {
            char = nextChar(state);
        } while (char <= 57 /* Nine */ && char >= 48 /* Zero */);
    }
    else {
        state.currentChar = state.input.charCodeAt(--state.index);
    }
    state.tokenValue = parseFloat(state.tokenRaw);
    return 8192 /* NumericLiteral */;
}
function scanString(state) {
    const quote = state.currentChar;
    nextChar(state); // Skip initial quote.
    let unescaped = 0;
    const buffer = new Array();
    let marker = state.index;
    while (state.currentChar !== quote) {
        if (state.currentChar === 92 /* Backslash */) {
            buffer.push(state.input.slice(marker, state.index));
            nextChar(state);
            unescaped = unescapeCode(state.currentChar);
            nextChar(state);
            buffer.push(String.fromCharCode(unescaped));
            marker = state.index;
        }
        else if (state.index >= state.length) {
            throw new Error(`Unterminated quote in string literal: '${state.input}'`);
        }
        else {
            nextChar(state);
        }
    }
    const last = state.input.slice(marker, state.index);
    nextChar(state); // Skip terminating quote.
    // Compute the unescaped string value.
    buffer.push(last);
    const unescapedStr = buffer.join('');
    state.tokenValue = unescapedStr;
    return 4096 /* StringLiteral */;
}
function scanTemplate(state) {
    let tail = true;
    let result = '';
    while (nextChar(state) !== 96 /* Backtick */) {
        if (state.currentChar === 36 /* Dollar */) {
            if ((state.index + 1) < state.length && state.input.charCodeAt(state.index + 1) === 123 /* OpenBrace */) {
                state.index++;
                tail = false;
                break;
            }
            else {
                result += '$';
            }
        }
        else if (state.currentChar === 92 /* Backslash */) {
            result += String.fromCharCode(unescapeCode(nextChar(state)));
        }
        else {
            if (state.index >= state.length) {
                throw new Error(`Unterminated template string: '${state.input}'`);
            }
            result += String.fromCharCode(state.currentChar);
        }
    }
    nextChar(state);
    state.tokenValue = result;
    if (tail) {
        return 540714 /* TemplateTail */;
    }
    return 540715 /* TemplateContinuation */;
}
function scanTemplateTail(state) {
    if (state.index >= state.length) {
        throw new Error(`Unterminated template string: '${state.input}'`);
    }
    state.index--;
    return scanTemplate(state);
}
function consumeOpt(state, token) {
    if (state.currentToken === token) {
        nextToken(state);
        return true;
    }
    return false;
}
function consume(state, token) {
    if (state.currentToken === token) {
        nextToken(state);
    }
    else {
        throw new Error(`Missing expected token: '${state.input}'`);
    }
}
/**
 * Array for mapping tokens to token values. The indices of the values
 * correspond to the token bits 0-38.
 * For this to work properly, the values in the array must be kept in
 * the same order as the token bits.
 * Usage: TokenValues[token & Token.Type]
 */
const TokenValues = [
    $false, $true, $null, $undefined, '$this', '$host', '$parent',
    '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\'', '"',
    '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>',
    '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',
    540714 /* TemplateTail */, 540715 /* TemplateContinuation */,
    'of'
];
const KeywordLookup = Object.create(null);
KeywordLookup.true = 2049 /* TrueKeyword */;
KeywordLookup.null = 2050 /* NullKeyword */;
KeywordLookup.false = 2048 /* FalseKeyword */;
KeywordLookup.undefined = 2051 /* UndefinedKeyword */;
KeywordLookup.$this = 3076 /* ThisScope */;
KeywordLookup.$host = 3077 /* HostScope */;
KeywordLookup.$parent = 3078 /* ParentScope */;
KeywordLookup.in = 1640799 /* InKeyword */;
KeywordLookup.instanceof = 1640800 /* InstanceOfKeyword */;
KeywordLookup.typeof = 34851 /* TypeofKeyword */;
KeywordLookup.void = 34852 /* VoidKeyword */;
KeywordLookup.of = 1051180 /* OfKeyword */;
/**
 * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)
 * Single values are denoted by the second value being a 0
 *
 * Copied from output generated with "node build/generate-unicode.js"
 *
 * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF
 */
const codes = {
    /* [$0-9A-Za_a-z] */
    AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],
    IdStart: /* IdentifierStart */ [0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],
    Digit: /* DecimalNumber */ [0x30, 0x3A],
    Skip: /* Skippable */ [0, 0x21, 0x7F, 0xA1]
};
/**
 * Decompress the ranges into an array of numbers so that the char code
 * can be used as an index to the lookup
 */
function decompress(lookup, $set, compressed, value) {
    const rangeCount = compressed.length;
    for (let i = 0; i < rangeCount; i += 2) {
        const start = compressed[i];
        let end = compressed[i + 1];
        end = end > 0 ? end : start + 1;
        if (lookup) {
            lookup.fill(value, start, end);
        }
        if ($set) {
            for (let ch = start; ch < end; ch++) {
                $set.add(ch);
            }
        }
    }
}
// CharFuncLookup functions
function returnToken(token) {
    return s => {
        nextChar(s);
        return token;
    };
}
const unexpectedCharacter = s => {
    throw new Error(`Unexpected character: '${s.input}'`);
};
unexpectedCharacter.notMapped = true;
// ASCII IdentifierPart lookup
const AsciiIdParts = new Set();
decompress(null, AsciiIdParts, codes.AsciiIdPart, true);
// IdentifierPart lookup
const IdParts = new Uint8Array(0xFFFF);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
decompress(IdParts, null, codes.IdStart, 1);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
decompress(IdParts, null, codes.Digit, 1);
// Character scanning function lookup
const CharScanners = new Array(0xFFFF);
CharScanners.fill(unexpectedCharacter, 0, 0xFFFF);
decompress(CharScanners, null, codes.Skip, s => {
    nextChar(s);
    return null;
});
decompress(CharScanners, null, codes.IdStart, scanIdentifier);
decompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));
CharScanners[34 /* DoubleQuote */] =
    CharScanners[39 /* SingleQuote */] = s => {
        return scanString(s);
    };
CharScanners[96 /* Backtick */] = s => {
    return scanTemplate(s);
};
// !, !=, !==
CharScanners[33 /* Exclamation */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 32809 /* Exclamation */;
    }
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638680 /* ExclamationEquals */;
    }
    nextChar(s);
    return 1638682 /* ExclamationEqualsEquals */;
};
// =, ==, ===
CharScanners[61 /* Equals */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 1048616 /* Equals */;
    }
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638679 /* EqualsEquals */;
    }
    nextChar(s);
    return 1638681 /* EqualsEqualsEquals */;
};
// &, &&
CharScanners[38 /* Ampersand */] = s => {
    if (nextChar(s) !== 38 /* Ampersand */) {
        return 1572883 /* Ampersand */;
    }
    nextChar(s);
    return 1638614 /* AmpersandAmpersand */;
};
// |, ||
CharScanners[124 /* Bar */] = s => {
    if (nextChar(s) !== 124 /* Bar */) {
        return 1572884 /* Bar */;
    }
    nextChar(s);
    return 1638549 /* BarBar */;
};
// .
CharScanners[46 /* Dot */] = s => {
    if (nextChar(s) <= 57 /* Nine */ && s.currentChar >= 48 /* Zero */) {
        return scanNumber(s, true);
    }
    return 16393 /* Dot */;
};
// <, <=
CharScanners[60 /* LessThan */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638747 /* LessThan */;
    }
    nextChar(s);
    return 1638749 /* LessThanEquals */;
};
// >, >=
CharScanners[62 /* GreaterThan */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638748 /* GreaterThan */;
    }
    nextChar(s);
    return 1638750 /* GreaterThanEquals */;
};
CharScanners[37 /* Percent */] = returnToken(1638886 /* Percent */);
CharScanners[40 /* OpenParen */] = returnToken(671751 /* OpenParen */);
CharScanners[41 /* CloseParen */] = returnToken(1835019 /* CloseParen */);
CharScanners[42 /* Asterisk */] = returnToken(1638885 /* Asterisk */);
CharScanners[43 /* Plus */] = returnToken(623009 /* Plus */);
CharScanners[44 /* Comma */] = returnToken(1572876 /* Comma */);
CharScanners[45 /* Minus */] = returnToken(623010 /* Minus */);
CharScanners[47 /* Slash */] = returnToken(1638887 /* Slash */);
CharScanners[58 /* Colon */] = returnToken(1572879 /* Colon */);
CharScanners[63 /* Question */] = returnToken(1572880 /* Question */);
CharScanners[91 /* OpenBracket */] = returnToken(671757 /* OpenBracket */);
CharScanners[93 /* CloseBracket */] = returnToken(1835022 /* CloseBracket */);
CharScanners[123 /* OpenBrace */] = returnToken(131080 /* OpenBrace */);
CharScanners[125 /* CloseBrace */] = returnToken(1835018 /* CloseBrace */);
//# sourceMappingURL=expression-parser.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IPlatform": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform,
/* harmony export */   "Platform": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Platform,
/* harmony export */   "TaskQueue": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueue,
/* harmony export */   "Task": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Task,
/* harmony export */   "TaskAbortError": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskAbortError,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueuePriority,
/* harmony export */   "TaskStatus": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskStatus,
/* harmony export */   "alias": () => /* reexport safe */ _alias_js__WEBPACK_IMPORTED_MODULE_2__.alias,
/* harmony export */   "registerAliases": () => /* reexport safe */ _alias_js__WEBPACK_IMPORTED_MODULE_2__.registerAliases,
/* harmony export */   "ExpressionKind": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ExpressionKind,
/* harmony export */   "CallFunctionExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CallFunctionExpression,
/* harmony export */   "CustomExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CustomExpression,
/* harmony export */   "BindingBehaviorExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.BindingBehaviorExpression,
/* harmony export */   "ValueConverterExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ValueConverterExpression,
/* harmony export */   "AssignExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AssignExpression,
/* harmony export */   "ConditionalExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ConditionalExpression,
/* harmony export */   "AccessThisExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessThisExpression,
/* harmony export */   "AccessScopeExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessScopeExpression,
/* harmony export */   "AccessMemberExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessMemberExpression,
/* harmony export */   "AccessKeyedExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessKeyedExpression,
/* harmony export */   "CallScopeExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CallScopeExpression,
/* harmony export */   "CallMemberExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CallMemberExpression,
/* harmony export */   "BinaryExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.BinaryExpression,
/* harmony export */   "UnaryExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.UnaryExpression,
/* harmony export */   "PrimitiveLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.PrimitiveLiteralExpression,
/* harmony export */   "HtmlLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.HtmlLiteralExpression,
/* harmony export */   "ArrayLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ArrayLiteralExpression,
/* harmony export */   "ObjectLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ObjectLiteralExpression,
/* harmony export */   "TemplateExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.TemplateExpression,
/* harmony export */   "TaggedTemplateExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.TaggedTemplateExpression,
/* harmony export */   "ArrayBindingPattern": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ArrayBindingPattern,
/* harmony export */   "ObjectBindingPattern": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ObjectBindingPattern,
/* harmony export */   "BindingIdentifier": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.BindingIdentifier,
/* harmony export */   "ForOfStatement": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ForOfStatement,
/* harmony export */   "Interpolation": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.Interpolation,
/* harmony export */   "connectable": () => /* reexport safe */ _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__.connectable,
/* harmony export */   "BindingMediator": () => /* reexport safe */ _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__.BindingMediator,
/* harmony export */   "BindingObserverRecord": () => /* reexport safe */ _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__.BindingObserverRecord,
/* harmony export */   "IExpressionParser": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.IExpressionParser,
/* harmony export */   "BindingType": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.BindingType,
/* harmony export */   "parseExpression": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.parseExpression,
/* harmony export */   "Char": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.Char,
/* harmony export */   "Access": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.Access,
/* harmony export */   "Precedence": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.Precedence,
/* harmony export */   "parse": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.parse,
/* harmony export */   "ParserState": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.ParserState,
/* harmony export */   "ArrayObserver": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.ArrayObserver,
/* harmony export */   "ArrayIndexObserver": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.ArrayIndexObserver,
/* harmony export */   "enableArrayObservation": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.enableArrayObservation,
/* harmony export */   "disableArrayObservation": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.disableArrayObservation,
/* harmony export */   "applyMutationsToIndices": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.applyMutationsToIndices,
/* harmony export */   "synchronizeIndices": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.synchronizeIndices,
/* harmony export */   "MapObserver": () => /* reexport safe */ _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__.MapObserver,
/* harmony export */   "enableMapObservation": () => /* reexport safe */ _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__.enableMapObservation,
/* harmony export */   "disableMapObservation": () => /* reexport safe */ _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__.disableMapObservation,
/* harmony export */   "SetObserver": () => /* reexport safe */ _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__.SetObserver,
/* harmony export */   "enableSetObservation": () => /* reexport safe */ _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__.enableSetObservation,
/* harmony export */   "disableSetObservation": () => /* reexport safe */ _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__.disableSetObservation,
/* harmony export */   "BindingContext": () => /* reexport safe */ _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__.BindingContext,
/* harmony export */   "Scope": () => /* reexport safe */ _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__.Scope,
/* harmony export */   "OverrideContext": () => /* reexport safe */ _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__.OverrideContext,
/* harmony export */   "CollectionLengthObserver": () => /* reexport safe */ _observation_collection_length_observer_js__WEBPACK_IMPORTED_MODULE_10__.CollectionLengthObserver,
/* harmony export */   "CollectionSizeObserver": () => /* reexport safe */ _observation_collection_length_observer_js__WEBPACK_IMPORTED_MODULE_10__.CollectionSizeObserver,
/* harmony export */   "ComputedObserver": () => /* reexport safe */ _observation_computed_observer_js__WEBPACK_IMPORTED_MODULE_11__.ComputedObserver,
/* harmony export */   "IDirtyChecker": () => /* reexport safe */ _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__.IDirtyChecker,
/* harmony export */   "DirtyCheckProperty": () => /* reexport safe */ _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__.DirtyCheckProperty,
/* harmony export */   "DirtyCheckSettings": () => /* reexport safe */ _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__.DirtyCheckSettings,
/* harmony export */   "observable": () => /* reexport safe */ _observation_observable_js__WEBPACK_IMPORTED_MODULE_13__.observable,
/* harmony export */   "IObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.IObserverLocator,
/* harmony export */   "INodeObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.INodeObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.getCollectionObserver,
/* harmony export */   "ObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.ObserverLocator,
/* harmony export */   "PrimitiveObserver": () => /* reexport safe */ _observation_primitive_observer_js__WEBPACK_IMPORTED_MODULE_15__.PrimitiveObserver,
/* harmony export */   "PropertyAccessor": () => /* reexport safe */ _observation_property_accessor_js__WEBPACK_IMPORTED_MODULE_16__.PropertyAccessor,
/* harmony export */   "ProxyObservable": () => /* reexport safe */ _observation_proxy_observation_js__WEBPACK_IMPORTED_MODULE_17__.ProxyObservable,
/* harmony export */   "SetterObserver": () => /* reexport safe */ _observation_setter_observer_js__WEBPACK_IMPORTED_MODULE_18__.SetterObserver,
/* harmony export */   "ISignaler": () => /* reexport safe */ _observation_signaler_js__WEBPACK_IMPORTED_MODULE_19__.ISignaler,
/* harmony export */   "SubscriberRecord": () => /* reexport safe */ _observation_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_20__.SubscriberRecord,
/* harmony export */   "subscriberCollection": () => /* reexport safe */ _observation_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_20__.subscriberCollection,
/* harmony export */   "ConnectableSwitcher": () => /* reexport safe */ _observation_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_21__.ConnectableSwitcher,
/* harmony export */   "bindingBehavior": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.bindingBehavior,
/* harmony export */   "BindingBehavior": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehavior,
/* harmony export */   "BindingBehaviorDefinition": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehaviorDefinition,
/* harmony export */   "BindingInterceptor": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingInterceptor,
/* harmony export */   "BindingBehaviorFactory": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehaviorFactory,
/* harmony export */   "BindingBehaviorStrategy": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehaviorStrategy,
/* harmony export */   "ValueConverter": () => /* reexport safe */ _value_converter_js__WEBPACK_IMPORTED_MODULE_23__.ValueConverter,
/* harmony export */   "ValueConverterDefinition": () => /* reexport safe */ _value_converter_js__WEBPACK_IMPORTED_MODULE_23__.ValueConverterDefinition,
/* harmony export */   "valueConverter": () => /* reexport safe */ _value_converter_js__WEBPACK_IMPORTED_MODULE_23__.valueConverter,
/* harmony export */   "BindingMode": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.BindingMode,
/* harmony export */   "LifecycleFlags": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.LifecycleFlags,
/* harmony export */   "AccessorType": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.AccessorType,
/* harmony export */   "CollectionKind": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.CollectionKind,
/* harmony export */   "DelegationStrategy": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.DelegationStrategy,
/* harmony export */   "isIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.isIndexMap,
/* harmony export */   "copyIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.copyIndexMap,
/* harmony export */   "cloneIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.cloneIndexMap,
/* harmony export */   "createIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.createIndexMap
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");
/* harmony import */ var _alias_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./alias.js */ "./node_modules/@aurelia/runtime/dist/esm/alias.js");
/* harmony import */ var _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./binding/ast.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/ast.js");
/* harmony import */ var _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binding/connectable.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js");
/* harmony import */ var _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding/expression-parser.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/expression-parser.js");
/* harmony import */ var _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./observation/array-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js");
/* harmony import */ var _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./observation/map-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js");
/* harmony import */ var _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./observation/set-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js");
/* harmony import */ var _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./observation/binding-context.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js");
/* harmony import */ var _observation_collection_length_observer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./observation/collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _observation_computed_observer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./observation/computed-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js");
/* harmony import */ var _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./observation/dirty-checker.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./observation/observable.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/observable.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./observation/observer-locator.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/observer-locator.js");
/* harmony import */ var _observation_primitive_observer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./observation/primitive-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js");
/* harmony import */ var _observation_property_accessor_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./observation/property-accessor.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js");
/* harmony import */ var _observation_proxy_observation_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./observation/proxy-observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js");
/* harmony import */ var _observation_setter_observer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./observation/setter-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js");
/* harmony import */ var _observation_signaler_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./observation/signaler.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js");
/* harmony import */ var _observation_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./observation/subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _observation_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./observation/connectable-switcher.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js");
/* harmony import */ var _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./binding-behavior.js */ "./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js");
/* harmony import */ var _value_converter_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./value-converter.js */ "./node_modules/@aurelia/runtime/dist/esm/value-converter.js");
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");

























//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingMode": () => /* binding */ BindingMode,
/* harmony export */   "LifecycleFlags": () => /* binding */ LifecycleFlags,
/* harmony export */   "SubscriberFlags": () => /* binding */ SubscriberFlags,
/* harmony export */   "DelegationStrategy": () => /* binding */ DelegationStrategy,
/* harmony export */   "CollectionKind": () => /* binding */ CollectionKind,
/* harmony export */   "AccessorType": () => /* binding */ AccessorType,
/* harmony export */   "copyIndexMap": () => /* binding */ copyIndexMap,
/* harmony export */   "createIndexMap": () => /* binding */ createIndexMap,
/* harmony export */   "cloneIndexMap": () => /* binding */ cloneIndexMap,
/* harmony export */   "isIndexMap": () => /* binding */ isIndexMap
/* harmony export */ });
/*
* Note: the oneTime binding now has a non-zero value for 2 reasons:
*  - plays nicer with bitwise operations (more consistent code, more explicit settings)
*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model
*
* Furthermore, the "default" mode would be for simple ".bind" expressions to make it explicit for our logic that the default is being used.
* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it
*/
var BindingMode;
(function (BindingMode) {
    BindingMode[BindingMode["oneTime"] = 1] = "oneTime";
    BindingMode[BindingMode["toView"] = 2] = "toView";
    BindingMode[BindingMode["fromView"] = 4] = "fromView";
    BindingMode[BindingMode["twoWay"] = 6] = "twoWay";
    BindingMode[BindingMode["default"] = 8] = "default";
})(BindingMode || (BindingMode = {}));
var LifecycleFlags;
(function (LifecycleFlags) {
    LifecycleFlags[LifecycleFlags["none"] = 0] = "none";
    // Bitmask for flags that need to be stored on a binding during $bind for mutation
    // callbacks outside of $bind
    LifecycleFlags[LifecycleFlags["persistentBindingFlags"] = 15367] = "persistentBindingFlags";
    LifecycleFlags[LifecycleFlags["allowParentScopeTraversal"] = 1024] = "allowParentScopeTraversal";
    LifecycleFlags[LifecycleFlags["observeLeafPropertiesOnly"] = 2048] = "observeLeafPropertiesOnly";
    LifecycleFlags[LifecycleFlags["targetObserverFlags"] = 12295] = "targetObserverFlags";
    LifecycleFlags[LifecycleFlags["noFlush"] = 4096] = "noFlush";
    LifecycleFlags[LifecycleFlags["persistentTargetObserverQueue"] = 8192] = "persistentTargetObserverQueue";
    LifecycleFlags[LifecycleFlags["bindingStrategy"] = 7] = "bindingStrategy";
    LifecycleFlags[LifecycleFlags["getterSetterStrategy"] = 1] = "getterSetterStrategy";
    LifecycleFlags[LifecycleFlags["proxyStrategy"] = 2] = "proxyStrategy";
    LifecycleFlags[LifecycleFlags["isStrictBindingStrategy"] = 4] = "isStrictBindingStrategy";
    LifecycleFlags[LifecycleFlags["update"] = 24] = "update";
    LifecycleFlags[LifecycleFlags["updateTarget"] = 8] = "updateTarget";
    LifecycleFlags[LifecycleFlags["updateSource"] = 16] = "updateSource";
    LifecycleFlags[LifecycleFlags["from"] = 96] = "from";
    LifecycleFlags[LifecycleFlags["fromBind"] = 32] = "fromBind";
    LifecycleFlags[LifecycleFlags["fromUnbind"] = 64] = "fromUnbind";
    LifecycleFlags[LifecycleFlags["mustEvaluate"] = 128] = "mustEvaluate";
    LifecycleFlags[LifecycleFlags["isTraversingParentScope"] = 256] = "isTraversingParentScope";
    LifecycleFlags[LifecycleFlags["dispose"] = 512] = "dispose";
})(LifecycleFlags || (LifecycleFlags = {}));
/** @internal */
var SubscriberFlags;
(function (SubscriberFlags) {
    SubscriberFlags[SubscriberFlags["None"] = 0] = "None";
    SubscriberFlags[SubscriberFlags["Subscriber0"] = 1] = "Subscriber0";
    SubscriberFlags[SubscriberFlags["Subscriber1"] = 2] = "Subscriber1";
    SubscriberFlags[SubscriberFlags["Subscriber2"] = 4] = "Subscriber2";
    SubscriberFlags[SubscriberFlags["SubscribersRest"] = 8] = "SubscribersRest";
    SubscriberFlags[SubscriberFlags["Any"] = 15] = "Any";
})(SubscriberFlags || (SubscriberFlags = {}));
var DelegationStrategy;
(function (DelegationStrategy) {
    DelegationStrategy[DelegationStrategy["none"] = 0] = "none";
    DelegationStrategy[DelegationStrategy["capturing"] = 1] = "capturing";
    DelegationStrategy[DelegationStrategy["bubbling"] = 2] = "bubbling";
})(DelegationStrategy || (DelegationStrategy = {}));
var CollectionKind;
(function (CollectionKind) {
    CollectionKind[CollectionKind["indexed"] = 8] = "indexed";
    CollectionKind[CollectionKind["keyed"] = 4] = "keyed";
    CollectionKind[CollectionKind["array"] = 9] = "array";
    CollectionKind[CollectionKind["map"] = 6] = "map";
    CollectionKind[CollectionKind["set"] = 7] = "set";
})(CollectionKind || (CollectionKind = {}));
var AccessorType;
(function (AccessorType) {
    AccessorType[AccessorType["None"] = 0] = "None";
    AccessorType[AccessorType["Observer"] = 1] = "Observer";
    AccessorType[AccessorType["Node"] = 2] = "Node";
    // misc characteristic of accessors/observers when update
    //
    // by default, everything is synchronous
    // except changes that are supposed to cause reflow/heavy computation
    // an observer can use this flag to signal binding that don't carelessly tell it to update
    // queue it instead
    // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
    // todo: https://csstriggers.com/
    AccessorType[AccessorType["Layout"] = 4] = "Layout";
    // by default, everything is an object
    // eg: a property is accessed on an object
    // unless explicitly not so
    AccessorType[AccessorType["Primtive"] = 8] = "Primtive";
    AccessorType[AccessorType["Array"] = 18] = "Array";
    AccessorType[AccessorType["Set"] = 34] = "Set";
    AccessorType[AccessorType["Map"] = 66] = "Map";
})(AccessorType || (AccessorType = {}));
function copyIndexMap(existing, deletedItems) {
    const { length } = existing;
    const arr = Array(length);
    let i = 0;
    while (i < length) {
        arr[i] = existing[i];
        ++i;
    }
    if (deletedItems !== void 0) {
        arr.deletedItems = deletedItems.slice(0);
    }
    else if (existing.deletedItems !== void 0) {
        arr.deletedItems = existing.deletedItems.slice(0);
    }
    else {
        arr.deletedItems = [];
    }
    arr.isIndexMap = true;
    return arr;
}
function createIndexMap(length = 0) {
    const arr = Array(length);
    let i = 0;
    while (i < length) {
        arr[i] = i++;
    }
    arr.deletedItems = [];
    arr.isIndexMap = true;
    return arr;
}
function cloneIndexMap(indexMap) {
    const clone = indexMap.slice();
    clone.deletedItems = indexMap.deletedItems.slice();
    clone.isIndexMap = true;
    return clone;
}
function isIndexMap(value) {
    return value instanceof Array && value.isIndexMap === true;
}
//# sourceMappingURL=observation.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableArrayObservation": () => /* binding */ enableArrayObservation,
/* harmony export */   "disableArrayObservation": () => /* binding */ disableArrayObservation,
/* harmony export */   "ArrayObserver": () => /* binding */ ArrayObserver,
/* harmony export */   "ArrayIndexObserver": () => /* binding */ ArrayIndexObserver,
/* harmony export */   "getArrayObserver": () => /* binding */ getArrayObserver,
/* harmony export */   "applyMutationsToIndices": () => /* binding */ applyMutationsToIndices,
/* harmony export */   "synchronizeIndices": () => /* binding */ synchronizeIndices
/* harmony export */ });
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");
/* harmony import */ var _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");




const observerLookup = new WeakMap();
// https://tc39.github.io/ecma262/#sec-sortcompare
function sortCompare(x, y) {
    if (x === y) {
        return 0;
    }
    x = x === null ? 'null' : x.toString();
    y = y === null ? 'null' : y.toString();
    return x < y ? -1 : 1;
}
function preSortCompare(x, y) {
    if (x === void 0) {
        if (y === void 0) {
            return 0;
        }
        else {
            return 1;
        }
    }
    if (y === void 0) {
        return -1;
    }
    return 0;
}
function insertionSort(arr, indexMap, from, to, compareFn) {
    let velement, ielement, vtmp, itmp, order;
    let i, j;
    for (i = from + 1; i < to; i++) {
        velement = arr[i];
        ielement = indexMap[i];
        for (j = i - 1; j >= from; j--) {
            vtmp = arr[j];
            itmp = indexMap[j];
            order = compareFn(vtmp, velement);
            if (order > 0) {
                arr[j + 1] = vtmp;
                indexMap[j + 1] = itmp;
            }
            else {
                break;
            }
        }
        arr[j + 1] = velement;
        indexMap[j + 1] = ielement;
    }
}
function quickSort(arr, indexMap, from, to, compareFn) {
    let thirdIndex = 0, i = 0;
    let v0, v1, v2;
    let i0, i1, i2;
    let c01, c02, c12;
    let vtmp, itmp;
    let vpivot, ipivot, lowEnd, highStart;
    let velement, ielement, order, vtopElement;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (to - from <= 10) {
            insertionSort(arr, indexMap, from, to, compareFn);
            return;
        }
        thirdIndex = from + ((to - from) >> 1);
        v0 = arr[from];
        i0 = indexMap[from];
        v1 = arr[to - 1];
        i1 = indexMap[to - 1];
        v2 = arr[thirdIndex];
        i2 = indexMap[thirdIndex];
        c01 = compareFn(v0, v1);
        if (c01 > 0) {
            vtmp = v0;
            itmp = i0;
            v0 = v1;
            i0 = i1;
            v1 = vtmp;
            i1 = itmp;
        }
        c02 = compareFn(v0, v2);
        if (c02 >= 0) {
            vtmp = v0;
            itmp = i0;
            v0 = v2;
            i0 = i2;
            v2 = v1;
            i2 = i1;
            v1 = vtmp;
            i1 = itmp;
        }
        else {
            c12 = compareFn(v1, v2);
            if (c12 > 0) {
                vtmp = v1;
                itmp = i1;
                v1 = v2;
                i1 = i2;
                v2 = vtmp;
                i2 = itmp;
            }
        }
        arr[from] = v0;
        indexMap[from] = i0;
        arr[to - 1] = v2;
        indexMap[to - 1] = i2;
        vpivot = v1;
        ipivot = i1;
        lowEnd = from + 1;
        highStart = to - 1;
        arr[thirdIndex] = arr[lowEnd];
        indexMap[thirdIndex] = indexMap[lowEnd];
        arr[lowEnd] = vpivot;
        indexMap[lowEnd] = ipivot;
        partition: for (i = lowEnd + 1; i < highStart; i++) {
            velement = arr[i];
            ielement = indexMap[i];
            order = compareFn(velement, vpivot);
            if (order < 0) {
                arr[i] = arr[lowEnd];
                indexMap[i] = indexMap[lowEnd];
                arr[lowEnd] = velement;
                indexMap[lowEnd] = ielement;
                lowEnd++;
            }
            else if (order > 0) {
                do {
                    highStart--;
                    // eslint-disable-next-line eqeqeq
                    if (highStart == i) {
                        break partition;
                    }
                    vtopElement = arr[highStart];
                    order = compareFn(vtopElement, vpivot);
                } while (order > 0);
                arr[i] = arr[highStart];
                indexMap[i] = indexMap[highStart];
                arr[highStart] = velement;
                indexMap[highStart] = ielement;
                if (order < 0) {
                    velement = arr[i];
                    ielement = indexMap[i];
                    arr[i] = arr[lowEnd];
                    indexMap[i] = indexMap[lowEnd];
                    arr[lowEnd] = velement;
                    indexMap[lowEnd] = ielement;
                    lowEnd++;
                }
            }
        }
        if (to - highStart < lowEnd - from) {
            quickSort(arr, indexMap, highStart, to, compareFn);
            to = lowEnd;
        }
        else {
            quickSort(arr, indexMap, from, lowEnd, compareFn);
            from = highStart;
        }
    }
}
const proto = Array.prototype;
const $push = proto.push;
const $unshift = proto.unshift;
const $pop = proto.pop;
const $shift = proto.shift;
const $splice = proto.splice;
const $reverse = proto.reverse;
const $sort = proto.sort;
const native = { push: $push, unshift: $unshift, pop: $pop, shift: $shift, splice: $splice, reverse: $reverse, sort: $sort };
const methods = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'];
const observe = {
    // https://tc39.github.io/ecma262/#sec-array.prototype.push
    push: function (...args) {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $push.apply(this, args);
        }
        const len = this.length;
        const argCount = args.length;
        if (argCount === 0) {
            return len;
        }
        this.length = o.indexMap.length = len + argCount;
        let i = len;
        while (i < this.length) {
            this[i] = args[i - len];
            o.indexMap[i] = -2;
            i++;
        }
        o.notify();
        return this.length;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.unshift
    unshift: function (...args) {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $unshift.apply(this, args);
        }
        const argCount = args.length;
        const inserts = new Array(argCount);
        let i = 0;
        while (i < argCount) {
            inserts[i++] = -2;
        }
        $unshift.apply(o.indexMap, inserts);
        const len = $unshift.apply(this, args);
        o.notify();
        return len;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.pop
    pop: function () {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $pop.call(this);
        }
        const indexMap = o.indexMap;
        const element = $pop.call(this);
        // only mark indices as deleted if they actually existed in the original array
        const index = indexMap.length - 1;
        if (indexMap[index] > -1) {
            indexMap.deletedItems.push(indexMap[index]);
        }
        $pop.call(indexMap);
        o.notify();
        return element;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.shift
    shift: function () {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $shift.call(this);
        }
        const indexMap = o.indexMap;
        const element = $shift.call(this);
        // only mark indices as deleted if they actually existed in the original array
        if (indexMap[0] > -1) {
            indexMap.deletedItems.push(indexMap[0]);
        }
        $shift.call(indexMap);
        o.notify();
        return element;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.splice
    splice: function (...args) {
        const start = args[0];
        const deleteCount = args[1];
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $splice.apply(this, args);
        }
        const len = this.length;
        const relativeStart = start | 0;
        const actualStart = relativeStart < 0 ? Math.max((len + relativeStart), 0) : Math.min(relativeStart, len);
        const indexMap = o.indexMap;
        const argCount = args.length;
        const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;
        if (actualDeleteCount > 0) {
            let i = actualStart;
            const to = i + actualDeleteCount;
            while (i < to) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                i++;
            }
        }
        if (argCount > 2) {
            const itemCount = argCount - 2;
            const inserts = new Array(itemCount);
            let i = 0;
            while (i < itemCount) {
                inserts[i++] = -2;
            }
            $splice.call(indexMap, start, deleteCount, ...inserts);
        }
        else {
            $splice.apply(indexMap, args);
        }
        const deleted = $splice.apply(this, args);
        o.notify();
        return deleted;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
    reverse: function () {
        const o = observerLookup.get(this);
        if (o === void 0) {
            $reverse.call(this);
            return this;
        }
        const len = this.length;
        const middle = (len / 2) | 0;
        let lower = 0;
        while (lower !== middle) {
            const upper = len - lower - 1;
            const lowerValue = this[lower];
            const lowerIndex = o.indexMap[lower];
            const upperValue = this[upper];
            const upperIndex = o.indexMap[upper];
            this[lower] = upperValue;
            o.indexMap[lower] = upperIndex;
            this[upper] = lowerValue;
            o.indexMap[upper] = lowerIndex;
            lower++;
        }
        o.notify();
        return this;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.sort
    // https://github.com/v8/v8/blob/master/src/js/array.js
    sort: function (compareFn) {
        const o = observerLookup.get(this);
        if (o === void 0) {
            $sort.call(this, compareFn);
            return this;
        }
        const len = this.length;
        if (len < 2) {
            return this;
        }
        quickSort(this, o.indexMap, 0, len, preSortCompare);
        let i = 0;
        while (i < len) {
            if (this[i] === void 0) {
                break;
            }
            i++;
        }
        if (compareFn === void 0 || typeof compareFn !== 'function' /* spec says throw a TypeError, should we do that too? */) {
            compareFn = sortCompare;
        }
        quickSort(this, o.indexMap, 0, i, compareFn);
        o.notify();
        return this;
    }
};
for (const method of methods) {
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });
}
let enableArrayObservationCalled = false;
function enableArrayObservation() {
    for (const method of methods) {
        if (proto[method].observing !== true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.defineHiddenProp)(proto, method, observe[method]);
        }
    }
}
function disableArrayObservation() {
    for (const method of methods) {
        if (proto[method].observing === true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.defineHiddenProp)(proto, method, native[method]);
        }
    }
}
class ArrayObserver {
    constructor(array) {
        this.type = 18 /* Array */;
        if (!enableArrayObservationCalled) {
            enableArrayObservationCalled = true;
            enableArrayObservation();
        }
        this.indexObservers = {};
        this.collection = array;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(array.length);
        this.lenObs = void 0;
        observerLookup.set(array, this);
    }
    notify() {
        const indexMap = this.indexMap;
        const length = this.collection.length;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(length);
        this.subs.notifyCollection(indexMap, 8 /* updateTarget */);
    }
    getLengthObserver() {
        return this.lenObs ?? (this.lenObs = new _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__.CollectionLengthObserver(this));
    }
    getIndexObserver(index) {
        var _a;
        // It's unnecessary to destroy/recreate index observer all the time,
        // so just create once, and add/remove instead
        return (_a = this.indexObservers)[index] ?? (_a[index] = new ArrayIndexObserver(this, index));
    }
}
class ArrayIndexObserver {
    constructor(owner, index) {
        this.owner = owner;
        this.index = index;
        this.value = this.getValue();
    }
    getValue() {
        return this.owner.collection[this.index];
    }
    setValue(newValue, flags) {
        if (newValue === this.getValue()) {
            return;
        }
        const arrayObserver = this.owner;
        const index = this.index;
        const indexMap = arrayObserver.indexMap;
        if (indexMap[index] > -1) {
            indexMap.deletedItems.push(indexMap[index]);
        }
        indexMap[index] = -2;
        // do not need to update current value here
        // as it will be updated inside handle collection change
        arrayObserver.collection[index] = newValue;
        arrayObserver.notify();
    }
    /**
     * From interface `ICollectionSubscriber`
     */
    handleCollectionChange(indexMap, flags) {
        const index = this.index;
        const noChange = indexMap[index] === index;
        if (noChange) {
            return;
        }
        const prevValue = this.value;
        const currValue = this.value = this.getValue();
        // hmm
        if (prevValue !== currValue) {
            this.subs.notify(currValue, prevValue, flags);
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.owner.subscribe(this);
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.owner.unsubscribe(this);
        }
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(ArrayObserver);
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(ArrayIndexObserver);
function getArrayObserver(array) {
    let observer = observerLookup.get(array);
    if (observer === void 0) {
        observer = new ArrayObserver(array);
    }
    return observer;
}
/**
 * Applies offsets to the non-negative indices in the IndexMap
 * based on added and deleted items relative to those indices.
 *
 * e.g. turn `[-2, 0, 1]` into `[-2, 1, 2]`, allowing the values at the indices to be
 * used for sorting/reordering items if needed
 */
function applyMutationsToIndices(indexMap) {
    let offset = 0;
    let j = 0;
    const len = indexMap.length;
    for (let i = 0; i < len; ++i) {
        while (indexMap.deletedItems[j] <= i - offset) {
            ++j;
            --offset;
        }
        if (indexMap[i] === -2) {
            ++offset;
        }
        else {
            indexMap[i] += offset;
        }
    }
}
/**
 * After `applyMutationsToIndices`, this function can be used to reorder items in a derived
 * array (e.g.  the items in the `views` in the repeater are derived from the `items` property)
 */
function synchronizeIndices(items, indexMap) {
    const copy = items.slice();
    const len = indexMap.length;
    let to = 0;
    let from = 0;
    while (to < len) {
        from = indexMap[to];
        if (from !== -2) {
            items[to] = copy[from];
        }
        ++to;
    }
}
//# sourceMappingURL=array-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingContext": () => /* binding */ BindingContext,
/* harmony export */   "Scope": () => /* binding */ Scope,
/* harmony export */   "OverrideContext": () => /* binding */ OverrideContext
/* harmony export */ });
const marker = Object.freeze({});
class BindingContext {
    constructor(keyOrObj, value) {
        if (keyOrObj !== void 0) {
            if (value !== void 0) {
                // if value is defined then it's just a property and a value to initialize with
                this[keyOrObj] = value;
            }
            else {
                // can either be some random object or another bindingContext to clone from
                for (const prop in keyOrObj) {
                    if (Object.prototype.hasOwnProperty.call(keyOrObj, prop)) {
                        this[prop] = keyOrObj[prop];
                    }
                }
            }
        }
    }
    static create(keyOrObj, value) {
        return new BindingContext(keyOrObj, value);
    }
    static get(scope, name, ancestor, flags, hostScope) {
        if (scope == null && hostScope == null) {
            throw new Error(`Scope is ${scope} and HostScope is ${hostScope}.`);
        }
        const hasOtherScope = hostScope !== scope && hostScope != null;
        /* eslint-disable jsdoc/check-indentation */
        /**
         * This fallback is needed to support the following case:
         * <div au-slot="s1">
         *  <let outer-host.bind="$host"></let>
         *  ${outerHost.prop}
         * </div>
         * To enable the `let` binding for 'hostScope', the property is added to `hostScope.overrideContext`. That enables us to use such let binding also inside a repeater.
         * However, as the expression `${outerHost.prop}` does not start with `$host`, it is considered that to evaluate this expression, we don't need the access to hostScope.
         * This artifact raises the need for this fallback.
         */
        /* eslint-enable jsdoc/check-indentation */
        let context = chooseContext(scope, name, ancestor);
        if (context !== null
            && ((context == null ? false : name in context)
                || !hasOtherScope)) {
            return context;
        }
        if (hasOtherScope) {
            context = chooseContext(hostScope, name, ancestor);
            if (context !== null) {
                return context;
            }
        }
        // still nothing found. return the root binding context (or null
        // if this is a parent scope traversal, to ensure we fall back to the
        // correct level)
        if (flags & 256 /* isTraversingParentScope */) {
            return marker;
        }
        return scope.bindingContext || scope.overrideContext;
    }
}
function chooseContext(scope, name, ancestor) {
    let overrideContext = scope.overrideContext;
    let currentScope = scope;
    if (ancestor > 0) {
        // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)
        while (ancestor > 0) {
            ancestor--;
            currentScope = currentScope.parentScope;
            if (currentScope?.overrideContext == null) {
                return void 0;
            }
        }
        overrideContext = currentScope.overrideContext;
        return name in overrideContext ? overrideContext : overrideContext.bindingContext;
    }
    // traverse the context and it's ancestors, searching for a context that has the name.
    while (!currentScope?.isComponentBoundary
        && overrideContext
        && !(name in overrideContext)
        && !(overrideContext.bindingContext
            && name in overrideContext.bindingContext)) {
        currentScope = currentScope.parentScope ?? null;
        overrideContext = currentScope?.overrideContext ?? null;
    }
    if (overrideContext) {
        return name in overrideContext ? overrideContext : overrideContext.bindingContext;
    }
    return null;
}
class Scope {
    constructor(parentScope, bindingContext, overrideContext, isComponentBoundary) {
        this.parentScope = parentScope;
        this.bindingContext = bindingContext;
        this.overrideContext = overrideContext;
        this.isComponentBoundary = isComponentBoundary;
    }
    static create(bc, oc, isComponentBoundary) {
        return new Scope(null, bc, oc == null ? OverrideContext.create(bc) : oc, isComponentBoundary ?? false);
    }
    static fromOverride(oc) {
        if (oc == null) {
            throw new Error(`OverrideContext is ${oc}`);
        }
        return new Scope(null, oc.bindingContext, oc, false);
    }
    static fromParent(ps, bc) {
        if (ps == null) {
            throw new Error(`ParentScope is ${ps}`);
        }
        return new Scope(ps, bc, OverrideContext.create(bc), false);
    }
}
class OverrideContext {
    constructor(bindingContext) {
        this.bindingContext = bindingContext;
    }
    static create(bc) {
        return new OverrideContext(bc);
    }
}
//# sourceMappingURL=binding-context.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionLengthObserver": () => /* binding */ CollectionLengthObserver,
/* harmony export */   "CollectionSizeObserver": () => /* binding */ CollectionSizeObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");



class CollectionLengthObserver {
    constructor(owner) {
        this.owner = owner;
        this.type = 18 /* Array */;
        this.value = (this.obj = owner.collection).length;
    }
    getValue() {
        return this.obj.length;
    }
    setValue(newValue, flags) {
        const currentValue = this.value;
        // if in the template, length is two-way bound directly
        // then there's a chance that the new value is invalid
        // add a guard so that we don't accidentally broadcast invalid values
        if (newValue !== currentValue && (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isArrayIndex)(newValue)) {
            if ((flags & 4096 /* noFlush */) === 0) {
                this.obj.length = newValue;
            }
            this.value = newValue;
            this.subs.notify(newValue, currentValue, flags | 8 /* updateTarget */);
        }
    }
    handleCollectionChange(_, flags) {
        const oldValue = this.value;
        const value = this.obj.length;
        if ((this.value = value) !== oldValue) {
            this.subs.notify(value, oldValue, flags);
        }
    }
}
class CollectionSizeObserver {
    constructor(owner) {
        this.owner = owner;
        this.value = (this.obj = owner.collection).size;
        this.type = this.obj instanceof Map ? 66 /* Map */ : 34 /* Set */;
    }
    getValue() {
        return this.obj.size;
    }
    setValue() {
        throw new Error('Map/Set "size" is a readonly property');
    }
    handleCollectionChange(_, flags) {
        const oldValue = this.value;
        const value = this.obj.size;
        this.value = value;
        if (value !== oldValue) {
            this.subs.notify(value, oldValue, flags);
        }
    }
}
function implementLengthObserver(klass) {
    const proto = klass.prototype;
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_2__.ensureProto)(proto, 'subscribe', subscribe, true);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_2__.ensureProto)(proto, 'unsubscribe', unsubscribe, true);
    (0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)(klass);
}
function subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
        this.owner.subscribe(this);
    }
}
function unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
        this.owner.subscribe(this);
    }
}
implementLengthObserver(CollectionLengthObserver);
implementLengthObserver(CollectionSizeObserver);
//# sourceMappingURL=collection-length-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComputedObserver": () => /* binding */ ComputedObserver
/* harmony export */ });
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _connectable_switcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connectable-switcher.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js");
/* harmony import */ var _binding_connectable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binding/connectable.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js");
/* harmony import */ var _proxy_observation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy-observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");





class ComputedObserver {
    constructor(obj, get, set, useProxy, observerLocator) {
        this.obj = obj;
        this.get = get;
        this.set = set;
        this.useProxy = useProxy;
        this.observerLocator = observerLocator;
        this.interceptor = this;
        this.type = 1 /* Observer */;
        this.value = void 0;
        // todo: maybe use a counter allow recursive call to a certain level
        /**
         * @internal
         */
        this.running = false;
        this.isDirty = false;
        _binding_connectable_js__WEBPACK_IMPORTED_MODULE_2__.connectable.assignIdTo(this);
    }
    static create(obj, key, descriptor, observerLocator, useProxy) {
        const getter = descriptor.get;
        const setter = descriptor.set;
        const observer = new ComputedObserver(obj, getter, setter, useProxy, observerLocator);
        const $get = (( /* Computed Observer */) => observer.getValue());
        $get.getObserver = () => observer;
        (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_4__.def)(obj, key, {
            enumerable: descriptor.enumerable,
            configurable: true,
            get: $get,
            set: (/* Computed Observer */ v) => {
                observer.setValue(v, 0 /* none */);
            },
        });
        return observer;
    }
    getValue() {
        if (this.subs.count === 0) {
            return this.get.call(this.obj, this);
        }
        if (this.isDirty) {
            this.compute();
            this.isDirty = false;
        }
        return this.value;
    }
    // deepscan-disable-next-line
    setValue(v, _flags) {
        if (typeof this.set === 'function') {
            if (v !== this.value) {
                // setting running true as a form of batching
                this.running = true;
                this.set.call(this.obj, v);
                this.running = false;
                this.run();
            }
        }
        else {
            throw new Error('Property is readonly');
        }
    }
    handleChange() {
        this.isDirty = true;
        if (this.subs.count > 0) {
            this.run();
        }
    }
    handleCollectionChange() {
        this.isDirty = true;
        if (this.subs.count > 0) {
            this.run();
        }
    }
    subscribe(subscriber) {
        // in theory, a collection subscriber could be added before a property subscriber
        // and it should be handled similarly in subscribeToCollection
        // though not handling for now, and wait until the merge of normal + collection subscription
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.compute();
            this.isDirty = false;
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.isDirty = true;
            this.obs.clear(true);
        }
    }
    run() {
        if (this.running) {
            return;
        }
        const oldValue = this.value;
        const newValue = this.compute();
        this.isDirty = false;
        if (!Object.is(newValue, oldValue)) {
            // should optionally queue
            this.subs.notify(newValue, oldValue, 0 /* none */);
        }
    }
    compute() {
        this.running = true;
        this.obs.version++;
        try {
            (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_1__.enterConnectable)(this);
            return this.value = (0,_proxy_observation_js__WEBPACK_IMPORTED_MODULE_3__.unwrap)(this.get.call(this.useProxy ? (0,_proxy_observation_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this.obj) : this.obj, this));
        }
        finally {
            this.obs.clear(false);
            this.running = false;
            (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_1__.exitConnectable)(this);
        }
    }
}
(0,_binding_connectable_js__WEBPACK_IMPORTED_MODULE_2__.connectable)(ComputedObserver);
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(ComputedObserver);
//# sourceMappingURL=computed-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "connecting": () => /* binding */ connecting,
/* harmony export */   "pauseConnecting": () => /* binding */ pauseConnecting,
/* harmony export */   "resumeConnecting": () => /* binding */ resumeConnecting,
/* harmony export */   "currentConnectable": () => /* binding */ currentConnectable,
/* harmony export */   "enterConnectable": () => /* binding */ enterConnectable,
/* harmony export */   "exitConnectable": () => /* binding */ exitConnectable,
/* harmony export */   "ConnectableSwitcher": () => /* binding */ ConnectableSwitcher
/* harmony export */ });
/**
 * Current subscription collector
 */
let _connectable = null;
const connectables = [];
// eslint-disable-next-line
let connecting = false;
// todo: layer based collection pause/resume?
function pauseConnecting() {
    connecting = false;
}
function resumeConnecting() {
    connecting = true;
}
function currentConnectable() {
    return _connectable;
}
function enterConnectable(connectable) {
    if (connectable == null) {
        throw new Error('connectable cannot be null/undefined');
    }
    if (_connectable == null) {
        _connectable = connectable;
        connectables[0] = _connectable;
        connecting = true;
        return;
    }
    if (_connectable === connectable) {
        throw new Error(`Already in this connectable ${connectable.id}`);
    }
    connectables.push(_connectable);
    _connectable = connectable;
    connecting = true;
}
function exitConnectable(connectable) {
    if (connectable == null) {
        throw new Error('Connectable cannot be null/undefined');
    }
    if (_connectable !== connectable) {
        throw new Error(`${connectable.id} is not currently collecting`);
    }
    connectables.pop();
    _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;
    connecting = _connectable != null;
}
const ConnectableSwitcher = Object.freeze({
    get current() {
        return _connectable;
    },
    get connecting() {
        return connecting;
    },
    enter: enterConnectable,
    exit: exitConnectable,
    pause: pauseConnecting,
    resume: resumeConnecting,
});
//# sourceMappingURL=connectable-switcher.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IDirtyChecker": () => /* binding */ IDirtyChecker,
/* harmony export */   "DirtyCheckSettings": () => /* binding */ DirtyCheckSettings,
/* harmony export */   "DirtyChecker": () => /* binding */ DirtyChecker,
/* harmony export */   "DirtyCheckProperty": () => /* binding */ DirtyCheckProperty
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");


const IDirtyChecker = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IDirtyChecker', x => x.singleton(DirtyChecker));
const DirtyCheckSettings = {
    /**
     * Default: `6`
     *
     * Adjust the global dirty check frequency.
     * Measures in "timeouts per check", such that (given a default of 250 timeouts per second in modern browsers):
     * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)
     * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)
     */
    timeoutsPerCheck: 25,
    /**
     * Default: `false`
     *
     * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking
     * or an adapter, will simply not be observed.
     */
    disabled: false,
    /**
     * Default: `false`
     *
     * Throw an error if a property is being dirty-checked.
     */
    throw: false,
    /**
     * Resets all dirty checking settings to the framework's defaults.
     */
    resetToDefault() {
        this.timeoutsPerCheck = 6;
        this.disabled = false;
        this.throw = false;
    }
};
const queueTaskOpts = {
    persistent: true,
};
class DirtyChecker {
    constructor(platform) {
        this.platform = platform;
        this.tracked = [];
        this.task = null;
        this.elapsedFrames = 0;
        this.check = () => {
            if (DirtyCheckSettings.disabled) {
                return;
            }
            if (++this.elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {
                return;
            }
            this.elapsedFrames = 0;
            const tracked = this.tracked;
            const len = tracked.length;
            let current;
            let i = 0;
            for (; i < len; ++i) {
                current = tracked[i];
                if (current.isDirty()) {
                    current.flush(0 /* none */);
                }
            }
        };
    }
    createProperty(obj, propertyName) {
        if (DirtyCheckSettings.throw) {
            throw new Error(`Property '${propertyName}' is being dirty-checked.`);
        }
        return new DirtyCheckProperty(this, obj, propertyName);
    }
    addProperty(property) {
        this.tracked.push(property);
        if (this.tracked.length === 1) {
            this.task = this.platform.macroTaskQueue.queueTask(this.check, queueTaskOpts);
        }
    }
    removeProperty(property) {
        this.tracked.splice(this.tracked.indexOf(property), 1);
        if (this.tracked.length === 0) {
            this.task.cancel();
            this.task = null;
        }
    }
}
/**
 * @internal
 */
DirtyChecker.inject = [_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform];
class DirtyCheckProperty {
    constructor(dirtyChecker, obj, propertyKey) {
        this.dirtyChecker = dirtyChecker;
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.type = 0 /* None */;
    }
    getValue() {
        return this.obj[this.propertyKey];
    }
    setValue(v, f) {
        // todo: this should be allowed, probably
        // but the construction of dirty checker should throw instead
        throw new Error(`Trying to set value for property ${this.propertyKey} in dirty checker`);
    }
    isDirty() {
        return this.oldValue !== this.obj[this.propertyKey];
    }
    flush(flags) {
        const oldValue = this.oldValue;
        const newValue = this.getValue();
        this.subs.notify(newValue, oldValue, flags | 8 /* updateTarget */);
        this.oldValue = newValue;
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.oldValue = this.obj[this.propertyKey];
            this.dirtyChecker.addProperty(this);
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.dirtyChecker.removeProperty(this);
        }
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)(DirtyCheckProperty);
//# sourceMappingURL=dirty-checker.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableMapObservation": () => /* binding */ enableMapObservation,
/* harmony export */   "disableMapObservation": () => /* binding */ disableMapObservation,
/* harmony export */   "MapObserver": () => /* binding */ MapObserver,
/* harmony export */   "getMapObserver": () => /* binding */ getMapObserver
/* harmony export */ });
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");
/* harmony import */ var _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");




const observerLookup = new WeakMap();
const proto = Map.prototype;
const $set = proto.set;
const $clear = proto.clear;
const $delete = proto.delete;
const native = { set: $set, clear: $clear, delete: $delete };
const methods = ['set', 'clear', 'delete'];
// note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls
// fortunately, map/delete/clear are easy to reconstruct for the indexMap
const observe = {
    // https://tc39.github.io/ecma262/#sec-map.prototype.map
    set: function (key, value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            $set.call(this, key, value);
            return this;
        }
        const oldValue = this.get(key);
        const oldSize = this.size;
        $set.call(this, key, value);
        const newSize = this.size;
        if (newSize === oldSize) {
            let i = 0;
            for (const entry of this.entries()) {
                if (entry[0] === key) {
                    if (entry[1] !== oldValue) {
                        o.indexMap.deletedItems.push(o.indexMap[i]);
                        o.indexMap[i] = -2;
                        o.notify();
                    }
                    return this;
                }
                i++;
            }
            return this;
        }
        o.indexMap[oldSize] = -2;
        o.notify();
        return this;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.clear
    clear: function () {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $clear.call(this);
        }
        const size = this.size;
        if (size > 0) {
            const indexMap = o.indexMap;
            let i = 0;
            // deepscan-disable-next-line
            for (const _ of this.keys()) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                i++;
            }
            $clear.call(this);
            indexMap.length = 0;
            o.notify();
        }
        return undefined;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.delete
    delete: function (value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $delete.call(this, value);
        }
        const size = this.size;
        if (size === 0) {
            return false;
        }
        let i = 0;
        const indexMap = o.indexMap;
        for (const entry of this.keys()) {
            if (entry === value) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                indexMap.splice(i, 1);
                const deleteResult = $delete.call(this, value);
                if (deleteResult === true) {
                    o.notify();
                }
                return deleteResult;
            }
            ++i;
        }
        return false;
    }
};
const descriptorProps = {
    writable: true,
    enumerable: false,
    configurable: true
};
for (const method of methods) {
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });
}
let enableMapObservationCalled = false;
function enableMapObservation() {
    for (const method of methods) {
        if (proto[method].observing !== true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: observe[method] });
        }
    }
}
function disableMapObservation() {
    for (const method of methods) {
        if (proto[method].observing === true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: native[method] });
        }
    }
}
class MapObserver {
    constructor(map) {
        this.type = 66 /* Map */;
        if (!enableMapObservationCalled) {
            enableMapObservationCalled = true;
            enableMapObservation();
        }
        this.collection = map;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(map.size);
        this.lenObs = void 0;
        observerLookup.set(map, this);
    }
    notify() {
        const indexMap = this.indexMap;
        const size = this.collection.size;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(size);
        this.subs.notifyCollection(indexMap, 8 /* updateTarget */);
    }
    getLengthObserver() {
        return this.lenObs ?? (this.lenObs = new _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__.CollectionSizeObserver(this));
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(MapObserver);
function getMapObserver(map) {
    let observer = observerLookup.get(map);
    if (observer === void 0) {
        observer = new MapObserver(map);
    }
    return observer;
}
//# sourceMappingURL=map-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/observable.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/observable.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "observable": () => /* binding */ observable
/* harmony export */ });
/* harmony import */ var _setter_observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setter-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");


function getObserversLookup(obj) {
    if (obj.$observers === void 0) {
        (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(obj, '$observers', { value: {} });
        // todo: define in a weakmap
    }
    return obj.$observers;
}
const noValue = {};
// impl, wont be seen
function observable(targetOrConfig, key, descriptor) {
    // either this check, or arguments.length === 3
    // or could be both, so can throw against user error for better DX
    if (key == null) {
        // for:
        //    @observable('prop')
        //    class {}
        //
        //    @observable({ name: 'prop', callback: ... })
        //    class {}
        //
        //    class {
        //      @observable() prop
        //      @observable({ callback: ... }) prop2
        //    }
        return ((t, k, d) => deco(t, k, d, targetOrConfig));
    }
    // for:
    //    class {
    //      @observable prop
    //    }
    return deco(targetOrConfig, key, descriptor);
    function deco(target, key, descriptor, config) {
        // class decorator?
        const isClassDecorator = key === void 0;
        config = typeof config !== 'object'
            ? { name: config }
            : (config || {});
        if (isClassDecorator) {
            key = config.name;
        }
        if (key == null || key === '') {
            throw new Error('Invalid usage, cannot determine property name for @observable');
        }
        // determine callback name based on config or convention.
        const callback = config.callback || `${String(key)}Changed`;
        let initialValue = noValue;
        if (descriptor) {
            // we're adding a getter and setter which means the property descriptor
            // cannot have a "value" or "writable" attribute
            delete descriptor.value;
            delete descriptor.writable;
            initialValue = descriptor.initializer?.();
            delete descriptor.initializer;
        }
        else {
            descriptor = { configurable: true };
        }
        // make the accessor enumerable by default, as fields are enumerable
        if (!('enumerable' in descriptor)) {
            descriptor.enumerable = true;
        }
        // todo(bigopon/fred): discuss string api for converter
        const $set = config.set;
        descriptor.get = function g( /* @observable */) {
            return getNotifier(this, key, callback, initialValue, $set).getValue();
        };
        descriptor.set = function s(newValue) {
            getNotifier(this, key, callback, initialValue, $set).setValue(newValue, 0 /* none */);
        };
        descriptor.get.getObserver = function gO(/* @observable */ obj) {
            return getNotifier(obj, key, callback, initialValue, $set);
        };
        if (isClassDecorator) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(target.prototype, key, descriptor);
        }
        else {
            return descriptor;
        }
    }
}
function getNotifier(obj, key, callbackKey, initialValue, set) {
    const lookup = getObserversLookup(obj);
    let notifier = lookup[key];
    if (notifier == null) {
        notifier = new _setter_observer_js__WEBPACK_IMPORTED_MODULE_0__.SetterNotifier(obj, callbackKey, set, initialValue === noValue ? void 0 : initialValue);
        lookup[key] = notifier;
    }
    return notifier;
}
/*
          | typescript       | babel
----------|------------------|-------------------------
property  | config           | config
w/parens  | target, key      | target, key, descriptor
----------|------------------|-------------------------
property  | target, key      | target, key, descriptor
no parens | n/a              | n/a
----------|------------------|-------------------------
class     | config           | config
          | target           | target
*/
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/observer-locator.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/observer-locator.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "propertyAccessor": () => /* binding */ propertyAccessor,
/* harmony export */   "IObserverLocator": () => /* binding */ IObserverLocator,
/* harmony export */   "INodeObserverLocator": () => /* binding */ INodeObserverLocator,
/* harmony export */   "ObserverLocator": () => /* binding */ ObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* binding */ getCollectionObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _array_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js");
/* harmony import */ var _computed_observer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computed-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js");
/* harmony import */ var _dirty_checker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dirty-checker.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js");
/* harmony import */ var _map_observer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js");
/* harmony import */ var _primitive_observer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./primitive-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js");
/* harmony import */ var _property_accessor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./property-accessor.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js");
/* harmony import */ var _set_observer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./set-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js");
/* harmony import */ var _setter_observer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./setter-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");










const propertyAccessor = new _property_accessor_js__WEBPACK_IMPORTED_MODULE_6__.PropertyAccessor();
const IObserverLocator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IObserverLocator', x => x.singleton(ObserverLocator));
const INodeObserverLocator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('INodeObserverLocator', x => x.cachedCallback(handler => {
    handler.getAll(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger).forEach(logger => {
        logger.error('Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).');
    });
    return new DefaultNodeObserverLocator();
}));
class DefaultNodeObserverLocator {
    handles() {
        return false;
    }
    getObserver() {
        return propertyAccessor;
    }
    getAccessor() {
        return propertyAccessor;
    }
}
class ObserverLocator {
    constructor(dirtyChecker, nodeObserverLocator) {
        this.dirtyChecker = dirtyChecker;
        this.nodeObserverLocator = nodeObserverLocator;
        this.adapters = [];
    }
    addAdapter(adapter) {
        this.adapters.push(adapter);
    }
    getObserver(obj, key) {
        return obj.$observers?.[key]
            ?? this.cache(obj, key, this.createObserver(obj, key));
    }
    getAccessor(obj, key) {
        const cached = obj.$observers?.[key];
        if (cached !== void 0) {
            return cached;
        }
        if (this.nodeObserverLocator.handles(obj, key, this)) {
            return this.nodeObserverLocator.getAccessor(obj, key, this);
        }
        return propertyAccessor;
    }
    getArrayObserver(observedArray) {
        return (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(observedArray);
    }
    getMapObserver(observedMap) {
        return (0,_map_observer_js__WEBPACK_IMPORTED_MODULE_4__.getMapObserver)(observedMap);
    }
    getSetObserver(observedSet) {
        return (0,_set_observer_js__WEBPACK_IMPORTED_MODULE_7__.getSetObserver)(observedSet);
    }
    createObserver(obj, key) {
        if (!(obj instanceof Object)) {
            return new _primitive_observer_js__WEBPACK_IMPORTED_MODULE_5__.PrimitiveObserver(obj, key);
        }
        if (this.nodeObserverLocator.handles(obj, key, this)) {
            return this.nodeObserverLocator.getObserver(obj, key, this);
        }
        switch (key) {
            case 'length':
                if (obj instanceof Array) {
                    return (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(obj).getLengthObserver();
                }
                break;
            case 'size':
                if (obj instanceof Map) {
                    return (0,_map_observer_js__WEBPACK_IMPORTED_MODULE_4__.getMapObserver)(obj).getLengthObserver();
                }
                else if (obj instanceof Set) {
                    return (0,_set_observer_js__WEBPACK_IMPORTED_MODULE_7__.getSetObserver)(obj).getLengthObserver();
                }
                break;
            default:
                if (obj instanceof Array && (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isArrayIndex)(key)) {
                    return (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(obj).getIndexObserver(Number(key));
                }
                break;
        }
        let pd = Object.getOwnPropertyDescriptor(obj, key);
        // Only instance properties will yield a descriptor here, otherwise walk up the proto chain
        if (pd === void 0) {
            let proto = Object.getPrototypeOf(obj);
            while (proto !== null) {
                pd = Object.getOwnPropertyDescriptor(proto, key);
                if (pd === void 0) {
                    proto = Object.getPrototypeOf(proto);
                }
                else {
                    break;
                }
            }
        }
        // If the descriptor does not have a 'value' prop, it must have a getter and/or setter
        if (pd !== void 0 && !Object.prototype.hasOwnProperty.call(pd, 'value')) {
            let obs = this.getAdapterObserver(obj, key, pd);
            if (obs == null) {
                obs = (pd.get?.getObserver ?? pd.set?.getObserver)?.(obj, this);
            }
            return obs == null
                ? pd.configurable
                    ? _computed_observer_js__WEBPACK_IMPORTED_MODULE_2__.ComputedObserver.create(obj, key, pd, this, /* AOT: not true for IE11 */ true)
                    : this.dirtyChecker.createProperty(obj, key)
                : obs;
        }
        // Ordinary get/set observation (the common use case)
        // TODO: think about how to handle a data property that does not sit on the instance (should we do anything different?)
        return new _setter_observer_js__WEBPACK_IMPORTED_MODULE_8__.SetterObserver(obj, key);
    }
    getAdapterObserver(obj, propertyName, pd) {
        if (this.adapters.length > 0) {
            for (const adapter of this.adapters) {
                const observer = adapter.getObserver(obj, propertyName, pd, this);
                if (observer != null) {
                    return observer;
                }
            }
        }
        return null;
    }
    cache(obj, key, observer) {
        if (observer.doNotCache === true) {
            return observer;
        }
        if (obj.$observers === void 0) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_9__.def)(obj, '$observers', { value: { [key]: observer } });
            return observer;
        }
        return obj.$observers[key] = observer;
    }
}
ObserverLocator.inject = [_dirty_checker_js__WEBPACK_IMPORTED_MODULE_3__.IDirtyChecker, INodeObserverLocator];
function getCollectionObserver(collection) {
    let obs;
    if (collection instanceof Array) {
        obs = (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(collection);
    }
    else if (collection instanceof Map) {
        obs = (0,_map_observer_js__WEBPACK_IMPORTED_MODULE_4__.getMapObserver)(collection);
    }
    else if (collection instanceof Set) {
        obs = (0,_set_observer_js__WEBPACK_IMPORTED_MODULE_7__.getSetObserver)(collection);
    }
    return obs;
}
//# sourceMappingURL=observer-locator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrimitiveObserver": () => /* binding */ PrimitiveObserver
/* harmony export */ });
class PrimitiveObserver {
    constructor(obj, propertyKey) {
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.type = 0 /* None */;
    }
    get doNotCache() { return true; }
    getValue() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-explicit-any
        return this.obj[this.propertyKey];
    }
    setValue() { }
    subscribe() { }
    unsubscribe() { }
}
//# sourceMappingURL=primitive-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyAccessor": () => /* binding */ PropertyAccessor
/* harmony export */ });
class PropertyAccessor {
    constructor() {
        // the only thing can be guaranteed is it's an object
        // even if this property accessor is used to access an element
        this.type = 0 /* None */;
    }
    getValue(obj, key) {
        return obj[key];
    }
    setValue(value, flags, obj, key) {
        obj[key] = value;
    }
}
//# sourceMappingURL=property-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rawKey": () => /* binding */ rawKey,
/* harmony export */   "wrap": () => /* binding */ wrap,
/* harmony export */   "getProxy": () => /* binding */ getProxy,
/* harmony export */   "getRaw": () => /* binding */ getRaw,
/* harmony export */   "unwrap": () => /* binding */ unwrap,
/* harmony export */   "ProxyObservable": () => /* binding */ ProxyObservable
/* harmony export */ });
/* harmony import */ var _connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./connectable-switcher.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js");

const R$get = Reflect.get;
const toStringTag = Object.prototype.toString;
const proxyMap = new WeakMap();
function canWrap(obj) {
    switch (toStringTag.call(obj)) {
        case '[object Object]':
        case '[object Array]':
        case '[object Map]':
        case '[object Set]':
            // it's unlikely that methods on the following 2 objects need to be observed for changes
            // so while they are valid/ we don't wrap them either
            // case '[object Math]':
            // case '[object Reflect]':
            return true;
        default:
            return false;
    }
}
const rawKey = '__raw__';
function wrap(v) {
    return canWrap(v) ? getProxy(v) : v;
}
function getProxy(obj) {
    // deepscan-disable-next-line
    return proxyMap.get(obj) ?? createProxy(obj);
}
function getRaw(obj) {
    // todo: get in a weakmap if null/undef
    return obj[rawKey] ?? obj;
}
function unwrap(v) {
    // eslint-disable-next-line
    return canWrap(v) && v[rawKey] || v;
}
function doNotCollect(key) {
    return key === 'constructor'
        || key === '__proto__'
        // probably should revert to v1 naming style for consistency with builtin?
        // __o__ is shorters & less chance of conflict with other libs as well
        || key === '$observers'
        || key === Symbol.toPrimitive
        || key === Symbol.toStringTag;
}
function createProxy(obj) {
    const handler = obj instanceof Array
        ? arrayHandler
        : obj instanceof Map || obj instanceof Set
            ? collectionHandler
            : objectHandler;
    const proxiedObj = new Proxy(obj, handler);
    proxyMap.set(obj, proxiedObj);
    return proxiedObj;
}
const objectHandler = {
    get(target, key, receiver) {
        // maybe use symbol?
        if (key === rawKey) {
            return target;
        }
        const connectable = (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)();
        if (!_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.connecting || doNotCollect(key) || connectable == null) {
            return R$get(target, key, receiver);
        }
        // todo: static
        connectable.observeProperty(target, key);
        return wrap(R$get(target, key, receiver));
    },
};
const arrayHandler = {
    get(target, key, receiver) {
        // maybe use symbol?
        if (key === rawKey) {
            return target;
        }
        const connectable = (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)();
        if (!_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.connecting || doNotCollect(key) || connectable == null) {
            return R$get(target, key, receiver);
        }
        switch (key) {
            case 'length':
                connectable.observeProperty(target, 'length');
                return target.length;
            case 'map':
                return wrappedArrayMap;
            case 'includes':
                return wrappedArrayIncludes;
            case 'indexOf':
                return wrappedArrayIndexOf;
            case 'lastIndexOf':
                return wrappedArrayLastIndexOf;
            case 'every':
                return wrappedArrayEvery;
            case 'filter':
                return wrappedArrayFilter;
            case 'findIndex':
                return wrappedArrayFindIndex;
            case 'flat':
                return wrappedArrayFlat;
            case 'flatMap':
                return wrappedArrayFlatMap;
            case 'join':
                return wrappedArrayJoin;
            case 'push':
                return wrappedArrayPush;
            case 'pop':
                return wrappedArrayPop;
            case 'reduce':
                return wrappedReduce;
            case 'reduceRight':
                return wrappedReduceRight;
            case 'reverse':
                return wrappedArrayReverse;
            case 'shift':
                return wrappedArrayShift;
            case 'unshift':
                return wrappedArrayUnshift;
            case 'slice':
                return wrappedArraySlice;
            case 'splice':
                return wrappedArraySplice;
            case 'some':
                return wrappedArraySome;
            case 'sort':
                return wrappedArraySort;
            case 'keys':
                return wrappedKeys;
            case 'values':
            case Symbol.iterator:
                return wrappedValues;
            case 'entries':
                return wrappedEntries;
        }
        connectable.observeProperty(target, key);
        return wrap(R$get(target, key, receiver));
    },
    // for (let i in array) ...
    ownKeys(target) {
        (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeProperty(target, 'length');
        return Reflect.ownKeys(target);
    },
};
function wrappedArrayMap(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.map((v, i) => 
    // do we wrap `thisArg`?
    unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArrayEvery(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.every((v, i) => cb.call(thisArg, wrap(v), i, this));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayFilter(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.filter((v, i) => 
    // do we wrap `thisArg`?
    unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArrayIncludes(v) {
    const raw = getRaw(this);
    const res = raw.includes(unwrap(v));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayIndexOf(v) {
    const raw = getRaw(this);
    const res = raw.indexOf(unwrap(v));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayLastIndexOf(v) {
    const raw = getRaw(this);
    const res = raw.lastIndexOf(unwrap(v));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayFindIndex(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.findIndex((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayFlat() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(raw.flat());
}
function wrappedArrayFlatMap(cb, thisArg) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return getProxy(raw.flatMap((v, i) => wrap(cb.call(thisArg, wrap(v), i, this))));
}
function wrappedArrayJoin(separator) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return raw.join(separator);
}
function wrappedArrayPop() {
    return wrap(getRaw(this).pop());
}
function wrappedArrayPush(...args) {
    return getRaw(this).push(...args);
}
function wrappedArrayShift() {
    return wrap(getRaw(this).shift());
}
function wrappedArrayUnshift(...args) {
    return getRaw(this).unshift(...args);
}
function wrappedArraySplice(...args) {
    return wrap(getRaw(this).splice(...args));
}
function wrappedArrayReverse(...args) {
    const raw = getRaw(this);
    const res = raw.reverse();
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArraySome(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.some((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArraySort(cb) {
    const raw = getRaw(this);
    const res = raw.sort(cb);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArraySlice(start, end) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return getProxy(raw.slice(start, end));
}
function wrappedReduce(cb, initValue) {
    const raw = getRaw(this);
    const res = raw.reduce((curr, v, i) => cb(curr, wrap(v), i, this), initValue);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedReduceRight(cb, initValue) {
    const raw = getRaw(this);
    const res = raw.reduceRight((curr, v, i) => cb(curr, wrap(v), i, this), initValue);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
// the below logic takes inspiration from Vue, Mobx
// much thanks to them for working out this
const collectionHandler = {
    get(target, key, receiver) {
        // maybe use symbol?
        if (key === rawKey) {
            return target;
        }
        const connectable = (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)();
        if (!_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.connecting || doNotCollect(key) || connectable == null) {
            return R$get(target, key, receiver);
        }
        switch (key) {
            case 'size':
                connectable.observeProperty(target, 'size');
                return target.size;
            case 'clear':
                return wrappedClear;
            case 'delete':
                return wrappedDelete;
            case 'forEach':
                return wrappedForEach;
            case 'add':
                if (target instanceof Set) {
                    return wrappedAdd;
                }
                break;
            case 'get':
                if (target instanceof Map) {
                    return wrappedGet;
                }
                break;
            case 'set':
                if (target instanceof Map) {
                    return wrappedSet;
                }
                break;
            case 'has':
                return wrappedHas;
            case 'keys':
                return wrappedKeys;
            case 'values':
                return wrappedValues;
            case 'entries':
                return wrappedEntries;
            case Symbol.iterator:
                return target instanceof Map ? wrappedEntries : wrappedValues;
        }
        return wrap(R$get(target, key, receiver));
    },
};
function wrappedForEach(cb, thisArg) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return raw.forEach((v, key) => {
        cb.call(/* should wrap or not?? */ thisArg, wrap(v), wrap(key), this);
    });
}
function wrappedHas(v) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return raw.has(unwrap(v));
}
function wrappedGet(k) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(raw.get(unwrap(k)));
}
function wrappedSet(k, v) {
    return wrap(getRaw(this).set(unwrap(k), unwrap(v)));
}
function wrappedAdd(v) {
    return wrap(getRaw(this).add(unwrap(v)));
}
function wrappedClear() {
    return wrap(getRaw(this).clear());
}
function wrappedDelete(k) {
    return wrap(getRaw(this).delete(unwrap(k)));
}
function wrappedKeys() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    const iterator = raw.keys();
    return {
        next() {
            const next = iterator.next();
            const value = next.value;
            const done = next.done;
            return done
                ? { value: void 0, done }
                : { value: wrap(value), done };
        },
        [Symbol.iterator]() {
            return this;
        },
    };
}
function wrappedValues() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    const iterator = raw.values();
    return {
        next() {
            const next = iterator.next();
            const value = next.value;
            const done = next.done;
            return done
                ? { value: void 0, done }
                : { value: wrap(value), done };
        },
        [Symbol.iterator]() {
            return this;
        },
    };
}
function wrappedEntries() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    const iterator = raw.entries();
    // return a wrapped iterator which returns observed versions of the
    // values emitted from the real iterator
    return {
        next() {
            const next = iterator.next();
            const value = next.value;
            const done = next.done;
            return done
                ? { value: void 0, done }
                : { value: [wrap(value[0]), wrap(value[1])], done };
        },
        [Symbol.iterator]() {
            return this;
        },
    };
}
const ProxyObservable = Object.freeze({
    getProxy,
    getRaw,
    wrap,
    unwrap,
    rawKey,
});
//# sourceMappingURL=proxy-observation.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableSetObservation": () => /* binding */ enableSetObservation,
/* harmony export */   "disableSetObservation": () => /* binding */ disableSetObservation,
/* harmony export */   "SetObserver": () => /* binding */ SetObserver,
/* harmony export */   "getSetObserver": () => /* binding */ getSetObserver
/* harmony export */ });
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");
/* harmony import */ var _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");




const observerLookup = new WeakMap();
const proto = Set.prototype;
const $add = proto.add;
const $clear = proto.clear;
const $delete = proto.delete;
const native = { add: $add, clear: $clear, delete: $delete };
const methods = ['add', 'clear', 'delete'];
// note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls
// fortunately, add/delete/clear are easy to reconstruct for the indexMap
const observe = {
    // https://tc39.github.io/ecma262/#sec-set.prototype.add
    add: function (value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            $add.call(this, value);
            return this;
        }
        const oldSize = this.size;
        $add.call(this, value);
        const newSize = this.size;
        if (newSize === oldSize) {
            return this;
        }
        o.indexMap[oldSize] = -2;
        o.notify();
        return this;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.clear
    clear: function () {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $clear.call(this);
        }
        const size = this.size;
        if (size > 0) {
            const indexMap = o.indexMap;
            let i = 0;
            // deepscan-disable-next-line
            for (const _ of this.keys()) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                i++;
            }
            $clear.call(this);
            indexMap.length = 0;
            o.notify();
        }
        return undefined;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.delete
    delete: function (value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $delete.call(this, value);
        }
        const size = this.size;
        if (size === 0) {
            return false;
        }
        let i = 0;
        const indexMap = o.indexMap;
        for (const entry of this.keys()) {
            if (entry === value) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                indexMap.splice(i, 1);
                const deleteResult = $delete.call(this, value);
                if (deleteResult === true) {
                    o.notify();
                }
                return deleteResult;
            }
            i++;
        }
        return false;
    }
};
const descriptorProps = {
    writable: true,
    enumerable: false,
    configurable: true
};
for (const method of methods) {
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });
}
let enableSetObservationCalled = false;
function enableSetObservation() {
    for (const method of methods) {
        if (proto[method].observing !== true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: observe[method] });
        }
    }
}
function disableSetObservation() {
    for (const method of methods) {
        if (proto[method].observing === true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: native[method] });
        }
    }
}
class SetObserver {
    constructor(observedSet) {
        this.type = 34 /* Set */;
        if (!enableSetObservationCalled) {
            enableSetObservationCalled = true;
            enableSetObservation();
        }
        this.collection = observedSet;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(observedSet.size);
        this.lenObs = void 0;
        observerLookup.set(observedSet, this);
    }
    notify() {
        const indexMap = this.indexMap;
        const size = this.collection.size;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(size);
        this.subs.notifyCollection(indexMap, 8 /* updateTarget */);
    }
    getLengthObserver() {
        return this.lenObs ?? (this.lenObs = new _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__.CollectionSizeObserver(this));
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(SetObserver);
function getSetObserver(observedSet) {
    let observer = observerLookup.get(observedSet);
    if (observer === void 0) {
        observer = new SetObserver(observedSet);
    }
    return observer;
}
//# sourceMappingURL=set-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SetterObserver": () => /* binding */ SetterObserver,
/* harmony export */   "SetterNotifier": () => /* binding */ SetterNotifier
/* harmony export */ });
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");


/**
 * Observer for the mutation of object property value employing getter-setter strategy.
 * This is used for observing object properties that has no decorator.
 */
class SetterObserver {
    constructor(obj, propertyKey) {
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.currentValue = void 0;
        this.oldValue = void 0;
        this.inBatch = false;
        this.observing = false;
        // todo(bigopon): tweak the flag based on typeof obj (array/set/map/iterator/proxy etc...)
        this.type = 1 /* Observer */;
    }
    getValue() {
        return this.currentValue;
    }
    setValue(newValue, flags) {
        if (this.observing) {
            const currentValue = this.currentValue;
            this.currentValue = newValue;
            this.subs.notify(newValue, currentValue, flags);
        }
        else {
            // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,
            // so calling obj[propertyKey] will actually return this.currentValue.
            // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor
            // is unmodified and we need to explicitly set the property value.
            // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.
            // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.
            this.obj[this.propertyKey] = newValue;
        }
    }
    subscribe(subscriber) {
        if (this.observing === false) {
            this.start();
        }
        this.subs.add(subscriber);
    }
    start() {
        if (this.observing === false) {
            this.observing = true;
            this.currentValue = this.obj[this.propertyKey];
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(this.obj, this.propertyKey, {
                enumerable: true,
                configurable: true,
                get: ( /* Setter Observer */) => this.getValue(),
                set: (/* Setter Observer */ value) => {
                    this.setValue(value, 0 /* none */);
                },
            });
        }
        return this;
    }
    stop() {
        if (this.observing) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(this.obj, this.propertyKey, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.currentValue,
            });
            this.observing = false;
            // todo(bigopon/fred): add .removeAllSubscribers()
        }
        return this;
    }
}
class SetterNotifier {
    constructor(obj, callbackKey, set, initialValue) {
        this.type = 1 /* Observer */;
        /**
         * @internal
         */
        this.v = void 0;
        this.obj = obj;
        this.s = set;
        const callback = obj[callbackKey];
        this.cb = typeof callback === 'function' ? callback : void 0;
        this.v = initialValue;
    }
    getValue() {
        return this.v;
    }
    setValue(value, flags) {
        if (typeof this.s === 'function') {
            value = this.s(value);
        }
        const oldValue = this.v;
        if (!Object.is(value, oldValue)) {
            this.v = value;
            this.cb?.call(this.obj, value, oldValue, flags);
            // there's a chance that cb.call(...)
            // changes the latest value of this observer
            // and thus making `value` stale
            // so for now, call with this.v
            // todo: should oldValue be treated the same way?
            this.subs.notify(this.v, oldValue, flags);
        }
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(SetterObserver);
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(SetterNotifier);
//# sourceMappingURL=setter-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISignaler": () => /* binding */ ISignaler,
/* harmony export */   "Signaler": () => /* binding */ Signaler
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const ISignaler = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISignaler', x => x.singleton(Signaler));
class Signaler {
    constructor() {
        this.signals = Object.create(null);
    }
    dispatchSignal(name, flags) {
        const listeners = this.signals[name];
        if (listeners === undefined) {
            return;
        }
        for (const listener of listeners.keys()) {
            listener.handleChange(undefined, undefined, flags | 8 /* updateTarget */);
        }
    }
    addSignalListener(name, listener) {
        const signals = this.signals;
        const listeners = signals[name];
        if (listeners === undefined) {
            signals[name] = new Set([listener]);
        }
        else {
            listeners.add(listener);
        }
    }
    removeSignalListener(name, listener) {
        const listeners = this.signals[name];
        if (listeners) {
            listeners.delete(listener);
        }
    }
}
//# sourceMappingURL=signaler.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscriberCollection": () => /* binding */ subscriberCollection,
/* harmony export */   "SubscriberRecord": () => /* binding */ SubscriberRecord
/* harmony export */ });
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");

function subscriberCollection(target) {
    return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target);
}
function subscriberCollectionDeco(target) {
    const proto = target.prototype;
    // not configurable, as in devtool, the getter could be invoked on the prototype,
    // and become permanently broken
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.def)(proto, 'subs', { get: getSubscriberRecord });
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'subscribe', addSubscriber);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'unsubscribe', removeSubscriber);
}
/* eslint-enable @typescript-eslint/ban-types */
class SubscriberRecord {
    constructor(owner) {
        /**
         * subscriber flags: bits indicating the existence status of the subscribers of this record
         */
        this._sf = 0 /* None */;
        this.count = 0;
        this.owner = owner;
    }
    add(subscriber) {
        if (this.has(subscriber)) {
            return false;
        }
        const subscriberFlags = this._sf;
        if ((subscriberFlags & 1 /* Subscriber0 */) === 0) {
            this._s0 = subscriber;
            this._sf |= 1 /* Subscriber0 */;
        }
        else if ((subscriberFlags & 2 /* Subscriber1 */) === 0) {
            this._s1 = subscriber;
            this._sf |= 2 /* Subscriber1 */;
        }
        else if ((subscriberFlags & 4 /* Subscriber2 */) === 0) {
            this._s2 = subscriber;
            this._sf |= 4 /* Subscriber2 */;
        }
        else if ((subscriberFlags & 8 /* SubscribersRest */) === 0) {
            this._sr = [subscriber];
            this._sf |= 8 /* SubscribersRest */;
        }
        else {
            this._sr.push(subscriber); // Non-null is implied by else branch of (subscriberFlags & SF.SubscribersRest) === 0
        }
        ++this.count;
        return true;
    }
    has(subscriber) {
        // Flags here is just a perf tweak
        // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;
        // and minor slow-down when it does, and the former is more common than the latter.
        const subscriberFlags = this._sf;
        if ((subscriberFlags & 1 /* Subscriber0 */) > 0 && this._s0 === subscriber) {
            return true;
        }
        if ((subscriberFlags & 2 /* Subscriber1 */) > 0 && this._s1 === subscriber) {
            return true;
        }
        if ((subscriberFlags & 4 /* Subscriber2 */) > 0 && this._s2 === subscriber) {
            return true;
        }
        if ((subscriberFlags & 8 /* SubscribersRest */) > 0) {
            const subscribers = this._sr; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0
            const ii = subscribers.length;
            let i = 0;
            for (; i < ii; ++i) {
                if (subscribers[i] === subscriber) {
                    return true;
                }
            }
        }
        return false;
    }
    any() {
        return this._sf !== 0 /* None */;
    }
    remove(subscriber) {
        const subscriberFlags = this._sf;
        if ((subscriberFlags & 1 /* Subscriber0 */) > 0 && this._s0 === subscriber) {
            this._s0 = void 0;
            this._sf = (this._sf | 1 /* Subscriber0 */) ^ 1 /* Subscriber0 */;
            --this.count;
            return true;
        }
        else if ((subscriberFlags & 2 /* Subscriber1 */) > 0 && this._s1 === subscriber) {
            this._s1 = void 0;
            this._sf = (this._sf | 2 /* Subscriber1 */) ^ 2 /* Subscriber1 */;
            --this.count;
            return true;
        }
        else if ((subscriberFlags & 4 /* Subscriber2 */) > 0 && this._s2 === subscriber) {
            this._s2 = void 0;
            this._sf = (this._sf | 4 /* Subscriber2 */) ^ 4 /* Subscriber2 */;
            --this.count;
            return true;
        }
        else if ((subscriberFlags & 8 /* SubscribersRest */) > 0) {
            const subscribers = this._sr; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0
            const ii = subscribers.length;
            let i = 0;
            for (; i < ii; ++i) {
                if (subscribers[i] === subscriber) {
                    subscribers.splice(i, 1);
                    if (ii === 1) {
                        this._sf = (this._sf | 8 /* SubscribersRest */) ^ 8 /* SubscribersRest */;
                    }
                    --this.count;
                    return true;
                }
            }
        }
        return false;
    }
    notify(val, oldVal, flags) {
        /**
         * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this
         * callSubscribers invocation, so we're caching them all before invoking any.
         * Subscribers added during this invocation are not invoked (and they shouldn't be).
         * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,
         * however this is accounted for via $isBound and similar flags on the subscriber objects)
         */
        const owner = this.owner;
        const sub0 = this._s0;
        const sub1 = this._s1;
        const sub2 = this._s2;
        let subs = this._sr;
        if (subs !== void 0) {
            subs = subs.slice();
        }
        flags = (flags | 24 /* update */) ^ 24 /* update */;
        if (sub0 !== void 0) {
            sub0.handleChange(val, oldVal, flags | /* sub own flags */ (sub0.id === void 0 ? 0 : owner[sub0.id]));
        }
        if (sub1 !== void 0) {
            sub1.handleChange(val, oldVal, flags | /* sub own flags */ (sub1.id === void 0 ? 0 : owner[sub1.id]));
        }
        if (sub2 !== void 0) {
            sub2.handleChange(val, oldVal, flags | /* sub own flags */ (sub2.id === void 0 ? 0 : owner[sub2.id]));
        }
        if (subs !== void 0) {
            const ii = subs.length;
            let sub;
            let i = 0;
            for (; i < ii; ++i) {
                sub = subs[i];
                if (sub !== void 0) {
                    sub.handleChange(val, oldVal, flags | /* sub own flags */ (sub.id === void 0 ? 0 : owner[sub.id]));
                }
            }
        }
    }
    notifyCollection(indexMap, flags) {
        const sub0 = this._s0;
        const sub1 = this._s1;
        const sub2 = this._s2;
        let subs = this._sr;
        if (subs !== void 0) {
            subs = subs.slice();
        }
        if (sub0 !== void 0) {
            sub0.handleCollectionChange(indexMap, flags);
        }
        if (sub1 !== void 0) {
            sub1.handleCollectionChange(indexMap, flags);
        }
        if (sub2 !== void 0) {
            sub2.handleCollectionChange(indexMap, flags);
        }
        if (subs !== void 0) {
            const ii = subs.length;
            let sub;
            let i = 0;
            for (; i < ii; ++i) {
                sub = subs[i];
                if (sub !== void 0) {
                    sub.handleCollectionChange(indexMap, flags);
                }
            }
        }
    }
}
function getSubscriberRecord() {
    const record = new SubscriberRecord(this);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.defineHiddenProp)(this, 'subs', record);
    return record;
}
function addSubscriber(subscriber) {
    return this.subs.add(subscriber);
}
function removeSubscriber(subscriber) {
    return this.subs.remove(subscriber);
}
//# sourceMappingURL=subscriber-collection.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "def": () => /* binding */ def,
/* harmony export */   "defineHiddenProp": () => /* binding */ defineHiddenProp,
/* harmony export */   "ensureProto": () => /* binding */ ensureProto
/* harmony export */ });
const def = Reflect.defineProperty;
function defineHiddenProp(obj, key, value) {
    def(obj, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value
    });
}
function ensureProto(proto, key, defaultValue, force = false) {
    if (force || !Object.prototype.hasOwnProperty.call(proto, key)) {
        defineHiddenProp(proto, key, defaultValue);
    }
}
//# sourceMappingURL=utilities-objects.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/value-converter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/value-converter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "valueConverter": () => /* binding */ valueConverter,
/* harmony export */   "ValueConverterDefinition": () => /* binding */ ValueConverterDefinition,
/* harmony export */   "ValueConverter": () => /* binding */ ValueConverter
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _alias_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alias.js */ "./node_modules/@aurelia/runtime/dist/esm/alias.js");


function valueConverter(nameOrDef) {
    return function (target) {
        return ValueConverter.define(nameOrDef, target);
    };
}
class ValueConverterDefinition {
    constructor(Type, name, aliases, key) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        return new ValueConverterDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(ValueConverter.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(ValueConverter.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), ValueConverter.keyFrom(name));
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_alias_js__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, ValueConverter, key, container);
    }
}
const ValueConverter = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('value-converter'),
    keyFrom(name) {
        return `${ValueConverter.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(ValueConverter.name, value);
    },
    define(nameOrDef, Type) {
        const definition = ValueConverterDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(ValueConverter.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(ValueConverter.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, ValueConverter.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(ValueConverter.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
//# sourceMappingURL=value-converter.js.map

/***/ }),

/***/ "./src/app.html":
/*!**********************!*\
  !*** ./src/app.html ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _reset_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reset.css */ "./src/reset.css");
/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app.css */ "./src/app.css");




const name = "app";
const template = "<template>\n  \n  \n\n  <div id=\"au-dev-root\" class=\"${isDarkTheme ? 'dark' : ''}\">\n    <h1 class=\"app-header\">\n      <aurelia-logo></aurelia-logo>\n      <span class=\"logo-badge\">INSPECTOR</span>\n    </h1>\n\n    <main>\n      <p class=\"not-found\" style=\"margin-bottom: 10px\">\n        Select a node through the inspect window to scope into that node. Click\n        on the value will allow one to edit the value and bind to the view.\n      </p>\n      <!-- <debug-group heading=\"Binding Context\" show.bind=\"true\">\n        <template if.bind=\"debugInfo.bindingContext\">\n          <ul>\n            <li repeat.for=\"property of debugInfo.bindingContext.properties\">\n              <property-view property.bind=\"property\"></property-view>\n            </li>\n          </ul>\n        </template>\n        <template if.bind=\"!debugInfo.bindingContext\">\n          <span class=\"not-found\"\n            >No binding context found for the selected node.</span\n          >\n        </template>\n      </debug-group>\n\n      <debug-group heading=\"Override Context\">\n        <template\n          if.bind=\"debugInfo.overrideContext && debugInfo.overrideContext.properties.length\"\n        >\n          <ul>\n            <li repeat.for=\"property of debugInfo.overrideContext.properties\">\n              <property-view property.bind=\"property\"></property-view>\n            </li>\n          </ul>\n        </template>\n        <template\n          if.bind=\"!debugInfo.overrideContext || !debugInfo.overrideContext.properties.length\"\n        >\n          <span class=\"not-found\"\n            >No override context found for the selected node.</span\n          >\n        </template>\n      </debug-group> -->\n\n      <debug-group heading=\"Custom Element\">\n        <template au-slot>\n          <span if.bind=\"!selectedElement\" class=\"not-found\"\n            >The selected node is not a custom element.</span\n          >\n          <controller-view\n            else\n            controller.bind=\"selectedElement\"\n          ></controller-view>\n        </template>\n      </debug-group>\n\n      <debug-group heading=\"Custom Attributes\">\n        <template au-slot>\n          <span if.bind=\"!selectedElementAttributes\" class=\"not-found\"\n            >No custom attributes found on the selected node.</span\n          >\n          <ul else>\n            <li\n              repeat.for=\"customAttribute of selectedElementAttributes\"\n              class=\"custom-attribute\"\n            >\n              <h3 class=\"attribute-name\">${customAttribute.name}</h3>\n              &nbsp;<span class=\"block-token\">{</span>\n              <controller-view\n                controller.bind=\"customAttribute\"\n              ></controller-view>\n              <span class=\"block-token\">}</span>\n            </li>\n          </ul>\n        </template>\n      </debug-group>\n    </main>\n\n    <!-- <main>\n      <custom-element if.bind=\"selectedElement\">\n        ${JSON.stringify(selectedElement)}\n        <div>Name = ${selectedElement.name}</div>\n        <div>Key = ${selectedElement.key}</div>\n        <div>Aliases = ${selectedElement.aliases.join(', ')}</div>\n        <h3>Bindables</h3>\n        <div repeat.for=\"value of selectedElement.bindables\">\n          ${value.name} =\n          <input\n            value.bind=\"value.value\"\n            keyup.delegate=\"valueChanged(selectedElement)\"\n          />\n        </div>\n        <hr />\n      </custom-element>\n    </main> -->\n  </div>\n</template>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _reset_css__WEBPACK_IMPORTED_MODULE_2__.default, _app_css__WEBPACK_IMPORTED_MODULE_3__.default) ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/custom-elements/custom-element/custom-element.html":
/*!****************************************************************!*\
  !*** ./src/custom-elements/custom-element/custom-element.html ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");

const name = "custom-element";
const template = "<p id=\"custom-element\">\n  CustomElement works!\n</p>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [  ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/aurelia-logo.html":
/*!**************************************************!*\
  !*** ./src/resources/elements/aurelia-logo.html ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");

const name = "aurelia-logo";
const template = "<template>\n  <svg height=\"28px\" viewBox=\"315 19 140 41\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <defs>\n      <linearGradient x1=\"-388.147851%\" y1=\"-144.177425%\" x2=\"237.683809%\" y2=\"430.405754%\" id=\"linearGradient-1\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"72.9454854%\" y1=\"84.4240777%\" x2=\"-97.0517904%\" y2=\"-147.696591%\" id=\"linearGradient-2\">\n        <stop stop-color=\"#6E4D9B\" offset=\"0%\"></stop>\n        <stop stop-color=\"#77327A\" offset=\"14%\"></stop>\n        <stop stop-color=\"#B31777\" offset=\"29%\"></stop>\n        <stop stop-color=\"#CD0F7E\" offset=\"84%\"></stop>\n        <stop stop-color=\"#ED2C89\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-283.884079%\" y1=\"-693.599872%\" x2=\"287.537417%\" y2=\"101.70976%\" id=\"linearGradient-3\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-821.186214%\" y1=\"-469.047862%\" x2=\"101.985142%\" y2=\"288.23598%\" id=\"linearGradient-4\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-140.359373%\" y1=\"-230.925718%\" x2=\"419.012316%\" y2=\"261.976742%\" id=\"linearGradient-5\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"191.083716%\" y1=\"253.952517%\" x2=\"20.3577022%\" y2=\"20.4029283%\" id=\"linearGradient-6\">\n        <stop stop-color=\"#6E4D9B\" offset=\"0%\"></stop>\n        <stop stop-color=\"#77327A\" offset=\"14%\"></stop>\n        <stop stop-color=\"#B31777\" offset=\"29%\"></stop>\n        <stop stop-color=\"#CD0F7E\" offset=\"84%\"></stop>\n        <stop stop-color=\"#ED2C89\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-388.094004%\" y1=\"-173.850055%\" x2=\"237.674802%\" y2=\"518.990225%\" id=\"linearGradient-7\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"11.1884561%\" y1=\"89.6525993%\" x2=\"90.145125%\" y2=\"11.5773982%\" id=\"linearGradient-8\">\n        <stop stop-color=\"#6E4D9B\" offset=\"0%\"></stop>\n        <stop stop-color=\"#77327A\" offset=\"14%\"></stop>\n        <stop stop-color=\"#B31777\" offset=\"53%\"></stop>\n        <stop stop-color=\"#CD0F7E\" offset=\"79%\"></stop>\n        <stop stop-color=\"#ED2C89\" offset=\"100%\"></stop>\n      </linearGradient>\n      <rect id=\"path-9\" x=\"0.627498256\" y=\"0\" width=\"34\" height=\"16\" rx=\"2\"></rect>\n      <filter x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\" filterUnits=\"objectBoundingBox\" id=\"filter-10\">\n        <feOffset dx=\"0\" dy=\"1\" in=\"SourceAlpha\" result=\"shadowOffsetOuter1\"></feOffset>\n        <feColorMatrix values=\"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.15 0\" type=\"matrix\" in=\"shadowOffsetOuter1\"></feColorMatrix>\n      </filter>\n    </defs>\n    <g id=\"Group-3\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(317.000000, 21.000000)\">\n      <g id=\"Icon\" transform=\"translate(18.821436, 18.821436) rotate(11.283864) translate(-18.821436, -18.821436) translate(2.821436, 2.821436)\">\n        <g id=\"Group\" transform=\"translate(16.062217, 4.314649) rotate(-11.283864) translate(-16.062217, -4.314649) translate(12.909354, 0.852682)\"\n          fill=\"url(#linearGradient-1)\">\n          <polygon id=\"Shape\" points=\"6.24514134 4.78196568 3.21344731 6.8053618 0.0902584276 2.12490594 3.12195246 0.101509821\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(24.576671, 23.606062) rotate(-11.283864) translate(-24.576671, -23.606062) translate(18.394587, 16.929411)\"\n          fill=\"url(#linearGradient-2)\">\n          <polygon id=\"Shape\" points=\"7.16404632 1.47319064 12.3440146 9.23541541 6.17342916 13.3533016 0.993460912 5.5909532 0.0897638609 4.23695315 6.26047291 0.119066939\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.064001, 27.069671) rotate(-11.283864) translate(-16.064001, -27.069671) translate(12.602034, 23.854988)\"\n          fill=\"url(#linearGradient-3)\">\n          <polygon id=\"Shape\" points=\"5.69777962 1.46663763 6.83825049 3.17561295 2.14147393 6.30992958 0.0973060035 3.24683056 1.12340832 2.56210293 4.79420621 0.11251393\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(27.417287, 15.726712) rotate(-11.283864) translate(-27.417287, -15.726712) translate(24.820812, 13.130236)\"\n          fill=\"url(#linearGradient-4)\">\n          <path d=\"M1.81703815,0.894671208 L3.13444027,0.0155788519 L5.17848455,3.07867787 L2.14641959,5.10207399 L1.00594872,3.39309867 L2.72061156,2.24879491 L1.81703815,0.894671208 L1.81703815,0.894671208 Z M1.00594872,3.39309867 L0.102375312,2.03897497 L1.81703815,0.894671208 L2.72061156,2.24879491 L1.00594872,3.39309867 L1.00594872,3.39309867 Z\"\n            id=\"Shape\"></path>\n        </g>\n        <g id=\"Group\" transform=\"translate(4.721041, 15.716385) rotate(-11.283864) translate(-4.721041, -15.716385) translate(0.764507, 11.759851)\"\n          fill=\"url(#linearGradient-5)\">\n          <polygon id=\"Shape\" points=\"4.17241219 7.1450055 3.14643351 7.82973313 0.0229973528 3.14927727 4.71977391 0.0149606435 6.90909717 3.29579267 3.23842293 5.74538166 6.90909717 3.29579267 7.84321007 4.69554014\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(8.822560, 7.837609) rotate(-11.283864) translate(-8.822560, -7.837609) translate(2.640476, 1.160958)\"\n          fill=\"url(#linearGradient-6)\">\n          <polygon id=\"Shape\" points=\"11.3428879 7.75332257 12.2768771 9.15307005 6.10616809 13.2709563 5.17217883 11.8712088 0.0406781133 4.18168531 6.21138716 0.0637991077\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.122857, 4.300703) rotate(-11.283864) translate(-16.122857, -4.300703) translate(12.969994, 0.900557)\"\n          fill=\"url(#linearGradient-7)\">\n          <polygon id=\"Shape\" points=\"4.86604202 5.6013391 3.15137918 6.74551923 2.21726628 5.34589539 0.0279430201 2.06506337 3.06000798 0.0416672467 6.18344414 4.72212311\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(15.822071, 25.857155) rotate(-11.283864) translate(-15.822071, -25.857155) translate(13.472879, 23.878888)\"\n          fill=\"#714896\">\n          <polygon id=\"Shape\" points=\"0.914330236 3.91622662 0.0106331846 2.56210293 3.68143107 0.11251393 4.58500448 1.46663763\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(26.180721, 15.532164) rotate(-11.283864) translate(-26.180721, -15.532164) translate(24.758842, 14.233926)\"\n          fill=\"#6F4795\">\n          <polygon id=\"Shape\" points=\"1.00594872 2.5276069 0.102375312 1.1734832 1.81703815 0.0291794369 2.72061156 1.38330313\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(6.539242, 16.614393) rotate(-11.283864) translate(-6.539242, -16.614393) translate(4.190050, 14.636126)\"\n          fill=\"#88519F\">\n          <polygon id=\"Shape\" points=\"0.957728466 3.93032178 0.0237392029 2.53069794 3.69441345 0.0811089432 4.62852635 1.48085642\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.885795, 6.228777) rotate(-11.283864) translate(-16.885795, -6.228777) translate(15.463916, 4.868718)\"\n          fill=\"#85509E\">\n          <polygon id=\"Shape\" points=\"1.04947059 2.66534373 0.115357689 1.26571989 1.83014417 0.121416131 2.76413343 1.52116361\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(21.280404, 20.355313) rotate(-11.283864) translate(-21.280404, -20.355313) translate(17.694795, 17.511554)\"\n          fill=\"#8D166A\">\n          <polygon id=\"Shape\" points=\"7.16404632 1.47319064 0.993460912 5.5909532 0.0897638609 4.23695315 6.26047291 0.119066939\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(12.058201, 11.100454) rotate(-11.283864) translate(-12.058201, -11.100454) translate(8.410771, 8.256696)\"\n          fill=\"#A70D6F\">\n          <polygon id=\"Shape\" points=\"6.27357893 0.0875383106 7.20756819 1.48728579 1.03685914 5.605172 0.102869879 4.20542452\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(1.853411, 10.678267) rotate(45.000000) translate(-1.853411, -10.678267) translate(0.797906, 9.622762)\"\n          fill=\"#9E61AD\">\n          <rect id=\"Rectangle-path\" x=\"1.66662571e-15\" y=\"0\" width=\"2.0982715\" height=\"2.0982715\"></rect>\n        </g>\n        <g id=\"Group\" transform=\"translate(12.115669, 29.966366) rotate(45.000000) translate(-12.115669, -29.966366) translate(11.060163, 28.910860)\"\n          fill=\"#8053A3\">\n          <rect id=\"Rectangle-path\" x=\"1.66662571e-15\" y=\"0\" width=\"2.0982715\" height=\"2.0982715\"></rect>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.641954, 16.427437) rotate(0.000000) translate(-16.641954, -16.427437) translate(1.422442, 1.207924)\"\n          fill=\"url(#linearGradient-8)\">\n          <polygon id=\"Shape\" points=\"6.53446157 29.8878978 0.012982374 23.3175801 23.2186668 0.0630572451 29.9596099 6.46398583\"></polygon>\n        </g>\n      </g>\n      <g id=\"Aurelia-+-Type-something\" transform=\"translate(38.131960, 3.021427)\">\n        <g id=\"Aurelia\" transform=\"translate(0.929505, 0.290297)\">\n          <g id=\"A\" transform=\"translate(0.076673, 8.413465)\" fill=\"#ED2C88\">\n            <path d=\"M8.79524752,16.5403564 C8.91089109,16.5398812 9.02811881,16.5376634 9.14376238,16.5325941 C9.38930693,16.5216634 9.63326733,16.4993267 9.87722772,16.4652673 C10.5853465,16.3659406 11.2792079,16.167604 11.9334653,15.8765941 C12.7429703,15.5166733 13.4891089,15.0162376 14.1306931,14.4050693 C14.7358416,13.8271683 15.2475248,13.1512079 15.6388119,12.4104554 C15.969901,11.7821782 16.2138614,11.1084356 16.3611881,10.4133069 C16.540198,9.56356436 16.5750495,8.68324752 16.4657426,7.82178218 C16.3643564,7.03271287 16.1425743,6.26043564 15.8051485,5.53964356 C15.4186139,4.70954455 14.8815842,3.95025743 14.230495,3.30645545 C13.5445545,2.62922772 12.7334653,2.08110891 11.8479208,1.70011881 C11.3679208,1.49354455 10.8657426,1.33607921 10.3540594,1.23136634 C9.87405941,1.13314851 9.38455446,1.0810297 8.8950495,1.07485149 C8.41821782,1.06883168 7.94138614,1.10590099 7.47247525,1.18669307 C6.94019802,1.27841584 6.41742574,1.42653465 5.91524752,1.62788119 C5.03445545,1.98130693 4.22178218,2.49916832 3.52633663,3.14582178 C2.84514851,3.78011881 2.27960396,4.53687129 1.86455446,5.37061386 C1.51287129,6.08079208 1.27049505,6.8449901 1.15009901,7.6289901 C1.0170297,8.50407921 1.03287129,9.40229703 1.20079208,10.2718416 C1.3370297,10.9859802 1.57623762,11.6801584 1.90732673,12.3274455 C2.28910891,13.0731089 2.79287129,13.7552475 3.39326733,14.3405941 C4.01425743,14.9482772 4.73821782,15.450297 5.52712871,15.8181386 C6.15920792,16.1134257 6.83247525,16.321901 7.52,16.4359604 C7.76079208,16.4758812 8.00475248,16.504396 8.24871287,16.5213465 C8.38019802,16.5305347 8.51168317,16.5359208 8.64475248,16.5389307 C8.69544554,16.5397228 8.74455446,16.540198 8.79524752,16.5403564 L8.79524752,16.5403564 Z M16.8538614,12.199604 C16.769901,12.3988911 16.6780198,12.5950099 16.579802,12.7874851 C16.1330693,13.6613069 15.5374257,14.4579802 14.8261386,15.1353663 C14.1275248,15.8018218 13.3180198,16.3518416 12.440396,16.7550099 C11.7053465,17.0924356 10.9243564,17.3265743 10.1259406,17.4487129 C9.85188119,17.4905347 9.57623762,17.5193663 9.2990099,17.5350495 C9.16910891,17.542495 9.03762376,17.5466139 8.90772277,17.5486733 C8.86970297,17.5491485 8.83168317,17.5493069 8.79524752,17.5494653 C8.66376238,17.5489901 8.53227723,17.5466139 8.40079208,17.5407525 C8.12356436,17.528396 7.84792079,17.5030495 7.57227723,17.4647129 C6.77069307,17.352396 5.9849505,17.1277624 5.24514851,16.7987327 C4.34693069,16.3988911 3.51683168,15.8460198 2.80079208,15.1714851 C2.07366337,14.4861782 1.46534653,13.6768317 1.00910891,12.7874851 C0.641584158,12.0712871 0.375445545,11.3045545 0.218613861,10.5151683 C0.0316831683,9.57037624 0.00316831683,8.59453465 0.12990099,7.63992079 C0.247128713,6.76625743 0.495841584,5.91128713 0.86970297,5.11271287 C1.31485149,4.15857426 1.93425743,3.28760396 2.68831683,2.55192079 C3.46613861,1.79073267 4.38811881,1.17671287 5.39089109,0.752316832 C5.92,0.528633663 6.47128713,0.35770297 7.03366337,0.242693069 C7.59445545,0.128 8.16633663,0.0687524752 8.73821782,0.0652673267 C9.31168317,0.0616237624 9.88514851,0.113584158 10.4491089,0.221465347 C11.0130693,0.329663366 11.5675248,0.493940594 12.099802,0.711287129 C13.1089109,1.12364356 14.0372277,1.72689109 14.8261386,2.4790495 C15.5754455,3.1930297 16.1964356,4.03960396 16.6510891,4.96918812 C16.7223762,5.11588119 16.790495,5.26447525 16.8538614,5.4149703 L16.8538614,0.0944158416 L17.8439604,0.0944158416 L17.8439604,17.5201584 L16.8538614,17.5201584 L16.8538614,12.199604 L16.8538614,12.199604 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"U\" transform=\"translate(20.353901, 8.413465)\" fill=\"#CD0F7E\">\n            <path d=\"M16.5370297,12.8188515 C16.1710891,13.5234851 15.7116832,14.1790099 15.1714851,14.761505 C14.710495,15.2605149 14.1893069,15.7056634 13.6253465,16.0845941 C13.0106931,16.4967921 12.3421782,16.8299406 11.6435644,17.0724752 C11.0637624,17.2736634 10.4617822,17.4122772 9.85188119,17.4859406 C9.64910891,17.510495 9.44792079,17.5277624 9.24356436,17.5380594 C9.13108911,17.5437624 9.02019802,17.5469307 8.90772277,17.5486733 C8.86970297,17.5491485 8.83168317,17.5493069 8.79524752,17.5494653 C8.68118812,17.5491485 8.57029703,17.5472475 8.45623762,17.5429703 C8.21544554,17.5339406 7.97465347,17.5149307 7.73544554,17.486099 C7.03366337,17.401505 6.3429703,17.2318416 5.68079208,16.981703 C4.68910891,16.6065743 3.76712871,16.0505347 2.97188119,15.3492277 C2.40792079,14.8505347 1.90574257,14.2788119 1.48752475,13.6519604 C1.03445545,12.9745743 0.678019802,12.2330297 0.435643564,11.4553663 C0.256633663,10.8830099 0.139405941,10.291802 0.0855445545,9.69473267 C0.0586138614,9.39865347 0.0491089109,9.10162376 0.0522772277,8.80443564 L0.0522772277,0.0944158416 L1.06138614,0.0944158416 L1.06138614,8.81013861 L1.06138614,8.91453465 L1.06138614,9.0140198 C1.0629703,9.1130297 1.06455446,9.21188119 1.07089109,9.31073267 C1.0819802,9.53805941 1.10415842,9.76491089 1.13584158,9.99033663 C1.22772277,10.6333465 1.40356436,11.264 1.66019802,11.8613861 C2.01980198,12.7047921 2.53623762,13.4792871 3.16990099,14.1414653 C3.79564356,14.7939802 4.53544554,15.3357624 5.3449505,15.7362376 C6.05940594,16.0890297 6.82772277,16.3310891 7.6150495,16.4511683 C8.42613861,16.5747327 9.25782178,16.5704554 10.0673267,16.4359604 C10.7057426,16.3296634 11.3314851,16.1416238 11.9239604,15.8769109 C12.7714851,15.4979802 13.5477228,14.9631683 14.2067327,14.3089109 C14.8340594,13.6853861 15.3536634,12.9552475 15.740198,12.1587327 C16.0586139,11.5003564 16.2835644,10.7976238 16.4087129,10.0771485 C16.4578218,9.80308911 16.4910891,9.52665347 16.510099,9.24926733 C16.5180198,9.11651485 16.5243564,8.98376238 16.5275248,8.85069307 L16.5275248,8.80316832 L16.5370297,0.0944158416 L17.5271287,0.0944158416 L17.5271287,17.5201584 L16.5370297,17.5201584 L16.5370297,12.8188515 L16.5370297,12.8188515 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"R\" transform=\"translate(40.314297, 8.413465)\" fill=\"#B31776\">\n            <path d=\"M1.06455446,8.41552475 L1.04237624,17.5201584 L0.0522772277,17.5201584 L0.0522772277,0.0944158416 L1.04237624,0.0944158416 L1.04237624,4.55524752 C1.16594059,4.32966337 1.30059406,4.10978218 1.44316832,3.89639604 C1.83287129,3.31691089 2.29544554,2.78637624 2.81346535,2.31889109 C3.57069307,1.63611881 4.44831683,1.08910891 5.39405941,0.706693069 C6.08950495,0.425188119 6.82138614,0.232871287 7.56594059,0.133386139 C7.82257426,0.0993267327 8.07920792,0.076039604 8.33742574,0.0635247525 C8.48633663,0.0563960396 8.63524752,0.0532277228 8.78415842,0.0527524752 L8.78732673,1.08641584 C8.75247525,1.08657426 8.71920792,1.08673267 8.68594059,1.0870495 C8.65267327,1.08752475 8.61940594,1.08815842 8.58613861,1.0889505 C8.47049505,1.0919604 8.35485149,1.09687129 8.23920792,1.10463366 C7.99524752,1.12079208 7.75287129,1.14788119 7.51207921,1.18590099 C6.87366337,1.28681188 6.24792079,1.46550495 5.65227723,1.71849505 C4.82693069,2.0700198 4.06178218,2.56506931 3.40594059,3.17813861 C2.94653465,3.60712871 2.5409901,4.09346535 2.20356436,4.62320792 C1.85663366,5.16673267 1.5809901,5.75619802 1.38930693,6.37180198 C1.25306931,6.80966337 1.15960396,7.26035644 1.10891089,7.71611881 C1.0819802,7.94851485 1.06930693,8.18186139 1.06455446,8.41552475 L1.06455446,8.41552475 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"E\" transform=\"translate(48.393505, 8.413465)\" fill=\"#9B2073\">\n            <path d=\"M9.3750495,17.5510495 L8.81584158,17.5493069 C8.77940594,17.5488317 8.74138614,17.5483564 8.70336634,17.5478812 C8.59089109,17.5453465 8.48,17.5413861 8.36752475,17.5350495 C8.12831683,17.5214257 7.88910891,17.4979802 7.65148515,17.4647129 C6.98930693,17.3720396 6.33980198,17.2033267 5.71722772,16.9623762 C4.68277228,16.5620594 3.72910891,15.9626139 2.9180198,15.2072871 C2.12118812,14.4663762 1.46534653,13.5773465 0.993267327,12.5975446 C0.643168317,11.8707327 0.394455446,11.0954455 0.258217822,10.3003564 C0.0934653465,9.35081188 0.0887128713,8.37386139 0.239207921,7.42241584 C0.400792079,6.41489109 0.73980198,5.43778218 1.23722772,4.54732673 C1.78376238,3.56879208 2.52039604,2.69845545 3.39326733,1.99524752 C3.85742574,1.62075248 4.36118812,1.29394059 4.89188119,1.02178218 C5.3829703,0.770217822 5.89782178,0.565544554 6.42851485,0.411564356 C7.18574257,0.191524752 7.97148515,0.0757227723 8.76039604,0.0657425743 C9.64118812,0.0546534653 10.5235644,0.175366337 11.369505,0.426772277 C12.3184158,0.709386139 13.2182178,1.15564356 14.019802,1.73972277 C14.8673267,2.35849505 15.6023762,3.12966337 16.1805941,4.00665347 C16.5592079,4.58233663 16.869703,5.2030099 17.1025743,5.85172277 C17.3417822,6.51675248 17.4986139,7.21093069 17.569901,7.91413861 C17.5920792,8.13607921 17.6063366,8.35881188 17.6126733,8.58186139 C17.6126733,8.63825743 17.6142574,8.69449505 17.6142574,8.75073267 C17.6158416,8.78732673 17.6158416,8.82582178 17.6126733,8.86209901 C17.609505,8.8809505 17.6063366,8.89964356 17.6031683,8.91817822 C17.590495,8.97346535 17.5683168,9.02669307 17.5382178,9.07469307 C17.4780198,9.17132673 17.3845545,9.24562376 17.2768317,9.28332673 C17.2419802,9.29584158 17.2039604,9.30439604 17.1675248,9.30867327 C17.1485149,9.31073267 17.129505,9.31073267 17.110495,9.31184158 L9.0819802,9.31184158 L9.0819802,8.30273267 L16.5893069,8.30273267 C16.5718812,8.02867327 16.540198,7.75588119 16.4926733,7.48530693 C16.4023762,6.95271287 16.2534653,6.42962376 16.0522772,5.92807921 C15.7623762,5.20538614 15.3615842,4.528 14.8689109,3.92443564 C14.3112871,3.24007921 13.6364356,2.65188119 12.8823762,2.19342574 C12.2645545,1.81845545 11.5960396,1.53077228 10.8974257,1.34194059 C10.0625743,1.11588119 9.18970297,1.03287129 8.32633663,1.09322772 C7.90653465,1.12253465 7.48831683,1.18590099 7.07960396,1.28316832 C6.63287129,1.38914851 6.19722772,1.53520792 5.77584158,1.7189703 C4.89346535,2.10487129 4.08554455,2.65790099 3.40435644,3.33908911 C3.08752475,3.65655446 2.79762376,4.00158416 2.53940594,4.3689505 C2.21623762,4.82835644 1.94376238,5.32261386 1.72831683,5.84079208 C1.50336634,6.38384158 1.34019802,6.95287129 1.24356436,7.53314851 C1.16594059,8.00332673 1.13267327,8.48063366 1.14059406,8.95730693 C1.15168317,9.49449505 1.21663366,10.0305743 1.3370297,10.5541386 C1.47643564,11.1535842 1.68712871,11.7362376 1.96435644,12.2856238 C2.26534653,12.8817426 2.6439604,13.4382574 3.08594059,13.9375842 C3.49782178,14.4007921 3.96356436,14.8145743 4.47207921,15.1673663 C4.88237624,15.4514059 5.31960396,15.6958416 5.77584158,15.895604 C6.25584158,16.1050297 6.75485149,16.2653465 7.26653465,16.3733861 C7.59920792,16.4437228 7.93821782,16.4918812 8.27722772,16.517703 C8.45940594,16.5314851 8.64,16.5384554 8.82217822,16.540198 L9.37821782,16.5419406 C9.37821782,16.8782574 9.37663366,17.2145743 9.3750495,17.5510495 L9.3750495,17.5510495 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"L\" transform=\"translate(68.512317, 0.017426)\" fill=\"#8F2475\">\n            <path d=\"M5.15009901,25.945505 C4.98851485,25.9450297 4.82693069,25.9401188 4.66534653,25.9291881 C4.32475248,25.9062178 3.98415842,25.8577426 3.65148515,25.7802772 C3.31881188,25.7026535 2.99089109,25.5957228 2.67881188,25.4566337 C2.29227723,25.2849109 1.92633663,25.0642376 1.60158416,24.7947723 C1.43049505,24.6548911 1.27207921,24.5020198 1.12633663,24.3375842 C0.942574257,24.1314851 0.780990099,23.9074851 0.641584158,23.6692277 C0.467326733,23.3699802 0.331089109,23.0491881 0.234455446,22.7168317 C0.163168317,22.4693861 0.112475248,22.2157624 0.083960396,21.9597624 C0.0601980198,21.7470099 0.0491089109,21.5329901 0.0522772277,21.3189703 L0.0522772277,0.140673267 L1.06138614,0.140673267 L1.06138614,21.3253069 L1.06138614,21.430495 C1.0629703,21.5691089 1.07089109,21.7077228 1.08673267,21.8455446 C1.11207921,22.0673267 1.15643564,22.2870495 1.2229703,22.5001188 C1.30217822,22.7510495 1.40990099,22.9927921 1.54772277,23.2172673 C1.65227723,23.3893069 1.77425743,23.5510495 1.91049505,23.699802 C2.01821782,23.8186139 2.13544554,23.9291881 2.26059406,24.0305743 C2.36514851,24.1161188 2.4760396,24.1953267 2.59009901,24.2680396 C2.68831683,24.3306139 2.78970297,24.3884356 2.89267327,24.441505 C3.38534653,24.6930693 3.92712871,24.8370693 4.47524752,24.8991683 C4.70019802,24.9246733 4.92673267,24.9357624 5.15168317,24.936396 C5.15168317,25.2727129 5.15009901,25.6090297 5.15009901,25.945505 L5.15009901,25.945505 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"I\" transform=\"translate(75.957861, 0.017426)\" fill=\"#78327A\">\n            <path d=\"M0.148910891,25.916198 L0.148910891,8.49045545 L1.1390099,8.49045545 L1.1390099,25.916198 L0.148910891,25.916198 L0.148910891,25.916198 Z M0.153663366,2.47065347 L0.153663366,0.140673267 L1.13584158,0.140673267 L1.13584158,2.47065347 L0.153663366,2.47065347 L0.153663366,2.47065347 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"A1\" transform=\"translate(79.601426, 8.413465)\" fill=\"#6E4D9B\">\n            <path d=\"M8.79524752,16.5403564 C8.91089109,16.5398812 9.02811881,16.5376634 9.14376238,16.5325941 C9.38930693,16.5216634 9.63326733,16.4993267 9.87722772,16.4652673 C10.5853465,16.3659406 11.2792079,16.167604 11.9334653,15.8765941 C12.6716832,15.5480396 13.3576238,15.1027327 13.959604,14.5626931 C14.6281188,13.9616634 15.1920792,13.2446733 15.6166337,12.451802 C15.9588119,11.811802 16.2106931,11.1236436 16.3611881,10.4133069 C16.5433663,9.54756436 16.5766337,8.65029703 16.4594059,7.77330693 C16.3548515,6.98550495 16.1267327,6.21528713 15.7861386,5.49718812 C15.3932673,4.66946535 14.8514851,3.91382178 14.1972277,3.27382178 C13.5065347,2.60055446 12.6922772,2.0570297 11.8051485,1.68174257 C11.3378218,1.48419802 10.849901,1.33291089 10.3540594,1.23136634 C9.85663366,1.12982178 9.35128713,1.07754455 8.84435644,1.07437624 C8.33742574,1.07120792 7.82891089,1.1169901 7.32990099,1.21251485 C6.83089109,1.30819802 6.34138614,1.45346535 5.87247525,1.64546535 C4.9790099,2.01029703 4.15683168,2.54415842 3.45980198,3.20950495 C2.7960396,3.84126733 2.24633663,4.59041584 1.8439604,5.41275248 C1.49544554,6.12546535 1.25782178,6.89188119 1.14376238,7.6769901 C1.01861386,8.53671287 1.0360396,9.41813861 1.20079208,10.2716832 C1.34336634,11.0167129 1.59683168,11.7395644 1.95009901,12.4104554 C2.34138614,13.1512079 2.85306931,13.8271683 3.45980198,14.4050693 C4.07762376,14.9945347 4.79366337,15.4813465 5.56990099,15.8379406 C6.21940594,16.1362376 6.91009901,16.3432871 7.61663366,16.4511683 C7.8590099,16.4882376 8.1029703,16.5135842 8.34693069,16.5275248 C8.46257426,16.5341782 8.57821782,16.5378218 8.69386139,16.5397228 C8.72871287,16.5400396 8.76039604,16.540198 8.79524752,16.5403564 L8.79524752,16.5403564 Z M16.8538614,12.199604 C16.769901,12.3988911 16.6780198,12.5950099 16.579802,12.7874851 C16.1251485,13.6768317 15.5152475,14.4861782 14.7881188,15.1714851 C14.0720792,15.8460198 13.2435644,16.3988911 12.3437624,16.7987327 C11.6039604,17.1277624 10.8182178,17.352396 10.0166337,17.4647129 C9.74257426,17.5030495 9.46534653,17.528396 9.18811881,17.5407525 C9.05663366,17.5466139 8.92514851,17.5489901 8.79524752,17.5494653 C8.66376238,17.5489901 8.53227723,17.5466139 8.40079208,17.5407525 C8.12356436,17.528396 7.84792079,17.5030495 7.57227723,17.4647129 C6.77069307,17.352396 5.9849505,17.1277624 5.24514851,16.7987327 C4.33108911,16.3917624 3.48673267,15.8262178 2.76277228,15.1353663 C2.05306931,14.4579802 1.45742574,13.6613069 1.00910891,12.7874851 C0.633663366,12.0551287 0.364356436,11.269703 0.209108911,10.4616238 C0.0316831683,9.53362376 0.00475247525,8.57631683 0.12990099,7.63976238 C0.248712871,6.74867327 0.506930693,5.87706931 0.891881188,5.06471287 C1.34336634,4.11342574 1.96752475,3.24641584 2.72475248,2.51548515 C3.50891089,1.75873267 4.43405941,1.15009901 5.44,0.731722772 C5.98811881,0.504237624 6.55841584,0.332990099 7.13980198,0.221465347 C7.68475248,0.117069307 8.23920792,0.0651089109 8.79524752,0.0651089109 C9.34970297,0.0651089109 9.90415842,0.117069307 10.4491089,0.221465347 C11.030495,0.332990099 11.6007921,0.504237624 12.1489109,0.731722772 C13.1548515,1.15009901 14.08,1.75873267 14.8641584,2.51532673 C15.6087129,3.23390099 16.2249505,4.08443564 16.6748515,5.01687129 C16.7382178,5.1480396 16.7968317,5.28079208 16.8538614,5.4149703 L16.8538614,0.0944158416 L17.8439604,0.0944158416 L17.8439604,17.5201584 C17.8423762,17.5393267 16.8538614,17.5201584 16.8538614,17.5201584 L16.8538614,12.199604 L16.8538614,12.199604 Z\"\n              id=\"Shape\"></path>\n          </g>\n        </g>\n      </g>\n    </g>\n  </svg>\n</template>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [  ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/controller-view.html":
/*!*****************************************************!*\
  !*** ./src/resources/elements/controller-view.html ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "bindables": () => /* binding */ bindables,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _controller_view_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./controller-view.css */ "./src/resources/elements/controller-view.css");



const name = "controller-view";
const template = "<template >\n  \n\n  <div class=\"category\" if.bind=\"controller.bindables.length\">\n    <h4 class=\"category-name\">Bindables</h4>\n    <ul class=\"properties\">\n      <li repeat.for=\"bindable of controller.bindables\">\n        <property-view\n          controller.bind=\"controller\"\n          property.bind=\"bindable\"\n        ></property-view>\n      </li>\n    </ul>\n  </div>\n\n  <div class=\"category\" if.bind=\"controller.properties.length\">\n    <h4 class=\"category-name\">Properties</h4>\n    <ul class=\"properties\">\n      <li repeat.for=\"property of controller.properties\">\n        <property-view\n          controller.bind=\"controller\"\n          property.bind=\"property\"\n        ></property-view>\n      </li>\n    </ul>\n  </div>\n</template>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _controller_view_css__WEBPACK_IMPORTED_MODULE_2__.default) ];
const bindables = {"controller":{}};
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies, bindables });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/debug-group.html":
/*!*************************************************!*\
  !*** ./src/resources/elements/debug-group.html ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _debug_group_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug-group.css */ "./src/resources/elements/debug-group.css");



const name = "debug-group";
const template = "\n<section>\n  <h2 class=\"header\">${heading}</h2>\n  <div class=\"content\">\n    <au-slot></au-slot>\n  </div>\n</section>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _debug_group_css__WEBPACK_IMPORTED_MODULE_2__.default) ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/property-view.html":
/*!***************************************************!*\
  !*** ./src/resources/elements/property-view.html ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _property_view_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./property-view.css */ "./src/resources/elements/property-view.css");



const name = "property-view";
const template = "\n\n<span class=\"property-line\">\n  <span\n    css=\"opacity: ${property.canExpand ? 1 : 0}\"\n    class=\"arrow\"\n    click.trigger=\"debugHost.toggleDebugValueExpansion(property)\"\n  >\n    <span if.bind=\"property.isExpanded\" class=\"down\"></span>\n    <span if.bind=\"!property.isExpanded\" class=\"right\"></span>\n  </span>\n  <span class=\"property-name\">${property.name}</span\n  ><span class=\"token-colon\">:</span>&nbsp;\n\n  <span class=\"value-container\">\n    <span\n      if.bind=\"property.type === 'string' && !property.isEditing\"\n      class=\"property-value string\"\n      >\"</span\n    ><span\n      if.bind=\"!property.isEditing\"\n      class=\"property-value ${property.type}\"\n      click.trigger=\"beginEditing()\"\n      >${property.value}</span\n    ><span\n      if.bind=\"property.type === 'string' && !property.isEditing\"\n      class=\"property-value string\"\n      >\"</span\n    >\n\n    <!-- <select\n      if.bind=\"property.isEditing &&  property.type === 'boolean'\"\n      class=\"property-editor\"\n      value.bind=\"false\"\n    >\n      <option model.bind=\"true\">True</option>\n      <option model.bind=\"false\">False</option>\n    </select> -->\n\n    <input\n      if.bind=\"property.isEditing\"\n      class=\"property-editor\"\n      ref=\"editor\"\n      type=\"text\"\n      value.bind=\"property.value\"\n      keyup.trigger=\"onKeyDown($event)\"\n      blur.trigger=\"endEditing()\"\n    />\n  </span>\n</span>\n\n<ul if.bind=\"property.isExpanded && property.expandedValue\" class=\"properties\">\n  <div\n    if.bind=\"!property.expandedValue.properties.length\"\n    class=\"no-properties\"\n  >\n    Object has no properties.\n  </div>\n  <li repeat.for=\"p of property.expandedValue.properties\">\n    <property-view property.bind=\"p\"></property-view>\n  </li>\n</ul>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _property_view_css__WEBPACK_IMPORTED_MODULE_2__.default) ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./node_modules/aurelia/dist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/aurelia/dist/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PLATFORM": () => /* binding */ PLATFORM,
/* harmony export */   "IPlatform": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IPlatform,
/* harmony export */   "Aurelia": () => /* binding */ Aurelia,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "json": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.json,
/* harmony export */   "HttpClientConfiguration": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.HttpClientConfiguration,
/* harmony export */   "HttpClient": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.HttpClient,
/* harmony export */   "IHttpClient": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.IHttpClient,
/* harmony export */   "all": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.all,
/* harmony export */   "DI": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI,
/* harmony export */   "IContainer": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer,
/* harmony export */   "inject": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.inject,
/* harmony export */   "IServiceLocator": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IServiceLocator,
/* harmony export */   "lazy": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.lazy,
/* harmony export */   "optional": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.optional,
/* harmony export */   "Registration": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration,
/* harmony export */   "singleton": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.singleton,
/* harmony export */   "transient": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.transient,
/* harmony export */   "InstanceProvider": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider,
/* harmony export */   "Metadata": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata,
/* harmony export */   "ColorOptions": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ColorOptions,
/* harmony export */   "ILogger": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger,
/* harmony export */   "LoggerConfiguration": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.LoggerConfiguration,
/* harmony export */   "emptyArray": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray,
/* harmony export */   "emptyObject": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyObject,
/* harmony export */   "noop": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop,
/* harmony export */   "LogLevel": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.LogLevel,
/* harmony export */   "EventAggregator": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.EventAggregator,
/* harmony export */   "IEventAggregator": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IEventAggregator,
/* harmony export */   "isArrayIndex": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isArrayIndex,
/* harmony export */   "camelCase": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase,
/* harmony export */   "kebabCase": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase,
/* harmony export */   "pascalCase": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.pascalCase,
/* harmony export */   "toArray": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray,
/* harmony export */   "bound": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.bound,
/* harmony export */   "NavRoute": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.NavRoute,
/* harmony export */   "RouterOptions": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.RouterOptions,
/* harmony export */   "IRouter": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.IRouter,
/* harmony export */   "Router": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.Router,
/* harmony export */   "ViewportInstruction": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.ViewportInstruction,
/* harmony export */   "RouterConfiguration": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.RouterConfiguration,
/* harmony export */   "RouterRegistration": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.RouterRegistration,
/* harmony export */   "ComputedObserver": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ComputedObserver,
/* harmony export */   "ComputedWatcher": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ComputedWatcher,
/* harmony export */   "ExpressionWatcher": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ExpressionWatcher,
/* harmony export */   "Watch": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Watch,
/* harmony export */   "watch": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.watch,
/* harmony export */   "IObserverLocator": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator,
/* harmony export */   "ISignaler": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ISignaler,
/* harmony export */   "subscriberCollection": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection,
/* harmony export */   "bindingBehavior": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindingBehavior,
/* harmony export */   "BindingBehavior": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.BindingBehavior,
/* harmony export */   "customAttribute": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customAttribute,
/* harmony export */   "CustomAttribute": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomAttribute,
/* harmony export */   "templateController": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.templateController,
/* harmony export */   "containerless": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.containerless,
/* harmony export */   "customElement": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement,
/* harmony export */   "CustomElement": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement,
/* harmony export */   "useShadowDOM": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.useShadowDOM,
/* harmony export */   "ValueConverter": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ValueConverter,
/* harmony export */   "valueConverter": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.valueConverter,
/* harmony export */   "AppTask": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.TaskQueuePriority,
/* harmony export */   "bindable": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable,
/* harmony export */   "Bindable": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Bindable,
/* harmony export */   "children": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.children,
/* harmony export */   "Controller": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Controller,
/* harmony export */   "ViewFactory": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ViewFactory,
/* harmony export */   "IAppRoot": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAppRoot,
/* harmony export */   "alias": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.alias,
/* harmony export */   "registerAliases": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.registerAliases,
/* harmony export */   "INode": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.INode,
/* harmony export */   "IEventTarget": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IEventTarget,
/* harmony export */   "IRenderLocation": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation,
/* harmony export */   "BindingMode": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.BindingMode,
/* harmony export */   "LifecycleFlags": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.LifecycleFlags,
/* harmony export */   "renderer": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.renderer,
/* harmony export */   "IAurelia": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAurelia,
/* harmony export */   "NodeObserverLocator": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.NodeObserverLocator,
/* harmony export */   "attributePattern": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.attributePattern,
/* harmony export */   "IAttributePattern": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAttributePattern,
/* harmony export */   "IAttrSyntaxTransformer": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAttrSyntaxTransformer,
/* harmony export */   "bindingCommand": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindingCommand,
/* harmony export */   "getTarget": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.getTarget,
/* harmony export */   "ShortHandBindingSyntax": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ShortHandBindingSyntax,
/* harmony export */   "createElement": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.createElement,
/* harmony export */   "StyleConfiguration": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.StyleConfiguration,
/* harmony export */   "cssModules": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.cssModules,
/* harmony export */   "shadowCSS": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.shadowCSS
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @aurelia/platform-browser */ "./node_modules/@aurelia/platform-browser/dist/esm/index.js");
/* harmony import */ var _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aurelia/fetch-client */ "./node_modules/@aurelia/fetch-client/dist/esm/index.js");
/* harmony import */ var _aurelia_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @aurelia/router */ "./node_modules/@aurelia/router/dist/esm/index.js");



const PLATFORM = _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_2__.BrowserPlatform.getOrCreate(globalThis);

function createContainer() {
    return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer()
        .register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IPlatform, PLATFORM), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.StandardConfiguration);
}
class Aurelia extends _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Aurelia {
    constructor(container = createContainer()) {
        super(container);
    }
    static start(root) {
        return new Aurelia().start(root);
    }
    static app(config) {
        return new Aurelia().app(config);
    }
    static enhance(config) {
        return new Aurelia().enhance(config);
    }
    static register(...params) {
        return new Aurelia().register(...params);
    }
    app(config) {
        if (_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.isType(config)) {
            // Default to custom element element name
            const definition = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.getDefinition(config);
            let host = document.querySelector(definition.name);
            if (host === null) {
                // When no target is found, default to body.
                // For example, when user forgot to write <my-app></my-app> in html.
                host = document.body;
            }
            return super.app({
                host: host,
                component: config
            });
        }
        return super.app(config);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Aurelia);




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/app.css":
/*!***********************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/app.css ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".app-header {\n  background: #f4f4f4;\n  padding: 0;\n  padding: 5px 0 0 0;\n  text-align: center;\n}\n\n.dark .app-header {\n  background: #2a2a2a;\n}\n\n.logo-badge {\n  position: relative;\n  top: -7px;\n  font-weight: 100;\n  font-size: 16px;\n  color: #BB79A8;\n}\n\n.not-found {\n  font-style: italic;\n  font-size: 10px;\n}\n\n.dark .not-found {\n  color: #989898;\n}\n\n.custom-attribute {\n  margin-bottom: 4px;\n}\n\n.custom-attribute .attribute-name {\n  color: saddlebrown;\n}\n.dark .custom-attribute .attribute-name {\n  color: #ef9565;\n}\n\n.custom-attribute .block-token {\n  color: gray;\n}\n\n.custom-attribute .attribute-name, .custom-attribute .block-token {\n  font-size: 12px;\n  display: inline;\n  font-family: monospace;\n}\n\n.custom-attribute controller-view {\n  margin-left: 8px;\n  display: block;\n}\n\ncustom-element {\n  margin-top: 2px;\n  display: block;\n}\n\ncustom-element .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\ncustom-element .arrow .right {\n  margin-right: 1px;\n}\n\ncustom-element .property-line {\n  white-space: nowrap;\n}\n\ncustom-element .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark custom-element .property-name {\n  color: #34c7bb;\n}\ncustom-element .value-container {\n  position: relative;\n}\n\ncustom-element .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0,0,0,.5);\n  position: absolute;\n  top: 4px;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\ncustom-element .property-value, custom-element .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\ncustom-element .property-value.null, custom-element .property-value.undefined {\n  color: dimgray;\n}\n\ncustom-element .property-value.boolean {\n  color: deeppink;\n}\n\ncustom-element .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark custom-element .property-value.string {\n  color:#cbcbcb;\n}\n\ncustom-element .property-value.number {\n  color: blue;\n}\n\n.dark custom-element .property-value.number {\n  color: #59a6ca;\n}\n\ncustom-element .property-value.array {\n  color: black;\n}\n\n.dark custom-element .property-value.array {\n  color: #cbcbcb;\n}\n\ncustom-element .property-value.object, custom-element .property-value.node {\n  color: black;\n}\n\n.dark custom-element .property-value.object, custom-element .property-value.node {\n  color: #cbcbcb;\n}\n\ncustom-element ul.properties {\n  margin-left: 16px;\n}\n\ncustom-element .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark custom-element .no-properties {\n  color: #989898;\n}\n", "",{"version":3,"sources":["webpack://./src/app.css"],"names":[],"mappings":"AAAA;EACE,mBAAmB;EACnB,UAAU;EACV,kBAAkB;EAClB,kBAAkB;AACpB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,gBAAgB;EAChB,eAAe;EACf,cAAc;AAChB;;AAEA;EACE,kBAAkB;EAClB,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,eAAe;EACf,eAAe;EACf,sBAAsB;AACxB;;AAEA;EACE,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,eAAe;EACf,aAAa;EACb,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,sBAAsB;EACtB,eAAe;EACf,SAAS;EACT,YAAY;EACZ,aAAa;EACb,0BAA0B;EAC1B,kCAAkC;EAClC,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,sBAAsB;AACxB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,UAAU;EACV,mBAAmB;AACrB;AACA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,eAAe;EACf,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB","sourcesContent":[".app-header {\n  background: #f4f4f4;\n  padding: 0;\n  padding: 5px 0 0 0;\n  text-align: center;\n}\n\n.dark .app-header {\n  background: #2a2a2a;\n}\n\n.logo-badge {\n  position: relative;\n  top: -7px;\n  font-weight: 100;\n  font-size: 16px;\n  color: #BB79A8;\n}\n\n.not-found {\n  font-style: italic;\n  font-size: 10px;\n}\n\n.dark .not-found {\n  color: #989898;\n}\n\n.custom-attribute {\n  margin-bottom: 4px;\n}\n\n.custom-attribute .attribute-name {\n  color: saddlebrown;\n}\n.dark .custom-attribute .attribute-name {\n  color: #ef9565;\n}\n\n.custom-attribute .block-token {\n  color: gray;\n}\n\n.custom-attribute .attribute-name, .custom-attribute .block-token {\n  font-size: 12px;\n  display: inline;\n  font-family: monospace;\n}\n\n.custom-attribute controller-view {\n  margin-left: 8px;\n  display: block;\n}\n\ncustom-element {\n  margin-top: 2px;\n  display: block;\n}\n\ncustom-element .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\ncustom-element .arrow .right {\n  margin-right: 1px;\n}\n\ncustom-element .property-line {\n  white-space: nowrap;\n}\n\ncustom-element .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark custom-element .property-name {\n  color: #34c7bb;\n}\ncustom-element .value-container {\n  position: relative;\n}\n\ncustom-element .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0,0,0,.5);\n  position: absolute;\n  top: 4px;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\ncustom-element .property-value, custom-element .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\ncustom-element .property-value.null, custom-element .property-value.undefined {\n  color: dimgray;\n}\n\ncustom-element .property-value.boolean {\n  color: deeppink;\n}\n\ncustom-element .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark custom-element .property-value.string {\n  color:#cbcbcb;\n}\n\ncustom-element .property-value.number {\n  color: blue;\n}\n\n.dark custom-element .property-value.number {\n  color: #59a6ca;\n}\n\ncustom-element .property-value.array {\n  color: black;\n}\n\n.dark custom-element .property-value.array {\n  color: #cbcbcb;\n}\n\ncustom-element .property-value.object, custom-element .property-value.node {\n  color: black;\n}\n\n.dark custom-element .property-value.object, custom-element .property-value.node {\n  color: #cbcbcb;\n}\n\ncustom-element ul.properties {\n  margin-left: 16px;\n}\n\ncustom-element .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark custom-element .no-properties {\n  color: #989898;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/reset.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/reset.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* http://meyerweb.com/eric/tools/css/reset/\n   v2.0 | 20110126\n   License: none (public domain)\n*/\n\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tfont-size: 100%;\n\tfont: inherit;\n\tvertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n\tdisplay: block;\n}\nbody {\n\tline-height: 1;\n}\nol, ul {\n\tlist-style: none;\n}\nblockquote, q {\n\tquotes: none;\n}\nblockquote:before, blockquote:after,\nq:before, q:after {\n\tcontent: '';\n\tcontent: none;\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n\n/*! normalize.css v5.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Change the default font family in all browsers (opinionated).\n * 2. Correct the line height in all browsers.\n * 3. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  font-family: sans-serif; /* 1 */\n  line-height: 1.15; /* 2 */\n  -ms-text-size-adjust: 100%; /* 3 */\n  -webkit-text-size-adjust: 100%; /* 3 */\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Change the border, margin, and padding in all browsers (opinionated).\n */\n\nfieldset {\n  border: 1px solid #c0c0c0;\n  margin: 0 2px;\n  padding: 0.35em 0.625em 0.75em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n", "",{"version":3,"sources":["webpack://./src/reset.css"],"names":[],"mappings":"AAAA;;;CAGC;;AAED;;;;;;;;;;;;;CAaC,SAAS;CACT,UAAU;CACV,SAAS;CACT,eAAe;CACf,aAAa;CACb,wBAAwB;AACzB;AACA,gDAAgD;AAChD;;CAEC,cAAc;AACf;AACA;CACC,cAAc;AACf;AACA;CACC,gBAAgB;AACjB;AACA;CACC,YAAY;AACb;AACA;;CAEC,WAAW;CACX,aAAa;AACd;AACA;CACC,yBAAyB;CACzB,iBAAiB;AAClB;;AAEA,2EAA2E;;AAE3E;+EAC+E;;AAE/E;;;;;EAKE;;AAEF;EACE,uBAAuB,EAAE,MAAM;EAC/B,iBAAiB,EAAE,MAAM;EACzB,0BAA0B,EAAE,MAAM;EAClC,8BAA8B,EAAE,MAAM;AACxC;;AAEA;+EAC+E;;AAE/E;;;EAGE;;AAEF;;;;;EAKE,uBAAuB,EAAE,MAAM;EAC/B,eAAe,EAAE,MAAM;EACvB,iBAAiB,EAAE,MAAM;EACzB,SAAS,EAAE,MAAM;AACnB;;AAEA;;;EAGE;;AAEF;QACQ,MAAM;EACZ,iBAAiB;AACnB;;AAEA;;;EAGE;;AAEF;SACS,MAAM;EACb,oBAAoB;AACtB;;AAEA;;;;EAIE;;AAEF;;;;EAIE,0BAA0B,EAAE,MAAM;AACpC;;AAEA;;EAEE;;AAEF;;;;EAIE,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE;;AAEF;;;;EAIE,8BAA8B;AAChC;;AAEA;;EAEE;;AAEF;EACE,yBAAyB;EACzB,aAAa;EACb,8BAA8B;AAChC;;AAEA;;;;;EAKE;;AAEF;EACE,sBAAsB,EAAE,MAAM;EAC9B,cAAc,EAAE,MAAM;EACtB,cAAc,EAAE,MAAM;EACtB,eAAe,EAAE,MAAM;EACvB,UAAU,EAAE,MAAM;EAClB,mBAAmB,EAAE,MAAM;AAC7B;;AAEA;;;EAGE;;AAEF;EACE,qBAAqB,EAAE,MAAM;EAC7B,wBAAwB,EAAE,MAAM;AAClC;;AAEA;;EAEE;;AAEF;EACE,cAAc;AAChB;;AAEA;;;EAGE;;AAEF;;EAEE,sBAAsB,EAAE,MAAM;EAC9B,UAAU,EAAE,MAAM;AACpB;;AAEA;;EAEE;;AAEF;;EAEE,YAAY;AACd;;AAEA;;;EAGE;;AAEF;EACE,6BAA6B,EAAE,MAAM;EACrC,oBAAoB,EAAE,MAAM;AAC9B;;AAEA;;EAEE;;AAEF;;EAEE,wBAAwB;AAC1B;;AAEA;;;EAGE;;AAEF;EACE,0BAA0B,EAAE,MAAM;EAClC,aAAa,EAAE,MAAM;AACvB","sourcesContent":["/* http://meyerweb.com/eric/tools/css/reset/\n   v2.0 | 20110126\n   License: none (public domain)\n*/\n\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tfont-size: 100%;\n\tfont: inherit;\n\tvertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n\tdisplay: block;\n}\nbody {\n\tline-height: 1;\n}\nol, ul {\n\tlist-style: none;\n}\nblockquote, q {\n\tquotes: none;\n}\nblockquote:before, blockquote:after,\nq:before, q:after {\n\tcontent: '';\n\tcontent: none;\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n\n/*! normalize.css v5.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Change the default font family in all browsers (opinionated).\n * 2. Correct the line height in all browsers.\n * 3. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  font-family: sans-serif; /* 1 */\n  line-height: 1.15; /* 2 */\n  -ms-text-size-adjust: 100%; /* 3 */\n  -webkit-text-size-adjust: 100%; /* 3 */\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Change the border, margin, and padding in all browsers (opinionated).\n */\n\nfieldset {\n  border: 1px solid #c0c0c0;\n  margin: 0 2px;\n  padding: 0.35em 0.625em 0.75em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/controller-view.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/elements/controller-view.css ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: black;\n}\n\n.dark controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: white;\n}\n", "",{"version":3,"sources":["webpack://./src/resources/elements/controller-view.css"],"names":[],"mappings":"AAAA;EACE,eAAe;EACf,kBAAkB;EAClB,eAAe;EACf,YAAY;AACd;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,eAAe;EACf,YAAY;AACd","sourcesContent":["controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: black;\n}\n\n.dark controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: white;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/debug-group.css":
/*!**************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/elements/debug-group.css ***!
  \**************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "debug-group .header {\n  font-weight: normal;\n  font-size: 12px;\n  margin: 0;\n  padding: 4px;\n  background: #f4f4f4;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.25);\n  border-top: 1px solid rgba(0, 0, 0, 0.25);\n}\n\n.dark debug-group .header {\n  color: #989898;\n  background: #2a2a2a;\n  border-bottom: 1px solid #5c5c5c;\n  border-top: 1px solid #3d3d3d;\n}\n\ndebug-group .content {\n  margin: 4px;\n}\n", "",{"version":3,"sources":["webpack://./src/resources/elements/debug-group.css"],"names":[],"mappings":"AAAA;EACE,mBAAmB;EACnB,eAAe;EACf,SAAS;EACT,YAAY;EACZ,mBAAmB;EACnB,4CAA4C;EAC5C,yCAAyC;AAC3C;;AAEA;EACE,cAAc;EACd,mBAAmB;EACnB,gCAAgC;EAChC,6BAA6B;AAC/B;;AAEA;EACE,WAAW;AACb","sourcesContent":["debug-group .header {\n  font-weight: normal;\n  font-size: 12px;\n  margin: 0;\n  padding: 4px;\n  background: #f4f4f4;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.25);\n  border-top: 1px solid rgba(0, 0, 0, 0.25);\n}\n\n.dark debug-group .header {\n  color: #989898;\n  background: #2a2a2a;\n  border-bottom: 1px solid #5c5c5c;\n  border-top: 1px solid #3d3d3d;\n}\n\ndebug-group .content {\n  margin: 4px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/property-view.css":
/*!****************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/elements/property-view.css ***!
  \****************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "property-view {\n  padding-top: 2px;\n  padding-bottom: 2px;\n  display: block;\n}\n\nproperty-view .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\nproperty-view .arrow .right {\n  margin-right: 1px;\n}\n\nproperty-view .property-line {\n  white-space: nowrap;\n}\n\nproperty-view .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark property-view .property-name {\n  color: #34c7bb;\n}\nproperty-view .value-container {\n  position: relative;\n}\n\nproperty-view .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n  position: absolute;\n  top: 0;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\nproperty-view .property-value,\nproperty-view .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\nproperty-view .property-value.null,\nproperty-view .property-value.undefined {\n  color: dimgray;\n}\n\nproperty-view .property-value.boolean {\n  color: deeppink;\n}\n\nproperty-view .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark property-view .property-value.string {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.number {\n  color: blue;\n}\n\n.dark property-view .property-value.number {\n  color: #59a6ca;\n}\n\nproperty-view .property-value.array {\n  color: black;\n}\n\n.dark property-view .property-value.array {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.object,\nproperty-view .property-value.node {\n  color: black;\n}\n\n.dark property-view .property-value.object,\nproperty-view .property-value.node {\n  color: #cbcbcb;\n}\n\nproperty-view ul.properties {\n  margin-left: 16px;\n}\n\nproperty-view .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark property-view .no-properties {\n  color: #989898;\n}\n", "",{"version":3,"sources":["webpack://./src/resources/elements/property-view.css"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,eAAe;EACf,aAAa;EACb,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,sBAAsB;EACtB,eAAe;EACf,SAAS;EACT,YAAY;EACZ,aAAa;EACb,0BAA0B;EAC1B,sCAAsC;EACtC,kBAAkB;EAClB,MAAM;EACN,SAAS;EACT,kBAAkB;AACpB;;AAEA;;EAEE,eAAe;EACf,cAAc;EACd,sBAAsB;AACxB;;AAEA;;EAEE,cAAc;AAChB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,UAAU;EACV,mBAAmB;AACrB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;;EAEE,YAAY;AACd;;AAEA;;EAEE,cAAc;AAChB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,eAAe;EACf,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB","sourcesContent":["property-view {\n  padding-top: 2px;\n  padding-bottom: 2px;\n  display: block;\n}\n\nproperty-view .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\nproperty-view .arrow .right {\n  margin-right: 1px;\n}\n\nproperty-view .property-line {\n  white-space: nowrap;\n}\n\nproperty-view .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark property-view .property-name {\n  color: #34c7bb;\n}\nproperty-view .value-container {\n  position: relative;\n}\n\nproperty-view .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n  position: absolute;\n  top: 0;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\nproperty-view .property-value,\nproperty-view .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\nproperty-view .property-value.null,\nproperty-view .property-value.undefined {\n  color: dimgray;\n}\n\nproperty-view .property-value.boolean {\n  color: deeppink;\n}\n\nproperty-view .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark property-view .property-value.string {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.number {\n  color: blue;\n}\n\n.dark property-view .property-value.number {\n  color: #59a6ca;\n}\n\nproperty-view .property-value.array {\n  color: black;\n}\n\n.dark property-view .property-value.array {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.object,\nproperty-view .property-value.node {\n  color: black;\n}\n\n.dark property-view .property-value.object,\nproperty-view .property-value.node {\n  color: #cbcbcb;\n}\n\nproperty-view ul.properties {\n  margin-left: 16px;\n}\n\nproperty-view .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark property-view .no-properties {\n  color: #989898;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (typeof btoa === 'function') {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
};

/***/ }),

/***/ "./src/app.css":
/*!*********************!*\
  !*** ./src/app.css ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./app.css */ "./node_modules/css-loader/dist/cjs.js!./src/app.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/reset.css":
/*!***********************!*\
  !*** ./src/reset.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./reset.css */ "./node_modules/css-loader/dist/cjs.js!./src/reset.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/resources/elements/controller-view.css":
/*!****************************************************!*\
  !*** ./src/resources/elements/controller-view.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_controller_view_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./controller-view.css */ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/controller-view.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_controller_view_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_controller_view_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/resources/elements/debug-group.css":
/*!************************************************!*\
  !*** ./src/resources/elements/debug-group.css ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_debug_group_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./debug-group.css */ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/debug-group.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_debug_group_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_debug_group_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/resources/elements/property-view.css":
/*!**************************************************!*\
  !*** ./src/resources/elements/property-view.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_property_view_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./property-view.css */ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/property-view.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_property_view_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_property_view_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringifyValueConverter": () => /* binding */ StringifyValueConverter,
/* harmony export */   "App": () => /* binding */ App
/* harmony export */ });
/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.html */ "./src/app.html");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _backend_debug_host__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./backend/debug-host */ "./src/backend/debug-host.ts");
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




let StringifyValueConverter = class StringifyValueConverter {
    toView(value) {
        return JSON.stringify(value);
    }
};
StringifyValueConverter = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.valueConverter)('stringify')
], StringifyValueConverter);

let App = class App {
    constructor(debugHost, plat) {
        this.debugHost = debugHost;
        this.plat = plat;
        this.isDarkTheme = false;
        this.JSON = JSON;
        this.selectedElement = undefined;
        this.selectedElementAttributes = undefined;
        this.allAureliaObjects = undefined;
    }
    attaching() {
        this.debugHost.attach(this);
        this.isDarkTheme = chrome?.devtools?.panels?.themeName === "dark";
        [].join();
    }
    get currentController() {
        return this.selectedElement;
    }
    valueChanged(element) {
        this.plat.queueMicrotask(() => this.debugHost.updateValues(element));
    }
};
App = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)({ ..._app_html__WEBPACK_IMPORTED_MODULE_0__, dependencies: [..._app_html__WEBPACK_IMPORTED_MODULE_0__.dependencies, StringifyValueConverter] }),
    (0,aurelia__WEBPACK_IMPORTED_MODULE_3__.inject)(),
    __param(1, aurelia__WEBPACK_IMPORTED_MODULE_3__.IPlatform),
    __metadata("design:paramtypes", [_backend_debug_host__WEBPACK_IMPORTED_MODULE_2__.DebugHost, Object])
], App);



/***/ }),

/***/ "./src/backend/debug-host.ts":
/*!***********************************!*\
  !*** ./src/backend/debug-host.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectionChanged": () => /* binding */ SelectionChanged,
/* harmony export */   "DebugHost": () => /* binding */ DebugHost
/* harmony export */ });
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class SelectionChanged {
    constructor(debugInfo) {
        this.debugInfo = debugInfo;
    }
}
let DebugHost = class DebugHost {
    attach(consumer) {
        this.consumer = consumer;
        if (chrome && chrome.devtools) {
            chrome.devtools.network.onNavigated.addListener(() => {
                chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.getAllInfo()`, (debugObject) => {
                    this.consumer.allAureliaObjects = debugObject;
                });
            });
            chrome.devtools.panels.elements.onSelectionChanged.addListener(() => {
                chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.getCustomElementInfo($0, false)`, (debugObject) => {
                    this.consumer.selectedElement = debugObject?.customElementInfo;
                    this.consumer.selectedElementAttributes = debugObject?.customAttributesInfo;
                });
            });
            chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.getAllInfo()`, (debugObject) => {
                this.consumer.allAureliaObjects = debugObject;
            });
        }
    }
    updateValues(value) {
        chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.updateValues(${JSON.stringify(value)})`, (debugObject) => {
            // this.consumer.selectedElement = debugObject;
        });
    }
    updateDebugValue(debugInfo) {
        let value = debugInfo.value;
        if (debugInfo.type === "string") {
            value = "'" + value + "'";
        }
        let code = `aureliaDebugger.updateValueForId(${debugInfo.debugId}, ${value})`;
        chrome.devtools.inspectedWindow.eval(code);
    }
    toggleDebugValueExpansion(debugInfo) {
        if (debugInfo.canExpand) {
            debugInfo.isExpanded = !debugInfo.isExpanded;
            if (debugInfo.isExpanded && !debugInfo.expandedValue) {
                let code = `aureliaDebugger.getExpandedDebugValueForId(${debugInfo.debugId});`;
                chrome.devtools.inspectedWindow.eval(code, (expandedValue) => {
                    debugInfo.expandedValue = expandedValue;
                    debugInfo.isExpanded = true;
                });
            }
        }
    }
};
DebugHost = __decorate([
    (0,aurelia__WEBPACK_IMPORTED_MODULE_0__.inject)()
], DebugHost);



/***/ }),

/***/ "./src/custom-elements/custom-element/custom-element.ts":
/*!**************************************************************!*\
  !*** ./src/custom-elements/custom-element/custom-element.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomElement": () => /* binding */ CustomElement
/* harmony export */ });
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
/* harmony import */ var _custom_element_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./custom-element.html */ "./src/custom-elements/custom-element/custom-element.html");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let CustomElement = class CustomElement {
    constructor() {
        // you can inject the element or any DI in the constructor
    }
};
CustomElement = __decorate([
    (0,aurelia__WEBPACK_IMPORTED_MODULE_0__.customElement)({ name: 'custom-element', template: _custom_element_html__WEBPACK_IMPORTED_MODULE_1__.default }),
    __metadata("design:paramtypes", [])
], CustomElement);



/***/ }),

/***/ "./src/custom-elements/index.ts":
/*!**************************************!*\
  !*** ./src/custom-elements/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomElement": () => /* reexport safe */ _custom_element_custom_element__WEBPACK_IMPORTED_MODULE_0__.CustomElement
/* harmony export */ });
/* harmony import */ var _custom_element_custom_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./custom-element/custom-element */ "./src/custom-elements/custom-element/custom-element.ts");



/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app */ "./src/app.ts");
/* harmony import */ var _custom_elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./custom-elements */ "./src/custom-elements/index.ts");
/* harmony import */ var _resources_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resources/index */ "./src/resources/index.ts");





const aurelia = new aurelia__WEBPACK_IMPORTED_MODULE_0__.default(aurelia__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer()
    .register(aurelia__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(aurelia__WEBPACK_IMPORTED_MODULE_0__.IPlatform, aurelia__WEBPACK_IMPORTED_MODULE_0__.PLATFORM), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.StandardConfiguration, _custom_elements__WEBPACK_IMPORTED_MODULE_3__, _resources_index__WEBPACK_IMPORTED_MODULE_4__)).app(_app__WEBPACK_IMPORTED_MODULE_2__.App);
aurelia.start();


/***/ }),

/***/ "./src/resources/elements/debug-group.ts":
/*!***********************************************!*\
  !*** ./src/resources/elements/debug-group.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugGroup": () => /* binding */ DebugGroup
/* harmony export */ });
/* harmony import */ var _debug_group_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug-group.html */ "./src/resources/elements/debug-group.html");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let DebugGroup = class DebugGroup {
};
__decorate([
    aurelia__WEBPACK_IMPORTED_MODULE_2__.bindable,
    __metadata("design:type", String)
], DebugGroup.prototype, "heading", void 0);
DebugGroup = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)(_debug_group_html__WEBPACK_IMPORTED_MODULE_0__)
], DebugGroup);



/***/ }),

/***/ "./src/resources/elements/property-view.ts":
/*!*************************************************!*\
  !*** ./src/resources/elements/property-view.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyView": () => /* binding */ PropertyView
/* harmony export */ });
/* harmony import */ var _property_view_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property-view.html */ "./src/resources/elements/property-view.html");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
/* harmony import */ var _backend_debug_host__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../backend/debug-host */ "./src/backend/debug-host.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




const editableTypes = ['string', 'number', 'boolean', 'bigint'];
let PropertyView = class PropertyView {
    constructor(debugHost, platform) {
        this.debugHost = debugHost;
        this.platform = platform;
    }
    beginEditing() {
        if (editableTypes.some(x => x === this.property?.type || this.property.value == null)) {
            this.property.isEditing = true;
            this.platform.queueMicrotask(() => {
                this.editor.focus();
                this.editor.select();
            });
        }
    }
    keyup(e) {
        if (e.code === 'Enter') {
            this.endEditing();
        }
        if (this.property.type === 'undefined') {
            this.property.type = 'string';
        }
        this.platform.queueMicrotask(() => this.debugHost.updateValues(this.controller));
        return true;
    }
    endEditing() {
        this.property.isEditing = false;
    }
};
__decorate([
    aurelia__WEBPACK_IMPORTED_MODULE_2__.bindable,
    __metadata("design:type", Object)
], PropertyView.prototype, "property", void 0);
__decorate([
    aurelia__WEBPACK_IMPORTED_MODULE_2__.bindable,
    __metadata("design:type", Object)
], PropertyView.prototype, "controller", void 0);
PropertyView = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)(_property_view_html__WEBPACK_IMPORTED_MODULE_0__),
    (0,aurelia__WEBPACK_IMPORTED_MODULE_2__.inject)(),
    __param(1, aurelia__WEBPACK_IMPORTED_MODULE_2__.IPlatform),
    __metadata("design:paramtypes", [_backend_debug_host__WEBPACK_IMPORTED_MODULE_3__.DebugHost, Object])
], PropertyView);



/***/ }),

/***/ "./src/resources/index.ts":
/*!********************************!*\
  !*** ./src/resources/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugGroup": () => /* reexport safe */ _elements_debug_group__WEBPACK_IMPORTED_MODULE_0__.DebugGroup,
/* harmony export */   "PropertyView": () => /* reexport safe */ _elements_property_view__WEBPACK_IMPORTED_MODULE_1__.PropertyView,
/* harmony export */   "t": () => /* reexport module object */ _elements_aurelia_logo_html__WEBPACK_IMPORTED_MODULE_2__,
/* harmony export */   "t2": () => /* reexport module object */ _elements_controller_view_html__WEBPACK_IMPORTED_MODULE_3__
/* harmony export */ });
/* harmony import */ var _elements_debug_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elements/debug-group */ "./src/resources/elements/debug-group.ts");
/* harmony import */ var _elements_property_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elements/property-view */ "./src/resources/elements/property-view.ts");
/* harmony import */ var _elements_aurelia_logo_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elements/aurelia-logo.html */ "./src/resources/elements/aurelia-logo.html");
/* harmony import */ var _elements_controller_view_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./elements/controller-view.html */ "./src/resources/elements/controller-view.html");






/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/main.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvZmV0Y2gtY2xpZW50L2Rpc3QvZXNtL2h0dHAtY2xpZW50LWNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2ZldGNoLWNsaWVudC9kaXN0L2VzbS9odHRwLWNsaWVudC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvZmV0Y2gtY2xpZW50L2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9mZXRjaC1jbGllbnQvZGlzdC9lc20vcmV0cnktaW50ZXJjZXB0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2ZldGNoLWNsaWVudC9kaXN0L2VzbS91dGlsLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9rZXJuZWwvZGlzdC9lc20vZGkuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9ldmVudGFnZ3JlZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEva2VybmVsL2Rpc3QvZXNtL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEva2VybmVsL2Rpc3QvZXNtL21vZHVsZS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9wbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEva2VybmVsL2Rpc3QvZXNtL3Jlc291cmNlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9tZXRhZGF0YS9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcGxhdGZvcm0tYnJvd3Nlci9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcGxhdGZvcm0vZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlLXJlY29nbml6ZXIvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9hd2FpdGFibGUtbWFwLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vYnJvd3Nlci12aWV3ZXItc3RvcmUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9jb2xsZWN0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vY29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL2ZvdW5kLXJvdXRlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vaG9vay1tYW5hZ2VyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vaG9vay5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vaW5zdHJ1Y3Rpb24tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9pbnRlcmZhY2VzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vbGlmZWN5Y2xlLWxvZ2dlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL2xpbmstaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL25hdi1yb3V0ZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL25hdi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL25hdmlnYXRpb24tY29vcmRpbmF0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9uYXZpZ2F0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vbmF2aWdhdG9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vb3Blbi1wcm9taXNlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcGFyc2VyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcXVldWUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9yZXNvdXJjZXMvZ290by5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3Jlc291cmNlcy9ocmVmLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcmVzb3VyY2VzL2xvYWQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9yZXNvdXJjZXMvbmF2LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcmVzb3VyY2VzL3ZpZXdwb3J0LXNjb3BlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcmVzb3VyY2VzL3ZpZXdwb3J0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcm91dGUtcmVjb2duaXplci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3JvdXRlci1vcHRpb25zLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcm91dGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcnVubmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vc2NvcGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9zdGF0ZS1jb29yZGluYXRvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3Rhc2stcXVldWUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS90eXBlLXJlc29sdmVycy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3V0aWxzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vdmlld3BvcnQtY29udGVudC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vdmlld3BvcnQtc2NvcGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS92aWV3cG9ydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2FwcC1yb290LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYXBwLXRhc2suanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9hdHRyaWJ1dGUtc3ludGF4LXRyYW5zZm9ybWVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYXVyZWxpYS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRhYmxlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy1iZWhhdmlvcnMvYmluZGluZy1tb2RlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy1iZWhhdmlvcnMvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9iaW5kaW5nLWJlaGF2aW9ycy9zaWduYWxzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy1iZWhhdmlvcnMvdGhyb3R0bGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9iaW5kaW5nL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRpbmcvY2FsbC1iaW5kaW5nLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy9pbnRlcnBvbGF0aW9uLWJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9iaW5kaW5nL2xldC1iaW5kaW5nLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy9saXN0ZW5lci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRpbmcvcHJvcGVydHktYmluZGluZy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRpbmcvcmVmLWJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9jb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vY3JlYXRlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9kb20uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2F0dHJpYnV0ZS1ucy1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2JpbmRhYmxlLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vY2hlY2tlZC1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2NsYXNzLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2RhdGEtYXR0cmlidXRlLWFjY2Vzc29yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vZWxlbWVudC1hdHRyaWJ1dGUtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9vYnNlcnZhdGlvbi9ldmVudC1kZWxlZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9vYnNlcnZhdGlvbi9vYnNlcnZlci1sb2NhdG9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vc2VsZWN0LXZhbHVlLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vc3R5bGUtYXR0cmlidXRlLWFjY2Vzc29yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vc3ZnLWFuYWx5emVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vdmFsdWUtYXR0cmlidXRlLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9hdHRyaWJ1dGUtcGF0dGVybi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9iaW5kaW5nLWJlaGF2aW9ycy9hdHRyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2JpbmRpbmctYmVoYXZpb3JzL3NlbGYuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvYmluZGluZy1iZWhhdmlvcnMvdXBkYXRlLXRyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvYmluZGluZy1jb21tYW5kLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZXMvYmx1ci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlcy9mb2N1cy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlcy9zaG93LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9hdS1zbG90LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9jb21wb3NlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL2ZsYWdzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL2lmLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3BvcnRhbC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvc3dpdGNoLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3dpdGguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvdmFsdWUtY29udmVydGVycy9zYW5pdGl6ZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy92YWx1ZS1jb252ZXJ0ZXJzL3ZpZXcuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9zZW1hbnRpYy1tb2RlbC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRlLWJpbmRlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRlLWNvbXBpbGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vdGVtcGxhdGUtZWxlbWVudC1mYWN0b3J5LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vdGVtcGxhdGluZy9jaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvcmVuZGVyLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS90ZW1wbGF0aW5nL3N0eWxlcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvdmlldy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvd2F0Y2hlcnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS93YXRjaC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9hbGlhcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9iaW5kaW5nLWJlaGF2aW9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL2JpbmRpbmcvYXN0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL2JpbmRpbmcvY29ubmVjdGFibGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vYmluZGluZy9leHByZXNzaW9uLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9hcnJheS1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9iaW5kaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vY29sbGVjdGlvbi1sZW5ndGgtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vY29tcHV0ZWQtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vY29ubmVjdGFibGUtc3dpdGNoZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vZGlydHktY2hlY2tlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9tYXAtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vb2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9vYnNlcnZlci1sb2NhdG9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL29ic2VydmF0aW9uL3ByaW1pdGl2ZS1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9wcm9wZXJ0eS1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9wcm94eS1vYnNlcnZhdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9zZXQtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vc2V0dGVyLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL29ic2VydmF0aW9uL3NpZ25hbGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL29ic2VydmF0aW9uL3N1YnNjcmliZXItY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS91dGlsaXRpZXMtb2JqZWN0cy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS92YWx1ZS1jb252ZXJ0ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL2FwcC5odG1sIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9jdXN0b20tZWxlbWVudHMvY3VzdG9tLWVsZW1lbnQvY3VzdG9tLWVsZW1lbnQuaHRtbCIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2F1cmVsaWEtbG9nby5odG1sIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvY29udHJvbGxlci12aWV3Lmh0bWwiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9kZWJ1Zy1ncm91cC5odG1sIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvcHJvcGVydHktdmlldy5odG1sIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9hdXJlbGlhL2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9hcHAuY3NzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNldC5jc3MiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9jb250cm9sbGVyLXZpZXcuY3NzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvZGVidWctZ3JvdXAuY3NzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvcHJvcGVydHktdmlldy5jc3MiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvYXBwLmNzcz9hNjcyIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNldC5jc3M/ZWRlMCIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2NvbnRyb2xsZXItdmlldy5jc3M/YzNhNiIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2RlYnVnLWdyb3VwLmNzcz8yM2QyIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvcHJvcGVydHktdmlldy5jc3M/YmQ1OCIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL2FwcC50cyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvYmFja2VuZC9kZWJ1Zy1ob3N0LnRzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9jdXN0b20tZWxlbWVudHMvY3VzdG9tLWVsZW1lbnQvY3VzdG9tLWVsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL2N1c3RvbS1lbGVtZW50cy9pbmRleC50cyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbWFpbi50cyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2RlYnVnLWdyb3VwLnRzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvcHJvcGVydHktdmlldy50cyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2luZGV4LnRzIiwid2VicGFjazovL1tuYW1lXS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0EsZ0NBQWdDLG1FQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyR3FDO0FBQ29DO0FBQ2Y7QUFDMUQ7QUFDTyxvQkFBb0IsK0RBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0ZBQXVCO0FBQzFEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0RkFBaUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDZFQUEwQjtBQUN2RztBQUNBO0FBQ0EsMEdBQTBHLDZFQUEwQjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOElBQThJLE9BQU87QUFDcko7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0QsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRCQUE0QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFEQUFxRCxvREFBVTtBQUMvRCx5REFBeUQsb0RBQVU7QUFDbkUsbUJBQW1CLG9EQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0RBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RkNkI7QUFDdEIsa0JBQWtCLHNEQUFrQjtBQUNtRTtBQUNxSDtBQUN2SDtBQUMyRztBQUN2STtBQUNqQjtBQUM4RTtBQUNuRTtBQUM2TTtBQUN2UixpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWEEsa0JBQWtCLFNBQUksSUFBSSxTQUFJO0FBQzlCO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0EsZUFBZSxTQUFJLElBQUksU0FBSTtBQUMzQixtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ2tFO0FBQ2pCO0FBQ1I7QUFDSTtBQUN0QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUM5QixtQkFBbUIsc0RBQWtCO0FBQ3JDLGNBQWMsc0RBQWtCO0FBQ2hDLHlCQUF5QixzREFBa0I7QUFDM0MsZ0JBQWdCLHNEQUFrQjtBQUNsQyxtQkFBbUIsc0RBQWtCO0FBQ3JDO0FBQ1AsU0FBUyxvRUFBMEI7QUFDbkM7QUFDQSxRQUFRLDhEQUFlO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSwyREFBWTtBQUMzQixLQUFLO0FBQ0wsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWUsdURBQVE7QUFDOUI7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0wsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsdURBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFvRDtBQUNuRTtBQUNBLHNCQUFzQixzQ0FBc0MsSUFBSSwwQ0FBMEMsSUFBSSxRQUFRO0FBQ3RIO0FBQ0Esa0JBQWtCLHNDQUFzQyxJQUFJLDBDQUEwQyxHQUFHLG9DQUFvQyxJQUFJLFFBQVE7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDM0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVDtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVDtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBRztBQUNsQixlQUFlLGdEQUFRO0FBQ3ZCLGVBQWUsMENBQU07QUFDckI7QUFDeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBLGtEQUFrRCx5Q0FBeUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPLDRCQUE0Qix1REFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrRUFBK0UsS0FBSztBQUNoRyxlQUFlLHVEQUFRO0FBQ3ZCO0FBQ0EsbUNBQW1DLHlEQUFxQjtBQUN4RDtBQUNBLHVDQUF1Qyx5REFBcUI7QUFDNUQ7QUFDQTtBQUNBLHVDQUF1QywwREFBc0I7QUFDN0Q7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7QUFDRCxrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4YjZCO0FBQ2M7QUFDRjtBQUNsQyxzQkFBc0Isc0RBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0VBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoSEE7QUFDTztBQUNBLG9DQUFvQztBQUMzQztBQUNBO0FBQ08saUJBQWlCO0FBQ3hCLG9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTjZDO0FBQ0Y7QUFDM0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFlO0FBQ3BDO0FBQ0EsWUFBWSw4REFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFFBQVEsOERBQWU7QUFDdkIsS0FBSztBQUNMO0FBQ0EsZUFBZSw4REFBZTtBQUM5QixLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsOERBQWU7QUFDbEM7QUFDQSxZQUFZLDhEQUFlO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQixHQUFHLEtBQUs7QUFDOUM7QUFDQSxrQkFBa0IsZ0JBQWdCLEdBQUcsS0FBSyxHQUFHLFFBQVE7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFlO0FBQ3BDO0FBQ0EsWUFBWSw4REFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsOERBQWU7QUFDOUIsS0FBSztBQUNMO0FBQ0EscUJBQXFCLDhEQUFlO0FBQ3BDO0FBQ0EsbUJBQW1CLG9EQUFVO0FBQzdCO0FBQ0E7QUFDQSxpQ0FBaUMsOERBQWU7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsOERBQWU7QUFDbEM7QUFDQSxZQUFZLDhEQUFlO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxLQUFLO0FBQzVDO0FBQ0Esa0JBQWtCLGNBQWMsR0FBRyxLQUFLLEdBQUcsUUFBUTtBQUNuRCxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVLEdBQUcsMkJBQTJCLGdCQUFnQixVQUFVLGtCQUFrQixhQUFhLGFBQWEsNENBQTRDLElBQUksb0JBQW9CO0FBQzlNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0ZBQXNGLElBQUk7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEUsMEJBQTBCLEVBQUUsS0FBSyxLQUFLO0FBQ3RDLGFBQWE7QUFDYixvWEFBb1gsc0JBQXNCO0FBQzFZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7Ozs7Ozs7QUN4aEJ3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csS0FBSyxLQUFLO0FBQzVHO0FBQ0E7QUFDTyw4QkFBOEIsdURBQVE7QUFDN0MsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQVM7QUFDekMsaUNBQWlDLHdEQUFTO0FBQzFDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLEtBQUssS0FBSztBQUM1RztBQUNBO0FBQ087QUFDUCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFnRCxJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHVCQUF1QixTQUFTLFFBQVE7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJFQUEyRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVcsV0FBVyxRQUFRLFdBQVcsUUFBUSxZQUFZLFNBQVMsV0FBVyxRQUFRO0FBQ2hJLGdDQUFnQyxPQUFPLEtBQUssT0FBTyxJQUFJLEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRyxXQUFXLFFBQVEsU0FBUyxNQUFNLFdBQVcsUUFBUSxjQUFjLFdBQVcsWUFBWSxTQUFTLFVBQVUsT0FBTyxXQUFXLFFBQVE7QUFDekssZ0NBQWdDLE9BQU8sS0FBSyxPQUFPLElBQUksS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvcEJPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxTQUFTO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG9CQUFvQixrQkFBa0IseUJBQXlCO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSxlQUFlLGdCQUFnQixTQUFTLEVBQUU7QUFDMUM7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7Ozs7O0FDcmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUN6QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseURBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUseURBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJO0FBQzNCLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDZ0Y7QUFDcEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRLEVBQUU7QUFDdkM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxxREFBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrRkFBK0Y7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBNEMsUUFBUSxFQUFFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTLEVBQUUsS0FBSztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTLEVBQUUsS0FBSztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBUztBQUN4QixlQUFlLDBEQUFPO0FBQ3RCLGVBQWUsMkRBQVE7QUFDdkIsZUFBZSw0REFBUztBQUN4QjtBQUM4QjtBQUM5QixnRDs7Ozs7Ozs7Ozs7Ozs7O0FDeEt5QztBQUN6QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFXO0FBQ25CO0FBQ0E7QUFDQSxzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QnFDO0FBQ1c7QUFDTTtBQUNVO0FBQ1c7QUFDakI7QUFDQTtBQUNBO0FBQ3BCO0FBQy9CLDJCQUEyQiwrQ0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUMrSTtBQUN4SSwwQ0FBMEMseUVBQXFCO0FBQy9ELCtDQUErQyxvRkFBMEI7QUFDekUscUNBQXFDLCtEQUFnQjtBQUNyRCx3Q0FBd0MsbUVBQW1CO0FBQzNELHdDQUF3QyxtRUFBbUI7QUFDM0Qsd0NBQXdDLG1FQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHlFQUFxQjtBQUN6QixJQUFJLG9GQUEwQjtBQUM5QixJQUFJLCtEQUFnQjtBQUNwQixJQUFJLG1FQUFtQjtBQUN2QixJQUFJLG1FQUFtQjtBQUN2QixJQUFJLG1FQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwrREFBWSxDQUFDLCtDQUFPLDRDQUE0QywrREFBWSxDQUFDLCtDQUFPLG9EQUFvRCwrREFBWSxDQUFDLCtDQUFPO0FBQ3pPLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBa0I7QUFDL0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkJpQztBQUNqQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBDQUFJLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BFMkY7QUFDM0I7QUFDaEU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUZBQW1DO0FBQ3BEO0FBQ0EsaUNBQWlDLG9GQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtRkFBbUM7QUFDeEUsc0JBQXNCLG9GQUFvQztBQUMxRDtBQUNBLHFDQUFxQyxvRkFBb0M7QUFDekU7QUFDQTtBQUNBLGdDQUFnQyxpRkFBaUM7QUFDakUsb0NBQW9DLDhFQUE4QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnRkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25GaUQ7QUFDZ0I7QUFDZDtBQUNzQjtBQUNiO0FBQzVCO0FBQ1c7QUFDRztBQUNGO0FBQ047QUFDRjtBQUNtRTtBQUtqRTtBQUNlO0FBQ1g7QUFDOEI7QUFDUDtBQUM4VDtBQUMvWCxpQzs7Ozs7Ozs7Ozs7Ozs7O0FDdEJnRTtBQUN6RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUVBQW1CO0FBQ3pEO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CLEVBQUUseUJBQXlCO0FBQzVGO0FBQ0E7QUFDQSxzQ0FBc0MseUVBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdGQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQixFQUFFLGdCQUFnQjtBQUNyRSw2QkFBNkIsc0JBQXNCLEVBQUUsMkJBQTJCLEVBQUUsZ0JBQWdCLEVBQUUseUJBQXlCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsRUFBRSxzQkFBc0IsRUFBRSxLQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCLEVBQUUsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUE4QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVEsRUFBRSxjQUFjO0FBQ3RFO0FBQ0EsdURBQXVELFFBQVEsRUFBRSxjQUFjO0FBQy9FLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU0sRUFBRSxZQUFZO0FBQ2pEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkIsRUFBRSxXQUFXLEVBQUUsOEJBQThCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEOzs7Ozs7Ozs7Ozs7OztBQy9hTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQyxzQzs7Ozs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUssR0FBRyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSyxHQUFHLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSw2QkFBNkIsYUFBYTtBQUN6RCxrQkFBa0IsMEJBQTBCO0FBQzVDLGVBQWUsNkJBQTZCO0FBQzVDLGVBQWUsNkJBQTZCO0FBQzVDLGFBQWEsMkJBQTJCO0FBQ3hDLG9CQUFvQixrQ0FBa0M7QUFDdEQsaUJBQWlCLCtCQUErQjtBQUNoRCxpQkFBaUIsK0JBQStCLGFBQWE7QUFDN0QsY0FBYyw0QkFBNEI7QUFDMUMsaUJBQWlCLCtCQUErQjtBQUNoRCxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0EsNEM7Ozs7Ozs7Ozs7Ozs7OztBQzlDQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJO0FBQzNCLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNFQUFtQjtBQUM1QztBQUNBLHlCQUF5QixzRUFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQVM7QUFDeEI7QUFDdUI7QUFDdkIsd0M7Ozs7Ozs7Ozs7Ozs7OztBQzFIa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG1GQUFtQztBQUN0SCw4QkFBOEIsb0dBQW9EO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvR0FBb0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7Ozs7Ozs7O0FDdkYwQztBQUMxQztBQUNBO0FBQ0E7QUFDTztBQUNQLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1EQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7Ozs7Ozs7Ozs7OztBQ3pDMEQ7QUFDbkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0NBQW9DLG1FQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLEVBQUU7QUFDckQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrQkFBa0IsYUFBYSxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGtEOzs7Ozs7Ozs7Ozs7OztBQ25FTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURtQztBQUNVO0FBQ1I7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNEQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFVO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0MsNENBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4QkFBOEI7QUFDMUU7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzREFBVTtBQUNoRTtBQUNBLGtCQUFrQixzREFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHNEQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUlBQXlJO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBVSxFQUFFLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0RBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVU7QUFDN0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7Ozs7Ozs7O0FDelNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7Ozs7Ozs7Ozs7QUNoQkEsa0JBQWtCLFNBQUksSUFBSSxTQUFJO0FBQzlCO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ3dDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxtQkFBbUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBSztBQUNUO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJO0FBQzNCLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDeUg7QUFDbEY7QUFDOEI7QUFDcEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2REFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsbUVBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzRUFBbUI7QUFDOUMsd0JBQXdCLHdHQUF3RCwyQkFBMkIsc0JBQXNCO0FBQ2pJLDZCQUE2QixvR0FBb0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBUSxFQUFFLE9BQU8scUVBQWtCLEVBQUU7QUFDekM7QUFDQTtBQUNBLElBQUksc0VBQWU7QUFDbkIsZUFBZSx3REFBSztBQUNwQixlQUFlLCtDQUFPO0FBQ3RCO0FBQytCO0FBQy9CLGdDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hFQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJO0FBQzNCLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDc0Y7QUFDL0M7QUFDbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGtFQUFtQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFRLEVBQUUsT0FBTyxxRUFBa0IsRUFBRTtBQUN6QztBQUNBO0FBQ0EsSUFBSSxzRUFBZTtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSwrQ0FBTztBQUN0QjtBQUMrQjtBQUMvQixnQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuREEsa0JBQWtCLFNBQUksSUFBSSxTQUFJO0FBQzlCO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0EsZUFBZSxTQUFJLElBQUksU0FBSTtBQUMzQixtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ3lIO0FBQ2xGO0FBQzhCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1FQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0VBQW1CO0FBQzlDLHdCQUF3Qix3R0FBd0QsMkJBQTJCLHNCQUFzQjtBQUNqSSw2QkFBNkIsb0dBQW9EO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQVEsRUFBRSxPQUFPLHFFQUFrQixFQUFFO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJLHNFQUFlO0FBQ25CLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSwrQ0FBTztBQUN0QjtBQUMrQjtBQUMvQixnQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJO0FBQzNCLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDZ0U7QUFDekI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJEQUFRO0FBQ1o7QUFDQTtBQUNBLElBQUksMkRBQVE7QUFDWjtBQUNBO0FBQ0EsSUFBSSwyREFBUTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDJEQUFRO0FBQ1o7QUFDQTtBQUNBLElBQUksb0VBQWE7QUFDakI7QUFDQSxnQ0FBZ0MsS0FBSyxJQUFJLGVBQWU7QUFDeEQ7QUFDQTtBQUNBLDJDQUEyQyxNQUFNLElBQUksV0FBVztBQUNoRSx1RUFBdUUscUNBQXFDLElBQUksa0JBQWtCLElBQUksV0FBVztBQUNqSiw0REFBNEQsV0FBVyxZQUFZLG9DQUFvQyxJQUFJLFVBQVU7QUFDckksK0ZBQStGLG9DQUFvQyxJQUFJLFVBQVU7QUFDakoseUdBQXlHLG9DQUFvQyxJQUFJLGFBQWE7QUFDOUosbUpBQW1KLG9DQUFvQyxJQUFJLFVBQVU7QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSwrQ0FBTztBQUN0QjtBQUM0QjtBQUM1QiwrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFFQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJO0FBQzNCLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUN5SjtBQUM1RztBQUNOO0FBQ2U7QUFDL0MsNEJBQTRCLGlGQUE4QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtCQUErQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdGQUF5QjtBQUN4QztBQUNBO0FBQ0EsZUFBZSwrRUFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrREFBcUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkRBQVE7QUFDWjtBQUNBO0FBQ0EsSUFBSSwyREFBUTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDJEQUFRO0FBQ1o7QUFDQTtBQUNBLElBQUksMkRBQVE7QUFDWjtBQUNBO0FBQ0EsSUFBSSxvRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLCtDQUFPO0FBQ3RCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx1REFBVTtBQUN6QjtBQUNBLGVBQWUsOERBQVc7QUFDMUI7QUFDc0M7QUFDdEMsMEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEtBLGtCQUFrQixTQUFJLElBQUksU0FBSTtBQUM5QjtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUk7QUFDM0IsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQzZDO0FBQzBDO0FBQ2hEO0FBQzBCO0FBQzNCO0FBQy9CLHVCQUF1QixpRkFBOEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVEQUFVO0FBQzFEO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBVTtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLDBFQUEwQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJEQUFRO0FBQ1o7QUFDQTtBQUNBLElBQUksMkRBQVE7QUFDWjtBQUNBO0FBQ0EsSUFBSSwyREFBUTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDJEQUFRO0FBQ1o7QUFDQTtBQUNBLElBQUksMkRBQVE7QUFDWjtBQUNBO0FBQ0EsSUFBSSwyREFBUTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDJEQUFRO0FBQ1o7QUFDQTtBQUNBLElBQUksMkRBQVE7QUFDWjtBQUNBO0FBQ0EsSUFBSSwyREFBUTtBQUNaO0FBQ0E7QUFDQSxJQUFJLG9FQUFhO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSwrQ0FBTztBQUN0QixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsdURBQVU7QUFDekI7QUFDQTtBQUNpQztBQUNqQyxvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDek9zTDtBQUMvSyx3QkFBd0Isc0VBQWdCO0FBQ3hDLDBCQUEwQix3RUFBa0I7QUFDNUMsd0JBQXdCLHNFQUFnQjtBQUN4QyxpQkFBaUIsK0RBQVM7QUFDakMsNEM7Ozs7Ozs7Ozs7Ozs7O0FDTE87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsR0FBRyxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUN5RTtBQUNnQztBQUN6QztBQUNoQjtBQUNqQjtBQUNZO0FBQ3lCO0FBQ1A7QUFDcEI7QUFDdUI7QUFDbEI7QUFDRTtBQUNiO0FBQ2lCO0FBQ1c7QUFDbEI7QUFDdUI7QUFDaEI7QUFDSjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdCQUFnQiwrREFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCLEdBQUcsa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0Isa0JBQWtCLGFBQWEsRUFBRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxhQUFhLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVEQUFVO0FBQ3hDO0FBQ0E7QUFDQSwyREFBMkQsYUFBYSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxRkFBNEIscUJBQXFCLGdEQUFnRDtBQUNqSTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFrRCxFQUFFO0FBQzVFO0FBQ0Esd0JBQXdCLG1EQUFtRCxFQUFFO0FBQzdFO0FBQ0Esd0JBQXdCLGdEQUFnRCxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdFQUFnRTtBQUNqRjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFnRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3REFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVc7QUFDbkM7QUFDQTtBQUNBLHdCQUF3QixzREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0NBQXNDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLDZEQUE2RDtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQUssc0JBQXNCLGtEQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwwREFBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCLEdBQUcsd0dBQXdEO0FBQzNGO0FBQ0EsMkJBQTJCLG9HQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0NBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLEVBQUU7QUFDckQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUFRO0FBQ3BEO0FBQ0EsaUNBQWlDLDhEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRCxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUVBQW1CO0FBQzNEO0FBQ0E7QUFDQSx3Q0FBd0Msd0RBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUFlO0FBQzNCLDRDQUE0Qyx1REFBVTtBQUN0RDtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUFVO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFlLENBQUMscUVBQWtCO0FBQ2pFLG1CQUFtQiw0REFBZSxDQUFDLHFFQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkVBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFVLEVBQUUsb0RBQVMsRUFBRSx5RUFBa0IsRUFBRSx5REFBVyxFQUFFLHlFQUFtQixFQUFFLDBEQUFXLEVBQUUsOERBQWE7QUFDeEgsa0M7Ozs7Ozs7Ozs7Ozs7O0FDdnFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QiwyRUFBMkUsS0FBSztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsK0VBQStFLEtBQUs7QUFDcEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQixXQUFXLEVBQUU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCLFdBQVcsRUFBRTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0IsV0FBVyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlMb0Q7QUFDTjtBQUNzQjtBQUMzQjtBQUNBO0FBQ0k7QUFDVztBQUNuQjtBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQTZELEdBQUcsc0JBQXNCO0FBQ3hHO0FBQ0EsZUFBZSxnRkFBZ0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0RBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQ0FBMEM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMENBQTBDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELGtDQUFrQyw2REFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckMsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCLHVEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkIsb0dBQW9EO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7Ozs7Ozs7O0FDaGlCZ0Q7QUFDekM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseURBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5REFBVztBQUNqRDtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QixFQUFFLGdCQUFnQixXQUFXLEVBQUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2Qzs7Ozs7Ozs7Ozs7Ozs7OztBQzFHQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG1CQUFtQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhLEVBQUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBSztBQUNUO0FBQ0Esc0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqSnNEO0FBQ2I7QUFDdUI7QUFDekQ7QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSx1RUFBb0I7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4RUFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsa0RBQVE7QUFDM0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVyxHQUFHLHVCQUF1QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlFQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQzs7Ozs7Ozs7Ozs7Ozs7OztBQzNJQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUNBQXFDLFdBQVcsdUNBQXVDLFdBQVc7QUFDbEc7QUFDQSxpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJtRDtBQUNWO0FBQ3VCO0FBQ25CO0FBQ1I7QUFDYTtBQUNsRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdGQUEwQiw4QkFBOEIsc0RBQVU7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEVBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlDQUFpQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSSxzREFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLHNEQUFVO0FBQzlDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYSxHQUFHLGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFVc0Q7QUFDYTtBQUNmO0FBQ3BEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1GQUFtQztBQUMvQyxpQ0FBaUMsb0ZBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRkFBbUM7QUFDcEQ7QUFDQSxpQ0FBaUMsb0ZBQW9DO0FBQ3JFO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQXVDO0FBQ3hELGlEQUFpRCxvRkFBb0M7QUFDckYsaUNBQWlDLG9GQUFvQztBQUNyRSxxQ0FBcUMsd0ZBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQTBDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0VBQXFCO0FBQ2xELG1EQUFtRCx3RUFBcUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0VBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9GQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2REFBYTtBQUMzQyxnRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsVG1DO0FBQ007QUFDSjtBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVUsR0FBRyxZQUFZLElBQUksZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlNc0Q7QUFDYjtBQUNlO0FBQ3JCO0FBQ0U7QUFDOUI7QUFDUCwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWU7QUFDMUMsa0NBQWtDLDRDQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVLEdBQUcsWUFBWSxJQUFJLGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxFQU1WO0FBQ2Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZSxrQkFBa0IsYUFBYSxFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0Esc09BQXNPLHFCQUFxQixhQUFhLEVBQUU7QUFDMVE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0IsRUFBRTtBQUNsRSwyQkFBMkIsa0RBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsb0JBQW9CLGtEQUFVLHdDQUF3QyxlQUFlO0FBQ3JGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQkFBc0IseURBQXlELEVBQUU7QUFDakY7QUFDQSxzQkFBc0IsNkNBQTZDLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQTBELEVBQUU7QUFDbEY7QUFDQSxzQkFBc0IsK0RBQStELEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBVTtBQUN6QztBQUNBO0FBQ0EsK0JBQStCLGtEQUFVO0FBQ3pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFVO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQVU7QUFDekI7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVU7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQixzREFBVztBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvRUFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pqQjBFO0FBQ3pDO0FBQ1E7QUFDcUI7QUFDTjtBQUNqRCxpQkFBaUIsK0RBQWtCO0FBQ25DO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBSywwQkFBMEIsMENBQUs7QUFDOUQ7QUFDQTtBQUNBLGdDQUFnQyxrRUFBcUIsQ0FBQywwQ0FBSztBQUMzRDtBQUNBO0FBQ0EscUNBQXFDLHFGQUEyQixDQUFDLDhFQUFvQjtBQUNyRixrQkFBa0IsOEVBQW9CLEVBQUUsSUFBSSxxRkFBMkIsaURBQWlEO0FBQ3hILGtCQUFrQiw4RUFBb0IsRUFBRSxxREFBcUQ7QUFDN0Y7QUFDQSw4QkFBOEIsMERBQVM7QUFDdkMsNkJBQTZCLDhFQUFvQjtBQUNqRDtBQUNBO0FBQ0Esa0RBQWtELGtGQUEyQjtBQUM3RTtBQUNBLG1CQUFtQiwwREFBUztBQUM1QjtBQUNBLHVCQUF1QiwwREFBUztBQUNoQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsMERBQVM7QUFDeEIsbUJBQW1CLDBEQUFTO0FBQzVCLHVCQUF1QiwwREFBUztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLDBEQUFTO0FBQ3hCLG1CQUFtQiwwREFBUztBQUM1QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBVSwwQkFBMEIsa0RBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7Ozs7Ozs7O0FDckVvRDtBQUM3QyxpQkFBaUIsK0RBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtFQUFxQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRHFDO0FBQzlCLCtCQUErQiwrREFDbEI7QUFDYjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEpnRjtBQUNwQjtBQUNWO0FBQ1I7QUFDbkMsaUJBQWlCLCtEQUFrQjtBQUNuQztBQUNQLDRCQUE0QiwrREFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBcUI7QUFDaEQsbUNBQW1DLGtEQUFRLDBCQUEwQiw2REFBZ0I7QUFDckY7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDLHNCQUFzQix5QkFBeUI7QUFDL0Msc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1EQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzRUFBZTtBQUNuQyxvQ0FBb0Msa0VBQXFCLENBQUMsbURBQVM7QUFDbkU7QUFDQTtBQUNBLG1DQUFtQyxtREFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwREFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwREFBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnREFBZ0Q7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25IQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDd0c7QUFDeEQ7QUFDekM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLDREQUFlO0FBQ3ZCLFFBQVEseUVBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxVQUFVLHVFQUEwQjtBQUNwQztBQUNBLGtCQUFrQixjQUFjLEdBQUcsS0FBSztBQUN4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWU7QUFDcEMsb0JBQW9CLHlFQUE0QjtBQUNoRDtBQUNBLGdCQUFnQiw0REFBZTtBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrRUFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0VBQTJCO0FBQzlDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEMsZ0NBQWdDLDREQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxzQ0FBc0MsNkRBQVksZ0JBQWdCLDBEQUFTLFNBQVMsNkRBQVksa0JBQWtCLEtBQUssV0FBVyw2REFBWSxXQUFXLGdFQUFrQixHQUFHLDZEQUFZLHNCQUFzQiw2REFBWSxzQkFBc0IsNkRBQVksVUFBVSxpREFBSTtBQUM1UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBLGtCQUFrQixPQUFPLGdFQUFrQixFQUFFO0FBQzdDLGtCQUFrQiwwQkFBMEI7QUFDNUMsa0JBQWtCLG9CQUFvQjtBQUN0QyxrQkFBa0IsZ0JBQWdCO0FBQ2xDLGtCQUFrQiw4QkFBOEI7QUFDaEQsa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBLGtCQUFrQixnRUFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLHlCQUF5QixnRUFBa0IsRUFBRTtBQUMzRCxjQUFjLDRDQUE0QztBQUMxRCxjQUFjLHNDQUFzQztBQUNwRCxjQUFjLGtDQUFrQztBQUNoRCxjQUFjLHlCQUF5QixnRUFBa0IsNkRBQTZEO0FBQ3RIO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFrQjtBQUM1QywwQkFBMEIsZ0VBQWtCO0FBQzVDLDBCQUEwQixnRUFBa0I7QUFDNUMsMEJBQTBCLGdFQUFrQjtBQUM1QywwQkFBMEIsZ0VBQWtCO0FBQzVDLDBCQUEwQixnRUFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDck9nRTtBQUN6RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGNBQWMsaUVBQW1CO0FBQ2pDO0FBQ0E7QUFDTztBQUNQO0FBQ0EsY0FBYyxnRUFBa0I7QUFDaEM7QUFDQTtBQUNPO0FBQ1A7QUFDQSxjQUFjLGtFQUFvQjtBQUNsQztBQUNBO0FBQ087QUFDUDtBQUNBLGNBQWMsZ0VBQWtCO0FBQ2hDO0FBQ0E7QUFDQSxpRUFBZTtBQUNmLGlFQUFlO0FBQ2YsaUVBQWU7QUFDZixpRUFBZTtBQUNmLHdDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkM0QztBQUMyQjtBQUNoRSxzQ0FBc0MsZ0VBQWtCO0FBQy9EO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDZDQUE2QyxzREFBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmLG9DOzs7Ozs7Ozs7Ozs7Ozs7QUM3Q0Esa0JBQWtCLFNBQUksSUFBSSxTQUFJO0FBQzlCO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0EsZUFBZSxTQUFJLElBQUksU0FBSTtBQUMzQixtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQzhEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ2lDO0FBQ2pDLGlFQUFlO0FBQ2YsbUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QzRDO0FBQzJCO0FBQ2hFLHNDQUFzQyxnRUFBa0I7QUFDL0Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0RBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWU7QUFDZixvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRDZEO0FBQ29CO0FBQ3RDO0FBQzNDO0FBQ0EsT0FBTyw0QkFBNEIsR0FBRyx5REFBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQXNCO0FBQzlCLHFDQUFxQyxtREFBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHlGQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUFXO0FBQ1gscUM7Ozs7Ozs7Ozs7Ozs7O0FDbEtPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qzs7Ozs7Ozs7Ozs7Ozs7OztBQzNENkQ7QUFDN0QsT0FBTyxTQUFTLEdBQUcseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBVztBQUNYLGlEOzs7Ozs7Ozs7Ozs7Ozs7QUMxSytDO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQVc7QUFDWCx1Qzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFdUQ7QUFDZDtBQUN6QztBQUNBLEtBQUssMEVBQTRCLElBQUksZ0JBQWdCO0FBQ3JELEtBQUsseUVBQTJCLElBQUksaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxRUFBdUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlEQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUVBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7Ozs7OztBQ3RGNEQ7QUFDNUQ7QUFDQSxPQUFPLDRCQUE0QixHQUFHLHlEQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBVztBQUNYLDRDOzs7Ozs7Ozs7Ozs7OztBQzVKTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkRxQztBQUN1STtBQUNxTDtBQUN2UztBQUNzWTtBQUMzUztBQUMzRTtBQUNIO0FBQ0c7QUFDZDtBQUNnQjtBQUNBO0FBQ21CO0FBQ2xDO0FBQ0U7QUFDRjtBQUNPO0FBQzBCO0FBQzVCO0FBQ0U7QUFDSjtBQUN1QjtBQUN0QjtBQUNEO0FBQ2tCO0FBQ1I7QUFDRjtBQUNqRSw0Q0FBNEMsbUZBQXVCO0FBQ25FLDJDQUEyQyxzRkFBc0I7QUFDakUsMENBQTBDLHFGQUFxQjtBQUMvRCw0Q0FBNEMsdUZBQXVCO0FBQ25FLDBDQUEwQyxnRkFBcUI7QUFDL0QsNENBQTRDLG1GQUF1QjtBQUNuRSwwQ0FBMEMscUZBQXFCO0FBQy9ELHNDQUFzQyxtRUFBZ0I7QUFDdEQseUNBQXlDLGtGQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxxRUFBVztBQUMzQyxzREFBc0QsOEZBQWlDO0FBQ3ZGLHNEQUFzRCw4RkFBaUM7QUFDdkYsd0NBQXdDLGdGQUFtQjtBQUMzRCxpREFBaUQseUZBQTRCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPLHVDQUF1Qyw2RUFBa0I7QUFDekQsMENBQTBDLGdGQUFxQjtBQUMvRCxzQ0FBc0MsNEVBQWlCO0FBQ3ZELDJDQUEyQyxpRkFBc0I7QUFDakUsMENBQTBDLGdGQUFxQjtBQUMvRCx5Q0FBeUMsK0VBQW9CO0FBQzdELHlDQUF5QywrRUFBb0I7QUFDN0Qsc0NBQXNDLDRFQUFpQjtBQUN2RCwwQ0FBMEMsZ0ZBQXFCO0FBQy9ELDJDQUEyQyxpRkFBc0I7QUFDakUsMENBQTBDLGdGQUFxQjtBQUMvRCx1Q0FBdUMsNkVBQWtCO0FBQ3pELHdDQUF3Qyw4RUFBbUI7QUFDM0Qsd0NBQXdDLDhFQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLDRGQUFzQjtBQUNqRSx1Q0FBdUMsb0ZBQWtCO0FBQ3pELHNDQUFzQyx3RkFBaUI7QUFDdkQsbUNBQW1DLHFGQUFjO0FBQ2pELHVCQUF1QixzRUFBRTtBQUN6Qix5QkFBeUIsd0VBQUk7QUFDN0IsMkJBQTJCLDhFQUFNO0FBQ2pDLHlCQUF5QiwwRUFBSTtBQUM3QiwyQkFBMkIsOEVBQU07QUFDakMseUJBQXlCLDRFQUFJO0FBQzdCLGdDQUFnQyxtRkFBVztBQUMzQyx3Q0FBd0Msc0ZBQW1CO0FBQzNELHdDQUF3QyxzRkFBbUI7QUFDM0QsaURBQWlELHlHQUE0QjtBQUM3RSw0QkFBNEIsMkVBQU87QUFDbkMsMkJBQTJCLDhFQUFNO0FBQ2pDLDBCQUEwQix5RUFBSztBQUMvQix5QkFBeUIsdUVBQUk7QUFDN0IseUJBQXlCLHVFQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBFQUFNO0FBQ1Y7QUFDTyx3Q0FBd0MsNkRBQW1CO0FBQzNELDRDQUE0QyxpRUFBdUI7QUFDbkUsMENBQTBDLCtEQUFxQjtBQUMvRCxpREFBaUQsc0VBQTRCO0FBQzdFLDRDQUE0QyxpRUFBdUI7QUFDbkUsdUNBQXVDLDREQUFrQjtBQUN6RCw0Q0FBNEMsaUVBQXVCO0FBQ25FLHVDQUF1Qyw0REFBa0I7QUFDekQsd0NBQXdDLDZEQUFtQjtBQUMzRCwrQ0FBK0Msb0VBQTBCO0FBQ3pFLDRDQUE0QyxpRUFBdUI7QUFDbkUsNkNBQTZDLGtFQUF3QjtBQUNyRSx5Q0FBeUMsOERBQW9CO0FBQzdELDhDQUE4QyxtRUFBeUI7QUFDdkUsOENBQThDLG1FQUF5QjtBQUN2RSxpREFBaUQsc0VBQTRCO0FBQzdFLHdDQUF3Qyw2REFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUFrQjtBQUMvQztBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVPbUc7QUFDWjtBQUNyQjtBQUMzRDtBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEVBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3RkFBOEI7QUFDaEUsc0JBQXNCLG9GQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0VBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxRkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwrQ0FBK0MsaUVBQXVCO0FBQ3RFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxSXFDO0FBQ0k7QUFDQztBQUNvQjtBQUN2RCxjQUFjLCtEQUFrQjtBQUNoQyxxQkFBcUIsK0RBQWtCO0FBQzlDLG9CQUFvQixrREFBUTtBQUM1QiwyQkFBMkIsa0RBQVE7QUFDbkM7QUFDQSx1QkFBdUIsbURBQVM7QUFDaEMsQ0FBQztBQUNNLHdCQUF3QiwrREFBa0I7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQywyQkFBMkIsMkVBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQkFBZ0IsK0RBQWtCLG1EQUFtRCxtREFBUztBQUM5RixrQkFBa0IsK0RBQWtCO0FBQ3BDLGlCQUFpQiwrREFBa0I7QUFDMUMsK0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RROEc7QUFDakQ7QUFDVztBQUNEO0FBQzBOO0FBQ3ZIO0FBQy9GO0FBQ0g7QUFDRztBQUM0aUQ7QUFDcmtEO0FBQ0M7QUFDQTtBQUNrUDtBQUM4RztBQUN2VTtBQUMxQjtBQUNTO0FBQ0Y7QUFDa0I7QUFDcEI7QUFDVTtBQUNWO0FBQ3VpQjtBQUNoaEI7QUFDVDtBQUNlO0FBQ0Y7QUFDbUI7QUFDUjtBQUNoQjtBQUNNO0FBQ1M7QUFDUjtBQUNQO0FBQ0E7QUFDbUI7QUFDbUM7QUFDcEM7QUFDNUI7QUFDQztBQUNKO0FBQ3dCO0FBQ2I7QUFDWDtBQUNLO0FBQ3NHO0FBQ3ZDO0FBQ2xFO0FBQzZCO0FBQ3BCO0FBQ2lzRDtBQUNydEQ7QUFDaUI7QUFDNkI7QUFDckc7QUFDMEk7QUFDdEQ7QUFDc0I7QUFDMUM7QUFDMEo7QUFDL0s7QUFDNE47QUFDbkI7QUFDek07QUFDb0M7QUFDL0UsaUM7Ozs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QnVDO0FBQ2lCO0FBQ2pEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpREFBSTtBQUN2RCwrQkFBK0IsaURBQUk7QUFDbkMsNkNBQTZDLGlEQUFJO0FBQ2pELHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNFQUFvQjtBQUNwQiw2Qzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BGeUQ7QUFDSztBQUM5RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJFQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzRUFBb0I7QUFDcEIsNEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4TjZDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNP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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZLE9BQU8sU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7Ozs7Ozs7Ozs7OztBQzlReUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFvQjtBQUNwQixpRDs7Ozs7Ozs7Ozs7Ozs7O0FDN053RDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0ltRDtBQUNSO0FBQ3BDLHFCQUFxQiwrREFBa0I7QUFDdkM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtREFBUztBQUMvQix3Qzs7Ozs7Ozs7Ozs7Ozs7O0FDNVB3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnRUFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMERBQVM7QUFDcEM7QUFDQSxrRUFBa0UsaUVBQW1CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUZBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBZSxDQUFDLDRFQUFrQjtBQUM5QztBQUNB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O0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxS3NDO0FBQytmO0FBQzloQiwwQkFBMEIsK0RBQWtCO0FBQzVDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0VBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDOUI7QUFDUCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUhvRDtBQUN3QjtBQUNUO0FBQ0g7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRFQUFrQjtBQUM5QyxhQUFhLGdFQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVZbUQ7QUFDc0I7QUFDUDtBQUNwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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c0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7VUNOQTtVQUNBO1VBQ0E7VUFDQSIsImZpbGUiOiJidWlsZC9lbnRyeS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJldHJ5SW50ZXJjZXB0b3IgfSBmcm9tICcuL3JldHJ5LWludGVyY2VwdG9yLmpzJztcbi8qKlxuICogQSBjbGFzcyBmb3IgY29uZmlndXJpbmcgSHR0cENsaWVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50Q29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFzZSBVUkwgdG8gYmUgcHJlcGVuZGVkIHRvIGVhY2ggUmVxdWVzdCdzIHVybCBiZWZvcmUgc2VuZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCB2YWx1ZXMgdG8gYXBwbHkgdG8gaW5pdCBvYmplY3RzIHdoZW4gY3JlYXRpbmcgUmVxdWVzdHMuIE5vdGUgdGhhdFxuICAgICAgICAgKiBkZWZhdWx0cyBjYW5ub3QgYmUgYXBwbGllZCB3aGVuIFJlcXVlc3Qgb2JqZWN0cyBhcmUgbWFudWFsbHkgY3JlYXRlZCBiZWNhdXNlXG4gICAgICAgICAqIFJlcXVlc3QgcHJvdmlkZXMgaXRzIG93biBkZWZhdWx0cyBhbmQgZGlzY2FyZHMgdGhlIG9yaWdpbmFsIGluaXQgb2JqZWN0LlxuICAgICAgICAgKiBTZWUgYWxzbyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVxdWVzdC9SZXF1ZXN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcmNlcHRvcnMgdG8gYmUgYWRkZWQgdG8gdGhlIEh0dHBDbGllbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludGVyY2VwdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBiYXNlVXJsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhc2VVcmwgLSBUaGUgYmFzZSBVUkwuXG4gICAgICogQHJldHVybnMgVGhlIGNoYWluYWJsZSBpbnN0YW5jZSBvZiB0aGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB3aXRoQmFzZVVybChiYXNlVXJsKSB7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWZhdWx0cyAtIFRoZSBkZWZhdWx0cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2hhaW5hYmxlIGluc3RhbmNlIG9mIHRoaXMgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHdpdGhEZWZhdWx0cyhkZWZhdWx0cykge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGludGVyY2VwdG9yIHRvIGJlIHJ1biBvbiBhbGwgcmVxdWVzdHMgb3IgcmVzcG9uc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVyY2VwdG9yIC0gQW4gb2JqZWN0IHdpdGggcmVxdWVzdCwgcmVxdWVzdEVycm9yLFxuICAgICAqIHJlc3BvbnNlLCBvciByZXNwb25zZUVycm9yIG1ldGhvZHMuIHJlcXVlc3QgYW5kIHJlcXVlc3RFcnJvciBhY3QgYXNcbiAgICAgKiByZXNvbHZlIGFuZCByZWplY3QgaGFuZGxlcnMgZm9yIHRoZSBSZXF1ZXN0IGJlZm9yZSBpdCBpcyBzZW50LlxuICAgICAqIHJlc3BvbnNlIGFuZCByZXNwb25zZUVycm9yIGFjdCBhcyByZXNvbHZlIGFuZCByZWplY3QgaGFuZGxlcnMgZm9yXG4gICAgICogdGhlIFJlc3BvbnNlIGFmdGVyIGl0IGhhcyBiZWVuIHJlY2VpdmVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBjaGFpbmFibGUgaW5zdGFuY2Ugb2YgdGhpcyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgd2l0aEludGVyY2VwdG9yKGludGVyY2VwdG9yKSB7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzLnB1c2goaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGNvbmZpZ3VyYXRpb24gdGhhdCBhZGRyZXNzZXMgY29tbW9uIGFwcGxpY2F0aW9uIG5lZWRzLCBpbmNsdWRpbmdcbiAgICAgKiBjb25maWd1cmluZyBzYW1lLW9yaWdpbiBjcmVkZW50aWFscywgYW5kIHVzaW5nIHJlamVjdEVycm9yUmVzcG9uc2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNoYWluYWJsZSBpbnN0YW5jZSBvZiB0aGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB1c2VTdGFuZGFyZENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkQ29uZmlnID0geyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZGVmYXVsdHMsIHN0YW5kYXJkQ29uZmlnLCB0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVqZWN0RXJyb3JSZXNwb25zZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIFJlc3BvbnNlcyB3aG9zZSBzdGF0dXMgY29kZXMgZmFsbCBvdXRzaWRlIHRoZSByYW5nZSAyMDAtMjk5IHRvIHJlamVjdC5cbiAgICAgKiBUaGUgZmV0Y2ggQVBJIG9ubHkgcmVqZWN0cyBvbiBuZXR3b3JrIGVycm9ycyBvciBvdGhlciBjb25kaXRpb25zIHRoYXQgcHJldmVudFxuICAgICAqIHRoZSByZXF1ZXN0IGZyb20gY29tcGxldGluZywgbWVhbmluZyBjb25zdW1lcnMgbXVzdCBpbnNwZWN0IFJlc3BvbnNlLm9rIGluIHRoZVxuICAgICAqIFByb21pc2UgY29udGludWF0aW9uIHRvIGRldGVybWluZSBpZiB0aGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGEgc3VjY2VzcyBjb2RlLlxuICAgICAqIFRoaXMgbWV0aG9kIGFkZHMgYSByZXNwb25zZSBpbnRlcmNlcHRvciB0aGF0IGNhdXNlcyBSZXNwb25zZXMgd2l0aCBlcnJvciBjb2Rlc1xuICAgICAqIHRvIGJlIHJlamVjdGVkLCB3aGljaCBpcyBjb21tb24gYmVoYXZpb3IgaW4gSFRUUCBjbGllbnQgbGlicmFyaWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNoYWluYWJsZSBpbnN0YW5jZSBvZiB0aGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZWplY3RFcnJvclJlc3BvbnNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aEludGVyY2VwdG9yKHsgcmVzcG9uc2U6IHJlamVjdE9uRXJyb3IgfSk7XG4gICAgfVxuICAgIHdpdGhSZXRyeShjb25maWcpIHtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3IgPSBuZXcgUmV0cnlJbnRlcmNlcHRvcihjb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoSW50ZXJjZXB0b3IoaW50ZXJjZXB0b3IpO1xuICAgIH1cbiAgICB3aXRoRGlzcGF0Y2hlcihkaXNwYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlamVjdE9uRXJyb3IocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwLWNsaWVudC1jb25maWd1cmF0aW9uLmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEh0dHBDbGllbnRDb25maWd1cmF0aW9uIH0gZnJvbSAnLi9odHRwLWNsaWVudC1jb25maWd1cmF0aW9uLmpzJztcbmltcG9ydCB7IFJldHJ5SW50ZXJjZXB0b3IgfSBmcm9tICcuL3JldHJ5LWludGVyY2VwdG9yLmpzJztcbmNvbnN0IGFic29sdXRlVXJsUmVnZXhwID0gL14oW2Etel1bYS16MC05K1xcLS5dKjopP1xcL1xcLy9pO1xuZXhwb3J0IGNvbnN0IElIdHRwQ2xpZW50ID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJSHR0cENsaWVudCcsIHggPT4geC5zaW5nbGV0b24oSHR0cENsaWVudCkpO1xuLyoqXG4gKiBBbiBIVFRQIGNsaWVudCBiYXNlZCBvbiB0aGUgRmV0Y2ggQVBJLlxuICovXG5leHBvcnQgY2xhc3MgSHR0cENsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBIdHRwQ2xpZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaXNSZXF1ZXN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDb25maWd1cmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICcnO1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHRoaXMgY2xpZW50IHdpdGggZGVmYXVsdCBzZXR0aW5ncyB0byBiZSB1c2VkIGJ5IGFsbCByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb25maWdcbiAgICAgKiBvYmplY3QgYW5kIGNvbmZpZ3VyZXMgaXQuXG4gICAgICogQHJldHVybnMgVGhlIGNoYWluYWJsZSBpbnN0YW5jZSBvZiB0aGlzIEh0dHBDbGllbnQuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRDb25maWc7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluaXRDb25maWd1cmF0aW9uID0geyBkZWZhdWx0czogY29uZmlnIH07XG4gICAgICAgICAgICBub3JtYWxpemVkQ29uZmlnID0gcmVxdWVzdEluaXRDb25maWd1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRDb25maWcgPSBuZXcgSHR0cENsaWVudENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRDb25maWcuYmFzZVVybCA9IHRoaXMuYmFzZVVybDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRDb25maWcuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMgfTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRDb25maWcuaW50ZXJjZXB0b3JzID0gdGhpcy5pbnRlcmNlcHRvcnM7XG4gICAgICAgICAgICBub3JtYWxpemVkQ29uZmlnLmRpc3BhdGNoZXIgPSB0aGlzLmRpc3BhdGNoZXI7XG4gICAgICAgICAgICBjb25zdCBjID0gY29uZmlnKG5vcm1hbGl6ZWRDb25maWcpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKEh0dHBDbGllbnRDb25maWd1cmF0aW9uLnByb3RvdHlwZSwgYykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQ29uZmlnID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb25maWcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IG5vcm1hbGl6ZWRDb25maWcuZGVmYXVsdHM7XG4gICAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKEhlYWRlcnMucHJvdG90eXBlLCBkZWZhdWx0cy5oZWFkZXJzKSkge1xuICAgICAgICAgICAgLy8gSGVhZGVycyBpbnN0YW5jZXMgYXJlIG5vdCBpdGVyYWJsZSBpbiBhbGwgYnJvd3NlcnMuIFJlcXVpcmUgYSBwbGFpblxuICAgICAgICAgICAgLy8gb2JqZWN0IGhlcmUgdG8gYWxsb3cgZGVmYXVsdCBoZWFkZXJzIHRvIGJlIG1lcmdlZCBpbnRvIHJlcXVlc3QgaGVhZGVycy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCBoZWFkZXJzIG11c3QgYmUgYSBwbGFpbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JzID0gbm9ybWFsaXplZENvbmZpZy5pbnRlcmNlcHRvcnM7XG4gICAgICAgIGlmIChpbnRlcmNlcHRvcnMgIT09IHVuZGVmaW5lZCAmJiBpbnRlcmNlcHRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBmaW5kIGlmIHRoZXJlIGlzIGEgUmV0cnlJbnRlcmNlcHRvclxuICAgICAgICAgICAgaWYgKGludGVyY2VwdG9ycy5maWx0ZXIoeCA9PiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChSZXRyeUludGVyY2VwdG9yLnByb3RvdHlwZSwgeCkpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIFJldHJ5SW50ZXJjZXB0b3IgaXMgYWxsb3dlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldHJ5SW50ZXJjZXB0b3JJbmRleCA9IGludGVyY2VwdG9ycy5maW5kSW5kZXgoeCA9PiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChSZXRyeUludGVyY2VwdG9yLnByb3RvdHlwZSwgeCkpO1xuICAgICAgICAgICAgaWYgKHJldHJ5SW50ZXJjZXB0b3JJbmRleCA+PSAwICYmIHJldHJ5SW50ZXJjZXB0b3JJbmRleCAhPT0gaW50ZXJjZXB0b3JzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXRyeSBpbnRlcmNlcHRvciBtdXN0IGJlIHRoZSBsYXN0IGludGVyY2VwdG9yIGRlZmluZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXNlVXJsID0gbm9ybWFsaXplZENvbmZpZy5iYXNlVXJsO1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gbm9ybWFsaXplZENvbmZpZy5pbnRlcmNlcHRvcnMgIT09IHVuZGVmaW5lZCA/IG5vcm1hbGl6ZWRDb25maWcuaW50ZXJjZXB0b3JzIDogW107XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5vcm1hbGl6ZWRDb25maWcuZGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5pc0NvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBwcm9jZXNzIG9mIGZldGNoaW5nIGEgcmVzb3VyY2UuIERlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBSZXF1ZXN0LiBUaGUgY29uc3RydWN0ZWQgUmVxdWVzdCB3aWxsIGJlIHBhc3NlZCB0b1xuICAgICAqIHJlZ2lzdGVyZWQgcmVxdWVzdCBpbnRlcmNlcHRvcnMgYmVmb3JlIGJlaW5nIHNlbnQuIFRoZSBSZXNwb25zZSB3aWxsIGJlIHBhc3NlZFxuICAgICAqIHRvIHJlZ2lzdGVyZWQgUmVzcG9uc2UgaW50ZXJjZXB0b3JzIGJlZm9yZSBpdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUElcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0aGF0IHlvdSB3aXNoIHRvIGZldGNoLiBFaXRoZXIgYVxuICAgICAqIFJlcXVlc3Qgb2JqZWN0LCBvciBhIHN0cmluZyBjb250YWluaW5nIHRoZSBVUkwgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSBpbml0IC0gQW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyB0byBiZSBhcHBsaWVkIHRvXG4gICAgICogdGhlIFJlcXVlc3QuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciB0aGUgUmVzcG9uc2UgZnJvbSB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgICAgICB0aGlzLnRyYWNrUmVxdWVzdFN0YXJ0KCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyZXF1ZXN0LCB0aGlzLmludGVyY2VwdG9ycykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gaW52YWxpZCByZXN1bHQgd2FzIHJldHVybmVkIGJ5IHRoZSBpbnRlcmNlcHRvciBjaGFpbi4gRXhwZWN0ZWQgYSBSZXF1ZXN0IG9yIFJlc3BvbnNlIGluc3RhbmNlLCBidXQgZ290IFske3Jlc3VsdH1dYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UsIHRoaXMuaW50ZXJjZXB0b3JzLCByZXF1ZXN0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoUmVxdWVzdC5wcm90b3R5cGUsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrUmVxdWVzdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFja1JlcXVlc3RFbmQoKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRSZXF1ZXN0KGlucHV0LCBpbml0KSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0cyAhPT0gbnVsbCA/IHRoaXMuZGVmYXVsdHMgOiB7fTtcbiAgICAgICAgbGV0IHJlcXVlc3Q7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBsZXQgcmVxdWVzdENvbnRlbnRUeXBlO1xuICAgICAgICBjb25zdCBwYXJzZWREZWZhdWx0SGVhZGVycyA9IHBhcnNlSGVhZGVyVmFsdWVzKGRlZmF1bHRzLmhlYWRlcnMpO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoUmVxdWVzdC5wcm90b3R5cGUsIGlucHV0KSkge1xuICAgICAgICAgICAgcmVxdWVzdCA9IGlucHV0O1xuICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRUeXBlID0gbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKS5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpbml0KSB7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keSA9IGluaXQuYm9keTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlPYmogPSBib2R5ICE9PSB1bmRlZmluZWQgPyB7IGJvZHk6IGJvZHkgfSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5pdCA9IHsgLi4uZGVmYXVsdHMsIGhlYWRlcnM6IHt9LCAuLi5pbml0LCAuLi5ib2R5T2JqIH07XG4gICAgICAgICAgICByZXF1ZXN0Q29udGVudFR5cGUgPSBuZXcgSGVhZGVycyhyZXF1ZXN0SW5pdC5oZWFkZXJzKS5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGdldFJlcXVlc3RVcmwodGhpcy5iYXNlVXJsLCBpbnB1dCksIHJlcXVlc3RJbml0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcXVlc3RDb250ZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKG5ldyBIZWFkZXJzKHBhcnNlZERlZmF1bHRIZWFkZXJzKS5oYXMoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgbmV3IEhlYWRlcnMocGFyc2VkRGVmYXVsdEhlYWRlcnMpLmdldCgnY29udGVudC10eXBlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYm9keSAhPT0gdW5kZWZpbmVkICYmIGlzSlNPTihib2R5KSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0RGVmYXVsdEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzLCBwYXJzZWREZWZhdWx0SGVhZGVycyk7XG4gICAgICAgIGlmIChib2R5ICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoQmxvYi5wcm90b3R5cGUsIGJvZHkpICYmIGJvZHkudHlwZSkge1xuICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYnVnIGluIElFICYgRWRnZSB3aGVyZSB0aGUgQmxvYiB0eXBlIGlzIGlnbm9yZWQgaW4gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMjEzNjE2M1xuICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgYm9keS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgZmV0Y2ggYXMgYSBHRVQgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0aGF0IHlvdSB3aXNoIHRvIGZldGNoLiBFaXRoZXIgYVxuICAgICAqIFJlcXVlc3Qgb2JqZWN0LCBvciBhIHN0cmluZyBjb250YWluaW5nIHRoZSBVUkwgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSBpbml0IC0gQW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyB0byBiZSBhcHBsaWVkIHRvXG4gICAgICogdGhlIFJlcXVlc3QuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciB0aGUgUmVzcG9uc2UgZnJvbSB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQoaW5wdXQsIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goaW5wdXQsIGluaXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBmZXRjaCB3aXRoIHJlcXVlc3QgbWV0aG9kIHNldCB0byBQT1NULlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IC0gVGhlIHJlc291cmNlIHRoYXQgeW91IHdpc2ggdG8gZmV0Y2guIEVpdGhlciBhXG4gICAgICogUmVxdWVzdCBvYmplY3QsIG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIFVSTCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gaW5pdCAtIEFuIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgc2V0dGluZ3MgdG8gYmUgYXBwbGllZCB0b1xuICAgICAqIHRoZSBSZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgdGhlIFJlc3BvbnNlIGZyb20gdGhlIGZldGNoIHJlcXVlc3QuXG4gICAgICovXG4gICAgcG9zdChpbnB1dCwgYm9keSwgaW5pdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRmV0Y2goaW5wdXQsIGJvZHksIGluaXQsICdQT1NUJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIGZldGNoIHdpdGggcmVxdWVzdCBtZXRob2Qgc2V0IHRvIFBVVC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0aGF0IHlvdSB3aXNoIHRvIGZldGNoLiBFaXRoZXIgYVxuICAgICAqIFJlcXVlc3Qgb2JqZWN0LCBvciBhIHN0cmluZyBjb250YWluaW5nIHRoZSBVUkwgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGluaXQgLSBBbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHNldHRpbmdzIHRvIGJlIGFwcGxpZWQgdG9cbiAgICAgKiB0aGUgUmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIHRoZSBSZXNwb25zZSBmcm9tIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIHB1dChpbnB1dCwgYm9keSwgaW5pdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRmV0Y2goaW5wdXQsIGJvZHksIGluaXQsICdQVVQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgZmV0Y2ggd2l0aCByZXF1ZXN0IG1ldGhvZCBzZXQgdG8gUEFUQ0guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgcmVzb3VyY2UgdGhhdCB5b3Ugd2lzaCB0byBmZXRjaC4gRWl0aGVyIGFcbiAgICAgKiBSZXF1ZXN0IG9iamVjdCwgb3IgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgVVJMIG9mIHRoZSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBpbml0IC0gQW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyB0byBiZSBhcHBsaWVkIHRvXG4gICAgICogdGhlIFJlcXVlc3QuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciB0aGUgUmVzcG9uc2UgZnJvbSB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBwYXRjaChpbnB1dCwgYm9keSwgaW5pdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRmV0Y2goaW5wdXQsIGJvZHksIGluaXQsICdQQVRDSCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBmZXRjaCB3aXRoIHJlcXVlc3QgbWV0aG9kIHNldCB0byBERUxFVEUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgcmVzb3VyY2UgdGhhdCB5b3Ugd2lzaCB0byBmZXRjaC4gRWl0aGVyIGFcbiAgICAgKiBSZXF1ZXN0IG9iamVjdCwgb3IgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgVVJMIG9mIHRoZSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBpbml0IC0gQW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyB0byBiZSBhcHBsaWVkIHRvXG4gICAgICogdGhlIFJlcXVlc3QuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciB0aGUgUmVzcG9uc2UgZnJvbSB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBkZWxldGUoaW5wdXQsIGJvZHksIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbEZldGNoKGlucHV0LCBib2R5LCBpbml0LCAnREVMRVRFJyk7XG4gICAgfVxuICAgIHRyYWNrUmVxdWVzdFN0YXJ0KCkge1xuICAgICAgICB0aGlzLmlzUmVxdWVzdGluZyA9ICEhKCsrdGhpcy5hY3RpdmVSZXF1ZXN0Q291bnQpO1xuICAgICAgICBpZiAodGhpcy5pc1JlcXVlc3RpbmcgJiYgdGhpcy5kaXNwYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBldnQgPSBuZXcgdGhpcy5kaXNwYXRjaGVyLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuQ3VzdG9tRXZlbnQoJ2F1cmVsaWEtZmV0Y2gtY2xpZW50LXJlcXVlc3Qtc3RhcnRlZCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmRpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChldnQpOyB9LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFja1JlcXVlc3RFbmQoKSB7XG4gICAgICAgIHRoaXMuaXNSZXF1ZXN0aW5nID0gISEoLS10aGlzLmFjdGl2ZVJlcXVlc3RDb3VudCk7XG4gICAgICAgIGlmICghdGhpcy5pc1JlcXVlc3RpbmcgJiYgdGhpcy5kaXNwYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBldnQgPSBuZXcgdGhpcy5kaXNwYXRjaGVyLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuQ3VzdG9tRXZlbnQoJ2F1cmVsaWEtZmV0Y2gtY2xpZW50LXJlcXVlc3RzLWRyYWluZWQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5kaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoZXZ0KTsgfSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1JlcXVlc3QocmVxdWVzdCwgaW50ZXJjZXB0b3JzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5SW50ZXJjZXB0b3JzKHJlcXVlc3QsIGludGVyY2VwdG9ycywgJ3JlcXVlc3QnLCAncmVxdWVzdEVycm9yJywgdGhpcyk7XG4gICAgfVxuICAgIHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgaW50ZXJjZXB0b3JzLCByZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5SW50ZXJjZXB0b3JzKHJlc3BvbnNlLCBpbnRlcmNlcHRvcnMsICdyZXNwb25zZScsICdyZXNwb25zZUVycm9yJywgcmVxdWVzdCwgdGhpcyk7XG4gICAgfVxuICAgIGFwcGx5SW50ZXJjZXB0b3JzKGlucHV0LCBpbnRlcmNlcHRvcnMsIHN1Y2Nlc3NOYW1lLCBlcnJvck5hbWUsIC4uLmludGVyY2VwdG9yQXJncykge1xuICAgICAgICByZXR1cm4gKGludGVyY2VwdG9ycyAhPT0gdW5kZWZpbmVkID8gaW50ZXJjZXB0b3JzIDogW10pXG4gICAgICAgICAgICAucmVkdWNlKChjaGFpbiwgaW50ZXJjZXB0b3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gaW50ZXJjZXB0b3Jbc3VjY2Vzc05hbWVdO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gaW50ZXJjZXB0b3JbZXJyb3JOYW1lXTtcbiAgICAgICAgICAgIC8vIFRPRE86IEZpeCB0aGlzLCBhcyBpdCB2aW9sYXRlcyBgc3RyaWN0QmluZENhbGxBcHBseWAuXG4gICAgICAgICAgICByZXR1cm4gY2hhaW4udGhlbihzdWNjZXNzSGFuZGxlciA/ICh2YWx1ZSA9PiBzdWNjZXNzSGFuZGxlci5jYWxsKGludGVyY2VwdG9yLCB2YWx1ZSwgLi4uaW50ZXJjZXB0b3JBcmdzKSkgOiBpZGVudGl0eSwgZXJyb3JIYW5kbGVyID8gKHJlYXNvbiA9PiBlcnJvckhhbmRsZXIuY2FsbChpbnRlcmNlcHRvciwgcmVhc29uLCAuLi5pbnRlcmNlcHRvckFyZ3MpKSA6IHRocm93ZXIpO1xuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoaW5wdXQpKTtcbiAgICB9XG4gICAgY2FsbEZldGNoKGlucHV0LCBib2R5LCBpbml0LCBtZXRob2QpIHtcbiAgICAgICAgaWYgKCFpbml0KSB7XG4gICAgICAgICAgICBpbml0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaW5pdC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICBpbml0LmJvZHkgPSBib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGlucHV0LCBpbml0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUhlYWRlclZhbHVlcyhoZWFkZXJzKSB7XG4gICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHt9O1xuICAgIGNvbnN0ICRoZWFkZXJzID0gaGVhZGVycyAhPT0gdW5kZWZpbmVkID8gaGVhZGVycyA6IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiAkaGVhZGVycykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCRoZWFkZXJzLCBuYW1lKSkge1xuICAgICAgICAgICAgcGFyc2VkSGVhZGVyc1tuYW1lXSA9ICh0eXBlb2YgJGhlYWRlcnNbbmFtZV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgPyAkaGVhZGVyc1tuYW1lXSgpXG4gICAgICAgICAgICAgICAgOiAkaGVhZGVyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkSGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RVcmwoYmFzZVVybCwgdXJsKSB7XG4gICAgaWYgKGFic29sdXRlVXJsUmVnZXhwLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gKGJhc2VVcmwgIT09IHVuZGVmaW5lZCA/IGJhc2VVcmwgOiAnJykgKyB1cmw7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0SGVhZGVycyhoZWFkZXJzLCBkZWZhdWx0SGVhZGVycykge1xuICAgIGNvbnN0ICRkZWZhdWx0SGVhZGVycyA9IGRlZmF1bHRIZWFkZXJzICE9PSB1bmRlZmluZWQgPyBkZWZhdWx0SGVhZGVycyA6IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiAkZGVmYXVsdEhlYWRlcnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgkZGVmYXVsdEhlYWRlcnMsIG5hbWUpICYmICFoZWFkZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQobmFtZSwgJGRlZmF1bHRIZWFkZXJzW25hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSlNPTihzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICBKU09OLnBhcnNlKHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHRocm93ZXIoeCkge1xuICAgIHRocm93IHg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwLWNsaWVudC5qcy5tYXAiLCJleHBvcnQgeyBqc29uIH0gZnJvbSAnLi91dGlsLmpzJztcbmV4cG9ydCB7IHJldHJ5U3RyYXRlZ3ksIFJldHJ5SW50ZXJjZXB0b3IgfSBmcm9tICcuL3JldHJ5LWludGVyY2VwdG9yLmpzJztcbmV4cG9ydCB7IEh0dHBDbGllbnRDb25maWd1cmF0aW9uIH0gZnJvbSAnLi9odHRwLWNsaWVudC1jb25maWd1cmF0aW9uLmpzJztcbmV4cG9ydCB7IEh0dHBDbGllbnQsIElIdHRwQ2xpZW50IH0gZnJvbSAnLi9odHRwLWNsaWVudC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgcmV0cnlTdHJhdGVneSA9IHtcbiAgICBmaXhlZDogMCxcbiAgICBpbmNyZW1lbnRhbDogMSxcbiAgICBleHBvbmVudGlhbDogMixcbiAgICByYW5kb206IDNcbn07XG5jb25zdCBkZWZhdWx0UmV0cnlDb25maWcgPSB7XG4gICAgbWF4UmV0cmllczogMyxcbiAgICBpbnRlcnZhbDogMTAwMCxcbiAgICBzdHJhdGVneTogcmV0cnlTdHJhdGVneS5maXhlZFxufTtcbi8qKlxuICogSW50ZXJjZXB0b3IgdGhhdCByZXRyaWVzIHJlcXVlc3RzIG9uIGVycm9yLCBiYXNlZCBvbiBhIGdpdmVuIFJldHJ5Q29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJldHJ5SW50ZXJjZXB0b3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmV0cnlJbnRlcmNlcHRvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXRyeUNvbmZpZykge1xuICAgICAgICB0aGlzLnJldHJ5Q29uZmlnID0geyAuLi5kZWZhdWx0UmV0cnlDb25maWcsIC4uLihyZXRyeUNvbmZpZyAhPT0gdW5kZWZpbmVkID8gcmV0cnlDb25maWcgOiB7fSkgfTtcbiAgICAgICAgaWYgKHRoaXMucmV0cnlDb25maWcuc3RyYXRlZ3kgPT09IHJldHJ5U3RyYXRlZ3kuZXhwb25lbnRpYWwgJiZcbiAgICAgICAgICAgIHRoaXMucmV0cnlDb25maWcuaW50ZXJ2YWwgPD0gMTAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpbnRlcnZhbCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMSBzZWNvbmQgaXMgbm90IGFsbG93ZWQgd2hlbiB1c2luZyB0aGUgZXhwb25lbnRpYWwgcmV0cnkgc3RyYXRlZ3knKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCB0aGUgcmVxdWVzdCBiZWZvcmUgaXQgaXMgc2VudC4gSXQgcmVtZW1iZXJzIHRoZSByZXF1ZXN0IHNvIGl0IGNhbiBiZSByZXRyaWVkIG9uIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB0byBiZSBzZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSBleGlzdGluZyByZXF1ZXN0LCBhIG5ldyByZXF1ZXN0IG9yIGEgcmVzcG9uc2U7IG9yIGEgUHJvbWlzZSBmb3IgYW55IG9mIHRoZXNlLlxuICAgICAqL1xuICAgIHJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QucmV0cnlDb25maWcpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlDb25maWcgPSB7IC4uLnRoaXMucmV0cnlDb25maWcgfTtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlDb25maWcuY291bnRlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gdGhpcyBvbiBldmVyeSByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QucmV0cnlDb25maWcucmVxdWVzdENsb25lID0gcmVxdWVzdC5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggdGhlIHJlc3BvbnNlIGFmdGVyIGl0IGlzIHJlY2VpdmVkLiBDbGVhcnMgdGhlIHJlbWVtYmVyZWQgcmVxdWVzdCwgYXMgaXQgd2FzIHN1Y2Nlc2Z1bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlOyBvciBhIFByb21pc2UgZm9yIG9uZS5cbiAgICAgKi9cbiAgICByZXNwb25zZShyZXNwb25zZSwgcmVxdWVzdCkge1xuICAgICAgICAvLyByZXRyeSB3YXMgc3VjY2Vzc2Z1bCwgc28gY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzXG4gICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkocmVxdWVzdCwgJ3JldHJ5Q29uZmlnJyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBmZXRjaCBlcnJvcnMgYW5kIGVycm9ycyBnZW5lcmF0ZWQgYnkgcHJldmlvdXMgaW50ZXJjZXB0b3JzLiBUaGlzXG4gICAgICogZnVuY3Rpb24gYWN0cyBhcyBhIFByb21pc2UgcmVqZWN0aW9uIGhhbmRsZXIuIEl0IHdpbCByZXRyeSB0aGUgcmVtZW1iZXJlZCByZXF1ZXN0IGJhc2VkIG9uIHRoZVxuICAgICAqIGNvbmZpZ3VyZWQgUmV0cnlDb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIHJlamVjdGlvbiB2YWx1ZSBmcm9tIHRoZSBmZXRjaCByZXF1ZXN0IG9yIGZyb20gYVxuICAgICAqIHByZXZpb3VzIGludGVyY2VwdG9yLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBvZiB0aGUgcmV0cnk7IG9yIGEgUHJvbWlzZSBmb3Igb25lLlxuICAgICAqL1xuICAgIHJlc3BvbnNlRXJyb3IoZXJyb3IsIHJlcXVlc3QsIGh0dHBDbGllbnQpIHtcbiAgICAgICAgY29uc3QgeyByZXRyeUNvbmZpZyB9ID0gcmVxdWVzdDtcbiAgICAgICAgY29uc3QgeyByZXF1ZXN0Q2xvbmUgfSA9IHJldHJ5Q29uZmlnO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmV0cnlDb25maWcuY291bnRlciA8IHJldHJ5Q29uZmlnLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXRyeUNvbmZpZy5kb1JldHJ5ICE9PSB1bmRlZmluZWQgPyByZXRyeUNvbmZpZy5kb1JldHJ5KGVycm9yLCByZXF1ZXN0KSA6IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZG9SZXRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb1JldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvbmZpZy5jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IGNhbGN1bGF0ZURlbGF5KHJldHJ5Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgIWlzTmFOKGRlbGF5KSA/IGRlbGF5IDogMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JlcXVlc3QgPSByZXF1ZXN0Q2xvbmUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXRyeUNvbmZpZy5iZWZvcmVSZXRyeSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5Q29uZmlnLmJlZm9yZVJldHJ5KG5ld1JlcXVlc3QsIGh0dHBDbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4obmV3UmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlhYmxlUmVxdWVzdCA9IHsgLi4ubmV3UmVxdWVzdCwgcmV0cnlDb25maWcgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHR0cENsaWVudC5mZXRjaChyZXRyeWFibGVSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG1vcmUgcmV0cmllcywgc28gY2xlYW4gdXBcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShyZXF1ZXN0LCAncmV0cnlDb25maWcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBtb3JlIHJldHJpZXMsIHNvIGNsZWFuIHVwXG4gICAgICAgICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHJlcXVlc3QsICdyZXRyeUNvbmZpZycpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbGF5KHJldHJ5Q29uZmlnKSB7XG4gICAgY29uc3QgeyBpbnRlcnZhbCwgc3RyYXRlZ3ksIG1pblJhbmRvbUludGVydmFsLCBtYXhSYW5kb21JbnRlcnZhbCwgY291bnRlciB9ID0gcmV0cnlDb25maWc7XG4gICAgaWYgKHR5cGVvZiAoc3RyYXRlZ3kpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiByZXRyeUNvbmZpZy5zdHJhdGVneShjb3VudGVyKTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlIChyZXRyeVN0cmF0ZWd5LmZpeGVkKTpcbiAgICAgICAgICAgIHJldHVybiByZXRyeVN0cmF0ZWdpZXNbcmV0cnlTdHJhdGVneS5maXhlZF0oaW50ZXJ2YWwpO1xuICAgICAgICBjYXNlIChyZXRyeVN0cmF0ZWd5LmluY3JlbWVudGFsKTpcbiAgICAgICAgICAgIHJldHVybiByZXRyeVN0cmF0ZWdpZXNbcmV0cnlTdHJhdGVneS5pbmNyZW1lbnRhbF0oY291bnRlciwgaW50ZXJ2YWwpO1xuICAgICAgICBjYXNlIChyZXRyeVN0cmF0ZWd5LmV4cG9uZW50aWFsKTpcbiAgICAgICAgICAgIHJldHVybiByZXRyeVN0cmF0ZWdpZXNbcmV0cnlTdHJhdGVneS5leHBvbmVudGlhbF0oY291bnRlciwgaW50ZXJ2YWwpO1xuICAgICAgICBjYXNlIChyZXRyeVN0cmF0ZWd5LnJhbmRvbSk6XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlTdHJhdGVnaWVzW3JldHJ5U3RyYXRlZ3kucmFuZG9tXShjb3VudGVyLCBpbnRlcnZhbCwgbWluUmFuZG9tSW50ZXJ2YWwsIG1heFJhbmRvbUludGVydmFsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIHJldHJ5IHN0cmF0ZWd5Jyk7XG4gICAgfVxufVxuY29uc3QgcmV0cnlTdHJhdGVnaWVzID0gW1xuICAgIC8vIGZpeGVkXG4gICAgaW50ZXJ2YWwgPT4gaW50ZXJ2YWwsXG4gICAgLy8gaW5jcmVtZW50YWxcbiAgICAocmV0cnlDb3VudCwgaW50ZXJ2YWwpID0+IGludGVydmFsICogcmV0cnlDb3VudCxcbiAgICAvLyBleHBvbmVudGlhbFxuICAgIChyZXRyeUNvdW50LCBpbnRlcnZhbCkgPT4gcmV0cnlDb3VudCA9PT0gMSA/IGludGVydmFsIDogaW50ZXJ2YWwgKiogcmV0cnlDb3VudCAvIDEwMDAsXG4gICAgLy8gcmFuZG9tXG4gICAgKHJldHJ5Q291bnQsIGludGVydmFsLCBtaW5SYW5kb21JbnRlcnZhbCA9IDAsIG1heFJhbmRvbUludGVydmFsID0gNjAwMDApID0+IHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4UmFuZG9tSW50ZXJ2YWwgLSBtaW5SYW5kb21JbnRlcnZhbCkgKyBtaW5SYW5kb21JbnRlcnZhbDtcbiAgICB9XG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnktaW50ZXJjZXB0b3IuanMubWFwIiwiLyoqXG4gKiBTZXJpYWxpemUgYW4gb2JqZWN0IHRvIEpTT04uIFVzZWZ1bCBmb3IgZWFzaWx5IGNyZWF0aW5nIEpTT04gZmV0Y2ggcmVxdWVzdCBib2RpZXMuXG4gKlxuICogQHBhcmFtIGJvZHkgLSBUaGUgb2JqZWN0IHRvIGJlIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAqIEBwYXJhbSByZXBsYWNlciAtIFRoZSBKU09OLnN0cmluZ2lmeSByZXBsYWNlciB1c2VkIHdoZW4gc2VyaWFsaXppbmcuXG4gKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbihib2R5LCByZXBsYWNlcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgoYm9keSAhPT0gdW5kZWZpbmVkID8gYm9keSA6IHt9KSwgcmVwbGFjZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJpbXBvcnQgeyBNZXRhZGF0YSwgaXNPYmplY3QsIGFwcGx5TWV0YWRhdGFQb2x5ZmlsbCB9IGZyb20gJ0BhdXJlbGlhL21ldGFkYXRhJztcbmFwcGx5TWV0YWRhdGFQb2x5ZmlsbChSZWZsZWN0KTtcbmltcG9ydCB7IGlzQXJyYXlJbmRleCwgaXNOYXRpdmVGdW5jdGlvbiB9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7IGVtcHR5QXJyYXkgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IFByb3RvY29sIH0gZnJvbSAnLi9yZXNvdXJjZS5qcyc7XG5leHBvcnQgY2xhc3MgUmVzb2x2ZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGtleSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIGluc3RhbmNlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyUmVzb2x2ZXIoMCAvKiBpbnN0YW5jZSAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBzaW5nbGV0b24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJSZXNvbHZlcigxIC8qIHNpbmdsZXRvbiAqLywgdmFsdWUpO1xuICAgIH1cbiAgICB0cmFuc2llbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJSZXNvbHZlcigyIC8qIHRyYW5zaWVudCAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBjYWxsYmFjayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclJlc29sdmVyKDMgLyogY2FsbGJhY2sgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgY2FjaGVkQ2FsbGJhY2sodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJSZXNvbHZlcigzIC8qIGNhbGxiYWNrICovLCBjYWNoZUNhbGxiYWNrUmVzdWx0KHZhbHVlKSk7XG4gICAgfVxuICAgIGFsaWFzVG8oZGVzdGluYXRpb25LZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJSZXNvbHZlcig1IC8qIGFsaWFzICovLCBkZXN0aW5hdGlvbktleSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVzb2x2ZXIoc3RyYXRlZ3ksIHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyLCBrZXkgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5rZXkgPSAodm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKGtleSwgbmV3IFJlc29sdmVyKGtleSwgc3RyYXRlZ3ksIHN0YXRlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvbmVBcnJheVdpdGhQb3NzaWJsZVByb3BzKHNvdXJjZSkge1xuICAgIGNvbnN0IGNsb25lID0gc291cmNlLnNsaWNlKCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghaXNBcnJheUluZGV4KGtleSkpIHtcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG5leHBvcnQgY29uc3QgRGVmYXVsdFJlc29sdmVyID0ge1xuICAgIG5vbmUoa2V5KSB7IHRocm93IEVycm9yKGAke2tleS50b1N0cmluZygpfSBub3QgcmVnaXN0ZXJlZCwgZGlkIHlvdSBmb3JnZXQgdG8gYWRkIEBzaW5nbGV0b24oKT9gKTsgfSxcbiAgICBzaW5nbGV0b24oa2V5KSB7IHJldHVybiBuZXcgUmVzb2x2ZXIoa2V5LCAxIC8qIHNpbmdsZXRvbiAqLywga2V5KTsgfSxcbiAgICB0cmFuc2llbnQoa2V5KSB7IHJldHVybiBuZXcgUmVzb2x2ZXIoa2V5LCAyIC8qIHRyYW5zaWVudCAqLywga2V5KTsgfSxcbn07XG5leHBvcnQgY2xhc3MgQ29udGFpbmVyQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaW5oZXJpdFBhcmVudFJlc291cmNlcywgZGVmYXVsdFJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuaW5oZXJpdFBhcmVudFJlc291cmNlcyA9IGluaGVyaXRQYXJlbnRSZXNvdXJjZXM7XG4gICAgICAgIHRoaXMuZGVmYXVsdFJlc29sdmVyID0gZGVmYXVsdFJlc29sdmVyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwIHx8XG4gICAgICAgICAgICBjb25maWcgPT09IENvbnRhaW5lckNvbmZpZ3VyYXRpb24uREVGQVVMVCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbnRhaW5lckNvbmZpZ3VyYXRpb24uREVGQVVMVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lckNvbmZpZ3VyYXRpb24oY29uZmlnLmluaGVyaXRQYXJlbnRSZXNvdXJjZXMgPz8gZmFsc2UsIGNvbmZpZy5kZWZhdWx0UmVzb2x2ZXIgPz8gRGVmYXVsdFJlc29sdmVyLnNpbmdsZXRvbik7XG4gICAgfVxufVxuQ29udGFpbmVyQ29uZmlndXJhdGlvbi5ERUZBVUxUID0gQ29udGFpbmVyQ29uZmlndXJhdGlvbi5mcm9tKHt9KTtcbmV4cG9ydCBjb25zdCBESSA9IHtcbiAgICBjcmVhdGVDb250YWluZXIoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKG51bGwsIENvbnRhaW5lckNvbmZpZ3VyYXRpb24uZnJvbShjb25maWcpKTtcbiAgICB9LFxuICAgIGdldERlc2lnblBhcmFtdHlwZXMoVHlwZSkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKCdkZXNpZ246cGFyYW10eXBlcycsIFR5cGUpO1xuICAgIH0sXG4gICAgZ2V0QW5ub3RhdGlvblBhcmFtdHlwZXMoVHlwZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcignZGk6cGFyYW10eXBlcycpO1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKGtleSwgVHlwZSk7XG4gICAgfSxcbiAgICBnZXRPckNyZWF0ZUFubm90YXRpb25QYXJhbVR5cGVzKFR5cGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IoJ2RpOnBhcmFtdHlwZXMnKTtcbiAgICAgICAgbGV0IGFubm90YXRpb25QYXJhbXR5cGVzID0gTWV0YWRhdGEuZ2V0T3duKGtleSwgVHlwZSk7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uUGFyYW10eXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoa2V5LCBhbm5vdGF0aW9uUGFyYW10eXBlcyA9IFtdLCBUeXBlKTtcbiAgICAgICAgICAgIFByb3RvY29sLmFubm90YXRpb24uYXBwZW5kVG8oVHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvblBhcmFtdHlwZXM7XG4gICAgfSxcbiAgICBnZXREZXBlbmRlbmNpZXMoVHlwZSkge1xuICAgICAgICAvLyBOb3RlOiBFdmVyeSBkZXRhaWwgb2YgdGhpcyBnZXREZXBlbmRlbmNpZXMgbWV0aG9kIGlzIHByZXR0eSBkZWxpYmVyYXRlIGF0IHRoZSBtb21lbnQsIGFuZCBwcm9iYWJseSBub3QgeWV0IDEwMCUgdGVzdGVkIGZyb20gZXZlcnkgcG9zc2libGUgYW5nbGUsXG4gICAgICAgIC8vIHNvIGJlIGNhcmVmdWwgd2l0aCBtYWtpbmcgY2hhbmdlcyBoZXJlIGFzIGl0IGNhbiBoYXZlIGEgaHVnZSBpbXBhY3Qgb24gY29tcGxleCBlbmQgdXNlciBhcHBzLlxuICAgICAgICAvLyBQcmVmZXJhYmx5LCBvbmx5IG1ha2UgY2hhbmdlcyB0byB0aGUgZGVwZW5kZW5jeSByZXNvbHV0aW9uIHByb2Nlc3MgdmlhIGEgUkZDLlxuICAgICAgICBjb25zdCBrZXkgPSBQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcignZGk6ZGVwZW5kZW5jaWVzJyk7XG4gICAgICAgIGxldCBkZXBlbmRlbmNpZXMgPSBNZXRhZGF0YS5nZXRPd24oa2V5LCBUeXBlKTtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAvLyBUeXBlLmxlbmd0aCBpcyB0aGUgbnVtYmVyIG9mIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMuIElmIHRoaXMgaXMgMCwgaXQgY291bGQgbWVhbiB0aGUgY2xhc3MgaGFzIGFuIGVtcHR5IGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAvLyBidXQgaXQgY291bGQgYWxzbyBtZWFuIHRoZSBjbGFzcyBoYXMgbm8gY29uc3RydWN0b3IgYXQgYWxsIChpbiB3aGljaCBjYXNlIGl0IGluaGVyaXRzIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHRoZSBwcm90b3R5cGUpLlxuICAgICAgICAgICAgLy8gTm9uLXplcm8gY29uc3RydWN0b3IgbGVuZ3RoICsgbm8gcGFyYW10eXBlcyBtZWFucyBlbWl0RGVjb3JhdG9yTWV0YWRhdGEgaXMgb2ZmLCBvciB0aGUgY2xhc3MgaGFzIG5vIGRlY29yYXRvci5cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBkb2luZyBhbnl0aGluZyB3aXRoIHRoZSBhYm92ZSByaWdodCBub3csIGJ1dCBpdCdzIGdvb2QgdG8ga2VlcCBpbiBtaW5kIGZvciBhbnkgZnV0dXJlIGlzc3Vlcy5cbiAgICAgICAgICAgIGNvbnN0IGluamVjdCA9IFR5cGUuaW5qZWN0O1xuICAgICAgICAgICAgaWYgKGluamVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzaWduOnBhcmFtdHlwZXMgaXMgc2V0IGJ5IHRzYyB3aGVuIGVtaXREZWNvcmF0b3JNZXRhZGF0YSBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2lnblBhcmFtdHlwZXMgPSBESS5nZXREZXNpZ25QYXJhbXR5cGVzKFR5cGUpO1xuICAgICAgICAgICAgICAgIC8vIGF1OmFubm90YXRpb246ZGk6cGFyYW10eXBlcyBpcyBzZXQgYnkgdGhlIHBhcmFtZXRlciBkZWNvcmF0b3IgZnJvbSBESS5jcmVhdGVJbnRlcmZhY2Ugb3IgYnkgQGluamVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25QYXJhbXR5cGVzID0gREkuZ2V0QW5ub3RhdGlvblBhcmFtdHlwZXMoVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2lnblBhcmFtdHlwZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvblBhcmFtdHlwZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBnbyB1cCB0aGUgcHJvdG90eXBlIGlmIG5laXRoZXIgc3RhdGljIGluamVjdCBub3IgYW55IG9mIHRoZSBwYXJhbXR5cGVzIGlzIGRlZmluZWQsIGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBzb3VuZCB3YXkgdG8gbWVyZ2UgYSB0eXBlJ3MgZGVwcyB3aXRoIGl0cyBwcm90b3R5cGUncyBkZXBzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvdG8gPT09ICdmdW5jdGlvbicgJiYgUHJvdG8gIT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IGNsb25lQXJyYXlXaXRoUG9zc2libGVQcm9wcyhESS5nZXREZXBlbmRlbmNpZXMoUHJvdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gZGVzaWduOnBhcmFtdHlwZXMgc28ganVzdCB1c2UgdGhlIGF1OmFubm90YXRpb246ZGk6cGFyYW10eXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gY2xvbmVBcnJheVdpdGhQb3NzaWJsZVByb3BzKGFubm90YXRpb25QYXJhbXR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhbm5vdGF0aW9uUGFyYW10eXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGF1OmFubm90YXRpb246ZGk6cGFyYW10eXBlcyBzbyBqdXN0IHVzZSB0aGUgZGVzaWduOnBhcmFtdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gY2xvbmVBcnJheVdpdGhQb3NzaWJsZVByb3BzKGRlc2lnblBhcmFtdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZ290IGJvdGgsIHNvIG1lcmdlIHRoZW0gKGluIGNhc2Ugb2YgY29uZmxpY3Qgb24gc2FtZSBpbmRleCwgYXU6YW5ub3RhdGlvbjpkaTpwYXJhbXR5cGVzIHRha2UgcHJlY2VkZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gY2xvbmVBcnJheVdpdGhQb3NzaWJsZVByb3BzKGRlc2lnblBhcmFtdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVuID0gYW5ub3RhdGlvblBhcmFtdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXVBbm5vdGF0aW9uUGFyYW10eXBlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdUFubm90YXRpb25QYXJhbXR5cGUgPSBhbm5vdGF0aW9uUGFyYW10eXBlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdUFubm90YXRpb25QYXJhbXR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llc1tpXSA9IGF1QW5ub3RhdGlvblBhcmFtdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYW5ub3RhdGlvblBhcmFtdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheUluZGV4KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXNba2V5XSA9IGFubm90YXRpb25QYXJhbXR5cGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcGFyYW10eXBlcyBpZiB3ZSBoYXZlIHN0YXRpYyBpbmplY3RcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBjbG9uZUFycmF5V2l0aFBvc3NpYmxlUHJvcHMoaW5qZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShrZXksIGRlcGVuZGVuY2llcywgVHlwZSk7XG4gICAgICAgICAgICBQcm90b2NvbC5hbm5vdGF0aW9uLmFwcGVuZFRvKFR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYSBkZWNvcmF0b3IgdGhhdCBhbHNvIG1hdGNoZXMgYW4gaW50ZXJmYWNlIGFuZCBjYW4gYmUgdXNlZCBhcyBhIHtAbGlua2NvZGUgS2V5fS5cbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IElMb2dnZXIgPSBESS5jcmVhdGVJbnRlcmZhY2U8TG9nZ2VyPignTG9nZ2VyJyk7XG4gICAgICogY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oSUxvZ2dlciwgZ2V0U29tZUxvZ2dlcigpKSk7XG4gICAgICogY29uc3QgbG9nID0gY29udGFpbmVyLmdldChJTG9nZ2VyKTtcbiAgICAgKiBsb2cuaW5mbygnaGVsbG8gd29ybGQnKTtcbiAgICAgKiBjbGFzcyBGb28ge1xuICAgICAqICAgY29uc3RydWN0b3IoIEBJTG9nZ2VyIGxvZzogSUxvZ2dlciApIHtcbiAgICAgKiAgICAgbG9nLmluZm8oJ2hlbGxvIHdvcmxkJyk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIHlvdSBjYW4gYWxzbyBidWlsZCBkZWZhdWx0IHJlZ2lzdHJhdGlvbnMgaW50byB5b3VyIGludGVyZmFjZS5cbiAgICAgKiBgYGB0c1xuICAgICAqIGV4cG9ydCBjb25zdCBJTG9nZ2VyID0gREkuY3JlYXRlSW50ZXJmYWNlPExvZ2dlcj4oJ0xvZ2dlcicsIGJ1aWxkZXIgPT4gYnVpbGRlci5jYWNoZWRDYWxsYmFjayhMb2dnZXJEZWZhdWx0KSk7XG4gICAgICogY29uc3QgbG9nID0gY29udGFpbmVyLmdldChJTG9nZ2VyKTtcbiAgICAgKiBsb2cuaW5mbygnaGVsbG8gd29ybGQnKTtcbiAgICAgKiBjbGFzcyBGb28ge1xuICAgICAqICAgY29uc3RydWN0b3IoIEBJTG9nZ2VyIGxvZzogSUxvZ2dlciApIHtcbiAgICAgKiAgICAgbG9nLmluZm8oJ2hlbGxvIHdvcmxkJyk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIGJ1dCB0aGVzZSBkZWZhdWx0IHJlZ2lzdHJhdGlvbnMgd29uJ3Qgd29yayB0aGUgc2FtZSB3aXRoIG90aGVyIGRlY29yYXRvcnMgdGhhdCB0YWtlIGtleXMsIGZvciBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBleHBvcnQgY29uc3QgTXlTdHIgPSBESS5jcmVhdGVJbnRlcmZhY2U8c3RyaW5nPignTXlTdHInLCBidWlsZGVyID0+IGJ1aWxkZXIuaW5zdGFuY2UoJ3NvbWVzdHJpbmcnKSk7XG4gICAgICogY2xhc3MgRm9vIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKCBAb3B0aW9uYWwoTXlTdHIpIHB1YmxpYyByZWFkb25seSBzdHI6IHN0cmluZyApIHtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogY29udGFpbmVyLmdldChGb28pLnN0cjsgLy8gcmV0dXJucyB1bmRlZmluZWRcbiAgICAgKiBgYGBcbiAgICAgKiB0byBmaXggdGhpcyBhZGQgdGhpcyBsaW5lIHNvbWV3aGVyZSBiZWZvcmUgeW91IGRvIGEgYGdldGBcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnRhaW5lci5yZWdpc3RlcihNeVN0cik7XG4gICAgICogY29udGFpbmVyLmdldChGb28pLnN0cjsgLy8gcmV0dXJucyAnc29tZXN0cmluZydcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIC0gQHBhcmFtIGZyaWVuZGx5TmFtZSB1c2VkIHRvIGltcHJvdmUgZXJyb3IgbWVzc2FnaW5nXG4gICAgICovXG4gICAgY3JlYXRlSW50ZXJmYWNlKGNvbmZpZ3VyZU9yTmFtZSwgY29uZmlndXJvcikge1xuICAgICAgICBjb25zdCBjb25maWd1cmUgPSB0eXBlb2YgY29uZmlndXJlT3JOYW1lID09PSAnZnVuY3Rpb24nID8gY29uZmlndXJlT3JOYW1lIDogY29uZmlndXJvcjtcbiAgICAgICAgY29uc3QgZnJpZW5kbHlOYW1lID0gdHlwZW9mIGNvbmZpZ3VyZU9yTmFtZSA9PT0gJ3N0cmluZycgPyBjb25maWd1cmVPck5hbWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IEludGVyZmFjZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsIHx8IG5ldy50YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcmVnaXN0cmF0aW9uIGZvciBpbnRlcmZhY2U6ICcke0ludGVyZmFjZS5mcmllbmRseU5hbWV9J2ApOyAvLyBUT0RPOiBhZGQgZXJyb3IgKHRyeWluZyB0byByZXNvbHZlIGFuIEludGVyZmFjZVN5bWJvbCB0aGF0IGhhcyBubyByZWdpc3RyYXRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblBhcmFtdHlwZXMgPSBESS5nZXRPckNyZWF0ZUFubm90YXRpb25QYXJhbVR5cGVzKHRhcmdldCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uUGFyYW10eXBlc1tpbmRleF0gPSBJbnRlcmZhY2U7XG4gICAgICAgIH07XG4gICAgICAgIEludGVyZmFjZS4kaXNJbnRlcmZhY2UgPSB0cnVlO1xuICAgICAgICBJbnRlcmZhY2UuZnJpZW5kbHlOYW1lID0gZnJpZW5kbHlOYW1lID09IG51bGwgPyAnKGFub255bW91cyknIDogZnJpZW5kbHlOYW1lO1xuICAgICAgICBpZiAoY29uZmlndXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIEludGVyZmFjZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWd1cmUobmV3IFJlc29sdmVyQnVpbGRlcihjb250YWluZXIsIGtleSA/PyBJbnRlcmZhY2UpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgSW50ZXJmYWNlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gYEludGVyZmFjZVN5bWJvbDwke0ludGVyZmFjZS5mcmllbmRseU5hbWV9PmA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBpbmplY3QoLi4uZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ251bWJlcicpIHsgLy8gSXQncyBhIHBhcmFtZXRlciBkZWNvcmF0b3IuXG4gICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblBhcmFtdHlwZXMgPSBESS5nZXRPckNyZWF0ZUFubm90YXRpb25QYXJhbVR5cGVzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVwID0gZGVwZW5kZW5jaWVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChkZXAgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uUGFyYW10eXBlc1tkZXNjcmlwdG9yXSA9IGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkpIHsgLy8gSXQncyBhIHByb3BlcnR5IGRlY29yYXRvci4gTm90IHN1cHBvcnRlZCBieSB0aGUgY29udGFpbmVyIHdpdGhvdXQgcGx1Z2lucy5cbiAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uUGFyYW10eXBlcyA9IERJLmdldE9yQ3JlYXRlQW5ub3RhdGlvblBhcmFtVHlwZXModGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXAgPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGRlcCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25QYXJhbXR5cGVzW2tleV0gPSBkZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcikgeyAvLyBJdCdzIGEgZnVuY3Rpb24gZGVjb3JhdG9yIChub3QgYSBDbGFzcyBjb25zdHJ1Y3RvcilcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblBhcmFtdHlwZXMgPSBESS5nZXRPckNyZWF0ZUFubm90YXRpb25QYXJhbVR5cGVzKGZuKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcCA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uUGFyYW10eXBlc1tpXSA9IGRlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBJdCdzIGEgY2xhc3MgZGVjb3JhdG9yLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25QYXJhbXR5cGVzID0gREkuZ2V0T3JDcmVhdGVBbm5vdGF0aW9uUGFyYW1UeXBlcyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGxldCBkZXA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25QYXJhbXR5cGVzW2ldID0gZGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBgdGFyZ2V0YCBjbGFzcyBhcyBhIHRyYW5zaWVudCBkZXBlbmRlbmN5OyBlYWNoIHRpbWUgdGhlIGRlcGVuZGVuY3kgaXMgcmVzb2x2ZWRcbiAgICAgKiBhIG5ldyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGNsYXNzIC8gY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgYXMgdHJhbnNpZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIGNsYXNzLCB3aXRoIGEgc3RhdGljIGByZWdpc3RlcmAgbWV0aG9kIHRoYXQgdGFrZXMgYSBjb250YWluZXIgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIHJlc29sdmVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgYGBgdHNcbiAgICAgKiAvLyBPbiBhbiBleGlzdGluZyBjbGFzc1xuICAgICAqIGNsYXNzIEZvbyB7IH1cbiAgICAgKiBESS50cmFuc2llbnQoRm9vKTtcbiAgICAgKlxuICAgICAqIC8vIElubGluZSBkZWNsYXJhdGlvblxuICAgICAqIGNvbnN0IEZvbyA9IERJLnRyYW5zaWVudChjbGFzcyB7IH0pO1xuICAgICAqIC8vIEZvbyBpcyBub3cgc3Ryb25nbHkgdHlwZWQgd2l0aCByZWdpc3RlclxuICAgICAqIEZvby5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRyYW5zaWVudCh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb24gPSBSZWdpc3RyYXRpb24udHJhbnNpZW50KHRhcmdldCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RyYXRpb24ucmVnaXN0ZXIoY29udGFpbmVyLCB0YXJnZXQpO1xuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQucmVnaXN0ZXJJblJlcXVlc3RvciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBgdGFyZ2V0YCBjbGFzcyBhcyBhIHNpbmdsZXRvbiBkZXBlbmRlbmN5OyB0aGUgY2xhc3Mgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgb25jZS4gRWFjaFxuICAgICAqIGNvbnNlY3V0aXZlIHRpbWUgdGhlIGRlcGVuZGVuY3kgaXMgcmVzb2x2ZWQsIHRoZSBzYW1lIGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGNsYXNzIC8gY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgYXMgYSBzaW5nbGV0b24uXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgY2xhc3MsIHdpdGggYSBzdGF0aWMgYHJlZ2lzdGVyYCBtZXRob2QgdGhhdCB0YWtlcyBhIGNvbnRhaW5lciBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgcmVzb2x2ZXIuXG4gICAgICogQGV4YW1wbGUgYGBgdHNcbiAgICAgKiAvLyBPbiBhbiBleGlzdGluZyBjbGFzc1xuICAgICAqIGNsYXNzIEZvbyB7IH1cbiAgICAgKiBESS5zaW5nbGV0b24oRm9vKTtcbiAgICAgKlxuICAgICAqIC8vIElubGluZSBkZWNsYXJhdGlvblxuICAgICAqIGNvbnN0IEZvbyA9IERJLnNpbmdsZXRvbihjbGFzcyB7IH0pO1xuICAgICAqIC8vIEZvbyBpcyBub3cgc3Ryb25nbHkgdHlwZWQgd2l0aCByZWdpc3RlclxuICAgICAqIEZvby5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNpbmdsZXRvbih0YXJnZXQsIG9wdGlvbnMgPSBkZWZhdWx0U2luZ2xldG9uT3B0aW9ucykge1xuICAgICAgICB0YXJnZXQucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24odGFyZ2V0LCB0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbi5yZWdpc3Rlcihjb250YWluZXIsIHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5yZWdpc3RlckluUmVxdWVzdG9yID0gb3B0aW9ucy5zY29wZWQ7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgSUNvbnRhaW5lciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUNvbnRhaW5lcicpO1xuZXhwb3J0IGNvbnN0IElTZXJ2aWNlTG9jYXRvciA9IElDb250YWluZXI7XG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlcihnZXR0ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBESS5pbmplY3QocmVzb2x2ZXIpKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXNvbHZlci4kaXNSZXNvbHZlciA9IHRydWU7XG4gICAgICAgIHJlc29sdmVyLnJlc29sdmUgPSBmdW5jdGlvbiAoaGFuZGxlciwgcmVxdWVzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0dGVyKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgIH07XG59XG5leHBvcnQgY29uc3QgaW5qZWN0ID0gREkuaW5qZWN0O1xuZnVuY3Rpb24gdHJhbnNpZW50RGVjb3JhdG9yKHRhcmdldCkge1xuICAgIHJldHVybiBESS50cmFuc2llbnQodGFyZ2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2llbnQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldCA9PSBudWxsID8gdHJhbnNpZW50RGVjb3JhdG9yIDogdHJhbnNpZW50RGVjb3JhdG9yKHRhcmdldCk7XG59XG5jb25zdCBkZWZhdWx0U2luZ2xldG9uT3B0aW9ucyA9IHsgc2NvcGVkOiBmYWxzZSB9O1xuZnVuY3Rpb24gc2luZ2xldG9uRGVjb3JhdG9yKHRhcmdldCkge1xuICAgIHJldHVybiBESS5zaW5nbGV0b24odGFyZ2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGV0b24odGFyZ2V0T3JPcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRPck9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIERJLnNpbmdsZXRvbih0YXJnZXRPck9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCR0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIERJLnNpbmdsZXRvbigkdGFyZ2V0LCB0YXJnZXRPck9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBbGxSZXNvbHZlcihnZXR0ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgc2VhcmNoQW5jZXN0b3JzKSB7XG4gICAgICAgIHNlYXJjaEFuY2VzdG9ycyA9ICEhc2VhcmNoQW5jZXN0b3JzO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBESS5pbmplY3QocmVzb2x2ZXIpKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXNvbHZlci4kaXNSZXNvbHZlciA9IHRydWU7XG4gICAgICAgIHJlc29sdmVyLnJlc29sdmUgPSBmdW5jdGlvbiAoaGFuZGxlciwgcmVxdWVzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0dGVyKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yLCBzZWFyY2hBbmNlc3RvcnMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBhbGwgPSBjcmVhdGVBbGxSZXNvbHZlcigoa2V5LCBoYW5kbGVyLCByZXF1ZXN0b3IsIHNlYXJjaEFuY2VzdG9ycykgPT4gcmVxdWVzdG9yLmdldEFsbChrZXksIHNlYXJjaEFuY2VzdG9ycykpO1xuLyoqXG4gKiBMYXppbHkgaW5qZWN0IGEgZGVwZW5kZW5jeSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgW1tgS2V5YF1dIGlzIHByZXNlbnQgYXQgdGhlIHRpbWUgb2YgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBZb3UgbmVlZCB0byBtYWtlIHlvdXIgYXJndW1lbnQgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHR5cGUsIGZvciBleGFtcGxlXG4gKiBgYGB0c1xuICogY2xhc3MgRm9vIHtcbiAqICAgY29uc3RydWN0b3IoIEBsYXp5KCdyYW5kb20nKSBwdWJsaWMgcmFuZG9tOiAoKSA9PiBudW1iZXIgKVxuICogfVxuICogY29uc3QgZm9vID0gY29udGFpbmVyLmdldChGb28pOyAvLyBpbnN0YW5jZW9mIEZvb1xuICogZm9vLnJhbmRvbSgpOyAvLyB0aHJvd3NcbiAqIGBgYFxuICogd291bGQgdGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2UgeW91IGhhdmVuJ3QgcmVnaXN0ZXJlZCBgJ3JhbmRvbSdgIGJlZm9yZSBjYWxsaW5nIHRoZSBtZXRob2QuIFRoaXMsIHdvdWxkIGdpdmUgeW91IGFcbiAqIG5ldyBbWydNYXRoLnJhbmRvbSgpJ11dIG51bWJlciBlYWNoIHRpbWUuXG4gKiBgYGB0c1xuICogY2xhc3MgRm9vIHtcbiAqICAgY29uc3RydWN0b3IoIEBsYXp5KCdyYW5kb20nKSBwdWJsaWMgcmFuZG9tOiAoKSA9PiByYW5kb20gKVxuICogfVxuICogY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5jYWxsYmFjaygncmFuZG9tJywgTWF0aC5yYW5kb20gKSk7XG4gKiBjb250YWluZXIuZ2V0KEZvbykucmFuZG9tKCk7IC8vIHNvbWUgcmFuZG9tIG51bWJlclxuICogY29udGFpbmVyLmdldChGb28pLnJhbmRvbSgpOyAvLyBhbm90aGVyIHJhbmRvbSBudW1iZXJcbiAqIGBgYFxuICogYEBsYXp5YCBkb2VzIG5vdCBtYW5hZ2UgdGhlIGxpZmVjeWNsZSBvZiB0aGUgdW5kZXJseWluZyBrZXkuIElmIHlvdSB3YW50IGEgc2luZ2xldG9uLCB5b3UgaGF2ZSB0byByZWdpc3RlciBhcyBhXG4gKiBgc2luZ2xldG9uYCwgYHRyYW5zaWVudGAgd291bGQgYWxzbyBiZWhhdmUgYXMgeW91IHdvdWxkIGV4cGVjdCwgcHJvdmlkaW5nIHlvdSBhIG5ldyBpbnN0YW5jZSBlYWNoIHRpbWUuXG4gKlxuICogLSBAcGFyYW0ga2V5IFtbYEtleWBdXVxuICogc2VlIHsgQGxpbmsgREkuY3JlYXRlSW50ZXJmYWNlIH0gb24gaW50ZXJhY3Rpb25zIHdpdGggaW50ZXJmYWNlc1xuICovXG5leHBvcnQgY29uc3QgbGF6eSA9IGNyZWF0ZVJlc29sdmVyKChrZXksIGhhbmRsZXIsIHJlcXVlc3RvcikgPT4ge1xuICAgIHJldHVybiAoKSA9PiByZXF1ZXN0b3IuZ2V0KGtleSk7XG59KTtcbi8qKlxuICogQWxsb3dzIHlvdSB0byBvcHRpb25hbGx5IGluamVjdCBhIGRlcGVuZGVuY3kgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIFtbYEtleWBdXSBpcyBwcmVzZW50LCBmb3IgZXhhbXBsZVxuICogYGBgdHNcbiAqIGNsYXNzIEZvbyB7XG4gKiAgIGNvbnN0cnVjdG9yKCBAaW5qZWN0KCdteXN0cmluZycpIHB1YmxpYyBzdHI6IHN0cmluZyA9ICdzb21lc3RyaW5nJyApXG4gKiB9XG4gKiBjb250YWluZXIuZ2V0KEZvbyk7IC8vIHRocm93c1xuICogYGBgXG4gKiB3b3VsZCBmYWlsXG4gKiBgYGB0c1xuICogY2xhc3MgRm9vIHtcbiAqICAgY29uc3RydWN0b3IoIEBvcHRpb25hbCgnbXlzdHJpbmcnKSBwdWJsaWMgc3RyOiBzdHJpbmcgPSAnc29tZXN0cmluZycgKVxuICogfVxuICogY29udGFpbmVyLmdldChGb28pLnN0ciAvLyBzb21lc3RyaW5nXG4gKiBgYGBcbiAqIGlmIHlvdSB1c2UgaXQgd2l0aG91dCBhIGRlZmF1bHQgaXQgd2lsbCBpbmplY3QgYHVuZGVmaW5lZGAsIHNvIHJlbWJlciB0byBtYXJrIHlvdXIgaW5wdXQgdHlwZSBhc1xuICogcG9zc2libHkgYHVuZGVmaW5lZGAhXG4gKlxuICogLSBAcGFyYW0ga2V5OiBbW2BLZXlgXV1cbiAqXG4gKiBzZWUgeyBAbGluayBESS5jcmVhdGVJbnRlcmZhY2UgfSBvbiBpbnRlcmFjdGlvbnMgd2l0aCBpbnRlcmZhY2VzXG4gKi9cbmV4cG9ydCBjb25zdCBvcHRpb25hbCA9IGNyZWF0ZVJlc29sdmVyKChrZXksIGhhbmRsZXIsIHJlcXVlc3RvcikgPT4ge1xuICAgIGlmIChyZXF1ZXN0b3IuaGFzKGtleSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Rvci5nZXQoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufSk7XG4vKipcbiAqIGlnbm9yZSB0ZWxscyB0aGUgY29udGFpbmVyIG5vdCB0byB0cnkgdG8gaW5qZWN0IGEgZGVwZW5kZW5jeVxuICovXG5leHBvcnQgZnVuY3Rpb24gaWdub3JlKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICBESS5pbmplY3QoaWdub3JlKSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbn1cbmlnbm9yZS4kaXNSZXNvbHZlciA9IHRydWU7XG5pZ25vcmUucmVzb2x2ZSA9ICgpID0+IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZUZvclNjb3BlID0gY3JlYXRlUmVzb2x2ZXIoKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjcmVhdGVOZXdJbnN0YW5jZShrZXksIGhhbmRsZXIpO1xuICAgIGNvbnN0IGluc3RhbmNlUHJvdmlkZXIgPSBuZXcgSW5zdGFuY2VQcm92aWRlcihTdHJpbmcoa2V5KSk7XG4gICAgaW5zdGFuY2VQcm92aWRlci5wcmVwYXJlKGluc3RhbmNlKTtcbiAgICByZXF1ZXN0b3IucmVnaXN0ZXJSZXNvbHZlcihrZXksIGluc3RhbmNlUHJvdmlkZXIsIHRydWUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn0pO1xuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlT2YgPSBjcmVhdGVSZXNvbHZlcigoa2V5LCBoYW5kbGVyLCBfcmVxdWVzdG9yKSA9PiBjcmVhdGVOZXdJbnN0YW5jZShrZXksIGhhbmRsZXIpKTtcbmZ1bmN0aW9uIGNyZWF0ZU5ld0luc3RhbmNlKGtleSwgaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyLmdldEZhY3Rvcnkoa2V5KS5jb25zdHJ1Y3QoaGFuZGxlcik7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgdmFyIFJlc29sdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKFJlc29sdmVyU3RyYXRlZ3kpIHtcbiAgICBSZXNvbHZlclN0cmF0ZWd5W1Jlc29sdmVyU3RyYXRlZ3lbXCJpbnN0YW5jZVwiXSA9IDBdID0gXCJpbnN0YW5jZVwiO1xuICAgIFJlc29sdmVyU3RyYXRlZ3lbUmVzb2x2ZXJTdHJhdGVneVtcInNpbmdsZXRvblwiXSA9IDFdID0gXCJzaW5nbGV0b25cIjtcbiAgICBSZXNvbHZlclN0cmF0ZWd5W1Jlc29sdmVyU3RyYXRlZ3lbXCJ0cmFuc2llbnRcIl0gPSAyXSA9IFwidHJhbnNpZW50XCI7XG4gICAgUmVzb2x2ZXJTdHJhdGVneVtSZXNvbHZlclN0cmF0ZWd5W1wiY2FsbGJhY2tcIl0gPSAzXSA9IFwiY2FsbGJhY2tcIjtcbiAgICBSZXNvbHZlclN0cmF0ZWd5W1Jlc29sdmVyU3RyYXRlZ3lbXCJhcnJheVwiXSA9IDRdID0gXCJhcnJheVwiO1xuICAgIFJlc29sdmVyU3RyYXRlZ3lbUmVzb2x2ZXJTdHJhdGVneVtcImFsaWFzXCJdID0gNV0gPSBcImFsaWFzXCI7XG59KShSZXNvbHZlclN0cmF0ZWd5IHx8IChSZXNvbHZlclN0cmF0ZWd5ID0ge30pKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBzdHJhdGVneSwgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlc29sdmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgJGlzUmVzb2x2ZXIoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKGtleSB8fCB0aGlzLmtleSwgdGhpcyk7XG4gICAgfVxuICAgIHJlc29sdmUoaGFuZGxlciwgcmVxdWVzdG9yKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIGluc3RhbmNlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY2FzZSAxIC8qIHNpbmdsZXRvbiAqLzoge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN5Y2xpYyBkZXBlbmRlbmN5IGZvdW5kOiAke3RoaXMuc3RhdGUubmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBoYW5kbGVyLmdldEZhY3RvcnkodGhpcy5zdGF0ZSkuY29uc3RydWN0KHJlcXVlc3Rvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJhdGVneSA9IDAgLyogaW5zdGFuY2UgKi87XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMiAvKiB0cmFuc2llbnQgKi86IHtcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgY3JlYXRlIHRyYW5zaWVudHMgZnJvbSB0aGUgcmVxdWVzdGluZyBjb250YWluZXJcbiAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gaGFuZGxlci5nZXRGYWN0b3J5KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChmYWN0b3J5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb2x2ZXIgZm9yICR7U3RyaW5nKHRoaXMua2V5KX0gcmV0dXJuZWQgYSBudWxsIGZhY3RvcnlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkuY29uc3RydWN0KHJlcXVlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDMgLyogY2FsbGJhY2sgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUoaGFuZGxlciwgcmVxdWVzdG9yLCB0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgNCAvKiBhcnJheSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVswXS5yZXNvbHZlKGhhbmRsZXIsIHJlcXVlc3Rvcik7XG4gICAgICAgICAgICBjYXNlIDUgLyogYWxpYXMgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Rvci5nZXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNvbHZlciBzdHJhdGVneSBzcGVjaWZpZWQ6ICR7dGhpcy5zdHJhdGVneX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RmFjdG9yeShjb250YWluZXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogc2luZ2xldG9uICovOlxuICAgICAgICAgICAgY2FzZSAyIC8qIHRyYW5zaWVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmdldEZhY3RvcnkodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBjYXNlIDUgLyogYWxpYXMgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5nZXRSZXNvbHZlcih0aGlzLnN0YXRlKT8uZ2V0RmFjdG9yeT8uKGNvbnRhaW5lcikgPz8gbnVsbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb250YWluZXJHZXRLZXkoZCkge1xuICAgIHJldHVybiB0aGlzLmdldChkKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUluc3RhbmNlKGluc3QsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0oaW5zdCk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoVHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHRoaXMuVHlwZSA9IFR5cGU7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVycyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdChjb250YWluZXIsIGR5bmFtaWNEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlO1xuICAgICAgICBpZiAoZHluYW1pY0RlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IG5ldyB0aGlzLlR5cGUoLi4udGhpcy5kZXBlbmRlbmNpZXMubWFwKGNvbnRhaW5lckdldEtleSwgY29udGFpbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IG5ldyB0aGlzLlR5cGUoLi4udGhpcy5kZXBlbmRlbmNpZXMubWFwKGNvbnRhaW5lckdldEtleSwgY29udGFpbmVyKSwgLi4uZHluYW1pY0RlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcnMucmVkdWNlKHRyYW5zZm9ybUluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyVHJhbnNmb3JtZXIodHJhbnNmb3JtZXIpIHtcbiAgICAgICAgKHRoaXMudHJhbnNmb3JtZXJzID8/ICh0aGlzLnRyYW5zZm9ybWVycyA9IFtdKSkucHVzaCh0cmFuc2Zvcm1lcik7XG4gICAgfVxufVxuY29uc3QgY29udGFpbmVyUmVzb2x2ZXIgPSB7XG4gICAgJGlzUmVzb2x2ZXI6IHRydWUsXG4gICAgcmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RvcjtcbiAgICB9XG59O1xuZnVuY3Rpb24gaXNSZWdpc3RyeShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iai5yZWdpc3RlciA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzU2VsZlJlZ2lzdHJ5KG9iaikge1xuICAgIHJldHVybiBpc1JlZ2lzdHJ5KG9iaikgJiYgdHlwZW9mIG9iai5yZWdpc3RlckluUmVxdWVzdG9yID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBpc1JlZ2lzdGVySW5SZXF1ZXN0ZXIob2JqKSB7XG4gICAgcmV0dXJuIGlzU2VsZlJlZ2lzdHJ5KG9iaikgJiYgb2JqLnJlZ2lzdGVySW5SZXF1ZXN0b3I7XG59XG5mdW5jdGlvbiBpc0NsYXNzKG9iaikge1xuICAgIHJldHVybiBvYmoucHJvdG90eXBlICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBpc1Jlc291cmNlS2V5KGtleSkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuaW5kZXhPZignOicpID4gMDtcbn1cbmNvbnN0IEluc3RyaW5zaWNUeXBlTmFtZXMgPSBuZXcgU2V0KFtcbiAgICAnQXJyYXknLFxuICAgICdBcnJheUJ1ZmZlcicsXG4gICAgJ0Jvb2xlYW4nLFxuICAgICdEYXRhVmlldycsXG4gICAgJ0RhdGUnLFxuICAgICdFcnJvcicsXG4gICAgJ0V2YWxFcnJvcicsXG4gICAgJ0Zsb2F0MzJBcnJheScsXG4gICAgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJyxcbiAgICAnSW50OEFycmF5JyxcbiAgICAnSW50MTZBcnJheScsXG4gICAgJ0ludDMyQXJyYXknLFxuICAgICdNYXAnLFxuICAgICdOdW1iZXInLFxuICAgICdPYmplY3QnLFxuICAgICdQcm9taXNlJyxcbiAgICAnUmFuZ2VFcnJvcicsXG4gICAgJ1JlZmVyZW5jZUVycm9yJyxcbiAgICAnUmVnRXhwJyxcbiAgICAnU2V0JyxcbiAgICAnU2hhcmVkQXJyYXlCdWZmZXInLFxuICAgICdTdHJpbmcnLFxuICAgICdTeW50YXhFcnJvcicsXG4gICAgJ1R5cGVFcnJvcicsXG4gICAgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsXG4gICAgJ1VpbnQxNkFycmF5JyxcbiAgICAnVWludDMyQXJyYXknLFxuICAgICdVUklFcnJvcicsXG4gICAgJ1dlYWtNYXAnLFxuICAgICdXZWFrU2V0Jyxcbl0pO1xuY29uc3QgZmFjdG9yeUtleSA9ICdkaTpmYWN0b3J5JztcbmNvbnN0IGZhY3RvcnlBbm5vdGF0aW9uS2V5ID0gUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IoZmFjdG9yeUtleSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNvbmZpZykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZVJlc29sdmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlUmVzb2x2ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcmVudC5yb290O1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcmllcyA9IHBhcmVudC5mYWN0b3JpZXM7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmluaGVyaXRQYXJlbnRSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlUmVzb2x2ZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBwYXJlbnQucmVzb3VyY2VSZXNvbHZlcnMsIHRoaXMucm9vdC5yZXNvdXJjZVJlc29sdmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlUmVzb2x2ZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLnJvb3QucmVzb3VyY2VSZXNvbHZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb2x2ZXJzLnNldChJQ29udGFpbmVyLCBjb250YWluZXJSZXNvbHZlcik7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID09PSBudWxsID8gMCA6IHRoaXMucGFyZW50LmRlcHRoICsgMTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoLi4ucGFyYW1zKSB7XG4gICAgICAgIGlmICgrK3RoaXMucmVnaXN0ZXJEZXB0aCA9PT0gMTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBhdXRvcmVnaXN0ZXIgZGVwZW5kZW5jeTogWyR7cGFyYW1zLm1hcChTdHJpbmcpfV1gKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGNoYW5nZSB0byByZXBvcnRlci5lcnJvciBhbmQgYWRkIHZhcmlvdXMgcG9zc2libGUgY2F1c2VzIGluIGRlc2NyaXB0aW9uLlxuICAgICAgICAgICAgLy8gTW9zdCBsaWtlbHkgY2F1c2UgaXMgdHJ5aW5nIHRvIHJlZ2lzdGVyIGEgcGxhaW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaGF2ZSBhXG4gICAgICAgICAgICAvLyByZWdpc3RlciBtZXRob2QgYW5kIGlzIG5vdCBhIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgIGxldCBrZXlzO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGxldCBqO1xuICAgICAgICBsZXQgamo7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUmVnaXN0cnkoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoUHJvdG9jb2wucmVzb3VyY2UuaGFzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmcyA9IFByb3RvY29sLnJlc291cmNlLmdldEFsbChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciB0aGUgdmVyeSBjb21tb24gY2FzZVxuICAgICAgICAgICAgICAgICAgICBkZWZzWzBdLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gZGVmcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgbGVuOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZnNbZF0ucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NsYXNzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihjdXJyZW50LCBjdXJyZW50KS5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICBqaiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnRba2V5c1tqXV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCByZW1vdmUgdGhpcyBpZi1icmFuY2ggYW5kIGNhbGwgdGhpcy5yZWdpc3RlciBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSBleHRyYSBjaGVjayBpcyBqdXN0IGEgcGVyZiB0d2VhayB0byBjcmVhdGUgZmV3ZXIgdW5uZWNlc3NhcnkgYXJyYXlzIGJ5IHRoZSBzcHJlYWQgb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVnaXN0cnkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC0tdGhpcy5yZWdpc3RlckRlcHRoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVnaXN0ZXJSZXNvbHZlcihrZXksIHJlc29sdmVyLCBpc0Rpc3Bvc2FibGUgPSBmYWxzZSkge1xuICAgICAgICB2YWxpZGF0ZUtleShrZXkpO1xuICAgICAgICBjb25zdCByZXNvbHZlcnMgPSB0aGlzLnJlc29sdmVycztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZXJzLmdldChrZXkpO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVycy5zZXQoa2V5LCByZXNvbHZlcik7XG4gICAgICAgICAgICBpZiAoaXNSZXNvdXJjZUtleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZVJlc29sdmVyc1trZXldID0gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzb2x2ZXIgJiYgcmVzdWx0LnN0cmF0ZWd5ID09PSA0IC8qIGFycmF5ICovKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhdGUucHVzaChyZXNvbHZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlcnMuc2V0KGtleSwgbmV3IFJlc29sdmVyKGtleSwgNCAvKiBhcnJheSAqLywgW3Jlc3VsdCwgcmVzb2x2ZXJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlUmVzb2x2ZXJzLmFkZChyZXNvbHZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZGVyZWdpc3RlclJlc29sdmVyRm9yPEsgZXh0ZW5kcyBLZXksIFQgPSBLPihrZXk6IEspOiB2b2lkIHtcbiAgICAvLyAgIC8vIGNvbnN0IGNvbnNvbGUgPSAgKGdsb2JhbFRoaXMgYXMgYW55KS5jb25zb2xlO1xuICAgIC8vICAgLy8gY29uc29sZS5ncm91cChcImRlcmVnaXN0ZXJSZXNvbHZlckZvclwiKTtcbiAgICAvLyAgIHZhbGlkYXRlS2V5KGtleSk7XG4gICAgLy8gICBsZXQgY3VycmVudDogQ29udGFpbmVyID0gdGhpcztcbiAgICAvLyAgIGxldCByZXNvbHZlcjogSVJlc29sdmVyIHwgdW5kZWZpbmVkO1xuICAgIC8vICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgIC8vICAgICByZXNvbHZlciA9IGN1cnJlbnQucmVzb2x2ZXJzLmdldChrZXkpO1xuICAgIC8vICAgICBpZiAocmVzb2x2ZXIgIT0gbnVsbCkgeyBicmVhazsgfVxuICAgIC8vICAgICBpZiAoY3VycmVudC5wYXJlbnQgPT0gbnVsbCkgeyByZXR1cm47IH1cbiAgICAvLyAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIC8vICAgfVxuICAgIC8vICAgaWYgKHJlc29sdmVyID09PSB2b2lkIDApIHsgcmV0dXJuOyB9XG4gICAgLy8gICBpZiAocmVzb2x2ZXIgaW5zdGFuY2VvZiBSZXNvbHZlciAmJiByZXNvbHZlci5zdHJhdGVneSA9PT0gUmVzb2x2ZXJTdHJhdGVneS5hcnJheSkge1xuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXJlZ2lzdGVyIGEgcmVzb2x2ZXIgd2l0aCBhcnJheSBzdHJhdGVneScpO1xuICAgIC8vICAgfVxuICAgIC8vICAgaWYgKHRoaXMuZGlzcG9zYWJsZVJlc29sdmVycy5oYXMocmVzb2x2ZXIgYXMgSURpc3Bvc2FibGVSZXNvbHZlcjxUPikpIHtcbiAgICAvLyAgICAgKHJlc29sdmVyIGFzIElEaXNwb3NhYmxlUmVzb2x2ZXI8VD4pLmRpc3Bvc2UoKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGlmIChpc1Jlc291cmNlS2V5KGtleSkpIHtcbiAgICAvLyAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgIC8vICAgICBkZWxldGUgdGhpcy5yZXNvdXJjZVJlc29sdmVyc1trZXldO1xuICAgIC8vICAgfVxuICAgIC8vICAgLy8gY29uc29sZS5sb2coYEJFRk9SRSBkZWxldGUgJHtBcnJheS5mcm9tKGN1cnJlbnQucmVzb2x2ZXJzLmtleXMoKSkubWFwKChrKSA9PiBrLnRvU3RyaW5nKCkpfWApO1xuICAgIC8vICAgY3VycmVudC5yZXNvbHZlcnMuZGVsZXRlKGtleSk7XG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyhgQUZURVIgZGVsZXRlICR7QXJyYXkuZnJvbShjdXJyZW50LnJlc29sdmVycy5rZXlzKCkpLm1hcCgoaykgPT4gay50b1N0cmluZygpKX1gKTtcbiAgICAvLyAgIC8vIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAvLyB9XG4gICAgcmVnaXN0ZXJUcmFuc2Zvcm1lcihrZXksIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gdGhpcy5nZXRSZXNvbHZlcihrZXkpO1xuICAgICAgICBpZiAocmVzb2x2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlci5nZXRGYWN0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gcmVzb2x2ZXIuZ2V0RmFjdG9yeSh0aGlzKTtcbiAgICAgICAgICAgIGlmIChmYWN0b3J5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIHR5cGUgY2FzdCBpcyBhIGJpdCBvZiBhIGhhY2t5IG9uZSwgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgZHVwbGljaXR5IG9mIElSZXNvbHZlckxpa2UuXG4gICAgICAgICAgICAvLyBQcm9ibGVtIGlzIHRoYXQgdGhhdCBpbnRlcmZhY2UncyB0eXBlIGFyZyBjYW4gYmUgb2YgdHlwZSBLZXksIGJ1dCB0aGUgZ2V0RmFjdG9yeSBtZXRob2Qgb25seSB3b3JrcyBvblxuICAgICAgICAgICAgLy8gdHlwZSBDb25zdHJ1Y3RhYmxlLiBTbyB0aGUgcmV0dXJuIHR5cGUgb2YgdGhhdCBvcHRpb25hbCBtZXRob2QgaGFzIHRoaXMgYWRkaXRpb25hbCBjb25zdHJhaW50LCB3aGljaFxuICAgICAgICAgICAgLy8gc2VlbXMgdG8gY29uZnVzZSB0aGUgdHlwZSBjaGVja2VyLlxuICAgICAgICAgICAgZmFjdG9yeS5yZWdpc3RlclRyYW5zZm9ybWVyKHRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0UmVzb2x2ZXIoa2V5LCBhdXRvUmVnaXN0ZXIgPSB0cnVlKSB7XG4gICAgICAgIHZhbGlkYXRlS2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkucmVzb2x2ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IHJlc29sdmVyO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlciA9IGN1cnJlbnQucmVzb2x2ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKGlzUmVnaXN0ZXJJblJlcXVlc3RlcihrZXkpKSA/IHRoaXMgOiBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b1JlZ2lzdGVyID8gdGhpcy5qaXRSZWdpc3RlcihrZXksIGhhbmRsZXIpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBoYXMoa2V5LCBzZWFyY2hBbmNlc3RvcnMgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcnMuaGFzKGtleSlcbiAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgOiBzZWFyY2hBbmNlc3RvcnMgJiYgdGhpcy5wYXJlbnQgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdGhpcy5wYXJlbnQuaGFzKGtleSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHZhbGlkYXRlS2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkuJGlzUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkucmVzb2x2ZSh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIGxldCByZXNvbHZlcjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzb2x2ZXIgPSBjdXJyZW50LnJlc29sdmVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IChpc1JlZ2lzdGVySW5SZXF1ZXN0ZXIoa2V5KSkgPyB0aGlzIDogY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSB0aGlzLmppdFJlZ2lzdGVyKGtleSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGN1cnJlbnQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZShjdXJyZW50LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIGtleTogJHtrZXl9YCk7XG4gICAgfVxuICAgIGdldEFsbChrZXksIHNlYXJjaEFuY2VzdG9ycyA9IGZhbHNlKSB7XG4gICAgICAgIHZhbGlkYXRlS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RvciA9IHRoaXM7XG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVxdWVzdG9yO1xuICAgICAgICBsZXQgcmVzb2x2ZXI7XG4gICAgICAgIGlmIChzZWFyY2hBbmNlc3RvcnMpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHV0aW9ucyA9IGVtcHR5QXJyYXk7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSBjdXJyZW50LnJlc29sdmVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9ucyA9IHJlc29sdXRpb25zLmNvbmNhdChidWlsZEFsbFJlc3BvbnNlKHJlc29sdmVyLCBjdXJyZW50LCByZXF1ZXN0b3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVyID0gY3VycmVudC5yZXNvbHZlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQWxsUmVzcG9uc2UocmVzb2x2ZXIsIGN1cnJlbnQsIHJlcXVlc3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgIH1cbiAgICBnZXRGYWN0b3J5KFR5cGUpIHtcbiAgICAgICAgbGV0IGZhY3RvcnkgPSB0aGlzLmZhY3Rvcmllcy5nZXQoVHlwZSk7XG4gICAgICAgIGlmIChmYWN0b3J5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmIChpc05hdGl2ZUZ1bmN0aW9uKFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1R5cGUubmFtZX0gaXMgYSBuYXRpdmUgZnVuY3Rpb24gYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgc2FmZWx5IGNvbnN0cnVjdGVkIGJ5IERJLiBJZiB0aGlzIGlzIGludGVudGlvbmFsLCBwbGVhc2UgdXNlIGEgY2FsbGJhY2sgb3IgY2FjaGVkQ2FsbGJhY2sgcmVzb2x2ZXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZhY3Rvcmllcy5zZXQoVHlwZSwgZmFjdG9yeSA9IG5ldyBGYWN0b3J5KFR5cGUsIERJLmdldERlcGVuZGVuY2llcyhUeXBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH1cbiAgICByZWdpc3RlckZhY3Rvcnkoa2V5LCBmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZmFjdG9yaWVzLnNldChrZXksIGZhY3RvcnkpO1xuICAgIH1cbiAgICBjcmVhdGVDaGlsZChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwICYmIHRoaXMuY29uZmlnLmluaGVyaXRQYXJlbnRSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZyA9PT0gQ29udGFpbmVyQ29uZmlndXJhdGlvbi5ERUZBVUxUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIodGhpcywgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIodGhpcywgQ29udGFpbmVyQ29uZmlndXJhdGlvbi5mcm9tKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBpbmhlcml0UGFyZW50UmVzb3VyY2VzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcih0aGlzLCBDb250YWluZXJDb25maWd1cmF0aW9uLmZyb20oY29uZmlnID8/IHRoaXMuY29uZmlnKSk7XG4gICAgfVxuICAgIGRpc3Bvc2VSZXNvbHZlcnMoKSB7XG4gICAgICAgIGNvbnN0IGRpc3Bvc2FibGVzID0gQXJyYXkuZnJvbSh0aGlzLmRpc3Bvc2FibGVSZXNvbHZlcnMpO1xuICAgICAgICB3aGlsZSAoZGlzcG9zYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGlzcG9zYWJsZXMucG9wKCk/LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kKGtpbmQsIG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2luZC5rZXlGcm9tKG5hbWUpO1xuICAgICAgICBsZXQgcmVzb2x2ZXIgPSB0aGlzLnJlc291cmNlUmVzb2x2ZXJzW2tleV07XG4gICAgICAgIGlmIChyZXNvbHZlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXNvbHZlciA9IHRoaXMucm9vdC5yZXNvdXJjZVJlc29sdmVyc1trZXldO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIuZ2V0RmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IHJlc29sdmVyLmdldEZhY3RvcnkodGhpcyk7XG4gICAgICAgICAgICBpZiAoZmFjdG9yeSA9PT0gbnVsbCB8fCBmYWN0b3J5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBNZXRhZGF0YS5nZXRPd24oa2luZC5uYW1lLCBmYWN0b3J5LlR5cGUpO1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIG1heSB3YW50IHRvIGxvZyBhIHdhcm5pbmcgaGVyZSwgb3IgZXZlbiB0aHJvdy4gVGhpcyB3b3VsZCBoYXBwZW4gaWYgYSBkZXBlbmRlbmN5IGlzIHJlZ2lzdGVyZWQgd2l0aCBhIHJlc291cmNlLWxpa2Uga2V5XG4gICAgICAgICAgICAgICAgLy8gYnV0IGRvZXMgbm90IGFjdHVhbGx5IGhhdmUgYSBkZWZpbml0aW9uIGFzc29jaWF0ZWQgdmlhIHRoZSB0eXBlJ3MgbWV0YWRhdGEuIFRoYXQgKnNob3VsZCogZ2VuZXJhbGx5IG5vdCBoYXBwZW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3JlYXRlKGtpbmQsIG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2luZC5rZXlGcm9tKG5hbWUpO1xuICAgICAgICBsZXQgcmVzb2x2ZXIgPSB0aGlzLnJlc291cmNlUmVzb2x2ZXJzW2tleV07XG4gICAgICAgIGlmIChyZXNvbHZlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXNvbHZlciA9IHRoaXMucm9vdC5yZXNvdXJjZVJlc29sdmVyc1trZXldO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKHRoaXMucm9vdCwgdGhpcykgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZSh0aGlzLCB0aGlzKSA/PyBudWxsO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgaml0UmVnaXN0ZXIoa2V5QXNWYWx1ZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAodHlwZW9mIGtleUFzVmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGppdFJlZ2lzdGVyIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGNvbnN0cnVjdG9yOiAnJHtrZXlBc1ZhbHVlfScuIERpZCB5b3UgZm9yZ2V0IHRvIHJlZ2lzdGVyIHRoaXMgcmVzb3VyY2U/YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEluc3RyaW5zaWNUeXBlTmFtZXMuaGFzKGtleUFzVmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGppdFJlZ2lzdGVyIGFuIGludHJpbnNpYyB0eXBlOiAke2tleUFzVmFsdWUubmFtZX0uIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBAaW5qZWN0KEtleSlgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWdpc3RyeShrZXlBc1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cmF0aW9uUmVzb2x2ZXIgPSBrZXlBc1ZhbHVlLnJlZ2lzdGVyKGhhbmRsZXIsIGtleUFzVmFsdWUpO1xuICAgICAgICAgICAgaWYgKCEocmVnaXN0cmF0aW9uUmVzb2x2ZXIgaW5zdGFuY2VvZiBPYmplY3QpIHx8IHJlZ2lzdHJhdGlvblJlc29sdmVyLnJlc29sdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Jlc29sdmVyID0gaGFuZGxlci5yZXNvbHZlcnMuZ2V0KGtleUFzVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdSZXNvbHZlciAhPSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Jlc29sdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzb2x2ZXIgcmV0dXJuZWQgZnJvbSB0aGUgc3RhdGljIHJlZ2lzdGVyIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvblJlc29sdmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFByb3RvY29sLnJlc291cmNlLmhhcyhrZXlBc1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGVmcyA9IFByb3RvY29sLnJlc291cmNlLmdldEFsbChrZXlBc1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgdGhlIHZlcnkgY29tbW9uIGNhc2VcbiAgICAgICAgICAgICAgICBkZWZzWzBdLnJlZ2lzdGVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gZGVmcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBsZW47ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZzW2RdLnJlZ2lzdGVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1Jlc29sdmVyID0gaGFuZGxlci5yZXNvbHZlcnMuZ2V0KGtleUFzVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG5ld1Jlc29sdmVyICE9IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdSZXNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNvbHZlciByZXR1cm5lZCBmcm9tIHRoZSBzdGF0aWMgcmVnaXN0ZXIgbWV0aG9kYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5QXNWYWx1ZS4kaXNJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGppdFJlZ2lzdGVyIGFuIGludGVyZmFjZTogJHtrZXlBc1ZhbHVlLmZyaWVuZGx5TmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gdGhpcy5jb25maWcuZGVmYXVsdFJlc29sdmVyKGtleUFzVmFsdWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaGFuZGxlci5yZXNvbHZlcnMuc2V0KGtleUFzVmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgSVJlZ2lzdHJ5IHRoYXQgZGVsZWdhdGVzIHJlZ2lzdHJhdGlvbiB0byBhXG4gKiBzZXBhcmF0ZWx5IHJlZ2lzdGVyZWQgY2xhc3MuIFRoZSBQYXJhbWV0ZXJpemVkUmVnaXN0cnkgZmFjaWxpdGF0ZXMgdGhlXG4gKiBwYXNzaW5nIG9mIHBhcmFtZXRlcnMgdG8gdGhlIGZpbmFsIHJlZ2lzdHJ5LlxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1ldGVyaXplZFJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHBhcmFtcykge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY29udGFpbmVyLmhhcyh0aGlzLmtleSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gY29udGFpbmVyLmdldCh0aGlzLmtleSk7XG4gICAgICAgICAgICByZWdpc3RyeS5yZWdpc3Rlcihjb250YWluZXIsIC4uLnRoaXMucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlciguLi50aGlzLnBhcmFtcy5maWx0ZXIoeCA9PiB0eXBlb2YgeCA9PT0gJ29iamVjdCcpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGNhY2hlQ2FsbGJhY2tSZXN1bHQoZnVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYW5kbGVyLCByZXF1ZXN0b3IsIHJlc29sdmVyKSB7XG4gICAgICAgIGlmIChjYWNoZS5oYXMocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KHJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ID0gZnVuKGhhbmRsZXIsIHJlcXVlc3RvciwgcmVzb2x2ZXIpO1xuICAgICAgICBjYWNoZS5zZXQocmVzb2x2ZXIsIHQpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xufVxuLyoqXG4gKiB5b3UgY2FuIHVzZSB0aGUgcmVzdWx0aW5nIHtAbGlua2NvZGUgSVJlZ2lzdHJhdGlvbn0gb2YgYW55IG9mIHRoZSBmYWN0b3J5IG1ldGhvZHNcbiAqIHRvIHJlZ2lzdGVyIHdpdGggdGhlIGNvbnRhaW5lciwgZS5nLlxuICogYGBgXG4gKiBjbGFzcyBGb28ge31cbiAqIGNvbnN0IGNvbnRhaW5lciA9IERJLmNyZWF0ZUNvbnRhaW5lcigpO1xuICogY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShGb28sIG5ldyBGb28oKSkpO1xuICogY29udGFpbmVyLmdldChGb28pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBSZWdpc3RyYXRpb24gPSB7XG4gICAgLyoqXG4gICAgICogYWxsb3dzIHlvdSB0byBwYXNzIGFuIGluc3RhbmNlLlxuICAgICAqIEV2ZXJ5IHRpbWUgeW91IHJlcXVlc3QgdGhpcyB7QGxpbmtjb2RlIEtleX0geW91IHdpbGwgZ2V0IHRoaXMgaW5zdGFuY2UgYmFjay5cbiAgICAgKiBgYGBcbiAgICAgKiBSZWdpc3RyYXRpb24uaW5zdGFuY2UoRm9vLCBuZXcgRm9vKCkpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBpbnN0YW5jZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXIoa2V5LCAwIC8qIGluc3RhbmNlICovLCB2YWx1ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIGZyb20gdGhlIGNsYXNzLlxuICAgICAqIEV2ZXJ5IHRpbWUgeW91IHJlcXVlc3QgdGhpcyB7QGxpbmtjb2RlIEtleX0geW91IHdpbGwgZ2V0IHRoZSBzYW1lIG9uZSBiYWNrLlxuICAgICAqIGBgYFxuICAgICAqIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oRm9vLCBGb28pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNpbmdsZXRvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXIoa2V5LCAxIC8qIHNpbmdsZXRvbiAqLywgdmFsdWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBmcm9tIGEgY2xhc3MuXG4gICAgICogRXZlcnkgdGltZSB5b3UgcmVxdWVzdCB0aGlzIHtAbGlua2NvZGUgS2V5fSB5b3Ugd2lsbCBnZXQgYSBuZXcgaW5zdGFuY2UuXG4gICAgICogYGBgXG4gICAgICogUmVnaXN0cmF0aW9uLmluc3RhbmNlKEZvbywgRm9vKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICB0cmFuc2llbnQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVyKGtleSwgMiAvKiB0cmFuc2llbnQgKi8sIHZhbHVlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2UgZnJvbSB0aGUgbWV0aG9kIHBhc3NlZC5cbiAgICAgKiBFdmVyeSB0aW1lIHlvdSByZXF1ZXN0IHRoaXMge0BsaW5rY29kZSBLZXl9IHlvdSB3aWxsIGdldCBhIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBgYGBcbiAgICAgKiBSZWdpc3RyYXRpb24uY2FsbGJhY2soRm9vLCAoKSA9PiBuZXcgRm9vKCkpO1xuICAgICAqIFJlZ2lzdHJhdGlvbi5jYWxsYmFjayhCYXIsIChjOiBJQ29udGFpbmVyKSA9PiBuZXcgQmFyKGMuZ2V0KEZvbykpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBjYWxsYmFjayhrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXIoa2V5LCAzIC8qIGNhbGxiYWNrICovLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIGZyb20gdGhlIG1ldGhvZCBwYXNzZWQuXG4gICAgICogT24gdGhlIGZpcnN0IHJlcXVlc3QgZm9yIHRoZSB7QGxpbmtjb2RlIEtleX0geW91ciBjYWxsYmFjayBpcyBjYWxsZWQgYW5kIHJldHVybnMgYW4gaW5zdGFuY2UuXG4gICAgICogc3Vic2VxdWVudCByZXF1ZXN0cyBmb3IgdGhlIHtAbGlua2NvZGUgS2V5fSwgdGhlIGluaXRpYWwgaW5zdGFuY2UgcmV0dXJuZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB5b3UgcGFzcyB0aGUgc2FtZSB7QGxpbmtjb2RlIFJlZ2lzdHJhdGlvbn0gdG8gYW5vdGhlciBjb250YWluZXIgdGhlIHNhbWUgY2FjaGVkIHZhbHVlIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBTaG91bGQgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIHJlc29sdmVyIHJldHVybmVkIGJlIHJlbW92ZWQsIHRoZSBjYWNoZSB3aWxsIGV4cGlyZS5cbiAgICAgKiBgYGBcbiAgICAgKiBSZWdpc3RyYXRpb24uY2FjaGVkQ2FsbGJhY2soRm9vLCAoKSA9PiBuZXcgRm9vKCkpO1xuICAgICAqIFJlZ2lzdHJhdGlvbi5jYWNoZWRDYWxsYmFjayhCYXIsIChjOiBJQ29udGFpbmVyKSA9PiBuZXcgQmFyKGMuZ2V0KEZvbykpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBjYWNoZWRDYWxsYmFjayhrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXIoa2V5LCAzIC8qIGNhbGxiYWNrICovLCBjYWNoZUNhbGxiYWNrUmVzdWx0KGNhbGxiYWNrKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIGFuIGFsdGVybmF0ZSB7QGxpbmtjb2RlIEtleX0gdG8gcmV0cmlldmUgYW4gaW5zdGFuY2UgYnkuXG4gICAgICogUmV0dXJucyB0aGUgc2FtZSBzY29wZSBhcyB0aGUgb3JpZ2luYWwge0BsaW5rY29kZSBLZXl9LlxuICAgICAqIGBgYFxuICAgICAqIFJlZ2lzdGVyLnNpbmdsZXRvbihGb28sIEZvbylcbiAgICAgKiBSZWdpc3Rlci5hbGlhc1RvKEZvbywgTXlGb29zKTtcbiAgICAgKlxuICAgICAqIGNvbnRhaW5lci5nZXRBbGwoTXlGb29zKSAvLyBjb250YWlucyBhbiBpbnN0YW5jZSBvZiBGb29cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEtleVxuICAgICAqIEBwYXJhbSBhbGlhc0tleVxuICAgICAqL1xuICAgIGFsaWFzVG8ob3JpZ2luYWxLZXksIGFsaWFzS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXIoYWxpYXNLZXksIDUgLyogYWxpYXMgKi8sIG9yaWdpbmFsS2V5KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgZGVmZXIoa2V5LCAuLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbWV0ZXJpemVkUmVnaXN0cnkoa2V5LCBwYXJhbXMpO1xuICAgIH1cbn07XG5leHBvcnQgY2xhc3MgSW5zdGFuY2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZnJpZW5kbHlOYW1lKSB7XG4gICAgICAgIHRoaXMuZnJpZW5kbHlOYW1lID0gZnJpZW5kbHlOYW1lO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgcHJlcGFyZShpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIGdldCAkaXNSZXNvbHZlcigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZXNvbHZlKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjYWxsIHJlc29sdmUgJHt0aGlzLmZyaWVuZGx5TmFtZX0gYmVmb3JlIGNhbGxpbmcgcHJlcGFyZSBvciBhZnRlciBjYWxsaW5nIGRpc3Bvc2UuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUtleShrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5L3ZhbHVlIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4gQXJlIHlvdSB0cnlpbmcgdG8gaW5qZWN0L3JlZ2lzdGVyIHNvbWV0aGluZyB0aGF0IGRvZXNuXFwndCBleGlzdCB3aXRoIERJPycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkQWxsUmVzcG9uc2UocmVzb2x2ZXIsIGhhbmRsZXIsIHJlcXVlc3Rvcikge1xuICAgIGlmIChyZXNvbHZlciBpbnN0YW5jZW9mIFJlc29sdmVyICYmIHJlc29sdmVyLnN0cmF0ZWd5ID09PSA0IC8qIGFycmF5ICovKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gcmVzb2x2ZXIuc3RhdGU7XG4gICAgICAgIGxldCBpID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gc3RhdGVbaV0ucmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc29sdmVyLnJlc29sdmUoaGFuZGxlciwgcmVxdWVzdG9yKV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaS5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMgKi9cbmltcG9ydCB7IERJIH0gZnJvbSAnLi9kaS5qcyc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBoYW5kbGVyIGZvciBhbiBFdmVudEFnZ3JlZ2F0b3IgZXZlbnQuXG4gKi9cbmNsYXNzIEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VUeXBlID0gbWVzc2FnZVR5cGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgaGFuZGxlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiB0aGlzLm1lc3NhZ2VUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrLmNhbGwobnVsbCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgSUV2ZW50QWdncmVnYXRvciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUV2ZW50QWdncmVnYXRvcicsIHggPT4geC5zaW5nbGV0b24oRXZlbnRBZ2dyZWdhdG9yKSk7XG4vKipcbiAqIEVuYWJsZXMgbG9vc2VseSBjb3VwbGVkIHB1Ymxpc2gvc3Vic2NyaWJlIG1lc3NhZ2luZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50QWdncmVnYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5ldmVudExvb2t1cCA9IHt9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzID0gW107XG4gICAgfVxuICAgIHB1Ymxpc2goY2hhbm5lbE9ySW5zdGFuY2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsT3JJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYW5uZWwgbmFtZSBvciBpbnN0YW5jZTogJHtjaGFubmVsT3JJbnN0YW5jZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGFubmVsT3JJbnN0YW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBzdWJzY3JpYmVycyA9IHRoaXMuZXZlbnRMb29rdXBbY2hhbm5lbE9ySW5zdGFuY2VdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBzdWJzY3JpYmVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbaV0obWVzc2FnZSwgY2hhbm5lbE9ySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5tZXNzYWdlSGFuZGxlcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCBpID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tpXS5oYW5kbGUoY2hhbm5lbE9ySW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShjaGFubmVsT3JUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNoYW5uZWxPclR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFubmVsIG5hbWUgb3IgdHlwZTogJHtjaGFubmVsT3JUeXBlfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgbGV0IHN1YnNjcmliZXJzO1xuICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWxPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudExvb2t1cFtjaGFubmVsT3JUeXBlXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudExvb2t1cFtjaGFubmVsT3JUeXBlXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlciA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMgPSB0aGlzLmV2ZW50TG9va3VwW2NoYW5uZWxPclR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlciA9IG5ldyBIYW5kbGVyKGNoYW5uZWxPclR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzID0gdGhpcy5tZXNzYWdlSGFuZGxlcnM7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN1YnNjcmliZU9uY2UoY2hhbm5lbE9yVHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWJzY3JpYmUoY2hhbm5lbE9yVHlwZSwgZnVuY3Rpb24gKG1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgICAgICAgICBzdWIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgY2FsbGJhY2sobWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudGFnZ3JlZ2F0b3IuanMubWFwIiwiaW1wb3J0IHsgZW1wdHlBcnJheSB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuY29uc3QgaXNOdW1lcmljTG9va3VwID0ge307XG4vKipcbiAqIEVmZmljaWVudGx5IGRldGVybWluZSB3aGV0aGVyIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBrZXkgaXMgbnVtZXJpY1xuICogKGFuZCB0aHVzIGNvdWxkIGJlIGFuIGFycmF5IGluZGV4ZXIpIG9yIG5vdC5cbiAqXG4gKiBBbHdheXMgcmV0dXJucyB0cnVlIGZvciB2YWx1ZXMgb2YgdHlwZSBgJ251bWJlcidgLlxuICpcbiAqIE90aGVyd2lzZSwgb25seSByZXR1cm5zIHRydWUgZm9yIHN0cmluZ3MgdGhhdCBjb25zaXN0IG9ubHkgb2YgcG9zaXRpdmUgaW50ZWdlcnMuXG4gKlxuICogUmVzdWx0cyBhcmUgY2FjaGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUluZGV4KHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmICh2YWx1ZSB8IDApID09PSB2YWx1ZTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXNOdW1lcmljTG9va3VwW3ZhbHVlXTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTnVtZXJpY0xvb2t1cFt2YWx1ZV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2ggPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIGNoID09PSAweDMwICYmIGxlbmd0aCA+IDEgLyogbXVzdCBub3Qgc3RhcnQgd2l0aCAwICovIHx8IGNoIDwgMHgzMCAvKiAwICovIHx8IGNoID4gMHgzOSAvKiA5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc051bWVyaWNMb29rdXBbdmFsdWVdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzTnVtZXJpY0xvb2t1cFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgYSBudW1iZXIgb3IgYmlnaW50IGZvciBwYXJzaW5nIHB1cnBvc2VzXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gZXZhbHVhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyT3JCaWdJbnQodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgYSBudW1iZXIgb3IgYmlnaW50IGZvciBwYXJzaW5nIHB1cnBvc2VzXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gZXZhbHVhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nT3JEYXRlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgaW1wbGVtZW50YXRpb24gb2YgY2FtZWwgYW5kIGtlYmFiIGNhc2VzXG4gKi9cbmNvbnN0IGJhc2VDYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgQ2hhcktpbmQ7XG4gICAgKGZ1bmN0aW9uIChDaGFyS2luZCkge1xuICAgICAgICBDaGFyS2luZFtDaGFyS2luZFtcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgICAgICBDaGFyS2luZFtDaGFyS2luZFtcImRpZ2l0XCJdID0gMV0gPSBcImRpZ2l0XCI7XG4gICAgICAgIENoYXJLaW5kW0NoYXJLaW5kW1widXBwZXJcIl0gPSAyXSA9IFwidXBwZXJcIjtcbiAgICAgICAgQ2hhcktpbmRbQ2hhcktpbmRbXCJsb3dlclwiXSA9IDNdID0gXCJsb3dlclwiO1xuICAgIH0pKENoYXJLaW5kIHx8IChDaGFyS2luZCA9IHt9KSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9uc1xuICAgIGNvbnN0IGlzRGlnaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgJzAnOiB0cnVlLFxuICAgICAgICAnMSc6IHRydWUsXG4gICAgICAgICcyJzogdHJ1ZSxcbiAgICAgICAgJzMnOiB0cnVlLFxuICAgICAgICAnNCc6IHRydWUsXG4gICAgICAgICc1JzogdHJ1ZSxcbiAgICAgICAgJzYnOiB0cnVlLFxuICAgICAgICAnNyc6IHRydWUsXG4gICAgICAgICc4JzogdHJ1ZSxcbiAgICAgICAgJzknOiB0cnVlLFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoYXJUb0tpbmQoY2hhcikge1xuICAgICAgICBpZiAoY2hhciA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCB0aGlzIGlmIHdlIGRvIGNoYXJBdCgpIHdpdGggYW4gaW5kZXggb3V0IG9mIHJhbmdlXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBub25lICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyICE9PSBjaGFyLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAzIC8qIGxvd2VyICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyICE9PSBjaGFyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIHVwcGVyICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RpZ2l0W2NoYXJdID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBkaWdpdCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBub25lICovO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBjYikge1xuICAgICAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VwID0gZmFsc2U7XG4gICAgICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAgICAgbGV0IHByZXZLaW5kO1xuICAgICAgICBsZXQgY3VyQ2hhciA9ICcnO1xuICAgICAgICBsZXQgY3VyS2luZCA9IDAgLyogbm9uZSAqLztcbiAgICAgICAgbGV0IG5leHRDaGFyID0gaW5wdXQuY2hhckF0KDApO1xuICAgICAgICBsZXQgbmV4dEtpbmQgPSBjaGFyVG9LaW5kKG5leHRDaGFyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcHJldktpbmQgPSBjdXJLaW5kO1xuICAgICAgICAgICAgY3VyQ2hhciA9IG5leHRDaGFyO1xuICAgICAgICAgICAgY3VyS2luZCA9IG5leHRLaW5kO1xuICAgICAgICAgICAgbmV4dENoYXIgPSBpbnB1dC5jaGFyQXQoaSArIDEpO1xuICAgICAgICAgICAgbmV4dEtpbmQgPSBjaGFyVG9LaW5kKG5leHRDaGFyKTtcbiAgICAgICAgICAgIGlmIChjdXJLaW5kID09PSAwIC8qIG5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzZXQgc2VwIHRvIHRydWUgaWYgaXQncyBub3QgYXQgdGhlIGJlZ2lubmluZyBvZiBvdXRwdXQuXG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXAgJiYgb3V0cHV0Lmxlbmd0aCA+IDAgJiYgY3VyS2luZCA9PT0gMiAvKiB1cHBlciAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXBhcmF0ZSBVQUZvbyBpbnRvIFVBIEZvby5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VwYXJhdGUgdWFGT08gaW50byB1YSBGT08uXG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IHByZXZLaW5kID09PSAzIC8qIGxvd2VyICovIHx8IG5leHRLaW5kID09PSAzIC8qIGxvd2VyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gY2IoY3VyQ2hhciwgc2VwKTtcbiAgICAgICAgICAgICAgICBzZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59KSgpO1xuLyoqXG4gKiBFZmZpY2llbnRseSBjb252ZXJ0IGEgc3RyaW5nIHRvIGNhbWVsQ2FzZS5cbiAqXG4gKiBOb24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYXJlIHRyZWF0ZWQgYXMgc2VwYXJhdG9ycy5cbiAqXG4gKiBQcmltYXJpbHkgdXNlZCBieSBBdXJlbGlhIHRvIGNvbnZlcnQgRE9NIGF0dHJpYnV0ZSBuYW1lcyB0byBWaWV3TW9kZWwgcHJvcGVydHkgbmFtZXMuXG4gKlxuICogUmVzdWx0cyBhcmUgY2FjaGVkLlxuICovXG5leHBvcnQgY29uc3QgY2FtZWxDYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gY2FsbGJhY2soY2hhciwgc2VwKSB7XG4gICAgICAgIHJldHVybiBzZXAgPyBjaGFyLnRvVXBwZXJDYXNlKCkgOiBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IGNhY2hlW2lucHV0XTtcbiAgICAgICAgaWYgKG91dHB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBjYWNoZVtpbnB1dF0gPSBiYXNlQ2FzZShpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIEVmZmljaWVudGx5IGNvbnZlcnQgYSBzdHJpbmcgdG8gUGFzY2FsQ2FzZS5cbiAqXG4gKiBOb24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYXJlIHRyZWF0ZWQgYXMgc2VwYXJhdG9ycy5cbiAqXG4gKiBQcmltYXJpbHkgdXNlZCBieSBBdXJlbGlhIHRvIGNvbnZlcnQgZWxlbWVudCBuYW1lcyB0byBjbGFzcyBuYW1lcyBmb3Igc3ludGhldGljIHR5cGVzLlxuICpcbiAqIFJlc3VsdHMgYXJlIGNhY2hlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhc2NhbENhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBjYWNoZVtpbnB1dF07XG4gICAgICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gY2FtZWxDYXNlKGlucHV0KTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dFswXS50b1VwcGVyQ2FzZSgpICsgb3V0cHV0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FjaGVbaW5wdXRdID0gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIEVmZmljaWVudGx5IGNvbnZlcnQgYSBzdHJpbmcgdG8ga2ViYWItY2FzZS5cbiAqXG4gKiBOb24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYXJlIHRyZWF0ZWQgYXMgc2VwYXJhdG9ycy5cbiAqXG4gKiBQcmltYXJpbHkgdXNlZCBieSBBdXJlbGlhIHRvIGNvbnZlcnQgVmlld01vZGVsIHByb3BlcnR5IG5hbWVzIHRvIERPTSBhdHRyaWJ1dGUgbmFtZXMuXG4gKlxuICogUmVzdWx0cyBhcmUgY2FjaGVkLlxuICovXG5leHBvcnQgY29uc3Qga2ViYWJDYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gY2FsbGJhY2soY2hhciwgc2VwKSB7XG4gICAgICAgIHJldHVybiBzZXAgPyBgLSR7Y2hhci50b0xvd2VyQ2FzZSgpfWAgOiBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IGNhY2hlW2lucHV0XTtcbiAgICAgICAgaWYgKG91dHB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBjYWNoZVtpbnB1dF0gPSBiYXNlQ2FzZShpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIEVmZmljaWVudGx5ICh1cCB0byAxMHggZmFzdGVyIHRoYW4gYEFycmF5LmZyb21gKSBjb252ZXJ0IGFuIGBBcnJheUxpa2VgIHRvIGEgcmVhbCBhcnJheS5cbiAqXG4gKiBQcmltYXJpbHkgdXNlZCBieSBBdXJlbGlhIHRvIGNvbnZlcnQgRE9NIG5vZGUgbGlzdHMgdG8gYXJyYXlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShpbnB1dCkge1xuICAgIC8vIGJlbmNobWFyazogaHR0cDovL2pzYmVuLmNoL3hqc3lGXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGlucHV0O1xuICAgIGNvbnN0IGFyciA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBpbnB1dFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGlkcyA9IHt9O1xuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbmV4dCBJRCBpbiBhIHNlcXVlbmNlIGZvciBhIGdpdmVuIHN0cmluZywgc3RhcnRpbmcgd2l0aCBgMWAuXG4gKlxuICogVXNlZCBieSBBdXJlbGlhIHRvIGFzc2lnbiB1bmlxdWUgSUQncyB0byBjb250cm9sbGVycyBhbmQgcmVzb3VyY2VzLlxuICpcbiAqIEF1cmVsaWEgd2lsbCBhbHdheXMgcHJlcGVuZCB0aGUgY29udGV4dCBuYW1lIHdpdGggYGF1JGAsIHNvIGFzIGxvbmcgYXMgeW91IGF2b2lkXG4gKiB1c2luZyB0aGF0IGNvbnZlbnRpb24geW91IHNob3VsZCBiZSBzYWZlIGZyb20gY29sbGlzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5leHRJZChjb250ZXh0KSB7XG4gICAgaWYgKGlkc1tjb250ZXh0XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlkc1tjb250ZXh0XSA9IDA7XG4gICAgfVxuICAgIHJldHVybiArK2lkc1tjb250ZXh0XTtcbn1cbi8qKlxuICogUmVzZXQgdGhlIElEIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLCBzbyB0aGF0IGBuZXh0SWRgIHdpbGwgcmV0dXJuIGAxYCBhZ2FpbiBmb3IgdGhlIG5leHQgY2FsbC5cbiAqXG4gKiBVc2VkIGJ5IEF1cmVsaWEgdG8gcmVzZXQgSUQncyBpbiBiZXR3ZWVuIHVuaXQgdGVzdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldElkKGNvbnRleHQpIHtcbiAgICBpZHNbY29udGV4dF0gPSAwO1xufVxuLyoqXG4gKiBBIGNvbXBhcmUgZnVuY3Rpb24gdG8gcGFzcyB0byBgQXJyYXkucHJvdG90eXBlLnNvcnRgIGZvciBzb3J0aW5nIG51bWJlcnMuXG4gKiBUaGlzIGlzIG5lZWRlZCBmb3IgbnVtZXJpYyBzb3J0LCBzaW5jZSB0aGUgZGVmYXVsdCBzb3J0cyB0aGVtIGFzIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlTnVtYmVyKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IG1lcmdlIGFuZCBkZWR1cGxpY2F0ZSB0aGUgKHByaW1pdGl2ZSkgdmFsdWVzIGluIHR3byBhcnJheXMuXG4gKlxuICogRG9lcyBub3QgZGVkdXBsaWNhdGUgZXhpc3RpbmcgdmFsdWVzIGluIHRoZSBmaXJzdCBhcnJheS5cbiAqXG4gKiBHdWFyZHMgYWdhaW5zdCBudWxsIG9yIHVuZGVmaW5lZCBhcnJheXMuXG4gKlxuICogUmV0dXJucyBgZW1wdHlBcnJheWAgaWYgYm90aCBhcnJheXMgYXJlIGVpdGhlciBgbnVsbGAsIGB1bmRlZmluZWRgIG9yIGBlbXB0eUFycmF5YFxuICpcbiAqIEBwYXJhbSBzbGljZSAtIElmIGB0cnVlYCwgYWx3YXlzIHJldHVybnMgYSBuZXcgYXJyYXkgY29weSAodW5sZXNzIG5laXRoZXIgYXJyYXkgaXMvaGFzIGEgdmFsdWUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURpc3RpbmN0KGFycjEsIGFycjIsIHNsaWNlKSB7XG4gICAgaWYgKGFycjEgPT09IHZvaWQgMCB8fCBhcnIxID09PSBudWxsIHx8IGFycjEgPT09IGVtcHR5QXJyYXkpIHtcbiAgICAgICAgaWYgKGFycjIgPT09IHZvaWQgMCB8fCBhcnIyID09PSBudWxsIHx8IGFycjIgPT09IGVtcHR5QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlID8gYXJyMi5zbGljZSgwKSA6IGFycjI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXJyMiA9PT0gdm9pZCAwIHx8IGFycjIgPT09IG51bGwgfHwgYXJyMiA9PT0gZW1wdHlBcnJheSkge1xuICAgICAgICByZXR1cm4gc2xpY2UgPyBhcnIxLnNsaWNlKDApIDogYXJyMTtcbiAgICB9XG4gICAgY29uc3QgbG9va3VwID0ge307XG4gICAgY29uc3QgYXJyMyA9IHNsaWNlID8gYXJyMS5zbGljZSgwKSA6IGFycjE7XG4gICAgbGV0IGxlbjEgPSBhcnIxLmxlbmd0aDtcbiAgICBsZXQgbGVuMiA9IGFycjIubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4xLS0gPiAwKSB7XG4gICAgICAgIGxvb2t1cFthcnIxW2xlbjFdXSA9IHRydWU7XG4gICAgfVxuICAgIGxldCBpdGVtO1xuICAgIHdoaWxlIChsZW4yLS0gPiAwKSB7XG4gICAgICAgIGl0ZW0gPSBhcnIyW2xlbjJdO1xuICAgICAgICBpZiAobG9va3VwW2l0ZW1dID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGFycjMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGxvb2t1cFtpdGVtXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjM7XG59XG4vKipcbiAqIERlY29yYXRvci4gKGxhemlseSkgYmluZCB0aGUgbWV0aG9kIHRvIHRoZSBjbGFzcyBpbnN0YW5jZSBvbiBmaXJzdCBjYWxsLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5kKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kRm4gPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBib3VuZEZuLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZEZuO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGsgPSAwO1xuICAgIGNvbnN0IGFycmF5c0xlbiA9IGFycmF5cy5sZW5ndGg7XG4gICAgbGV0IGFycmF5TGVuID0gMDtcbiAgICBsZXQgYXJyYXk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXNMZW47ICsraSkge1xuICAgICAgICBhcnJheSA9IGFycmF5c1tpXTtcbiAgICAgICAgaWYgKGFycmF5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGFycmF5TGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJheUxlbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2srK10gPSBhcnJheVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyguLi5vYmplY3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3Qgb2JqZWN0c0xlbiA9IG9iamVjdHMubGVuZ3RoO1xuICAgIGxldCBvYmplY3Q7XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHNMZW47ICsraSkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAob2JqZWN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdERlZmluZWQoLi4udmFsdWVzKSB7XG4gICAgY29uc3QgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICBsZXQgdmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlZmF1bHQgdmFsdWUgZm91bmRgKTtcbn1cbmV4cG9ydCBjb25zdCBnZXRQcm90b3R5cGVDaGFpbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgY29uc3QgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIGxldCBwcm90byA9IGZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hhaW4gPSB2b2lkIDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgICAgIGNoYWluID0gY2FjaGUuZ2V0KFR5cGUpO1xuICAgICAgICBpZiAoY2hhaW4gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY2FjaGUuc2V0KFR5cGUsIGNoYWluID0gW3Byb3RvID0gVHlwZV0pO1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKHByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pKSAhPT0gZnVuY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjaGFpblsrK2ldID0gcHJvdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH07XG59KSgpO1xuZXhwb3J0IGZ1bmN0aW9uIHRvTG9va3VwKC4uLm9ianMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCAuLi5vYmpzKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpcyB0aGUgZnVuY3Rpb24gaXMgYSBuYXRpdmUgZnVuY3Rpb24sIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbmV4cG9ydCBjb25zdCBpc05hdGl2ZUZ1bmN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGNvbnN0IGxvb2t1cCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgbGV0IGlzTmF0aXZlID0gZmFsc2U7XG4gICAgbGV0IHNvdXJjZVRleHQgPSAnJztcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlzTmF0aXZlID0gbG9va3VwLmdldChmbik7XG4gICAgICAgIGlmIChpc05hdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzb3VyY2VUZXh0ID0gZm4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGkgPSBzb3VyY2VUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi8jcHJvZC1OYXRpdmVGdW5jdGlvblxuICAgICAgICAgICAgaXNOYXRpdmUgPSAoXG4gICAgICAgICAgICAvLyAyOSBpcyB0aGUgbGVuZ3RoIG9mICdmdW5jdGlvbiAoKSB7IFtuYXRpdmUgY29kZV0gfScgd2hpY2ggaXMgdGhlIHNtYWxsZXN0IGxlbmd0aCBvZiBhIG5hdGl2ZSBmdW5jdGlvbiBzdHJpbmdcbiAgICAgICAgICAgIGkgPj0gMjkgJiZcbiAgICAgICAgICAgICAgICAvLyAxMDAgc2VlbXMgdG8gYmUgYSBzYWZlIHVwcGVyIGJvdW5kIG9mIHRoZSBtYXggbGVuZ3RoIG9mIGEgbmF0aXZlIGZ1bmN0aW9uLiBJbiBDaHJvbWUgYW5kIEZGIGl0J3MgNTYsIGluIEVkZ2UgaXQncyA2MS5cbiAgICAgICAgICAgICAgICBpIDw9IDEwMCAmJlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2hvbGUgaGV1cmlzdGljICpjb3VsZCogYmUgdHJpY2tlZCBieSBhIGNvbW1lbnQuIERvIHdlIG5lZWQgdG8gY2FyZSBhYm91dCB0aGF0P1xuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4N0QgJiYgLy8gfVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoZSBzcGVjIGlzIGEgbGl0dGxlIHZhZ3VlIGFib3V0IHRoZSBwcmVjaXNlIGNvbnN0cmFpbnRzLCBzbyB3ZSBkbyBuZWVkIHRvIHRlc3QgdGhpcyBhY3Jvc3MgdmFyaW91cyBicm93c2VycyB0byBtYWtlIHN1cmUganVzdCBvbmUgd2hpdGVzcGFjZSBpcyBhIHNhZmUgYXNzdW1wdGlvbi5cbiAgICAgICAgICAgICAgICBzb3VyY2VUZXh0LmNoYXJDb2RlQXQoaSAtIDIpIDw9IDB4MjAgJiYgLy8gd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gMykgPT09IDB4NUQgJiYgLy8gXVxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gNCkgPT09IDB4NjUgJiYgLy8gZVxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gNSkgPT09IDB4NjQgJiYgLy8gZFxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gNikgPT09IDB4NkYgJiYgLy8gb1xuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gNykgPT09IDB4NjMgJiYgLy8gY1xuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gOCkgPT09IDB4MjAgJiYgLy9cbiAgICAgICAgICAgICAgICBzb3VyY2VUZXh0LmNoYXJDb2RlQXQoaSAtIDkpID09PSAweDY1ICYmIC8vIGVcbiAgICAgICAgICAgICAgICBzb3VyY2VUZXh0LmNoYXJDb2RlQXQoaSAtIDEwKSA9PT0gMHg3NiAmJiAvLyB2XG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSAxMSkgPT09IDB4NjkgJiYgLy8gaVxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gMTIpID09PSAweDc0ICYmIC8vIHRcbiAgICAgICAgICAgICAgICBzb3VyY2VUZXh0LmNoYXJDb2RlQXQoaSAtIDEzKSA9PT0gMHg2MSAmJiAvLyBhXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSAxNCkgPT09IDB4NkUgJiYgLy8gblxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gMTUpID09PSAweDU4IC8vIFtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb29rdXAuc2V0KGZuLCBpc05hdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmF0aXZlO1xuICAgIH07XG59KSgpO1xuLyoqXG4gKiBOb3JtYWxpemUgYSBwb3RlbnRpYWwgcHJvbWlzZSB2aWEgYSBjYWxsYmFjaywgdG8gZW5zdXJlIHRoaW5ncyBzdGF5IHN5bmNocm9ub3VzIHdoZW4gdGhleSBjYW4uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgcHJvbWlzZSwgaXQgaXMgYHRoZW5gZWQgYmVmb3JlIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLiBPdGhlcndpc2UgdGhlIGNhbGxiYWNrIGlzIGludm9rZWQgc3luY2hyb25vdXNseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uUmVzb2x2ZShtYXliZVByb21pc2UsIHJlc29sdmVDYWxsYmFjaykge1xuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBtYXliZVByb21pc2UudGhlbihyZXNvbHZlQ2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZUNhbGxiYWNrKG1heWJlUHJvbWlzZSk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhbiBhcnJheSBvZiBwb3RlbnRpYWwgcHJvbWlzZXMsIHRvIGVuc3VyZSB0aGluZ3Mgc3RheSBzeW5jaHJvbm91cyB3aGVuIHRoZXkgY2FuLlxuICpcbiAqIElmIGV4YWN0bHkgb25lIHZhbHVlIGlzIGEgcHJvbWlzZSwgdGhlbiB0aGF0IHByb21pc2UgaXMgcmV0dXJuZWQuXG4gKlxuICogSWYgbW9yZSB0aGFuIG9uZSB2YWx1ZSBpcyBhIHByb21pc2UsIGEgbmV3IGBQcm9taXNlLmFsbGAgaXMgcmV0dXJuZWQuXG4gKlxuICogSWYgbm9uZSBvZiB0aGUgdmFsdWVzIGlzIGEgcHJvbWlzZSwgbm90aGluZyBpcyByZXR1cm5lZCwgdG8gaW5kaWNhdGUgdGhhdCB0aGluZ3MgY2FuIHN0YXkgc3luY2hyb25vdXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQWxsKC4uLm1heWJlUHJvbWlzZXMpIHtcbiAgICBsZXQgbWF5YmVQcm9taXNlID0gdm9pZCAwO1xuICAgIGxldCBmaXJzdFByb21pc2UgPSB2b2lkIDA7XG4gICAgbGV0IHByb21pc2VzID0gdm9pZCAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG1heWJlUHJvbWlzZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2VzW2ldO1xuICAgICAgICBpZiAoKG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZXNbaV0pIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQcm9taXNlID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvbWlzZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzID0gW2ZpcnN0UHJvbWlzZSwgbWF5YmVQcm9taXNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobWF5YmVQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvbWlzZXMgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25zLmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnLi9kaS5qcyc7XG5leHBvcnQgY29uc3QgSVBsYXRmb3JtID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJUGxhdGZvcm0nKTtcbmV4cG9ydCB7IFBsYXRmb3JtLCBUYXNrUXVldWUsIFRhc2ssIFRhc2tBYm9ydEVycm9yLCBUYXNrUXVldWVQcmlvcml0eSwgVGFza1N0YXR1cywgfSBmcm9tICdAYXVyZWxpYS9wbGF0Zm9ybSc7XG5leHBvcnQgeyBhbGwsIERJLCBJQ29udGFpbmVyLCBpbmplY3QsIElTZXJ2aWNlTG9jYXRvciwgbGF6eSwgb3B0aW9uYWwsIGlnbm9yZSwgUmVnaXN0cmF0aW9uLCBzaW5nbGV0b24sIHRyYW5zaWVudCwgSW5zdGFuY2VQcm92aWRlciwgbmV3SW5zdGFuY2VGb3JTY29wZSwgbmV3SW5zdGFuY2VPZiwgQ29udGFpbmVyQ29uZmlndXJhdGlvbiwgRGVmYXVsdFJlc29sdmVyLCB9IGZyb20gJy4vZGkuanMnO1xuZXhwb3J0IHsgbWV0YWRhdGEsIE1ldGFkYXRhLCBpc051bGxPclVuZGVmaW5lZCwgaXNPYmplY3QsIGFwcGx5TWV0YWRhdGFQb2x5ZmlsbCwgfSBmcm9tICdAYXVyZWxpYS9tZXRhZGF0YSc7XG5leHBvcnQgeyBMb2dMZXZlbCwgQ29sb3JPcHRpb25zLCBJTG9nQ29uZmlnLCBJTG9nRXZlbnRGYWN0b3J5LCBJU2luaywgSUxvZ2dlciwgTG9nQ29uZmlnLCBEZWZhdWx0TG9nRXZlbnQsIERlZmF1bHRMb2dFdmVudEZhY3RvcnksIERlZmF1bHRMb2dnZXIsIENvbnNvbGVTaW5rLCBMb2dnZXJDb25maWd1cmF0aW9uLCBmb3JtYXQsIHNpbmssIH0gZnJvbSAnLi9sb2dnZXIuanMnO1xuZXhwb3J0IHsgSU1vZHVsZUxvYWRlciwgQW5hbHl6ZWRNb2R1bGUsIE1vZHVsZUl0ZW0sIH0gZnJvbSAnLi9tb2R1bGUtbG9hZGVyLmpzJztcbmV4cG9ydCB7IG5vb3AsIGVtcHR5QXJyYXksIGVtcHR5T2JqZWN0LCB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuZXhwb3J0IHsgUHJvdG9jb2wsIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0LCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCwgZnJvbURlZmluaXRpb25PckRlZmF1bHQsIH0gZnJvbSAnLi9yZXNvdXJjZS5qcyc7XG5leHBvcnQgeyBFdmVudEFnZ3JlZ2F0b3IsIElFdmVudEFnZ3JlZ2F0b3IsIH0gZnJvbSAnLi9ldmVudGFnZ3JlZ2F0b3IuanMnO1xuZXhwb3J0IHsgaXNBcnJheUluZGV4LCBjYW1lbENhc2UsIGtlYmFiQ2FzZSwgcGFzY2FsQ2FzZSwgdG9BcnJheSwgbmV4dElkLCByZXNldElkLCBjb21wYXJlTnVtYmVyLCBtZXJnZURpc3RpbmN0LCBpc051bWJlck9yQmlnSW50LCBpc1N0cmluZ09yRGF0ZSwgYm91bmQsIG1lcmdlQXJyYXlzLCBtZXJnZU9iamVjdHMsIGZpcnN0RGVmaW5lZCwgZ2V0UHJvdG90eXBlQ2hhaW4sIGlzTmF0aXZlRnVuY3Rpb24sIG9uUmVzb2x2ZSwgcmVzb2x2ZUFsbCwgfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGFsbCwgREksIGlnbm9yZSwgb3B0aW9uYWwsIFJlZ2lzdHJhdGlvbiB9IGZyb20gJy4vZGkuanMnO1xuaW1wb3J0IHsgYm91bmQsIHRvTG9va3VwIH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHsgUHJvdG9jb2wgfSBmcm9tICcuL3Jlc291cmNlLmpzJztcbmltcG9ydCB7IE1ldGFkYXRhIH0gZnJvbSAnQGF1cmVsaWEvbWV0YWRhdGEnO1xuZXhwb3J0IHZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBpbnRlcm5hbCBhcHAgc3RhdGUuXG4gICAgICpcbiAgICAgKiBEaXNhYmxlZCBieSBkZWZhdWx0IGFuZCBzaG91bGQgbmV2ZXIgYmUgZW5hYmxlZCBpbiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ0cmFjZVwiXSA9IDBdID0gXCJ0cmFjZVwiO1xuICAgIC8qKlxuICAgICAqIEluZm9ybWF0aW9uIHRoYXQgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgZHVyaW5nIGRldmVsb3BtZW50IGFuZCBoYXMgbm8gbG9uZy10ZXJtIHZhbHVlLlxuICAgICAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiZGVidWdcIl0gPSAxXSA9IFwiZGVidWdcIjtcbiAgICAvKipcbiAgICAgKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2VuZXJhbCBmbG93IG9mIHRoZSBhcHBsaWNhdGlvbiB0aGF0IGhhcyBsb25nLXRlcm0gdmFsdWUuXG4gICAgICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJpbmZvXCJdID0gMl0gPSBcImluZm9cIjtcbiAgICAvKipcbiAgICAgKiBVbmV4cGVjdGVkIGNpcmN1bXN0YW5jZXMgdGhhdCByZXF1aXJlIGF0dGVudGlvbiBidXQgZG8gbm90IG90aGVyd2lzZSBjYXVzZSB0aGUgY3VycmVudCBmbG93IG9mIGV4ZWN1dGlvbiB0byBzdG9wLlxuICAgICAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wid2FyblwiXSA9IDNdID0gXCJ3YXJuXCI7XG4gICAgLyoqXG4gICAgICogVW5leHBlY3RlZCBjaXJjdW1zdGFuY2VzIHRoYXQgY2F1c2UgdGhlIGZsb3cgb2YgZXhlY3V0aW9uIGluIHRoZSBjdXJyZW50IGFjdGl2aXR5IHRvIHN0b3AgYnV0IGRvIG5vdCBjYXVzZSBhbiBhcHAtd2lkZSBmYWlsdXJlLlxuICAgICAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiZXJyb3JcIl0gPSA0XSA9IFwiZXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBVbmV4cGVjdGVkIGNpcmN1bXN0YW5jZXMgdGhhdCBjYXVzZSBhbiBhcHAtd2lkZSBmYWlsdXJlIG9yIG90aGVyd2lzZSByZXF1aXJlIGltbWVkaWF0ZSBhdHRlbnRpb24uXG4gICAgICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJmYXRhbFwiXSA9IDVdID0gXCJmYXRhbFwiO1xuICAgIC8qKlxuICAgICAqIE5vIG1lc3NhZ2VzIHNob3VsZCBiZSB3cml0dGVuLlxuICAgICAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wibm9uZVwiXSA9IDZdID0gXCJub25lXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuLyoqXG4gKiBGbGFncyB0byBlbmFibGUvZGlzYWJsZSBjb2xvciB1c2FnZSBpbiB0aGUgbG9nZ2luZyBvdXRwdXQuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3JPcHRpb25zO1xuKGZ1bmN0aW9uIChDb2xvck9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBEbyBub3QgdXNlIEFTQ0lJIGNvbG9yIGNvZGVzIGluIGxvZ2dpbmcgb3V0cHV0LlxuICAgICAqL1xuICAgIENvbG9yT3B0aW9uc1tDb2xvck9wdGlvbnNbXCJub0NvbG9yc1wiXSA9IDBdID0gXCJub0NvbG9yc1wiO1xuICAgIC8qKlxuICAgICAqIFVzZSBBU0NJSSBjb2xvciBjb2RlcyBpbiBsb2dnaW5nIG91dHB1dC4gQnkgZGVmYXVsdCwgdGltZXN0YW1wcyBhbmQgdGhlIFRSQyBhbmQgREJHIHByZWZpeCBhcmUgY29sb3JlZCBncmV5LiBJTkYgd2hpdGUsIFdSTiB5ZWxsb3csIGFuZCBFUlIgYW5kIEZUTCByZWQuXG4gICAgICovXG4gICAgQ29sb3JPcHRpb25zW0NvbG9yT3B0aW9uc1tcImNvbG9yc1wiXSA9IDFdID0gXCJjb2xvcnNcIjtcbn0pKENvbG9yT3B0aW9ucyB8fCAoQ29sb3JPcHRpb25zID0ge30pKTtcbmV4cG9ydCBjb25zdCBJTG9nQ29uZmlnID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJTG9nQ29uZmlnJywgeCA9PiB4Lmluc3RhbmNlKG5ldyBMb2dDb25maWcoMCAvKiBub0NvbG9ycyAqLywgMyAvKiB3YXJuICovKSkpO1xuZXhwb3J0IGNvbnN0IElTaW5rID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJU2luaycpO1xuZXhwb3J0IGNvbnN0IElMb2dFdmVudEZhY3RvcnkgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lMb2dFdmVudEZhY3RvcnknLCB4ID0+IHguc2luZ2xldG9uKERlZmF1bHRMb2dFdmVudEZhY3RvcnkpKTtcbmV4cG9ydCBjb25zdCBJTG9nZ2VyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJTG9nZ2VyJywgeCA9PiB4LnNpbmdsZXRvbihEZWZhdWx0TG9nZ2VyKSk7XG5leHBvcnQgY29uc3QgSUxvZ1Njb3BlcyA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUxvZ1Njb3BlJyk7XG5leHBvcnQgY29uc3QgTG9nZ2VyU2luayA9IE9iamVjdC5mcmVlemUoe1xuICAgIGtleTogUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IoJ2xvZ2dlci1zaW5rLWhhbmRsZXMnKSxcbiAgICBkZWZpbmUodGFyZ2V0LCBkZWZpbml0aW9uKSB7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZSh0aGlzLmtleSwgZGVmaW5pdGlvbi5oYW5kbGVzLCB0YXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuICAgIGdldEhhbmRsZXModGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5nZXQodGhpcy5rZXksIHRhcmdldCk7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmsoZGVmaW5pdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBMb2dnZXJTaW5rLmRlZmluZSh0YXJnZXQsIGRlZmluaXRpb24pO1xuICAgIH07XG59XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcbmV4cG9ydCBjb25zdCBmb3JtYXQgPSB0b0xvb2t1cCh7XG4gICAgcmVkKHN0cikge1xuICAgICAgICByZXR1cm4gYFxcdTAwMWJbMzFtJHtzdHJ9XFx1MDAxYlszOW1gO1xuICAgIH0sXG4gICAgZ3JlZW4oc3RyKSB7XG4gICAgICAgIHJldHVybiBgXFx1MDAxYlszMm0ke3N0cn1cXHUwMDFiWzM5bWA7XG4gICAgfSxcbiAgICB5ZWxsb3coc3RyKSB7XG4gICAgICAgIHJldHVybiBgXFx1MDAxYlszM20ke3N0cn1cXHUwMDFiWzM5bWA7XG4gICAgfSxcbiAgICBibHVlKHN0cikge1xuICAgICAgICByZXR1cm4gYFxcdTAwMWJbMzRtJHtzdHJ9XFx1MDAxYlszOW1gO1xuICAgIH0sXG4gICAgbWFnZW50YShzdHIpIHtcbiAgICAgICAgcmV0dXJuIGBcXHUwMDFiWzM1bSR7c3RyfVxcdTAwMWJbMzltYDtcbiAgICB9LFxuICAgIGN5YW4oc3RyKSB7XG4gICAgICAgIHJldHVybiBgXFx1MDAxYlszNm0ke3N0cn1cXHUwMDFiWzM5bWA7XG4gICAgfSxcbiAgICB3aGl0ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIGBcXHUwMDFiWzM3bSR7c3RyfVxcdTAwMWJbMzltYDtcbiAgICB9LFxuICAgIGdyZXkoc3RyKSB7XG4gICAgICAgIHJldHVybiBgXFx1MDAxYls5MG0ke3N0cn1cXHUwMDFiWzM5bWA7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGNsYXNzIExvZ0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoY29sb3JPcHRpb25zLCBsZXZlbCkge1xuICAgICAgICB0aGlzLmNvbG9yT3B0aW9ucyA9IGNvbG9yT3B0aW9ucztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbn1cbmNvbnN0IGdldExvZ0xldmVsU3RyaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBsb2dMZXZlbFN0cmluZyA9IFtcbiAgICAgICAgdG9Mb29rdXAoe1xuICAgICAgICAgICAgVFJDOiAnVFJDJyxcbiAgICAgICAgICAgIERCRzogJ0RCRycsXG4gICAgICAgICAgICBJTkY6ICdJTkYnLFxuICAgICAgICAgICAgV1JOOiAnV1JOJyxcbiAgICAgICAgICAgIEVSUjogJ0VSUicsXG4gICAgICAgICAgICBGVEw6ICdGVEwnLFxuICAgICAgICAgICAgUVFROiAnPz8/JyxcbiAgICAgICAgfSksXG4gICAgICAgIHRvTG9va3VwKHtcbiAgICAgICAgICAgIFRSQzogZm9ybWF0LmdyZXkoJ1RSQycpLFxuICAgICAgICAgICAgREJHOiBmb3JtYXQuZ3JleSgnREJHJyksXG4gICAgICAgICAgICBJTkY6IGZvcm1hdC53aGl0ZSgnSU5GJyksXG4gICAgICAgICAgICBXUk46IGZvcm1hdC55ZWxsb3coJ1dSTicpLFxuICAgICAgICAgICAgRVJSOiBmb3JtYXQucmVkKCdFUlInKSxcbiAgICAgICAgICAgIEZUTDogZm9ybWF0LnJlZCgnRlRMJyksXG4gICAgICAgICAgICBRUVE6IGZvcm1hdC5ncmV5KCc/Pz8nKSxcbiAgICAgICAgfSksXG4gICAgXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxldmVsLCBjb2xvck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxldmVsIDw9IDAgLyogdHJhY2UgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dMZXZlbFN0cmluZ1tjb2xvck9wdGlvbnNdLlRSQztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPD0gMSAvKiBkZWJ1ZyAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsU3RyaW5nW2NvbG9yT3B0aW9uc10uREJHO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA8PSAyIC8qIGluZm8gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dMZXZlbFN0cmluZ1tjb2xvck9wdGlvbnNdLklORjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPD0gMyAvKiB3YXJuICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nTGV2ZWxTdHJpbmdbY29sb3JPcHRpb25zXS5XUk47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsIDw9IDQgLyogZXJyb3IgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dMZXZlbFN0cmluZ1tjb2xvck9wdGlvbnNdLkVSUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPD0gNSAvKiBmYXRhbCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsU3RyaW5nW2NvbG9yT3B0aW9uc10uRlRMO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dMZXZlbFN0cmluZ1tjb2xvck9wdGlvbnNdLlFRUTtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIGdldFNjb3BlU3RyaW5nKHNjb3BlLCBjb2xvck9wdGlvbnMpIHtcbiAgICBpZiAoY29sb3JPcHRpb25zID09PSAwIC8qIG5vQ29sb3JzICovKSB7XG4gICAgICAgIHJldHVybiBzY29wZS5qb2luKCcuJyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZS5tYXAoZm9ybWF0LmN5YW4pLmpvaW4oJy4nKTtcbn1cbmZ1bmN0aW9uIGdldElzb1N0cmluZyh0aW1lc3RhbXAsIGNvbG9yT3B0aW9ucykge1xuICAgIGlmIChjb2xvck9wdGlvbnMgPT09IDAgLyogbm9Db2xvcnMgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdC5ncmV5KG5ldyBEYXRlKHRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSk7XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdExvZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzZXZlcml0eSwgbWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMsIHNjb3BlLCBjb2xvck9wdGlvbnMsIHRpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMub3B0aW9uYWxQYXJhbXMgPSBvcHRpb25hbFBhcmFtcztcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmNvbG9yT3B0aW9ucyA9IGNvbG9yT3B0aW9ucztcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCB7IHNldmVyaXR5LCBtZXNzYWdlLCBzY29wZSwgY29sb3JPcHRpb25zLCB0aW1lc3RhbXAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzY29wZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtnZXRJc29TdHJpbmcodGltZXN0YW1wLCBjb2xvck9wdGlvbnMpfSBbJHtnZXRMb2dMZXZlbFN0cmluZyhzZXZlcml0eSwgY29sb3JPcHRpb25zKX1dICR7bWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtnZXRJc29TdHJpbmcodGltZXN0YW1wLCBjb2xvck9wdGlvbnMpfSBbJHtnZXRMb2dMZXZlbFN0cmluZyhzZXZlcml0eSwgY29sb3JPcHRpb25zKX0gJHtnZXRTY29wZVN0cmluZyhzY29wZSwgY29sb3JPcHRpb25zKX1dICR7bWVzc2FnZX1gO1xuICAgIH1cbn1cbmxldCBEZWZhdWx0TG9nRXZlbnRGYWN0b3J5ID0gY2xhc3MgRGVmYXVsdExvZ0V2ZW50RmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICBjcmVhdGVMb2dFdmVudChsb2dnZXIsIGxldmVsLCBtZXNzYWdlLCBvcHRpb25hbFBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRMb2dFdmVudChsZXZlbCwgbWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMsIGxvZ2dlci5zY29wZSwgdGhpcy5jb25maWcuY29sb3JPcHRpb25zLCBEYXRlLm5vdygpKTtcbiAgICB9XG59O1xuRGVmYXVsdExvZ0V2ZW50RmFjdG9yeSA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgSUxvZ0NvbmZpZylcbl0sIERlZmF1bHRMb2dFdmVudEZhY3RvcnkpO1xuZXhwb3J0IHsgRGVmYXVsdExvZ0V2ZW50RmFjdG9yeSB9O1xuZXhwb3J0IGNsYXNzIENvbnNvbGVTaW5rIHtcbiAgICBjb25zdHJ1Y3RvcigkY29uc29sZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uYWxQYXJhbXMgPSBldmVudC5vcHRpb25hbFBhcmFtcztcbiAgICAgICAgICAgIGlmIChvcHRpb25hbFBhcmFtcyA9PT0gdm9pZCAwIHx8IG9wdGlvbmFsUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIHRyYWNlICovOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogZGVidWcgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnNvbGUuZGVidWcoZXZlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBpbmZvICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb25zb2xlLmluZm8oZXZlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiB3YXJuICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb25zb2xlLndhcm4oZXZlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBlcnJvciAqLzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1IC8qIGZhdGFsICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb25zb2xlLmVycm9yKGV2ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIHRyYWNlICovOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogZGVidWcgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnNvbGUuZGVidWcoZXZlbnQudG9TdHJpbmcoKSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogaW5mbyAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29uc29sZS5pbmZvKGV2ZW50LnRvU3RyaW5nKCksIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIHdhcm4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnNvbGUud2FybihldmVudC50b1N0cmluZygpLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBlcnJvciAqLzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1IC8qIGZhdGFsICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb25zb2xlLmVycm9yKGV2ZW50LnRvU3RyaW5nKCksIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IERlZmF1bHRMb2dnZXIgPSBjbGFzcyBEZWZhdWx0TG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgZ2xvYmFsIGxvZ2dlciBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIGNvbmZpZywgZmFjdG9yeSwgc2lua3MsIFxuICAgIC8qKlxuICAgICAqIFRoZSBzY29wZXMgdGhhdCB0aGlzIGxvZ2dlciB3YXMgY3JlYXRlZCBmb3IsIGlmIGFueS5cbiAgICAgKi9cbiAgICBzY29wZSA9IFtdLCBwYXJlbnQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuc2NvcGVkTG9nZ2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCB0cmFjZVNpbmtzO1xuICAgICAgICBsZXQgZGVidWdTaW5rcztcbiAgICAgICAgbGV0IGluZm9TaW5rcztcbiAgICAgICAgbGV0IHdhcm5TaW5rcztcbiAgICAgICAgbGV0IGVycm9yU2lua3M7XG4gICAgICAgIGxldCBmYXRhbFNpbmtzO1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdHJhY2VTaW5rcyA9IHRoaXMudHJhY2VTaW5rcyA9IFtdO1xuICAgICAgICAgICAgZGVidWdTaW5rcyA9IHRoaXMuZGVidWdTaW5rcyA9IFtdO1xuICAgICAgICAgICAgaW5mb1NpbmtzID0gdGhpcy5pbmZvU2lua3MgPSBbXTtcbiAgICAgICAgICAgIHdhcm5TaW5rcyA9IHRoaXMud2FyblNpbmtzID0gW107XG4gICAgICAgICAgICBlcnJvclNpbmtzID0gdGhpcy5lcnJvclNpbmtzID0gW107XG4gICAgICAgICAgICBmYXRhbFNpbmtzID0gdGhpcy5mYXRhbFNpbmtzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0ICRzaW5rIG9mIHNpbmtzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcyA9IExvZ2dlclNpbmsuZ2V0SGFuZGxlcygkc2luayk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXM/LmluY2x1ZGVzKDAgLyogdHJhY2UgKi8pID8/IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VTaW5rcy5wdXNoKCRzaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXM/LmluY2x1ZGVzKDEgLyogZGVidWcgKi8pID8/IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdTaW5rcy5wdXNoKCRzaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXM/LmluY2x1ZGVzKDIgLyogaW5mbyAqLykgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvU2lua3MucHVzaCgkc2luayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVzPy5pbmNsdWRlcygzIC8qIHdhcm4gKi8pID8/IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FyblNpbmtzLnB1c2goJHNpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcz8uaW5jbHVkZXMoNCAvKiBlcnJvciAqLykgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvclNpbmtzLnB1c2goJHNpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcz8uaW5jbHVkZXMoNSAvKiBmYXRhbCAqLykgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmYXRhbFNpbmtzLnB1c2goJHNpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcmVudC5yb290O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0cmFjZVNpbmtzID0gdGhpcy50cmFjZVNpbmtzID0gcGFyZW50LnRyYWNlU2lua3M7XG4gICAgICAgICAgICBkZWJ1Z1NpbmtzID0gdGhpcy5kZWJ1Z1NpbmtzID0gcGFyZW50LmRlYnVnU2lua3M7XG4gICAgICAgICAgICBpbmZvU2lua3MgPSB0aGlzLmluZm9TaW5rcyA9IHBhcmVudC5pbmZvU2lua3M7XG4gICAgICAgICAgICB3YXJuU2lua3MgPSB0aGlzLndhcm5TaW5rcyA9IHBhcmVudC53YXJuU2lua3M7XG4gICAgICAgICAgICBlcnJvclNpbmtzID0gdGhpcy5lcnJvclNpbmtzID0gcGFyZW50LmVycm9yU2lua3M7XG4gICAgICAgICAgICBmYXRhbFNpbmtzID0gdGhpcy5mYXRhbFNpbmtzID0gcGFyZW50LmZhdGFsU2lua3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2UobWVzc2FnZU9yR2V0TWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxldmVsIDw9IDAgLyogdHJhY2UgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLnRyYWNlU2lua3MsIDAgLyogdHJhY2UgKi8sIG1lc3NhZ2VPckdldE1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWJ1ZyhtZXNzYWdlT3JHZXRNZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubGV2ZWwgPD0gMSAvKiBkZWJ1ZyAqLykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZGVidWdTaW5rcywgMSAvKiBkZWJ1ZyAqLywgbWVzc2FnZU9yR2V0TWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluZm8obWVzc2FnZU9yR2V0TWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxldmVsIDw9IDIgLyogaW5mbyAqLykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuaW5mb1NpbmtzLCAyIC8qIGluZm8gKi8sIG1lc3NhZ2VPckdldE1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXJuKG1lc3NhZ2VPckdldE1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5sZXZlbCA8PSAzIC8qIHdhcm4gKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLndhcm5TaW5rcywgMyAvKiB3YXJuICovLCBtZXNzYWdlT3JHZXRNZXNzYWdlLCBvcHRpb25hbFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZU9yR2V0TWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxldmVsIDw9IDQgLyogZXJyb3IgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmVycm9yU2lua3MsIDQgLyogZXJyb3IgKi8sIG1lc3NhZ2VPckdldE1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmYXRhbChtZXNzYWdlT3JHZXRNZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubGV2ZWwgPD0gNSAvKiBmYXRhbCAqLykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZmF0YWxTaW5rcywgNSAvKiBmYXRhbCAqLywgbWVzc2FnZU9yR2V0TWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBsb2dnZXIgd2l0aCBhbiBhZGRpdGlvbmFsIHBlcm1hbmVudCBwcmVmaXggYWRkZWQgdG8gdGhlIGxvZ2dpbmcgb3V0cHV0cy5cbiAgICAgKiBXaGVuIGNoYWluZWQsIG11bHRpcGxlIHNjb3BlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgZG90LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBwcmVsaW1pbmFyeSBBUEkgYW5kIHN1YmplY3QgdG8gY2hhbmdlIGJlZm9yZSBhbHBoYSByZWxlYXNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKEBJTG9nZ2VyIHByaXZhdGUgbG9nZ2VyOiBJTG9nZ2VyKSB7XG4gICAgICogICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdiZWZvcmUgc2NvcGluZycpO1xuICAgICAqICAgICAvLyBjb25zb2xlIG91dHB1dDogJ1tEQkddIGJlZm9yZSBzY29waW5nJ1xuICAgICAqICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlci5zY29wZVRvKCdNeUNvbXBvbmVudCcpO1xuICAgICAqICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnYWZ0ZXIgc2NvcGluZycpO1xuICAgICAqICAgICAvLyBjb25zb2xlIG91dHB1dDogJ1tEQkcgTXlDb21wb25lbnRdIGFmdGVyIHNjb3BpbmcnXG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIHB1YmxpYyBkb1N0dWZmKCk6IHZvaWQge1xuICAgICAqICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlci5zY29wZVRvKCdkb1N0dWZmKCknKTtcbiAgICAgKiAgICAgbG9nZ2VyLmRlYnVnKCdkb2luZyBzdHVmZicpO1xuICAgICAqICAgICAvLyBjb25zb2xlIG91dHB1dDogJ1tEQkcgTXlDb21wb25lbnQuZG9TdHVmZigpXSBkb2luZyBzdHVmZidcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2NvcGVUbyhuYW1lKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZExvZ2dlcnMgPSB0aGlzLnNjb3BlZExvZ2dlcnM7XG4gICAgICAgIGxldCBzY29wZWRMb2dnZXIgPSBzY29wZWRMb2dnZXJzW25hbWVdO1xuICAgICAgICBpZiAoc2NvcGVkTG9nZ2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNjb3BlZExvZ2dlciA9IHNjb3BlZExvZ2dlcnNbbmFtZV0gPSBuZXcgRGVmYXVsdExvZ2dlcih0aGlzLmNvbmZpZywgdGhpcy5mYWN0b3J5LCAodm9pZCAwKSwgdGhpcy5zY29wZS5jb25jYXQobmFtZSksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZWRMb2dnZXI7XG4gICAgfVxuICAgIGVtaXQoc2lua3MsIGxldmVsLCBtc2dPckdldE1zZywgb3B0aW9uYWxQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBtc2dPckdldE1zZyA9PT0gJ2Z1bmN0aW9uJyA/IG1zZ09yR2V0TXNnKCkgOiBtc2dPckdldE1zZztcbiAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmZhY3RvcnkuY3JlYXRlTG9nRXZlbnQodGhpcywgbGV2ZWwsIG1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2lua3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgc2lua3NbaV0uaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJvdW5kXG5dLCBEZWZhdWx0TG9nZ2VyLnByb3RvdHlwZSwgXCJ0cmFjZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJvdW5kXG5dLCBEZWZhdWx0TG9nZ2VyLnByb3RvdHlwZSwgXCJkZWJ1Z1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJvdW5kXG5dLCBEZWZhdWx0TG9nZ2VyLnByb3RvdHlwZSwgXCJpbmZvXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgYm91bmRcbl0sIERlZmF1bHRMb2dnZXIucHJvdG90eXBlLCBcIndhcm5cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBib3VuZFxuXSwgRGVmYXVsdExvZ2dlci5wcm90b3R5cGUsIFwiZXJyb3JcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBib3VuZFxuXSwgRGVmYXVsdExvZ2dlci5wcm90b3R5cGUsIFwiZmF0YWxcIiwgbnVsbCk7XG5EZWZhdWx0TG9nZ2VyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJTG9nQ29uZmlnKSxcbiAgICBfX3BhcmFtKDEsIElMb2dFdmVudEZhY3RvcnkpLFxuICAgIF9fcGFyYW0oMiwgYWxsKElTaW5rKSksXG4gICAgX19wYXJhbSgzLCBvcHRpb25hbChJTG9nU2NvcGVzKSksXG4gICAgX19wYXJhbSg0LCBpZ25vcmUpXG5dLCBEZWZhdWx0TG9nZ2VyKTtcbmV4cG9ydCB7IERlZmF1bHRMb2dnZXIgfTtcbi8qKlxuICogQSBiYXNpYyBgSUxvZ2dlcmAgY29uZmlndXJhdGlvbiB0aGF0IGNvbmZpZ3VyZXMgYSBzaW5nbGUgYGNvbnNvbGVgIHNpbmsgYmFzZWQgb24gcHJvdmlkZWQgb3B0aW9ucy5cbiAqXG4gKiBOT1RFOiBZb3UgKm11c3QqIHJlZ2lzdGVyIHRoZSByZXR1cm4gdmFsdWUgb2YgYC5jcmVhdGVgIHdpdGggdGhlIGNvbnRhaW5lciAvIGF1IGluc3RhbmNlLCBub3QgdGhpcyBgTG9nZ2VyQ29uZmlndXJhdGlvbmAgb2JqZWN0IGl0c2VsZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnRhaW5lci5yZWdpc3RlcihMb2dnZXJDb25maWd1cmF0aW9uLmNyZWF0ZSgpKTtcbiAqXG4gKiBjb250YWluZXIucmVnaXN0ZXIoTG9nZ2VyQ29uZmlndXJhdGlvbi5jcmVhdGUoeyRjb25zb2xlOiBjb25zb2xlfSkpXG4gKlxuICogY29udGFpbmVyLnJlZ2lzdGVyKExvZ2dlckNvbmZpZ3VyYXRpb24uY3JlYXRlKHskY29uc29sZTogY29uc29sZSwgbGV2ZWw6IExvZ0xldmVsLmRlYnVnfSkpXG4gKlxuICogY29udGFpbmVyLnJlZ2lzdGVyKExvZ2dlckNvbmZpZ3VyYXRpb24uY3JlYXRlKHtcbiAqICAkY29uc29sZToge1xuICogICAgIGRlYnVnOiBub29wLFxuICogICAgIGluZm86IG5vb3AsXG4gKiAgICAgd2Fybjogbm9vcCxcbiAqICAgICBlcnJvcjogbXNnID0+IHtcbiAqICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICogICAgIH1cbiAqICB9LFxuICogIGxldmVsOiBMb2dMZXZlbC5kZWJ1Z1xuICogfSkpXG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBMb2dnZXJDb25maWd1cmF0aW9uID0gdG9Mb29rdXAoe1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAkY29uc29sZSAtIFRoZSBgY29uc29sZWAgb2JqZWN0IHRvIHVzZS4gQ2FuIGJlIHRoZSBuYXRpdmUgYHdpbmRvdy5jb25zb2xlYCAvIGBnbG9iYWwuY29uc29sZWAsIGJ1dCBjYW4gYWxzbyBiZSBhIHdyYXBwZXIgb3IgbW9jayB0aGF0IGltcGxlbWVudHMgdGhlIHNhbWUgaW50ZXJmYWNlLlxuICAgICAqIEBwYXJhbSBsZXZlbCAtIFRoZSBnbG9iYWwgYExvZ0xldmVsYCB0byBjb25maWd1cmUuIERlZmF1bHRzIHRvIGB3YXJuYCBvciBoaWdoZXIuXG4gICAgICogQHBhcmFtIGNvbG9yT3B0aW9ucyAtIFdoZXRoZXIgdG8gdXNlIGNvbG9ycyBvciBub3QuIERlZmF1bHRzIHRvIGBub0NvbG9yc2AuIENvbG9ycyBhcmUgZXNwZWNpYWxseSBuaWNlIGluIG5vZGVqcyBlbnZpcm9ubWVudHMgYnV0IGRvbid0IG5lY2Vzc2FyaWx5IHdvcmsgKHdlbGwpIGluIGFsbCBlbnZpcm9ubWVudHMsIHN1Y2ggYXMgYnJvd3NlcnMuXG4gICAgICovXG4gICAgY3JlYXRlKHsgJGNvbnNvbGUsIGxldmVsID0gMyAvKiB3YXJuICovLCBjb2xvck9wdGlvbnMgPSAwIC8qIG5vQ29sb3JzICovLCBzaW5rcyA9IFtdLCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRvTG9va3VwKHtcbiAgICAgICAgICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlcihSZWdpc3RyYXRpb24uaW5zdGFuY2UoSUxvZ0NvbmZpZywgbmV3IExvZ0NvbmZpZyhjb2xvck9wdGlvbnMsIGxldmVsKSkpO1xuICAgICAgICAgICAgICAgIGlmICgkY29uc29sZSAhPT0gdm9pZCAwICYmICRjb25zb2xlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlcihSZWdpc3RyYXRpb24uaW5zdGFuY2UoSVNpbmssIG5ldyBDb25zb2xlU2luaygkY29uc29sZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCAkc2luayBvZiBzaW5rcykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihJU2luaywgJHNpbmspKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0sXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlci5qcy5tYXAiLCJpbXBvcnQgeyBESSB9IGZyb20gJy4vZGkuanMnO1xuaW1wb3J0IHsgZW1wdHlBcnJheSB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgUHJvdG9jb2wgfSBmcm9tICcuL3Jlc291cmNlLmpzJztcbmV4cG9ydCBjb25zdCBJTW9kdWxlTG9hZGVyID0gREkuY3JlYXRlSW50ZXJmYWNlKHggPT4geC5zaW5nbGV0b24oTW9kdWxlTG9hZGVyKSk7XG5mdW5jdGlvbiBub1RyYW5zZm9ybShtKSB7XG4gICAgcmV0dXJuIG07XG59XG5jbGFzcyBNb2R1bGVUcmFuc2Zvcm1lciB7XG4gICAgY29uc3RydWN0b3IoJHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLiR0cmFuc2Zvcm0gPSAkdHJhbnNmb3JtO1xuICAgICAgICB0aGlzLnByb21pc2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5vYmplY3RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKG9iak9yUHJvbWlzZSkge1xuICAgICAgICBpZiAob2JqT3JQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUHJvbWlzZShvYmpPclByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmpPclByb21pc2UgPT09ICdvYmplY3QnICYmIG9iak9yUHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtT2JqZWN0KG9iak9yUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5wdXQ6ICR7U3RyaW5nKG9iak9yUHJvbWlzZSl9LiBFeHBlY3RlZCBQcm9taXNlIG9yIE9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm1Qcm9taXNlKHByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZUNhY2hlLmhhcyhwcm9taXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZUNhY2hlLmdldChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBwcm9taXNlLnRoZW4ob2JqID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU9iamVjdChvYmopO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9taXNlQ2FjaGUuc2V0KHByb21pc2UsIHJldCk7XG4gICAgICAgIHZvaWQgcmV0LnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgLy8gbWFrZSBpdCBzeW5jaHJvbm91cyBmb3IgZnV0dXJlIHJlcXVlc3RzXG4gICAgICAgICAgICB0aGlzLnByb21pc2VDYWNoZS5zZXQocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdHJhbnNmb3JtT2JqZWN0KG9iaikge1xuICAgICAgICBpZiAodGhpcy5vYmplY3RDYWNoZS5oYXMob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0Q2FjaGUuZ2V0KG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy4kdHJhbnNmb3JtKHRoaXMuYW5hbHl6ZShvYmopKTtcbiAgICAgICAgdGhpcy5vYmplY3RDYWNoZS5zZXQob2JqLCByZXQpO1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgdm9pZCByZXQudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBpdCBzeW5jaHJvbm91cyBmb3IgZnV0dXJlIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RDYWNoZS5zZXQob2JqLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhbmFseXplKG0pIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBsZXQgaXNSZWdpc3RyeTtcbiAgICAgICAgbGV0IGlzQ29uc3RydWN0YWJsZTtcbiAgICAgICAgbGV0IGRlZmluaXRpb25zO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUgPSBtW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc1JlZ2lzdHJ5ID0gdHlwZW9mIHZhbHVlLnJlZ2lzdGVyID09PSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgICBpc0NvbnN0cnVjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnMgPSBlbXB0eUFycmF5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGlzUmVnaXN0cnkgPSB0eXBlb2YgdmFsdWUucmVnaXN0ZXIgPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIGlzQ29uc3RydWN0YWJsZSA9IHZhbHVlLnByb3RvdHlwZSAhPT0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9ucyA9IFByb3RvY29sLnJlc291cmNlLmdldEFsbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMucHVzaChuZXcgTW9kdWxlSXRlbShrZXksIHZhbHVlLCBpc1JlZ2lzdHJ5LCBpc0NvbnN0cnVjdGFibGUsIGRlZmluaXRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbmFseXplZE1vZHVsZShtLCBpdGVtcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vZHVsZUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBsb2FkKG9iak9yUHJvbWlzZSwgdHJhbnNmb3JtID0gbm9UcmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXJzID0gdGhpcy50cmFuc2Zvcm1lcnM7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVycy5nZXQodHJhbnNmb3JtKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVycy5zZXQodHJhbnNmb3JtLCB0cmFuc2Zvcm1lciA9IG5ldyBNb2R1bGVUcmFuc2Zvcm1lcih0cmFuc2Zvcm0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtKG9iak9yUHJvbWlzZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXJzLmNsZWFyKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFuYWx5emVkTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcsIGl0ZW1zKSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3O1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vZHVsZUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGlzUmVnaXN0cnksIGlzQ29uc3RydWN0YWJsZSwgZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pc1JlZ2lzdHJ5ID0gaXNSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGFibGUgPSBpc0NvbnN0cnVjdGFibGU7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUtbG9hZGVyLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5leHBvcnQgY29uc3QgZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pO1xuZXhwb3J0IGNvbnN0IGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm0uanMubWFwIiwiaW1wb3J0IHsgTWV0YWRhdGEgfSBmcm9tICdAYXVyZWxpYS9tZXRhZGF0YSc7XG5pbXBvcnQgeyBlbXB0eUFycmF5IH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5jb25zdCBhbm5vdGF0aW9uID0ge1xuICAgIG5hbWU6ICdhdTphbm5vdGF0aW9uJyxcbiAgICBhcHBlbmRUbyh0YXJnZXQsIGtleSkge1xuICAgICAgICBjb25zdCBrZXlzID0gTWV0YWRhdGEuZ2V0T3duKGFubm90YXRpb24ubmFtZSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKGFubm90YXRpb24ubmFtZSwgW2tleV0sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKGFubm90YXRpb24ua2V5Rm9yKHByb3ApLCB2YWx1ZSwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLmdldE93bihhbm5vdGF0aW9uLmtleUZvcihwcm9wKSwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIGdldEtleXModGFyZ2V0KSB7XG4gICAgICAgIGxldCBrZXlzID0gTWV0YWRhdGEuZ2V0T3duKGFubm90YXRpb24ubmFtZSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKGFubm90YXRpb24ubmFtZSwga2V5cyA9IFtdLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH0sXG4gICAgaXNLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkuc3RhcnRzV2l0aChhbm5vdGF0aW9uLm5hbWUpO1xuICAgIH0sXG4gICAga2V5Rm9yKG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2Fubm90YXRpb24ubmFtZX06JHtuYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Fubm90YXRpb24ubmFtZX06JHtuYW1lfToke2NvbnRleHR9YDtcbiAgICB9LFxufTtcbmNvbnN0IHJlc291cmNlID0ge1xuICAgIG5hbWU6ICdhdTpyZXNvdXJjZScsXG4gICAgYXBwZW5kVG8odGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE1ldGFkYXRhLmdldE93bihyZXNvdXJjZS5uYW1lLCB0YXJnZXQpO1xuICAgICAgICBpZiAoa2V5cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUocmVzb3VyY2UubmFtZSwgW2tleV0sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGFzKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuaGFzT3duKHJlc291cmNlLm5hbWUsIHRhcmdldCk7XG4gICAgfSxcbiAgICBnZXRBbGwodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBNZXRhZGF0YS5nZXRPd24ocmVzb3VyY2UubmFtZSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5tYXAoayA9PiBNZXRhZGF0YS5nZXRPd24oaywgdGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEtleXModGFyZ2V0KSB7XG4gICAgICAgIGxldCBrZXlzID0gTWV0YWRhdGEuZ2V0T3duKHJlc291cmNlLm5hbWUsIHRhcmdldCk7XG4gICAgICAgIGlmIChrZXlzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShyZXNvdXJjZS5uYW1lLCBrZXlzID0gW10sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSxcbiAgICBpc0tleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKHJlc291cmNlLm5hbWUpO1xuICAgIH0sXG4gICAga2V5Rm9yKG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3Jlc291cmNlLm5hbWV9OiR7bmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtyZXNvdXJjZS5uYW1lfToke25hbWV9OiR7Y29udGV4dH1gO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IFByb3RvY29sID0ge1xuICAgIGFubm90YXRpb24sXG4gICAgcmVzb3VyY2UsXG59O1xuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogVGhlIG9yZGVyIGluIHdoaWNoIHRoZSB2YWx1ZXMgYXJlIGNoZWNrZWQ6XG4gKiAxLiBBbm5vdGF0aW9ucyAodXN1YWxseSBzZXQgYnkgZGVjb3JhdG9ycykgaGF2ZSB0aGUgaGlnaGVzdCBwcmlvcml0eTsgdGhleSBvdmVycmlkZSB0aGUgZGVmaW5pdGlvbiBhcyB3ZWxsIGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9uIHRoZSB0eXBlLlxuICogMi4gRGVmaW5pdGlvbiBwcm9wZXJ0aWVzICh1c3VhbGx5IHNldCBieSB0aGUgY3VzdG9tRWxlbWVudCBkZWNvcmF0b3Igb2JqZWN0IGxpdGVyYWwpIGNvbWUgbmV4dC4gVGhleSBvdmVycmlkZSBzdGF0aWMgcHJvcGVydGllcyBvbiB0aGUgdHlwZS5cbiAqIDMuIFN0YXRpYyBwcm9wZXJ0aWVzIG9uIHRoZSB0eXBlIGNvbWUgbGFzdC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgbG9vayB1cCB0aGUgcHJvdG90eXBlIGNoYWluIChiaW5kYWJsZXMgYXJlIGFuIGV4Y2VwdGlvbiBoZXJlLCBidXQgd2UgZG8gdGhhdCBkaWZmZXJlbnRseSBhbnl3YXkpXG4gKiA0LiBUaGUgZGVmYXVsdCBwcm9wZXJ0eSB0aGF0IGlzIHByb3ZpZGVkIGxhc3QuIFRoZSBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGUgZGVmYXVsdCBwcm9wZXJ0eSBpcyBuZWVkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0KG5hbWUsIGRlZiwgVHlwZSwgZ2V0RGVmYXVsdCkge1xuICAgIGxldCB2YWx1ZSA9IE1ldGFkYXRhLmdldE93bihQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcihuYW1lKSwgVHlwZSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFsdWUgPSBkZWZbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFR5cGVbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCAhaGFzT3duLmNhbGwoVHlwZSwgbmFtZSkpIHsgLy8gRmlyc3QganVzdCBjaGVjayB0aGUgdmFsdWUgKGNvbW1vbiBjYXNlIGlzIGZhc3RlciksIGJ1dCBkbyBtYWtlIHN1cmUgaXQgZG9lc24ndCBjb21lIGZyb20gdGhlIHByb3RvIGNoYWluXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogVGhlIG9yZGVyIGluIHdoaWNoIHRoZSB2YWx1ZXMgYXJlIGNoZWNrZWQ6XG4gKiAxLiBBbm5vdGF0aW9ucyAodXN1YWxseSBzZXQgYnkgZGVjb3JhdG9ycykgaGF2ZSB0aGUgaGlnaGVzdCBwcmlvcml0eTsgdGhleSBvdmVycmlkZSBzdGF0aWMgcHJvcGVydGllcyBvbiB0aGUgdHlwZS5cbiAqIDIuIFN0YXRpYyBwcm9wZXJ0aWVzIG9uIHRoZSB0eXAuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGxvb2sgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiAoYmluZGFibGVzIGFyZSBhbiBleGNlcHRpb24gaGVyZSwgYnV0IHdlIGRvIHRoYXQgZGlmZmVyZW50bHkgYW55d2F5KVxuICogMy4gVGhlIGRlZmF1bHQgcHJvcGVydHkgdGhhdCBpcyBwcm92aWRlZCBsYXN0LiBUaGUgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhlIGRlZmF1bHQgcHJvcGVydHkgaXMgbmVlZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdChuYW1lLCBUeXBlLCBnZXREZWZhdWx0KSB7XG4gICAgbGV0IHZhbHVlID0gTWV0YWRhdGEuZ2V0T3duKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKG5hbWUpLCBUeXBlKTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICB2YWx1ZSA9IFR5cGVbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8ICFoYXNPd24uY2FsbChUeXBlLCBuYW1lKSkgeyAvLyBGaXJzdCBqdXN0IGNoZWNrIHRoZSB2YWx1ZSAoY29tbW9uIGNhc2UgaXMgZmFzdGVyKSwgYnV0IGRvIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGNvbWUgZnJvbSB0aGUgcHJvdG8gY2hhaW5cbiAgICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkOlxuICogMS4gRGVmaW5pdGlvbiBwcm9wZXJ0aWVzLlxuICogMi4gVGhlIGRlZmF1bHQgcHJvcGVydHkgdGhhdCBpcyBwcm92aWRlZCBsYXN0LiBUaGUgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhlIGRlZmF1bHQgcHJvcGVydHkgaXMgbmVlZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdChuYW1lLCBkZWYsIGdldERlZmF1bHQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGRlZltuYW1lXTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvdXJjZS5qcy5tYXAiLCIvKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICpcbiAqIFVzZXMgYHR5cGVvZmAgdG8gZ3VhcmFudGVlIHRoaXMgd29ya3MgY3Jvc3MtcmVhbG0sIHdoaWNoIGlzIHdoZXJlIGBpbnN0YW5jZW9mIE9iamVjdGAgbWlnaHQgZmFpbC5cbiAqXG4gKiBTb21lIGVudmlyb25tZW50cyB3aGVyZSB0aGVzZSBpc3N1ZXMgYXJlIGtub3duIHRvIGFyaXNlOlxuICogLSBzYW1lLW9yaWdpbiBpZnJhbWVzIChhY2Nlc3NpbmcgdGhlIG90aGVyIHJlYWxtIHZpYSBgd2luZG93LnRvcGApXG4gKiAtIGBqZXN0YC5cbiAqXG4gKiBUaGUgZXhhY3QgdGVzdCBpczpcbiAqIGBgYHRzXG4gKiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKiBBbHNvIHBlcmZvcm1zIGEgdHlwZSBhc3NlcnRpb24gdGhhdCBkZWZhdWx0cyB0byBgdmFsdWUgaXMgT2JqZWN0IHwgRnVuY3Rpb25gIHdoaWNoLCBpZiB0aGUgaW5wdXQgdHlwZSBpcyBhIHVuaW9uIHdpdGggYW4gb2JqZWN0IHR5cGUsIHdpbGwgaW5mZXIgdGhlIGNvcnJlY3QgdHlwZS5cbiAqIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgZ2VuZXJpYyB0eXBlIGFyZ3VtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEZvbyB7XG4gKiAgIGJhciA9IDQyO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIGRvU3R1ZmYoaW5wdXQ/OiBGb28gfCBudWxsKSB7XG4gKiAgIGlucHV0LmJhcjsgLy8gT2JqZWN0IGlzIHBvc3NpYmx5ICdudWxsJyBvciAndW5kZWZpbmVkJ1xuICpcbiAqICAgLy8gaW5wdXQgaGFzIGFuIG9iamVjdCB0eXBlIGluIGl0cyB1bmlvbiAoRm9vKSBzbyB0aGF0IHR5cGUgd2lsbCBiZSBleHRyYWN0ZWQgZm9yIHRoZSAndHJ1ZScgY29uZGl0aW9uXG4gKiAgIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAqICAgICBpbnB1dC5iYXI7IC8vIE9LIChpbnB1dCBpcyBub3cgdHlwZWQgYXMgRm9vKVxuICogICB9XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gZG9PdGhlclN0dWZmKGlucHV0OiB1bmtub3duKSB7XG4gKiAgIGlucHV0LmJhcjsgLy8gT2JqZWN0IGlzIG9mIHR5cGUgJ3Vua25vd24nXG4gKlxuICogICAvLyBpbnB1dCBpcyAndW5rbm93bicgc28gdGhlcmUgaXMgbm8gdW5pb24gdHlwZSB0byBtYXRjaCBhbmQgaXQgd2lsbCBkZWZhdWx0IHRvICdPYmplY3QgfCBGdW5jdGlvbidcbiAqICAgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICogICAgIGlucHV0LmJhcjsgLy8gUHJvcGVydHkgJ2JhcicgZG9lcyBub3QgZXhpc3Qgb24gdHlwZSAnT2JqZWN0IHwgRnVuY3Rpb24nXG4gKiAgIH1cbiAqXG4gKiAgIC8vIGlmIHdlIGtub3cgZm9yIHN1cmUgdGhhdCwgaWYgaW5wdXQgaXMgYW4gb2JqZWN0LCBpdCBtdXN0IGJlIGEgc3BlY2lmaWMgdHlwZSwgd2UgY2FuIGV4cGxpY2l0bHkgdGVsbCB0aGUgZnVuY3Rpb24gdG8gYXNzZXJ0IHRoYXQgZm9yIHVzXG4gKiAgIGlmIChpc09iamVjdDxGb28+KGlucHV0KSkge1xuICogICAgaW5wdXQuYmFyOyAvLyBPSyAoaW5wdXQgaXMgbm93IHR5cGVkIGFzIEZvbylcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQWxzbyBwZXJmb3JtcyBhIHR5cGUgYXNzZXJ0aW9uIHRoYXQgZW5zdXJlcyBUeXBlU2NyaXB0IHRyZWF0cyB0aGUgdmFsdWUgYXBwcm9wcmlhdGVseSBpbiB0aGUgYGlmYCBhbmQgYGVsc2VgIGJyYW5jaGVzIGFmdGVyIHRoaXMgY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwO1xufVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlcyAqL1xuY29uc3QgbWV0YWRhdGFJbnRlcm5hbFNsb3QgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJHR5cGVFcnJvcihvcGVyYXRpb24sIGFyZ3MsIHBhcmFtTmFtZSwgYWN0dWFsVmFsdWUsIGV4cGVjdGVkVHlwZSkge1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGAke29wZXJhdGlvbn0oJHthcmdzLm1hcChTdHJpbmcpLmpvaW4oJywnKX0pIC0gRXhwZWN0ZWQgJyR7cGFyYW1OYW1lfScgdG8gYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZX0sIGJ1dCBnb3Q6ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFjdHVhbFZhbHVlKX0gKCR7U3RyaW5nKGFjdHVhbFZhbHVlKX0pYCk7XG59XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wZXJ0eUtleSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5S2V5O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGAke3Byb3BlcnR5S2V5fWA7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlLZXk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJvcGVydHlLZXl9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVQcm9wZXJ0eUtleU9yVW5kZWZpbmVkKHByb3BlcnR5S2V5KSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUtleTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbWV0YWRhdGEgcHJvcGVydHlLZXk6ICR7cHJvcGVydHlLZXl9LmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgQ3JlYXRlKSB7XG4gICAgLy8gMS4gQXNzZXJ0OiBQIGlzIHVuZGVmaW5lZCBvciBJc1Byb3BlcnR5S2V5KFApIGlzIHRydWUuXG4gICAgLy8gMi4gTGV0IHRhcmdldE1ldGFkYXRhIGJlIHRoZSB2YWx1ZSBvZiBPJ3MgW1tNZXRhZGF0YV1dIGludGVybmFsIHNsb3QuXG4gICAgbGV0IHRhcmdldE1ldGFkYXRhID0gbWV0YWRhdGFJbnRlcm5hbFNsb3QuZ2V0KE8pO1xuICAgIC8vIDMuIElmIHRhcmdldE1ldGFkYXRhIGlzIHVuZGVmaW5lZCwgdGhlblxuICAgIGlmICh0YXJnZXRNZXRhZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIC8vIDMuIGEuIElmIENyZWF0ZSBpcyBmYWxzZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKCFDcmVhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gYi4gU2V0IHRhcmdldE1ldGFkYXRhIHRvIGJlIGEgbmV3bHkgY3JlYXRlZCBNYXAgb2JqZWN0LlxuICAgICAgICB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gMy4gYy4gU2V0IHRoZSBbW01ldGFkYXRhXV0gaW50ZXJuYWwgc2xvdCBvZiBPIHRvIHRhcmdldE1ldGFkYXRhLlxuICAgICAgICBtZXRhZGF0YUludGVybmFsU2xvdC5zZXQoTywgdGFyZ2V0TWV0YWRhdGEpO1xuICAgIH1cbiAgICAvLyA0LiBMZXQgbWV0YWRhdGFNYXAgYmUgPyBJbnZva2UodGFyZ2V0TWV0YWRhdGEsIFwiZ2V0XCIsIFApLlxuICAgIGxldCBtZXRhZGF0YU1hcCA9IHRhcmdldE1ldGFkYXRhLmdldChQKTtcbiAgICAvLyA1LiBJZiBtZXRhZGF0YU1hcCBpcyB1bmRlZmluZWQsIHRoZW5cbiAgICBpZiAobWV0YWRhdGFNYXAgPT09IHZvaWQgMCkge1xuICAgICAgICAvLyA1LiBhLiBJZiBDcmVhdGUgaXMgZmFsc2UsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgIGlmICghQ3JlYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIDUuIGIuIFNldCBtZXRhZGF0YU1hcCB0byBiZSBhIG5ld2x5IGNyZWF0ZWQgTWFwIG9iamVjdC5cbiAgICAgICAgbWV0YWRhdGFNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIDUuIGMuIFBlcmZvcm0gPyBJbnZva2UodGFyZ2V0TWV0YWRhdGEsIFwic2V0XCIsIFAsIG1ldGFkYXRhTWFwKS5cbiAgICAgICAgdGFyZ2V0TWV0YWRhdGEuc2V0KFAsIG1ldGFkYXRhTWFwKTtcbiAgICB9XG4gICAgLy8gNi4gUmV0dXJuIG1ldGFkYXRhTWFwLlxuICAgIHJldHVybiBtZXRhZGF0YU1hcDtcbn1cbi8vIDMuMS4yLjEgT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbi8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcbmZ1bmN0aW9uIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgbWV0YWRhdGFNYXAgYmUgPyBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKS5cbiAgICBjb25zdCBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLyogQ3JlYXRlICovIGZhbHNlKTtcbiAgICAvLyAzLiBJZiBtZXRhZGF0YU1hcCBpcyB1bmRlZmluZWQsIHJldHVybiBmYWxzZS5cbiAgICBpZiAobWV0YWRhdGFNYXAgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIDQuIFJldHVybiA/IFRvQm9vbGVhbig/IEludm9rZShtZXRhZGF0YU1hcCwgXCJoYXNcIiwgTWV0YWRhdGFLZXkpKS5cbiAgICByZXR1cm4gbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn1cbi8vIDMuMS4xLjEgT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbi8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzbWV0YWRhdGFcbmZ1bmN0aW9uIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgaGFzT3duIGJlID8gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkuXG4gICAgLy8gMy4gSWYgaGFzT3duIGlzIHRydWUsIHJldHVybiB0cnVlLlxuICAgIGlmIChPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gNC4gTGV0IHBhcmVudCBiZSA/IE8uW1tHZXRQcm90b3R5cGVPZl1dKCkuXG4gICAgY29uc3QgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pO1xuICAgIC8vIDUuIElmIHBhcmVudCBpcyBub3QgbnVsbCwgUmV0dXJuID8gcGFyZW50LltbSGFzTWV0YWRhdGFdXShNZXRhZGF0YUtleSwgUCkuXG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKTtcbiAgICB9XG4gICAgLy8gNi4gUmV0dXJuIGZhbHNlLlxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIDMuMS40LjEgT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbi8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0b3dubWV0YWRhdGFcbmZ1bmN0aW9uIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgbWV0YWRhdGFNYXAgYmUgPyBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKS5cbiAgICBjb25zdCBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLyogQ3JlYXRlICovIGZhbHNlKTtcbiAgICAvLyAzLiBJZiBtZXRhZGF0YU1hcCBpcyB1bmRlZmluZWQsIHJldHVybiB1bmRlZmluZWQuXG4gICAgaWYgKG1ldGFkYXRhTWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgLy8gNC4gUmV0dXJuID8gSW52b2tlKG1ldGFkYXRhTWFwLCBcImdldFwiLCBNZXRhZGF0YUtleSkuXG4gICAgcmV0dXJuIG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59XG4vLyAzLjEuMy4xIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4vLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXG5mdW5jdGlvbiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gICAgLy8gMS4gQXNzZXJ0OiBQIGlzIHVuZGVmaW5lZCBvciBJc1Byb3BlcnR5S2V5KFApIGlzIHRydWUuXG4gICAgLy8gMi4gTGV0IGhhc093biBiZSA/IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApLlxuICAgIC8vIDMuIElmIGhhc093biBpcyB0cnVlLCByZXR1cm4gPyBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKS5cbiAgICBpZiAoT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkpIHtcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgIH1cbiAgICAvLyA0LiBMZXQgcGFyZW50IGJlID8gTy5bW0dldFByb3RvdHlwZU9mXV0oKS5cbiAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XG4gICAgLy8gNS4gSWYgcGFyZW50IGlzIG5vdCBudWxsLCByZXR1cm4gPyBwYXJlbnQuW1tHZXRNZXRhZGF0YV1dKE1ldGFkYXRhS2V5LCBQKS5cbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xuICAgIH1cbiAgICAvLyA2LiBSZXR1cm4gdW5kZWZpbmVkLlxuICAgIHJldHVybiB2b2lkIDA7XG59XG4vLyAzLjEuNS4xIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApXG4vLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWRlZmluZW93bm1ldGFkYXRhXG5mdW5jdGlvbiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gICAgLy8gMS4gQXNzZXJ0OiBQIGlzIHVuZGVmaW5lZCBvciBJc1Byb3BlcnR5S2V5KFApIGlzIHRydWUuXG4gICAgLy8gMi4gTGV0IG1ldGFkYXRhTWFwIGJlID8gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5cbiAgICBjb25zdCBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLyogQ3JlYXRlICovIHRydWUpO1xuICAgIC8vIDMuIFJldHVybiA/IEludm9rZShtZXRhZGF0YU1hcCwgXCJzZXRcIiwgTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpLlxuICAgIG1ldGFkYXRhTWFwLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59XG4vLyAzLjEuNy4xIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4vLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW93bm1ldGFkYXRha2V5c1xuZnVuY3Rpb24gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkge1xuICAgIC8vIDEuIEFzc2VydDogUCBpcyB1bmRlZmluZWQgb3IgSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICAgIC8vIDIuIExldCBrZXlzIGJlID8gQXJyYXlDcmVhdGUoMCkuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIC8vIDMuIExldCBtZXRhZGF0YU1hcCBiZSA/IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpLlxuICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKiBDcmVhdGUgKi8gZmFsc2UpO1xuICAgIC8vIDQuIElmIG1ldGFkYXRhTWFwIGlzIHVuZGVmaW5lZCwgcmV0dXJuIGtleXMuXG4gICAgaWYgKG1ldGFkYXRhTWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIC8vIDUuIExldCBrZXlzT2JqIGJlID8gSW52b2tlKG1ldGFkYXRhTWFwLCBcImtleXNcIikuXG4gICAgY29uc3Qga2V5c09iaiA9IG1ldGFkYXRhTWFwLmtleXMoKTtcbiAgICAvLyA2LiBMZXQgaXRlcmF0b3IgYmUgPyBHZXRJdGVyYXRvcihrZXlzT2JqKS5cbiAgICAvLyA3LiBMZXQgayBiZSAwLlxuICAgIGxldCBrID0gMDtcbiAgICAvLyA4LiBSZXBlYXRcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzT2JqKSB7XG4gICAgICAgIC8vIDguIGEuIExldCBQayBiZSAhIFRvU3RyaW5nKGspLlxuICAgICAgICAvLyA4LiBiLiBMZXQgbmV4dCBiZSA/IEl0ZXJhdG9yU3RlcChpdGVyYXRvcikuXG4gICAgICAgIC8vIDguIGMuIElmIG5leHQgaXMgZmFsc2UsIHRoZW5cbiAgICAgICAgLy8gOC4gYy4gaS4gTGV0IHNldFN0YXR1cyBiZSA/IFNldChrZXlzLCBcImxlbmd0aFwiLCBrLCB0cnVlKS5cbiAgICAgICAgLy8gOC4gYy4gaWkuIEFzc2VydDogc2V0U3RhdHVzIGlzIHRydWUuXG4gICAgICAgIC8vIDguIGMuIGlpaS4gUmV0dXJuIGtleXMuXG4gICAgICAgIC8vIDguIGQuIExldCBuZXh0VmFsdWUgYmUgPyBJdGVyYXRvclZhbHVlKG5leHQpLlxuICAgICAgICAvLyA4LiBlLiBMZXQgZGVmaW5lU3RhdHVzIGJlIENyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3coa2V5cywgUGssIG5leHRWYWx1ZSkuXG4gICAgICAgIGtleXNba10gPSBrZXk7XG4gICAgICAgIC8vIDguIGYuIElmIGRlZmluZVN0YXR1cyBpcyBhbiBhYnJ1cHQgY29tcGxldGlvbiwgcmV0dXJuID8gSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgZGVmaW5lU3RhdHVzKS5cbiAgICAgICAgLy8gOC4gZy4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICArK2s7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLy8gMy4xLjYuMSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhPLCBQKVxuLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnltZXRhZGF0YWtleXNcbmZ1bmN0aW9uIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgb3duS2V5cyBiZSA/IE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApLlxuICAgIGNvbnN0IG93bktleXMgPSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgICAvLyAzLiBMZXQgcGFyZW50IGJlID8gTy5bW0dldFByb3RvdHlwZU9mXV0oKS5cbiAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XG4gICAgLy8gNC4gSWYgcGFyZW50IGlzIG51bGwsIHRoZW4gcmV0dXJuIG93bktleXMuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb3duS2V5cztcbiAgICB9XG4gICAgLy8gNS4gTGV0IHBhcmVudEtleXMgYmUgPyBPLltbT3JkaW5hcnlNZXRhZGF0YUtleXNdXShQKS5cbiAgICBjb25zdCBwYXJlbnRLZXlzID0gT3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgICAvLyA2LiBMZXQgb3duS2V5c0xlbiA9ID8gR2V0KG93bktleXMsIFwibGVuZ3RoXCIpLlxuICAgIGNvbnN0IG93bktleXNMZW4gPSBvd25LZXlzLmxlbmd0aDtcbiAgICAvLyA3LiBJZiBvd25LZXlzTGVuIGlzIDAsIHJldHVybiBwYXJlbnRLZXlzLlxuICAgIGlmIChvd25LZXlzTGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRLZXlzO1xuICAgIH1cbiAgICAvLyA4LiBMZXQgcGFyZW50S2V5c0xlbiA9ID8gR2V0KHBhcmVudEtleXMsIFwibGVuZ3RoXCIpLlxuICAgIGNvbnN0IHBhcmVudEtleXNMZW4gPSBwYXJlbnRLZXlzLmxlbmd0aDtcbiAgICAvLyA5LiBJZiBwYXJlbnRLZXlzTGVuIGlzIDAsIHJldHVybiBvd25LZXlzLlxuICAgIGlmIChwYXJlbnRLZXlzTGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBvd25LZXlzO1xuICAgIH1cbiAgICAvLyAxMC4gTGV0IHNldCBiZSBhIG5ld2x5IGNyZWF0ZWQgU2V0IG9iamVjdC5cbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gICAgLy8gMTEuIExldCBrZXlzIGJlID8gQXJyYXlDcmVhdGUoMCkuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIC8vIDEyLiBMZXQgayBiZSAwLlxuICAgIGxldCBrID0gMDtcbiAgICAvLyAxMy4gRm9yIGVhY2ggZWxlbWVudCBrZXkgb2Ygb3duS2V5c1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvd25LZXlzTGVuOyArK2kpIHtcbiAgICAgICAga2V5ID0gb3duS2V5c1tpXTtcbiAgICAgICAgLy8gMTMuIGEuIExldCBoYXNLZXkgYmUgPyBJbnZva2Uoc2V0LCBcImhhc1wiLCBrZXkpLlxuICAgICAgICAvLyAxMy4gYi4gSWYgaGFzS2V5IGlzIGZhbHNlLCB0aGVuXG4gICAgICAgIGlmICghc2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyAxMy4gYi4gaS4gTGV0IFBrIGJlICEgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAvLyAxMy4gYi4gaWkuIFBlcmZvcm0gPyBJbnZva2Uoc2V0LCBcImFkZFwiLCBrZXkpLlxuICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgICAgICAgLy8gMTMuIGIuIGlpaS4gTGV0IGRlZmluZVN0YXR1cyBiZSBDcmVhdGVEYXRhUHJvcGVydHkoa2V5cywgUGssIGtleSkuXG4gICAgICAgICAgICAvLyAxMy4gYi4gaXYuIEFzc2VydDogZGVmaW5lU3RhdHVzIGlzIHRydWUuXG4gICAgICAgICAgICBrZXlzW2tdID0ga2V5O1xuICAgICAgICAgICAgLy8gMTMuIGIuIHYuIEluY3JlYXNlIGsgYnkgMS5cbiAgICAgICAgICAgICsraztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAxNC4gRm9yIGVhY2ggZWxlbWVudCBrZXkgb2YgcGFyZW50S2V5c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50S2V5c0xlbjsgKytpKSB7XG4gICAgICAgIGtleSA9IHBhcmVudEtleXNbaV07XG4gICAgICAgIC8vIDE0LiBhLiBMZXQgaGFzS2V5IGJlID8gSW52b2tlKHNldCwgXCJoYXNcIiwga2V5KS5cbiAgICAgICAgLy8gMTQuIGIuIElmIGhhc0tleSBpcyBmYWxzZSwgdGhlblxuICAgICAgICBpZiAoIXNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gMTQuIGIuIGkuIExldCBQayBiZSAhIFRvU3RyaW5nKGspLlxuICAgICAgICAgICAgLy8gMTQuIGIuIGlpLiBQZXJmb3JtID8gSW52b2tlKHNldCwgXCJhZGRcIiwga2V5KS5cbiAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgICAgICAgIC8vIDE0LiBiLiBpaWkuIExldCBkZWZpbmVTdGF0dXMgYmUgQ3JlYXRlRGF0YVByb3BlcnR5KGtleXMsIFBrLCBrZXkpLlxuICAgICAgICAgICAgLy8gMTQuIGIuIGl2LiBBc3NlcnQ6IGRlZmluZVN0YXR1cyBpcyB0cnVlLlxuICAgICAgICAgICAga2V5c1trXSA9IGtleTtcbiAgICAgICAgICAgIC8vIDE0LiBiLiB2LiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICAgICAgICArK2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMTUuIFBlcmZvcm0gPyBTZXQoa2V5cywgXCJsZW5ndGhcIiwgaykuXG4gICAgLy8gMTYuIHJldHVybiBrZXlzLlxuICAgIHJldHVybiBrZXlzO1xufVxuLy8gMy4xLjggRGVsZXRlTWV0YWRhdGEoTWV0YWRhdGFLZXksIFApXG4vLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHMtZGVsZXRlbWV0YWRhdGFcbmZ1bmN0aW9uIE9yZGluYXJ5RGVsZXRlTWV0YWRhdGEoTywgTWV0YWRhdGFLZXksIFApIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgbWV0YWRhdGFNYXAgYmUgPyBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKS5cbiAgICBjb25zdCBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICAgIC8vIDMuIElmIG1ldGFkYXRhTWFwIGlzIHVuZGVmaW5lZCwgcmV0dXJuIGZhbHNlLlxuICAgIGlmIChtZXRhZGF0YU1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gNC4gUmV0dXJuID8gSW52b2tlKG1ldGFkYXRhTWFwLCBcImRlbGV0ZVwiLCBNZXRhZGF0YUtleSkuXG4gICAgcmV0dXJuIG1ldGFkYXRhTWFwLmRlbGV0ZShNZXRhZGF0YUtleSk7XG59XG4vLyA0LjEuMiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKVxuLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jcmVmbGVjdC5tZXRhZGF0YVxuLyoqXG4gKiBBIGRlZmF1bHQgbWV0YWRhdGEgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCBvbiBhIGNsYXNzLCBjbGFzcyBtZW1iZXIsIG9yIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0gbWV0YWRhdGFLZXkgLSBUaGUga2V5IGZvciB0aGUgbWV0YWRhdGEgZW50cnkuXG4gKiBJZiBgbWV0YWRhdGFLZXlgIGlzIGFscmVhZHkgZGVmaW5lZCBmb3IgdGhlIHRhcmdldCBhbmQgdGFyZ2V0IGtleSwgdGhlXG4gKiBtZXRhZGF0YVZhbHVlIGZvciB0aGF0IGtleSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICogQHBhcmFtIG1ldGFkYXRhVmFsdWUgLSBUaGUgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cbiAqIEByZXR1cm5zIEEgZGVjb3JhdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAvLyAxLiBBc3NlcnQ6IEYgaGFzIGEgW1tNZXRhZGF0YUtleV1dIGludGVybmFsIHNsb3Qgd2hvc2UgdmFsdWUgaXMgYW4gRUNNQVNjcmlwdCBsYW5ndWFnZSB2YWx1ZSwgb3IgdW5kZWZpbmVkLlxuICAgICAgICAvLyAyLiBBc3NlcnQ6IEYgaGFzIGEgW1tNZXRhZGF0YVZhbHVlXV0gaW50ZXJuYWwgc2xvdCB3aG9zZSB2YWx1ZSBpcyBhbiBFQ01BU2NyaXB0IGxhbmd1YWdlIHZhbHVlLCBvciB1bmRlZmluZWQuXG4gICAgICAgIC8vIDMuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignQG1ldGFkYXRhJywgW21ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5XSwgJ3RhcmdldCcsIHRhcmdldCwgJ09iamVjdCBvciBGdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDQuIElmIGtleSBpcyBub3QgdW5kZWZpbmVkIGFuZCBJc1Byb3BlcnR5S2V5KGtleSkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gNS4gTGV0IG1ldGFkYXRhS2V5IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tNZXRhZGF0YUtleV1dIGludGVybmFsIHNsb3QuXG4gICAgICAgIC8vIDYuIExldCBtZXRhZGF0YVZhbHVlIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tNZXRhZGF0YVZhbHVlXV0gaW50ZXJuYWwgc2xvdC5cbiAgICAgICAgLy8gNy4gUGVyZm9ybSA/IHRhcmdldC5bW0RlZmluZU1ldGFkYXRhXV0obWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwga2V5KS5cbiAgICAgICAgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBlbnN1cmVQcm9wZXJ0eUtleU9yVW5kZWZpbmVkKHByb3BlcnR5S2V5KSk7XG4gICAgICAgIC8vIDguIFJldHVybiB1bmRlZmluZWQuXG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0b3I7XG59XG5mdW5jdGlvbiBkZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHByb3BlcnR5S2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRlY29yYXRvcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdNZXRhZGF0YS5kZWNvcmF0ZScsIFtkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzXSwgJ2RlY29yYXRvcnMnLCBkZWNvcmF0b3JzLCAnQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmRlY29yYXRlJywgW2RlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXNdLCAndGFyZ2V0JywgdGFyZ2V0LCAnT2JqZWN0IG9yIEZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc09iamVjdChhdHRyaWJ1dGVzKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmRlY29yYXRlJywgW2RlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXNdLCAnYXR0cmlidXRlcycsIGF0dHJpYnV0ZXMsICdPYmplY3QsIEZ1bmN0aW9uLCBudWxsLCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICByZXR1cm4gRGVjb3JhdGVQcm9wZXJ0eShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWNvcmF0b3JzKSkge1xuICAgICAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignTWV0YWRhdGEuZGVjb3JhdGUnLCBbZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlc10sICdkZWNvcmF0b3JzJywgZGVjb3JhdG9ycywgJ0FycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmRlY29yYXRlJywgW2RlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXNdLCAndGFyZ2V0JywgdGFyZ2V0LCAnRnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcbiAgICAgICAgY29uc3QgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCk7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZGVjb3JhdGVkKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWNvcmF0ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdEZWNvcmF0ZUNvbnN0cnVjdG9yJywgW2RlY29yYXRvcnMsIHRhcmdldF0sICdkZWNvcmF0ZWQnLCBkZWNvcmF0ZWQsICdGdW5jdGlvbiwgbnVsbCwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQgPSBkZWNvcmF0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xuICAgIGZvciAobGV0IGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV07XG4gICAgICAgIGNvbnN0IGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChkZWNvcmF0ZWQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGRlY29yYXRlZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdEZWNvcmF0ZVByb3BlcnR5JywgW2RlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3JdLCAnZGVjb3JhdGVkJywgZGVjb3JhdGVkLCAnT2JqZWN0LCBGdW5jdGlvbiwgbnVsbCwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVjb3JhdGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufVxuZnVuY3Rpb24gJGRlZmluZShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmRlZmluZScsIFttZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbRGVmaW5lTWV0YWRhdGFdXShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgcHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZnVuY3Rpb24gJGhhcyhtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmhhcycsIFttZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbSGFzTWV0YWRhdGFdXShtZXRhZGF0YUtleSwgcHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZnVuY3Rpb24gJGhhc093bihtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmhhc093bicsIFttZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbSGFzT3duXV0obWV0YWRhdGFLZXksIHByb3BlcnR5S2V5KS5cbiAgICByZXR1cm4gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCB0b1Byb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpKTtcbn1cbmZ1bmN0aW9uICRnZXQobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAvLyAxLiBJZiBUeXBlKHRhcmdldCkgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdNZXRhZGF0YS5nZXQnLCBbbWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXldLCAndGFyZ2V0JywgdGFyZ2V0LCAnT2JqZWN0IG9yIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIC8vIDIuIFJldHVybiA/IHRhcmdldC5bW0dldE1ldGFkYXRhXV0obWV0YWRhdGFLZXksIHByb3BlcnR5S2V5KS5cbiAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCB0b1Byb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpKTtcbn1cbmZ1bmN0aW9uICRnZXRPd24obWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAvLyAxLiBJZiBUeXBlKHRhcmdldCkgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdNZXRhZGF0YS5nZXRPd24nLCBbbWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXldLCAndGFyZ2V0JywgdGFyZ2V0LCAnT2JqZWN0IG9yIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIC8vIDIuIFJldHVybiA/IHRhcmdldC5bW0dldE93bk1ldGFkYXRhXV0obWV0YWRhdGFLZXksIHByb3BlcnR5S2V5KS5cbiAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCB0b1Byb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpKTtcbn1cbmZ1bmN0aW9uICRnZXRLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAvLyAxLiBJZiBUeXBlKHRhcmdldCkgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdNZXRhZGF0YS5nZXRLZXlzJywgW3RhcmdldCwgcHJvcGVydHlLZXldLCAndGFyZ2V0JywgdGFyZ2V0LCAnT2JqZWN0IG9yIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIC8vIDIuIFJldHVybiA/IHRhcmdldC5bW0dldE1ldGFkYXRhS2V5c11dKHByb3BlcnR5S2V5KS5cbiAgICByZXR1cm4gT3JkaW5hcnlNZXRhZGF0YUtleXModGFyZ2V0LCB0b1Byb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpKTtcbn1cbmZ1bmN0aW9uICRnZXRPd25LZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAvLyAxLiBJZiBUeXBlKHRhcmdldCkgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdNZXRhZGF0YS5nZXRPd25LZXlzJywgW3RhcmdldCwgcHJvcGVydHlLZXldLCAndGFyZ2V0JywgdGFyZ2V0LCAnT2JqZWN0IG9yIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIC8vIDIuIFJldHVybiA/IHRhcmdldC5bW0dldE93bk1ldGFkYXRhS2V5c11dKHByb3BlcnR5S2V5KS5cbiAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCB0b1Byb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpKTtcbn1cbmZ1bmN0aW9uICRkZWxldGUobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAvLyAxLiBJZiBUeXBlKHRhcmdldCkgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdNZXRhZGF0YS5kZWxldGUnLCBbbWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXldLCAndGFyZ2V0JywgdGFyZ2V0LCAnT2JqZWN0IG9yIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIC8vIDIuIFJldHVybiA/IHRhcmdldC5bW0RlbGV0ZU1ldGFkYXRhXV0obWV0YWRhdGFLZXksIHByb3BlcnR5S2V5KS5cbiAgICByZXR1cm4gT3JkaW5hcnlEZWxldGVNZXRhZGF0YSh0YXJnZXQsIG1ldGFkYXRhS2V5LCB0b1Byb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpKTtcbn1cbmV4cG9ydCBjb25zdCBNZXRhZGF0YSA9IHtcbiAgICBkZWZpbmU6ICRkZWZpbmUsXG4gICAgaGFzOiAkaGFzLFxuICAgIGhhc093bjogJGhhc093bixcbiAgICBnZXQ6ICRnZXQsXG4gICAgZ2V0T3duOiAkZ2V0T3duLFxuICAgIGdldEtleXM6ICRnZXRLZXlzLFxuICAgIGdldE93bktleXM6ICRnZXRPd25LZXlzLFxuICAgIGRlbGV0ZTogJGRlbGV0ZSxcbn07XG5mdW5jdGlvbiBkZWYob2JqLCBrZXksIHZhbHVlLCB3cml0YWJsZSwgY29uZmlndXJhYmxlKSB7XG4gICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHdyaXRhYmxlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlLFxuICAgICAgICB2YWx1ZSxcbiAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBhcHBseSBtZXRhZGF0YSBwb2x5ZmlsbDogY291bGQgbm90IGFkZCBwcm9wZXJ0eSAnJHtrZXl9JyB0byB0aGUgZ2xvYmFsIFJlZmxlY3Qgb2JqZWN0YCk7XG4gICAgfVxufVxuY29uc3QgaW50ZXJuYWxTbG90TmFtZSA9ICdbWyRhdV1dJztcbmZ1bmN0aW9uIGhhc0ludGVybmFsU2xvdChyZWZsZWN0KSB7XG4gICAgcmV0dXJuIGludGVybmFsU2xvdE5hbWUgaW4gcmVmbGVjdDtcbn1cbmZ1bmN0aW9uICRhcHBseU1ldGFkYXRhUG9seWZpbGwocmVmbGVjdCwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSkge1xuICAgIGRlZihyZWZsZWN0LCBpbnRlcm5hbFNsb3ROYW1lLCBtZXRhZGF0YUludGVybmFsU2xvdCwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG4gICAgZGVmKHJlZmxlY3QsICdtZXRhZGF0YScsIG1ldGFkYXRhLCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ2RlY29yYXRlJywgZGVjb3JhdGUsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xuICAgIGRlZihyZWZsZWN0LCAnZGVmaW5lTWV0YWRhdGEnLCAkZGVmaW5lLCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ2hhc01ldGFkYXRhJywgJGhhcywgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG4gICAgZGVmKHJlZmxlY3QsICdoYXNPd25NZXRhZGF0YScsICRoYXNPd24sIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xuICAgIGRlZihyZWZsZWN0LCAnZ2V0TWV0YWRhdGEnLCAkZ2V0LCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ2dldE93bk1ldGFkYXRhJywgJGdldE93biwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG4gICAgZGVmKHJlZmxlY3QsICdnZXRNZXRhZGF0YUtleXMnLCAkZ2V0S2V5cywgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG4gICAgZGVmKHJlZmxlY3QsICdnZXRPd25NZXRhZGF0YUtleXMnLCAkZ2V0T3duS2V5cywgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG4gICAgZGVmKHJlZmxlY3QsICdkZWxldGVNZXRhZGF0YScsICRkZWxldGUsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TWV0YWRhdGFQb2x5ZmlsbChyZWZsZWN0LCB0aHJvd0lmQ29uZmxpY3QgPSB0cnVlLCBmb3JjZU92ZXJ3cml0ZSA9IGZhbHNlLCB3cml0YWJsZSA9IHRydWUsIGNvbmZpZ3VyYWJsZSA9IHRydWUpIHtcbiAgICBpZiAoaGFzSW50ZXJuYWxTbG90KHJlZmxlY3QpKSB7XG4gICAgICAgIGlmIChyZWZsZWN0W2ludGVybmFsU2xvdE5hbWVdID09PSBtZXRhZGF0YUludGVybmFsU2xvdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uZmxpY3RpbmcgQGF1cmVsaWEvbWV0YWRhdGEgbW9kdWxlIGltcG9ydCBkZXRlY3RlZC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgc2FtZSB2ZXJzaW9uIG9mIGFsbCBBdXJlbGlhIHBhY2thZ2VzIGluIHlvdXIgZGVwZW5kZW5jeSB0cmVlLmApO1xuICAgIH1cbiAgICBjb25zdCBwcmVzZW50UHJvcHMgPSBbXG4gICAgICAgICdtZXRhZGF0YScsXG4gICAgICAgICdkZWNvcmF0ZScsXG4gICAgICAgICdkZWZpbmVNZXRhZGF0YScsXG4gICAgICAgICdoYXNNZXRhZGF0YScsXG4gICAgICAgICdoYXNPd25NZXRhZGF0YScsXG4gICAgICAgICdnZXRNZXRhZGF0YScsXG4gICAgICAgICdnZXRPd25NZXRhZGF0YScsXG4gICAgICAgICdnZXRNZXRhZGF0YUtleXMnLFxuICAgICAgICAnZ2V0T3duTWV0YWRhdGFLZXlzJyxcbiAgICAgICAgJ2RlbGV0ZU1ldGFkYXRhJyxcbiAgICBdLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcCBpbiBSZWZsZWN0O1xuICAgIH0pO1xuICAgIGlmIChwcmVzZW50UHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodGhyb3dJZkNvbmZsaWN0KSB7XG4gICAgICAgICAgICBjb25zdCBpbXBsZW1lbnRhdGlvblN1bW1hcnkgPSBwcmVzZW50UHJvcHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1wbCA9IGAke1JlZmxlY3RbcF0udG9TdHJpbmcoKS5zbGljZSgwLCAxMDApfS4uLmA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3B9OlxcbiR7aW1wbH1gO1xuICAgICAgICAgICAgfSkuam9pbignXFxuXFxuJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbmZsaWN0aW5nIHJlZmxlY3QubWV0YWRhdGEgcG9seWZpbGwgZm91bmQuIElmIHlvdSBoYXZlICdyZWZsZWN0LW1ldGFkYXRhJyBvciBhbnkgb3RoZXIgcmVmbGVjdCBwb2x5ZmlsbCBpbXBvcnRlZCwgcGxlYXNlIHJlbW92ZSBpdCwgaWYgbm90IChvciBpZiB5b3UgbXVzdCB1c2UgYSBzcGVjaWZpYyBwb2x5ZmlsbCkgcGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F1cmVsaWEvYXVyZWxpYS9pc3N1ZXMgc28gdGhhdCB3ZSBjYW4gbG9vayBpbnRvIGNvbXBhdGliaWxpdHkgb3B0aW9ucyBmb3IgdGhpcyBzY2VuYXJpby4gSW1wbGVtZW50YXRpb24gc3VtbWFyeTpcXG5cXG4ke2ltcGxlbWVudGF0aW9uU3VtbWFyeX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZU92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgJGFwcGx5TWV0YWRhdGFQb2x5ZmlsbChyZWZsZWN0LCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJGFwcGx5TWV0YWRhdGFQb2x5ZmlsbChyZWZsZWN0LCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBQbGF0Zm9ybSwgVGFza1F1ZXVlIH0gZnJvbSAnQGF1cmVsaWEvcGxhdGZvcm0nO1xuY29uc3QgbG9va3VwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgUExBVEZPUk0gZGlkIG5vdCByZWNlaXZlIGEgdmFsaWQgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgZnVuY3Rpb24gJyR7bmFtZX0nLmApOyAvLyBUT0RPOiBsaW5rIHRvIGRvY3MgZGVzY3JpYmluZyBob3cgdG8gZml4IHRoaXMgaXNzdWVcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIEJyb3dzZXJQbGF0Zm9ybSBleHRlbmRzIFBsYXRmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihnLCBvdmVycmlkZXMgPSB7fSkge1xuICAgICAgICBzdXBlcihnLCBvdmVycmlkZXMpO1xuICAgICAgICB0aGlzLmRvbVJlYWRSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb21SZWFkSGFuZGxlID0gLTE7XG4gICAgICAgIHRoaXMuZG9tV3JpdGVSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb21Xcml0ZUhhbmRsZSA9IC0xO1xuICAgICAgICB0aGlzLk5vZGUgPSAnTm9kZScgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLk5vZGUgOiBnLk5vZGU7XG4gICAgICAgIHRoaXMuRWxlbWVudCA9ICdFbGVtZW50JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuRWxlbWVudCA6IGcuRWxlbWVudDtcbiAgICAgICAgdGhpcy5IVE1MRWxlbWVudCA9ICdIVE1MRWxlbWVudCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLkhUTUxFbGVtZW50IDogZy5IVE1MRWxlbWVudDtcbiAgICAgICAgdGhpcy5DdXN0b21FdmVudCA9ICdDdXN0b21FdmVudCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLkN1c3RvbUV2ZW50IDogZy5DdXN0b21FdmVudDtcbiAgICAgICAgdGhpcy5DU1NTdHlsZVNoZWV0ID0gJ0NTU1N0eWxlU2hlZXQnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5DU1NTdHlsZVNoZWV0IDogZy5DU1NTdHlsZVNoZWV0O1xuICAgICAgICB0aGlzLlNoYWRvd1Jvb3QgPSAnU2hhZG93Um9vdCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLlNoYWRvd1Jvb3QgOiBnLlNoYWRvd1Jvb3Q7XG4gICAgICAgIHRoaXMuTXV0YXRpb25PYnNlcnZlciA9ICdNdXRhdGlvbk9ic2VydmVyJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuTXV0YXRpb25PYnNlcnZlciA6IGcuTXV0YXRpb25PYnNlcnZlcjtcbiAgICAgICAgdGhpcy53aW5kb3cgPSAnd2luZG93JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMud2luZG93IDogZy53aW5kb3c7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSAnZG9jdW1lbnQnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5kb2N1bWVudCA6IGcuZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSAnbG9jYXRpb24nIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5sb2NhdGlvbiA6IGcubG9jYXRpb247XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9ICdoaXN0b3J5JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuaGlzdG9yeSA6IGcuaGlzdG9yeTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0b3IgPSAnbmF2aWdhdG9yJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMubmF2aWdhdG9yIDogZy5uYXZpZ2F0b3I7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSAnZmV0Y2gnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5mZXRjaCA6IGcuZmV0Y2g/LmJpbmQoZykgPz8gbm90SW1wbGVtZW50ZWQoJ2ZldGNoJyk7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gJ3JlcXVlc3RBbmltYXRpb25GcmFtZScgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGcucmVxdWVzdEFuaW1hdGlvbkZyYW1lPy5iaW5kKGcpID8/IG5vdEltcGxlbWVudGVkKCdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcbiAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9ICdjYW5jZWxBbmltYXRpb25GcmFtZScgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmNhbmNlbEFuaW1hdGlvbkZyYW1lIDogZy5jYW5jZWxBbmltYXRpb25GcmFtZT8uYmluZChnKSA/PyBub3RJbXBsZW1lbnRlZCgnY2FuY2VsQW5pbWF0aW9uRnJhbWUnKTtcbiAgICAgICAgdGhpcy5jdXN0b21FbGVtZW50cyA9ICdjdXN0b21FbGVtZW50cycgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmN1c3RvbUVsZW1lbnRzIDogZy5jdXN0b21FbGVtZW50cztcbiAgICAgICAgdGhpcy5mbHVzaERvbVJlYWQgPSB0aGlzLmZsdXNoRG9tUmVhZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZsdXNoRG9tV3JpdGUgPSB0aGlzLmZsdXNoRG9tV3JpdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb21SZWFkUXVldWUgPSBuZXcgVGFza1F1ZXVlKHRoaXMsIHRoaXMucmVxdWVzdERvbVJlYWQuYmluZCh0aGlzKSwgdGhpcy5jYW5jZWxEb21SZWFkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmRvbVdyaXRlUXVldWUgPSBuZXcgVGFza1F1ZXVlKHRoaXMsIHRoaXMucmVxdWVzdERvbVdyaXRlLmJpbmQodGhpcyksIHRoaXMuY2FuY2VsRG9tV3JpdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uICovXG4gICAgfVxuICAgIHN0YXRpYyBnZXRPckNyZWF0ZShnLCBvdmVycmlkZXMgPSB7fSkge1xuICAgICAgICBsZXQgcGxhdGZvcm0gPSBsb29rdXAuZ2V0KGcpO1xuICAgICAgICBpZiAocGxhdGZvcm0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbG9va3VwLnNldChnLCBwbGF0Zm9ybSA9IG5ldyBCcm93c2VyUGxhdGZvcm0oZywgb3ZlcnJpZGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0KGcsIHBsYXRmb3JtKSB7XG4gICAgICAgIGxvb2t1cC5zZXQoZywgcGxhdGZvcm0pO1xuICAgIH1cbiAgICByZXF1ZXN0RG9tUmVhZCgpIHtcbiAgICAgICAgdGhpcy5kb21SZWFkUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gWWVzLCB0aGlzIGlzIGludGVudGlvbmFsOiB0aGUgdGltaW5nIG9mIHRoZSByZWFkIGNhbiBvbmx5IGJlIFwiZm91bmRcIiBieSBkb2luZyBhIHdyaXRlIGZpcnN0LlxuICAgICAgICAvLyBUaGUgZmx1c2hEb21Xcml0ZSBxdWV1ZXMgdGhlIHJlYWQuXG4gICAgICAgIC8vIElmL3doZW4gcmVxdWVzdFBvc3RBbmltYXRpb25GcmFtZSBpcyBpbXBsZW1lbnRlZCBpbiBicm93c2Vycywgd2UgY2FuIHVzZSB0aGF0IGluc3RlYWQuXG4gICAgICAgIGlmICh0aGlzLmRvbVdyaXRlSGFuZGxlID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5kb21Xcml0ZUhhbmRsZSA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hEb21Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsRG9tUmVhZCgpIHtcbiAgICAgICAgdGhpcy5kb21SZWFkUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRvbVJlYWRIYW5kbGUgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQodGhpcy5kb21SZWFkSGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMuZG9tUmVhZEhhbmRsZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvbVdyaXRlUmVxdWVzdGVkID09PSBmYWxzZSAmJiB0aGlzLmRvbVdyaXRlSGFuZGxlID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kb21Xcml0ZUhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLmRvbVdyaXRlSGFuZGxlID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hEb21SZWFkKCkge1xuICAgICAgICB0aGlzLmRvbVJlYWRIYW5kbGUgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuZG9tUmVhZFJlcXVlc3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kb21SZWFkUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRvbVJlYWRRdWV1ZS5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3REb21Xcml0ZSgpIHtcbiAgICAgICAgdGhpcy5kb21Xcml0ZVJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmRvbVdyaXRlSGFuZGxlID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5kb21Xcml0ZUhhbmRsZSA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hEb21Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsRG9tV3JpdGUoKSB7XG4gICAgICAgIHRoaXMuZG9tV3JpdGVSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZG9tV3JpdGVIYW5kbGUgPiAtMSAmJlxuICAgICAgICAgICAgLy8gaWYgZG9tIHJlYWQgaXMgcmVxdWVzdGVkIGFuZCB0aGVyZSBpcyBubyByZWFkSGFuZGxlIHlldCwgd2UgbmVlZCB0aGUgckFGIHRvIHByb2NlZWQgcmVnYXJkbGVzcy5cbiAgICAgICAgICAgIC8vIFRoZSBkb21Xcml0ZVJlcXVlc3RlZD1mYWxzZSB3aWxsIHByZXZlbnQgdGhlIHJlYWQgZmx1c2ggZnJvbSBoYXBwZW5pbmcuXG4gICAgICAgICAgICAodGhpcy5kb21SZWFkUmVxdWVzdGVkID09PSBmYWxzZSB8fCB0aGlzLmRvbVJlYWRIYW5kbGUgPiAtMSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kb21Xcml0ZUhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLmRvbVdyaXRlSGFuZGxlID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hEb21Xcml0ZSgpIHtcbiAgICAgICAgdGhpcy5kb21Xcml0ZUhhbmRsZSA9IC0xO1xuICAgICAgICBpZiAodGhpcy5kb21Xcml0ZVJlcXVlc3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kb21Xcml0ZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kb21Xcml0ZVF1ZXVlLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9tUmVhZFJlcXVlc3RlZCA9PT0gdHJ1ZSAmJiB0aGlzLmRvbVJlYWRIYW5kbGUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVJlYWRIYW5kbGUgPSB0aGlzLnNldFRpbWVvdXQodGhpcy5mbHVzaERvbVJlYWQsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiY29uc3QgbG9va3VwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgUExBVEZPUk0gZGlkIG5vdCByZWNlaXZlIGEgdmFsaWQgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgZnVuY3Rpb24gJyR7bmFtZX0nLmApOyAvLyBUT0RPOiBsaW5rIHRvIGRvY3MgZGVzY3JpYmluZyBob3cgdG8gZml4IHRoaXMgaXNzdWVcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIFBsYXRmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihnLCBvdmVycmlkZXMgPSB7fSkge1xuICAgICAgICB0aGlzLm1hY3JvVGFza1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hY3JvVGFza0hhbmRsZSA9IC0xO1xuICAgICAgICB0aGlzLmdsb2JhbFRoaXMgPSBnO1xuICAgICAgICB0aGlzLmRlY29kZVVSSSA9ICdkZWNvZGVVUkknIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5kZWNvZGVVUkkgOiBnLmRlY29kZVVSSTtcbiAgICAgICAgdGhpcy5kZWNvZGVVUklDb21wb25lbnQgPSAnZGVjb2RlVVJJQ29tcG9uZW50JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuZGVjb2RlVVJJQ29tcG9uZW50IDogZy5kZWNvZGVVUklDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZW5jb2RlVVJJID0gJ2VuY29kZVVSSScgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmVuY29kZVVSSSA6IGcuZW5jb2RlVVJJO1xuICAgICAgICB0aGlzLmVuY29kZVVSSUNvbXBvbmVudCA9ICdlbmNvZGVVUklDb21wb25lbnQnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5lbmNvZGVVUklDb21wb25lbnQgOiBnLmVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5EYXRlID0gJ0RhdGUnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5EYXRlIDogZy5EYXRlO1xuICAgICAgICB0aGlzLlJlZmxlY3QgPSAnUmVmbGVjdCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLlJlZmxlY3QgOiBnLlJlZmxlY3Q7XG4gICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCA9ICdjbGVhckludGVydmFsJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuY2xlYXJJbnRlcnZhbCA6IGcuY2xlYXJJbnRlcnZhbD8uYmluZChnKSA/PyBub3RJbXBsZW1lbnRlZCgnY2xlYXJJbnRlcnZhbCcpO1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCA9ICdjbGVhclRpbWVvdXQnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5jbGVhclRpbWVvdXQgOiBnLmNsZWFyVGltZW91dD8uYmluZChnKSA/PyBub3RJbXBsZW1lbnRlZCgnY2xlYXJUaW1lb3V0Jyk7XG4gICAgICAgIHRoaXMucXVldWVNaWNyb3Rhc2sgPSAncXVldWVNaWNyb3Rhc2snIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5xdWV1ZU1pY3JvdGFzayA6IGcucXVldWVNaWNyb3Rhc2s/LmJpbmQoZykgPz8gbm90SW1wbGVtZW50ZWQoJ3F1ZXVlTWljcm90YXNrJyk7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwgPSAnc2V0SW50ZXJ2YWwnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5zZXRJbnRlcnZhbCA6IGcuc2V0SW50ZXJ2YWw/LmJpbmQoZykgPz8gbm90SW1wbGVtZW50ZWQoJ3NldEludGVydmFsJyk7XG4gICAgICAgIHRoaXMuc2V0VGltZW91dCA9ICdzZXRUaW1lb3V0JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuc2V0VGltZW91dCA6IGcuc2V0VGltZW91dD8uYmluZChnKSA/PyBub3RJbXBsZW1lbnRlZCgnc2V0VGltZW91dCcpO1xuICAgICAgICB0aGlzLmNvbnNvbGUgPSAnY29uc29sZScgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmNvbnNvbGUgOiBnLmNvbnNvbGU7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VOb3cgPSAncGVyZm9ybWFuY2VOb3cnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5wZXJmb3JtYW5jZU5vdyA6IGcucGVyZm9ybWFuY2U/Lm5vdz8uYmluZChnLnBlcmZvcm1hbmNlKSA/PyBub3RJbXBsZW1lbnRlZCgncGVyZm9ybWFuY2Uubm93Jyk7XG4gICAgICAgIHRoaXMuZmx1c2hNYWNyb1Rhc2sgPSB0aGlzLmZsdXNoTWFjcm9UYXNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWFjcm9UYXNrUXVldWUgPSBuZXcgVGFza1F1ZXVlKHRoaXMsIHRoaXMucmVxdWVzdE1hY3JvVGFzay5iaW5kKHRoaXMpLCB0aGlzLmNhbmNlbE1hY3JvVGFzay5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE9yQ3JlYXRlKGcsIG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIGxldCBwbGF0Zm9ybSA9IGxvb2t1cC5nZXQoZyk7XG4gICAgICAgIGlmIChwbGF0Zm9ybSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsb29rdXAuc2V0KGcsIHBsYXRmb3JtID0gbmV3IFBsYXRmb3JtKGcsIG92ZXJyaWRlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybTtcbiAgICB9XG4gICAgc3RhdGljIHNldChnLCBwbGF0Zm9ybSkge1xuICAgICAgICBsb29rdXAuc2V0KGcsIHBsYXRmb3JtKTtcbiAgICB9XG4gICAgcmVxdWVzdE1hY3JvVGFzaygpIHtcbiAgICAgICAgdGhpcy5tYWNyb1Rhc2tSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5tYWNyb1Rhc2tIYW5kbGUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm1hY3JvVGFza0hhbmRsZSA9IHRoaXMuc2V0VGltZW91dCh0aGlzLmZsdXNoTWFjcm9UYXNrLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxNYWNyb1Rhc2soKSB7XG4gICAgICAgIHRoaXMubWFjcm9UYXNrUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm1hY3JvVGFza0hhbmRsZSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCh0aGlzLm1hY3JvVGFza0hhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLm1hY3JvVGFza0hhbmRsZSA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoTWFjcm9UYXNrKCkge1xuICAgICAgICB0aGlzLm1hY3JvVGFza0hhbmRsZSA9IC0xO1xuICAgICAgICBpZiAodGhpcy5tYWNyb1Rhc2tSZXF1ZXN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMubWFjcm9UYXNrUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1hY3JvVGFza1F1ZXVlLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1BlcnNpc3RlbnQodGFzaykge1xuICAgIHJldHVybiB0YXNrLnBlcnNpc3RlbnQ7XG59XG5leHBvcnQgY2xhc3MgVGFza1F1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybSwgJHJlcXVlc3QsICRjYW5jZWwpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLiRyZXF1ZXN0ID0gJHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuJGNhbmNlbCA9ICRjYW5jZWw7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IFtdO1xuICAgICAgICB0aGlzLnN1c3BlbmRlclRhc2sgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucGVuZGluZ0FzeW5jQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkID0gW107XG4gICAgICAgIHRoaXMuZmx1c2hSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55aWVsZFByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudGFza1Bvb2wgPSBbXTtcbiAgICAgICAgdGhpcy50YXNrUG9vbFNpemUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rmx1c2ggPSAwO1xuICAgICAgICB0aGlzLnJlcXVlc3RGbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIuZW50ZXIodGhpcywgJ3JlcXVlc3RGbHVzaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmZsdXNoUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVxdWVzdCA9IHRoaXMucGxhdGZvcm0ucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdyZXF1ZXN0Rmx1c2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFjZXIgPSBuZXcgVHJhY2VyKHBsYXRmb3JtLmNvbnNvbGUpO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZy5sZW5ndGggPT09IDAgJiYgdGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmRlbGF5ZWQubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJzaXN0ZW50IHRhc2tzIHdpbGwgcmUtcXVldWUgdGhlbXNlbHZlcyBpbmRlZmluaXRlbHkgdW50aWwgdGhleSBhcmUgZXhwbGljaXRseSBjYW5jZWxlZCxcbiAgICAgKiBzbyB3ZSBjb25zaWRlciB0aGVtICdpbmZpbml0ZSB3b3JrJyB3aGVyZWFzIG5vbi1wZXJzaXN0ZW50IChvbmUtb2ZmKSB0YXNrcyBhcmUgJ2Zpbml0ZSB3b3JrJy5cbiAgICAgKlxuICAgICAqIFRoaXMgYGhhc05vTW9yZUZpbml0ZVdvcmtgIGdldHRlcnMgcmV0dXJucyB0cnVlIGlmIGVpdGhlciBhbGwgcmVtYWluaW5nIHRhc2tzIGFyZSBwZXJzaXN0ZW50LCBvciBpZiB0aGVyZSBhcmUgbm8gbW9yZSB0YXNrcy5cbiAgICAgKlxuICAgICAqIElmIHRoYXQgaXMgdGhlIGNhc2UsIHdlIGNhbiByZXNvbHZlIHRoZSBwcm9taXNlIHRoYXQgd2FzIGNyZWF0ZWQgd2hlbiBgeWllbGQoKWAgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGdldCBoYXNOb01vcmVGaW5pdGVXb3JrKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGVuZGluZ0FzeW5jQ291bnQgPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5ldmVyeShpc1BlcnNpc3RlbnQpICYmXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcuZXZlcnkoaXNQZXJzaXN0ZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5kZWxheWVkLmV2ZXJ5KGlzUGVyc2lzdGVudCkpO1xuICAgIH1cbiAgICBmbHVzaCh0aW1lID0gdGhpcy5wbGF0Zm9ybS5wZXJmb3JtYW5jZU5vdygpKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAnZmx1c2gnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdEZsdXNoID0gdGltZTtcbiAgICAgICAgLy8gT25seSBwcm9jZXNzIG5vcm1hbGx5IGlmIHdlIGFyZSAqbm90KiBjdXJyZW50bHkgd2FpdGluZyBmb3IgYW4gYXN5bmMgdGFzayB0byBmaW5pc2hcbiAgICAgICAgaWYgKHRoaXMuc3VzcGVuZGVyVGFzayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcucHVzaCguLi50aGlzLnBlbmRpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgdGhpcy5kZWxheWVkLmxlbmd0aCAmJiB0aGlzLmRlbGF5ZWRbaV0ucXVldWVUaW1lIDw9IHRpbWUpIHsgLyogZG8gbm90aGluZyAqLyB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nLnB1c2goLi4udGhpcy5kZWxheWVkLnNwbGljZSgwLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VyO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMucHJvY2Vzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgKGN1ciA9IHRoaXMucHJvY2Vzc2luZy5zaGlmdCgpKS5ydW4oKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHN0aWxsIHJ1bm5pbmcsIGl0IGNhbiBvbmx5IGJlIGFuIGFzeW5jIHRhc2tcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnN0YXR1cyA9PT0gMSAvKiBydW5uaW5nICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIuc3VzcGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdXNwZW5kZXJUYXNrID0gY3VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ2ZsdXNoIGVhcmx5IGFzeW5jJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMucGVuZGluZ0FzeW5jQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcucHVzaCguLi50aGlzLnBlbmRpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgdGhpcy5kZWxheWVkLmxlbmd0aCAmJiB0aGlzLmRlbGF5ZWRbaV0ucXVldWVUaW1lIDw9IHRpbWUpIHsgLyogZG8gbm90aGluZyAqLyB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nLnB1c2goLi4udGhpcy5kZWxheWVkLnNwbGljZSgwLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nLmxlbmd0aCA+IDAgfHwgdGhpcy5kZWxheWVkLmxlbmd0aCA+IDAgfHwgdGhpcy5wZW5kaW5nQXN5bmNDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RGbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMueWllbGRQcm9taXNlICE9PSB2b2lkIDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmhhc05vTW9yZUZpbml0ZVdvcmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy55aWVsZFByb21pc2U7XG4gICAgICAgICAgICAgICAgdGhpcy55aWVsZFByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgcC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc3RpbGwgd2FpdGluZyBmb3IgYW4gYXN5bmMgdGFzayB0byBmaW5pc2gsIGp1c3Qgc2NoZWR1bGUgdGhlIG5leHQgZmx1c2ggYW5kIGRvIG5vdGhpbmcgZWxzZS5cbiAgICAgICAgICAgIC8vIFNob3VsZCB0aGUgdGFzayBmaW5pc2ggYmVmb3JlIHRoZSBuZXh0IGZsdXNoIGlzIGludm9rZWQsXG4gICAgICAgICAgICAvLyB0aGUgY2FsbGJhY2sgdG8gYGNvbXBsZXRlQXN5bmNUYXNrYCB3aWxsIGhhdmUgcmVzZXQgYHRoaXMuc3VzcGVuZGVyVGFza2AgYmFjayB0byB1bmRlZmluZWQgc28gcHJvY2Vzc2luZyBjYW4gcmV0dXJuIGJhY2sgdG8gbm9ybWFsIG5leHQgZmx1c2guXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAnZmx1c2ggZnVsbCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGUgbmV4dCBmbHVzaCBjeWNsZSAoYW5kL29yIHRoZSBtYWNyb3Rhc2sgdGhhdCBzY2hlZHVsZXMgdGhlIG5leHQgZmx1c2ggY3ljbGUsIGluIGNhc2UgdGhpcyBpcyBhIG1pY3JvdGFzayBxdWV1ZSksIGlmIGl0IHdhcyByZXF1ZXN0ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBpZGVtcG90ZW50IGFuZCB3aWxsIGRvIG5vdGhpbmcgaWYgbm8gZmx1c2ggaXMgc2NoZWR1bGVkLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdjYW5jZWwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbHVzaFJlcXVlc3RlZCkge1xuICAgICAgICAgICAgdGhpcy4kY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdjYW5jZWwnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0LCB3aGVuIGF3YWl0ZWQsIHJlc29sdmVzIHdoZW46XG4gICAgICogLSBhbGwgKm5vbiotcGVyc2lzdGVudCAoaW5jbHVkaW5nIGFzeW5jKSB0YXNrcyBoYXZlIGZpbmlzaGVkO1xuICAgICAqIC0gdGhlIGxhc3QtYWRkZWQgcGVyc2lzdGVudCB0YXNrIGhhcyBydW4gZXhhY3RseSBvbmNlO1xuICAgICAqXG4gICAgICogVGhpcyBvcGVyYXRpb24gaXMgaWRlbXBvdGVudDogdGhlIHNhbWUgcHJvbWlzZSB3aWxsIGJlIHJldHVybmVkIHVudGlsIGl0IHJlc29sdmVzLlxuICAgICAqXG4gICAgICogSWYgYHlpZWxkKClgIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvdyB3aGVuIHRoZXJlIGFyZSBvbmUgb3IgbW9yZSBwZXJzaXN0ZW50IHRhc2tzIGluIHRoZSBxdWV1ZSwgZWFjaCBjYWxsIHdpbGwgYXdhaXQgZXhhY3RseSBvbmUgY3ljbGUgb2YgdGhvc2UgdGFza3MuXG4gICAgICovXG4gICAgYXN5bmMgeWllbGQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAneWllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICd5aWVsZCBlbXB0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMueWllbGRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci50cmFjZSh0aGlzLCAneWllbGQgLSBjcmVhdGluZyBwcm9taXNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMueWllbGRQcm9taXNlID0gY3JlYXRlRXhwb3NlZFByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMueWllbGRQcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAneWllbGQgdGFzaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlVGFzayhjYWxsYmFjaywgb3B0cykge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIuZW50ZXIodGhpcywgJ3F1ZXVlVGFzaycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZGVsYXksIHByZWVtcHQsIHBlcnNpc3RlbnQsIHJldXNhYmxlLCBzdXNwZW5kIH0gPSB7IC4uLmRlZmF1bHRRdWV1ZVRhc2tPcHRpb25zLCAuLi5vcHRzIH07XG4gICAgICAgIGlmIChwcmVlbXB0KSB7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50czogcHJlZW1wdCBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBhIGdyZWF0ZXItdGhhbi16ZXJvIGRlbGF5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGVyc2lzdGVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcmd1bWVudHM6IHByZWVtcHQgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggcGVyc2lzdGVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLnBsYXRmb3JtLnBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIGxldCB0YXNrO1xuICAgICAgICBpZiAocmV1c2FibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tQb29sID0gdGhpcy50YXNrUG9vbDtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YXNrUG9vbFNpemUgLSAxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0YXNrID0gdGFza1Bvb2xbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRhc2tQb29sW2luZGV4XSA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgIHRoaXMudGFza1Bvb2xTaXplID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGFzay5yZXVzZSh0aW1lLCBkZWxheSwgcHJlZW1wdCwgcGVyc2lzdGVudCwgc3VzcGVuZCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFzayA9IG5ldyBUYXNrKHRoaXMudHJhY2VyLCB0aGlzLCB0aW1lLCB0aW1lICsgZGVsYXksIHByZWVtcHQsIHBlcnNpc3RlbnQsIHN1c3BlbmQsIHJldXNhYmxlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXNrID0gbmV3IFRhc2sodGhpcy50cmFjZXIsIHRoaXMsIHRpbWUsIHRpbWUgKyBkZWxheSwgcHJlZW1wdCwgcGVyc2lzdGVudCwgc3VzcGVuZCwgcmV1c2FibGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZW1wdCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nW3RoaXMucHJvY2Vzc2luZy5sZW5ndGhdID0gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nW3RoaXMucGVuZGluZy5sZW5ndGhdID0gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFt0aGlzLmRlbGF5ZWQubGVuZ3RoXSA9IHRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdxdWV1ZVRhc2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB0YXNrIGZyb20gdGhpcyBxdWV1ZS5cbiAgICAgKi9cbiAgICByZW1vdmUodGFzaykge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIuZW50ZXIodGhpcywgJ3JlbW92ZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZHggPSB0aGlzLnByb2Nlc3NpbmcuaW5kZXhPZih0YXNrKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3Npbmcuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdyZW1vdmUgcHJvY2Vzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlkeCA9IHRoaXMucGVuZGluZy5pbmRleE9mKHRhc2spO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3JlbW92ZSBwZW5kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWR4ID0gdGhpcy5kZWxheWVkLmluZGV4T2YodGFzayk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncmVtb3ZlIGRlbGF5ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3JlbW92ZSBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFzayAjJHt0YXNrLmlkfSBjb3VsZCBub3QgYmUgZm91bmRgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcmV1c2FibGUgdGFzayB0byB0aGUgc2hhcmVkIHRhc2sgcG9vbC5cbiAgICAgKiBUaGUgbmV4dCBxdWV1ZWQgY2FsbGJhY2sgd2lsbCByZXVzZSB0aGlzIHRhc2sgb2JqZWN0IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lLCB0byBzYXZlIG92ZXJoZWFkIG9mIGNyZWF0aW5nIGFkZGl0aW9uYWwgb2JqZWN0cy5cbiAgICAgKi9cbiAgICByZXR1cm5Ub1Bvb2wodGFzaykge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIudHJhY2UodGhpcywgJ3JldHVyblRvUG9vbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFza1Bvb2xbdGhpcy50YXNrUG9vbFNpemUrK10gPSB0YXNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcGVyc2lzdGVudCB0YXNrIGJhY2sgdG8gaXRzIHBlbmRpbmcgc3RhdGUsIHByZXBhcmluZyBpdCBmb3IgYmVpbmcgaW52b2tlZCBhZ2FpbiBvbiB0aGUgbmV4dCBmbHVzaC5cbiAgICAgKi9cbiAgICByZXNldFBlcnNpc3RlbnRUYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdyZXNldFBlcnNpc3RlbnRUYXNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGFzay5yZXNldCh0aGlzLnBsYXRmb3JtLnBlcmZvcm1hbmNlTm93KCkpO1xuICAgICAgICBpZiAodGFzay5jcmVhdGVkVGltZSA9PT0gdGFzay5xdWV1ZVRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1t0aGlzLnBlbmRpbmcubGVuZ3RoXSA9IHRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRbdGhpcy5kZWxheWVkLmxlbmd0aF0gPSB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncmVzZXRQZXJzaXN0ZW50VGFzaycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGUgcXVldWUgdGhhdCB0aGlzIGFzeW5jIHRhc2sgaGFzIGhhZCBpdHMgcHJvbWlzZSByZXNvbHZlZCwgc28gdGhhdCB0aGUgcXVldWUgY2FuIHByb2NlZWQgd2l0aCBjb25zZWN1dGl2ZSB0YXNrcyBvbiB0aGUgbmV4dCBmbHVzaC5cbiAgICAgKi9cbiAgICBjb21wbGV0ZUFzeW5jVGFzayh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAnY29tcGxldGVBc3luY1Rhc2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFzay5zdXNwZW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXNwZW5kZXJUYXNrICE9PSB0YXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ2NvbXBsZXRlQXN5bmNUYXNrIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmMgdGFzayBjb21wbGV0aW9uIG1pc21hdGNoOiBzdXNwZW5kZXJUYXNrPSR7dGhpcy5zdXNwZW5kZXJUYXNrPy5pZH0sIHRhc2s9JHt0YXNrLmlkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdXNwZW5kZXJUYXNrID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLS10aGlzLnBlbmRpbmdBc3luY0NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnlpZWxkUHJvbWlzZSAhPT0gdm9pZCAwICYmXG4gICAgICAgICAgICB0aGlzLmhhc05vTW9yZUZpbml0ZVdvcmspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnlpZWxkUHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgcC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ2NvbXBsZXRlQXN5bmNUYXNrJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVGFza0Fib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IodGFzaykge1xuICAgICAgICBzdXBlcignVGFzayB3YXMgY2FuY2VsZWQuJyk7XG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgfVxufVxubGV0IGlkID0gMDtcbmV4cG9ydCB2YXIgVGFza1N0YXR1cztcbihmdW5jdGlvbiAoVGFza1N0YXR1cykge1xuICAgIFRhc2tTdGF0dXNbVGFza1N0YXR1c1tcInBlbmRpbmdcIl0gPSAwXSA9IFwicGVuZGluZ1wiO1xuICAgIFRhc2tTdGF0dXNbVGFza1N0YXR1c1tcInJ1bm5pbmdcIl0gPSAxXSA9IFwicnVubmluZ1wiO1xuICAgIFRhc2tTdGF0dXNbVGFza1N0YXR1c1tcImNvbXBsZXRlZFwiXSA9IDJdID0gXCJjb21wbGV0ZWRcIjtcbiAgICBUYXNrU3RhdHVzW1Rhc2tTdGF0dXNbXCJjYW5jZWxlZFwiXSA9IDNdID0gXCJjYW5jZWxlZFwiO1xufSkoVGFza1N0YXR1cyB8fCAoVGFza1N0YXR1cyA9IHt9KSk7XG5leHBvcnQgY2xhc3MgVGFzayB7XG4gICAgY29uc3RydWN0b3IodHJhY2VyLCB0YXNrUXVldWUsIGNyZWF0ZWRUaW1lLCBxdWV1ZVRpbWUsIHByZWVtcHQsIHBlcnNpc3RlbnQsIHN1c3BlbmQsIHJldXNhYmxlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnRyYWNlciA9IHRyYWNlcjtcbiAgICAgICAgdGhpcy50YXNrUXVldWUgPSB0YXNrUXVldWU7XG4gICAgICAgIHRoaXMuY3JlYXRlZFRpbWUgPSBjcmVhdGVkVGltZTtcbiAgICAgICAgdGhpcy5xdWV1ZVRpbWUgPSBxdWV1ZVRpbWU7XG4gICAgICAgIHRoaXMucHJlZW1wdCA9IHByZWVtcHQ7XG4gICAgICAgIHRoaXMucGVyc2lzdGVudCA9IHBlcnNpc3RlbnQ7XG4gICAgICAgIHRoaXMuc3VzcGVuZCA9IHN1c3BlbmQ7XG4gICAgICAgIHRoaXMucmV1c2FibGUgPSByZXVzYWJsZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmlkID0gKytpZDtcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnJlamVjdCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSAwIC8qIHBlbmRpbmcgKi87XG4gICAgfVxuICAgIGdldCByZXN1bHQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3Jlc3VsdDtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBwZW5kaW5nICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9yZXN1bHQgPSBjcmVhdGVFeHBvc2VkUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUgPSBwcm9taXNlLnJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcHJvbWlzZS5yZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogcnVubmluZyAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYXdhaXQgdGFzayBmcm9tIHdpdGhpbiB0YXNrIHdpbGwgY2F1c2UgYSBkZWFkbG9jay4nKTtcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogY29tcGxldGVkICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIGNhbmNlbGVkICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0ID0gUHJvbWlzZS5yZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgIH1cbiAgICBydW4odGltZSA9IHRoaXMudGFza1F1ZXVlLnBsYXRmb3JtLnBlcmZvcm1hbmNlTm93KCkpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdydW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdHVzICE9PSAwIC8qIHBlbmRpbmcgKi8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3J1biBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcnVuIHRhc2sgaW4gJHt0aGlzLl9zdGF0dXN9IHN0YXRlYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5wZXJzaXN0ZW50IGNvdWxkIGJlIGNoYW5nZWQgd2hpbGUgdGhlIHRhc2sgaXMgcnVubmluZyAodGhpcyBjYW4gb25seSBiZSBkb25lIGJ5IHRoZSB0YXNrIGl0c2VsZiBpZiBjYW5jZWxlZCwgYW5kIGlzIGEgdmFsaWQgd2F5IG9mIHN0b3BwaW5nIGEgbG9vcClcbiAgICAgICAgLy8gc28gd2UgZGVsaWJlcmF0ZWx5IHJlZmVyZW5jZSB0aGlzLnBlcnNpc3RlbnQgaW5zdGVhZCBvZiB0aGUgbG9jYWwgdmFyaWFibGUsIGJ1dCB3ZSBrZWVwIGl0IGFyb3VuZCB0byBrbm93IHdoZXRoZXIgdGhlIHRhc2sgKndhcyogcGVyc2lzdGVudCBiZWZvcmUgcnVubmluZyBpdCxcbiAgICAgICAgLy8gc28gd2UgY2FuIHNldCB0aGUgY29ycmVjdCBjYW5jZWxhdGlvbiBzdGF0ZS5cbiAgICAgICAgY29uc3QgeyBwZXJzaXN0ZW50LCByZXVzYWJsZSwgdGFza1F1ZXVlLCBjYWxsYmFjaywgcmVzb2x2ZSwgcmVqZWN0LCBjcmVhdGVkVGltZSwgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogcnVubmluZyAqLztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGNhbGxiYWNrKHRpbWUgLSBjcmVhdGVkVGltZSk7XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldC50aGVuKCRyZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrUXVldWVbJ3Jlc2V0UGVyc2lzdGVudFRhc2snXSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyc2lzdGVudCB0YXNrcyBuZXZlciByZWFjaCBjb21wbGV0ZWQgc3RhdHVzLiBUaGV5J3JlIGVpdGhlciBwZW5kaW5nLCBydW5uaW5nLCBvciBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSAzIC8qIGNhbmNlbGVkICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gMiAvKiBjb21wbGV0ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXNrUXVldWVbJ2NvbXBsZXRlQXN5bmNUYXNrJ10odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncnVuIGFzeW5jIHRoZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCRyZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wZXJzaXN0ZW50ICYmIHJldXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrUXVldWVbJ3JldHVyblRvUG9vbCddKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXNrUXVldWVbJ2NvbXBsZXRlQXN5bmNUYXNrJ10odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncnVuIGFzeW5jIGNhdGNoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlamVjdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrUXVldWVbJ3Jlc2V0UGVyc2lzdGVudFRhc2snXSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJzaXN0ZW50IHRhc2tzIG5ldmVyIHJlYWNoIGNvbXBsZXRlZCBzdGF0dXMuIFRoZXkncmUgZWl0aGVyIHBlbmRpbmcsIHJ1bm5pbmcsIG9yIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gMyAvKiBjYW5jZWxlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDIgLyogY29tcGxldGVkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncnVuIHN5bmMgc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RlbnQgJiYgcmV1c2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza1F1ZXVlWydyZXR1cm5Ub1Bvb2wnXSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3J1biBzeW5jIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVqZWN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAnY2FuY2VsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gMCAvKiBwZW5kaW5nICovKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrUXVldWUgPSB0aGlzLnRhc2tRdWV1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJldXNhYmxlID0gdGhpcy5yZXVzYWJsZTtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdCA9IHRoaXMucmVqZWN0O1xuICAgICAgICAgICAgdGFza1F1ZXVlLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0YXNrUXVldWUuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHRhc2tRdWV1ZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDMgLyogY2FuY2VsZWQgKi87XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGlmIChyZXVzYWJsZSkge1xuICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVsncmV0dXJuVG9Qb29sJ10odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVqZWN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ2NhbmNlbCB0cnVlID1wZW5kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0dXMgPT09IDEgLyogcnVubmluZyAqLyAmJiB0aGlzLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAnY2FuY2VsIHRydWUgPXJ1bm5pbmcrcGVyc2lzdGVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdjYW5jZWwgZmFsc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlc2V0KHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdyZXNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5xdWV1ZVRpbWUgLSB0aGlzLmNyZWF0ZWRUaW1lO1xuICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5xdWV1ZVRpbWUgPSB0aW1lICsgZGVsYXk7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnJlamVjdCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3Jlc2V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2UodGltZSwgZGVsYXksIHByZWVtcHQsIHBlcnNpc3RlbnQsIHN1c3BlbmQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAncmV1c2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5xdWV1ZVRpbWUgPSB0aW1lICsgZGVsYXk7XG4gICAgICAgIHRoaXMucHJlZW1wdCA9IHByZWVtcHQ7XG4gICAgICAgIHRoaXMucGVyc2lzdGVudCA9IHBlcnNpc3RlbnQ7XG4gICAgICAgIHRoaXMuc3VzcGVuZCA9IHN1c3BlbmQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gMCAvKiBwZW5kaW5nICovO1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3JldXNlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLnRyYWNlKHRoaXMsICdkaXNwb3NlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9ICh2b2lkIDApO1xuICAgICAgICB0aGlzLnJlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGFza1N0YXR1cyhzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIDAgLyogcGVuZGluZyAqLzogcmV0dXJuICdwZW5kaW5nJztcbiAgICAgICAgY2FzZSAxIC8qIHJ1bm5pbmcgKi86IHJldHVybiAncnVubmluZyc7XG4gICAgICAgIGNhc2UgMyAvKiBjYW5jZWxlZCAqLzogcmV0dXJuICdjYW5jZWxlZCc7XG4gICAgICAgIGNhc2UgMiAvKiBjb21wbGV0ZWQgKi86IHJldHVybiAnY29tcGxldGVkJztcbiAgICB9XG59XG5jbGFzcyBUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnNvbGUpIHtcbiAgICAgICAgdGhpcy5jb25zb2xlID0gY29uc29sZTtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgIH1cbiAgICBlbnRlcihvYmosIG1ldGhvZCkge1xuICAgICAgICB0aGlzLmxvZyhgJHsnICAnLnJlcGVhdCh0aGlzLmRlcHRoKyspfT4gYCwgb2JqLCBtZXRob2QpO1xuICAgIH1cbiAgICBsZWF2ZShvYmosIG1ldGhvZCkge1xuICAgICAgICB0aGlzLmxvZyhgJHsnICAnLnJlcGVhdCgtLXRoaXMuZGVwdGgpfTwgYCwgb2JqLCBtZXRob2QpO1xuICAgIH1cbiAgICB0cmFjZShvYmosIG1ldGhvZCkge1xuICAgICAgICB0aGlzLmxvZyhgJHsnICAnLnJlcGVhdCh0aGlzLmRlcHRoKX0tIGAsIG9iaiwgbWV0aG9kKTtcbiAgICB9XG4gICAgbG9nKHByZWZpeCwgb2JqLCBtZXRob2QpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRhc2tRdWV1ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2luZyA9IG9ialsncHJvY2Vzc2luZyddLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSBvYmpbJ3BlbmRpbmcnXS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBkZWxheWVkID0gb2JqWydkZWxheWVkJ10ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZmx1c2hSZXEgPSBvYmpbJ2ZsdXNoUmVxdWVzdGVkJ107XG4gICAgICAgICAgICBjb25zdCBzdXNUYXNrID0gISFvYmpbJ3N1c3BlbmRlclRhc2snXTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBgcHJvY2Vzc2luZz0ke3Byb2Nlc3Npbmd9IHBlbmRpbmc9JHtwZW5kaW5nfSBkZWxheWVkPSR7ZGVsYXllZH0gZmx1c2hSZXE9JHtmbHVzaFJlcX0gc3VzVGFzaz0ke3N1c1Rhc2t9YDtcbiAgICAgICAgICAgIHRoaXMuY29uc29sZS5sb2coYCR7cHJlZml4fVtRLiR7bWV0aG9kfV0gJHtpbmZvfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBvYmpbJ2lkJ107XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkID0gTWF0aC5yb3VuZChvYmpbJ2NyZWF0ZWRUaW1lJ10gKiAxMCkgLyAxMDtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gTWF0aC5yb3VuZChvYmpbJ3F1ZXVlVGltZSddICogMTApIC8gMTA7XG4gICAgICAgICAgICBjb25zdCBwcmVlbXB0ID0gb2JqWydwcmVlbXB0J107XG4gICAgICAgICAgICBjb25zdCByZXVzYWJsZSA9IG9ialsncmV1c2FibGUnXTtcbiAgICAgICAgICAgIGNvbnN0IHBlcnNpc3RlbnQgPSBvYmpbJ3BlcnNpc3RlbnQnXTtcbiAgICAgICAgICAgIGNvbnN0IHN1c3BlbmQgPSBvYmpbJ3N1c3BlbmQnXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHRhc2tTdGF0dXMob2JqWydfc3RhdHVzJ10pO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGBpZD0ke2lkfSBjcmVhdGVkPSR7Y3JlYXRlZH0gcXVldWU9JHtxdWV1ZX0gcHJlZW1wdD0ke3ByZWVtcHR9IHBlcnNpc3RlbnQ9JHtwZXJzaXN0ZW50fSByZXVzYWJsZT0ke3JldXNhYmxlfSBzdGF0dXM9JHtzdGF0dXN9IHN1c3BlbmQ9JHtzdXNwZW5kfWA7XG4gICAgICAgICAgICB0aGlzLmNvbnNvbGUubG9nKGAke3ByZWZpeH1bVC4ke21ldGhvZH1dICR7aW5mb31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB2YXIgVGFza1F1ZXVlUHJpb3JpdHk7XG4oZnVuY3Rpb24gKFRhc2tRdWV1ZVByaW9yaXR5KSB7XG4gICAgVGFza1F1ZXVlUHJpb3JpdHlbVGFza1F1ZXVlUHJpb3JpdHlbXCJyZW5kZXJcIl0gPSAwXSA9IFwicmVuZGVyXCI7XG4gICAgVGFza1F1ZXVlUHJpb3JpdHlbVGFza1F1ZXVlUHJpb3JpdHlbXCJtYWNyb1Rhc2tcIl0gPSAxXSA9IFwibWFjcm9UYXNrXCI7XG4gICAgVGFza1F1ZXVlUHJpb3JpdHlbVGFza1F1ZXVlUHJpb3JpdHlbXCJwb3N0UmVuZGVyXCJdID0gMl0gPSBcInBvc3RSZW5kZXJcIjtcbn0pKFRhc2tRdWV1ZVByaW9yaXR5IHx8IChUYXNrUXVldWVQcmlvcml0eSA9IHt9KSk7XG5jb25zdCBkZWZhdWx0UXVldWVUYXNrT3B0aW9ucyA9IHtcbiAgICBkZWxheTogMCxcbiAgICBwcmVlbXB0OiBmYWxzZSxcbiAgICBwZXJzaXN0ZW50OiBmYWxzZSxcbiAgICByZXVzYWJsZTogdHJ1ZSxcbiAgICBzdXNwZW5kOiBmYWxzZSxcbn07XG5sZXQgJHJlc29sdmU7XG5sZXQgJHJlamVjdDtcbmZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICRyZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAkcmVqZWN0ID0gcmVqZWN0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBjcmVhdGUgYSBwcm9taXNlIHdoZXJlIHRoZSBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIGZ1bmN0aW9ucyBhcmUgc3RvcmVkIGFzIHByb3BlcnRpZXMgb24gdGhlIHByb21taXNlIGl0c2VsZi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXhwb3NlZFByb21pc2UoKSB7XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKGV4ZWN1dG9yKTtcbiAgICBwLnJlc29sdmUgPSAkcmVzb2x2ZTtcbiAgICBwLnJlamVjdCA9ICRyZWplY3Q7XG4gICAgcmV0dXJuIHA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY2xhc3MgQ29uZmlndXJhYmxlUm91dGUge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNhc2VTZW5zaXRpdmUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRW5kcG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHJvdXRlLCBwYXJhbU5hbWVzKSB7XG4gICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgdGhpcy5wYXJhbU5hbWVzID0gcGFyYW1OYW1lcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVjb2duaXplZFJvdXRlIHtcbiAgICBjb25zdHJ1Y3RvcihlbmRwb2ludCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxufVxuY2xhc3MgQ2FuZGlkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFycywgc3RhdGVzLCBza2lwcGVkU3RhdGVzLCByZXN1bHQpIHtcbiAgICAgICAgdGhpcy5jaGFycyA9IGNoYXJzO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICAgICAgdGhpcy5za2lwcGVkU3RhdGVzID0gc2tpcHBlZFN0YXRlcztcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuaGVhZCA9IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0ZWQtb3B0aW9uYWwtY2hhaW5cbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IHRoaXMuaGVhZD8uZW5kcG9pbnQ7XG4gICAgfVxuICAgIGFkdmFuY2UoY2gpIHtcbiAgICAgICAgY29uc3QgeyBjaGFycywgc3RhdGVzLCBza2lwcGVkU3RhdGVzLCByZXN1bHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzdGF0ZVRvQWRkID0gbnVsbDtcbiAgICAgICAgbGV0IG1hdGNoQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZ1bmN0aW9uICRwcm9jZXNzKG5leHRTdGF0ZSwgc2tpcHBlZFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXRlLmlzTWF0Y2goY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrbWF0Y2hDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVRvQWRkID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChuZXcgQ2FuZGlkYXRlKGNoYXJzLmNvbmNhdChjaCksIHN0YXRlcy5jb25jYXQobmV4dFN0YXRlKSwgc2tpcHBlZFN0YXRlID09PSBudWxsID8gc2tpcHBlZFN0YXRlcyA6IHNraXBwZWRTdGF0ZXMuY29uY2F0KHNraXBwZWRTdGF0ZSksIHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5zZWdtZW50ID09PSBudWxsICYmIG5leHRTdGF0ZS5pc09wdGlvbmFsICYmIG5leHRTdGF0ZS5uZXh0U3RhdGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5uZXh0U3RhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25leHRTdGF0ZS5uZXh0U3RhdGVzLmxlbmd0aH0gbmV4dFN0YXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBuZXh0U3RhdGUubmV4dFN0YXRlc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlcGFyYXRvci5pc1NlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIHNlcGFyYXRvcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLm5leHRTdGF0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCAkbmV4dFN0YXRlIG9mIHNlcGFyYXRvci5uZXh0U3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcHJvY2VzcygkbmV4dFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5pc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICRwcm9jZXNzKHN0YXRlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUubmV4dFN0YXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0U3RhdGUgb2Ygc3RhdGUubmV4dFN0YXRlcykge1xuICAgICAgICAgICAgICAgICRwcm9jZXNzKG5leHRTdGF0ZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlVG9BZGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlcy5wdXNoKHRoaXMuaGVhZCA9IHN0YXRlVG9BZGQpO1xuICAgICAgICAgICAgY2hhcnMucHVzaChjaCk7XG4gICAgICAgICAgICBpZiAoc3RhdGVUb0FkZC5lbmRwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQgPSBzdGF0ZVRvQWRkLmVuZHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICBmdW5jdGlvbiBjb2xsZWN0U2tpcHBlZFN0YXRlcyhza2lwcGVkU3RhdGVzLCBzdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXRlcyA9IHN0YXRlLm5leHRTdGF0ZXM7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA9PT0gMSAmJiBuZXh0U3RhdGVzWzBdLnNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdFNraXBwZWRTdGF0ZXMoc2tpcHBlZFN0YXRlcywgbmV4dFN0YXRlc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5leHRTdGF0ZSBvZiBuZXh0U3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLmlzT3B0aW9uYWwgJiYgbmV4dFN0YXRlLmVuZHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFN0YXRlcy5wdXNoKG5leHRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5uZXh0U3RhdGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgJG5leHRTdGF0ZSBvZiBuZXh0U3RhdGUubmV4dFN0YXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdFNraXBwZWRTdGF0ZXMoc2tpcHBlZFN0YXRlcywgJG5leHRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdFNraXBwZWRTdGF0ZXModGhpcy5za2lwcGVkU3RhdGVzLCB0aGlzLmhlYWQpO1xuICAgIH1cbiAgICBnZXRQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGVzLCBjaGFycywgZW5kcG9pbnQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICAvLyBGaXJzdCBpbml0aWFsaXplIGFsbCBwcm9wZXJ0aWVzIHdpdGggdW5kZWZpbmVkIHNvIHRoZXkgYWxsIGV4aXN0IChldmVuIGlmIHRoZXkncmUgbm90IGZpbGxlZCwgZS5nLiBub24tbWF0Y2hlZCBvcHRpb25hbCBwYXJhbXMpXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBlbmRwb2ludC5wYXJhbU5hbWVzKSB7XG4gICAgICAgICAgICBwYXJhbXNbbmFtZV0gPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RhdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzW2ldO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzRHluYW1pYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS5zZWdtZW50Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtc1tuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IGNoYXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW25hbWVdICs9IGNoYXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGlzIGNhbmRpZGF0ZSB0byBhbm90aGVyIGNhbmRpZGF0ZSB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3Qgc29ydGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIGRpZmZlcmVudCBmcm9tIGBzb3J0U29sdXRpb25zYCBpbiB2MSdzIHJvdXRlLXJlY29nbml6ZXIgaW4gdGhhdCBpdCBjb21wYXJlc1xuICAgICAqIHRoZSBjYW5kaWRhdGVzIHNlZ21lbnQtYnktc2VnbWVudCwgcmF0aGVyIHRoYW4gbWVyZWx5IGNvbXBhcmluZyB0aGUgY3VtdWxhdGl2ZSBvZiBzZWdtZW50IHR5cGVzXG4gICAgICpcbiAgICAgKiBUaGlzIHJlc29sdmVzIHYxJ3MgYW1iaWd1aXR5IGluIHNpdHVhdGlvbnMgbGlrZSBgL2Zvby86aWQvYmFyYCB2cy4gYC9mb28vYmFyLzppZGAsIHdoaWNoIGhhZCB0aGVcbiAgICAgKiBzYW1lIHNvcnRpbmcgdmFsdWUgYmVjYXVzZSB0aGV5IGJvdGggY29uc2lzdCBvZiB0d28gc3RhdGljIHNlZ21lbnRzIGFuZCBvbmUgZHluYW1pYyBzZWdtZW50LlxuICAgICAqXG4gICAgICogV2l0aCB0aGlzIGFsZ29yaXRobSwgYC9mb28vYmFyLzppZGAgd291bGQgYWx3YXlzIGJlIHNvcnRlZCBmaXJzdCBiZWNhdXNlIHRoZSBzZWNvbmQgc2VnbWVudCBpcyBkaWZmZXJlbnQsXG4gICAgICogYW5kIHN0YXRpYyB3aW5zIG92ZXIgZHluYW1pYy5cbiAgICAgKlxuICAgICAqICMjIyBOT1RFXG4gICAgICogVGhpcyBhbGdvcml0aG0gdmlvbGF0ZXMgc29tZSBvZiB0aGUgaW52YXJpYW50cyBvZiB2MSdzIGFsZ29yaXRobSxcbiAgICAgKiBidXQgdGhvc2UgaW52YXJpYW50cyB3ZXJlIGFyZ3VhYmx5IG5vdCB2ZXJ5IHNvdW5kIHRvIGJlZ2luIHdpdGguIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgL2Zvby8qcGF0aC9iYXIvYmF6YCB2cy4gYC9mb28vYmFyLypwYXRoMS8qcGF0aDJgXG4gICAgICogLSBpbiB2MSwgdGhlIGZpcnN0IHdvdWxkIHdpbiBiZWNhdXNlIHRoYXQgbWF0Y2ggaGFzIGZld2VyIHN0YXJzXG4gICAgICogLSBpbiB2MiwgdGhlIHNlY29uZCB3aWxsIHdpbiBiZWNhdXNlIHRoZXJlIGlzIGEgYmlnZ2VyIHN0YXRpYyBtYXRjaCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhdHRlcm5cbiAgICAgKlxuICAgICAqIFRoZSBhbGdvcml0aG0gc2hvdWxkIGJlIG1vcmUgbG9naWNhbCBhbmQgZWFzaWVyIHRvIHJlYXNvbiBhYm91dCBpbiB2MiwgYnV0IGl0J3MgaW1wb3J0YW50IHRvIGJlIGF3YXJlIG9mXG4gICAgICogc3VidGxlIGRpZmZlcmVuY2UgbGlrZSB0aGlzIHdoaWNoIG1pZ2h0IHN1cnByaXNlIHNvbWUgdXNlcnMgd2hvIGhhcHBlbmVkIHRvIHJlbHkgb24gdGhpcyBiZWhhdmlvciBmcm9tIHYxLFxuICAgICAqIGludGVudGlvbmFsbHkgb3IgdW5pbnRlbnRpb25hbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGIgLSBUaGUgY2FuZGlkYXRlIHRvIGNvbXBhcmUgdGhpcyB0by5cbiAgICAgKiBQYXJhbWV0ZXIgbmFtZSBpcyBgYmAgYmVjYXVzZSB0aGUgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGxpa2Ugc286IGBzdGF0ZXMuc29ydCgoYSwgYikgPT4gYS5jb21wYXJlVG8oYikpYC5cbiAgICAgKiBUaGlzIHdpbGwgYnJpbmcgdGhlIGNhbmRpZGF0ZSB3aXRoIHRoZSBoaWdoZXN0IHNjb3JlIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBvZiB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgY29tcGFyZVRvKGIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVzQSA9IHRoaXMuc3RhdGVzO1xuICAgICAgICBjb25zdCBzdGF0ZXNCID0gYi5zdGF0ZXM7XG4gICAgICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwLCBpaSA9IE1hdGgubWF4KHN0YXRlc0EubGVuZ3RoLCBzdGF0ZXNCLmxlbmd0aCk7IGlBIDwgaWk7ICsraUEpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZUEgPSBzdGF0ZXNBW2lBXTtcbiAgICAgICAgICAgIGlmIChzdGF0ZUEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXRlQiA9IHN0YXRlc0JbaUJdO1xuICAgICAgICAgICAgaWYgKHN0YXRlQiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNlZ21lbnRBID0gc3RhdGVBLnNlZ21lbnQ7XG4gICAgICAgICAgICBsZXQgc2VnbWVudEIgPSBzdGF0ZUIuc2VnbWVudDtcbiAgICAgICAgICAgIGlmIChzZWdtZW50QSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50QiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICArK2lCO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdGF0ZUEgPSBzdGF0ZXNBWysraUFdKSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWdtZW50QSA9IHN0YXRlQS5zZWdtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnbWVudEIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHN0YXRlQiA9IHN0YXRlc0JbKytpQl0pID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWdtZW50QiA9IHN0YXRlQi5zZWdtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZ21lbnRBLmtpbmQgPCBzZWdtZW50Qi5raW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudEEua2luZCA+IHNlZ21lbnRCLmtpbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2lCO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNraXBwZWRTdGF0ZXNBID0gdGhpcy5za2lwcGVkU3RhdGVzO1xuICAgICAgICBjb25zdCBza2lwcGVkU3RhdGVzQiA9IGIuc2tpcHBlZFN0YXRlcztcbiAgICAgICAgY29uc3Qgc2tpcHBlZFN0YXRlc0FMZW4gPSBza2lwcGVkU3RhdGVzQS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHNraXBwZWRTdGF0ZXNCTGVuID0gc2tpcHBlZFN0YXRlc0IubGVuZ3RoO1xuICAgICAgICBpZiAoc2tpcHBlZFN0YXRlc0FMZW4gPCBza2lwcGVkU3RhdGVzQkxlbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWRTdGF0ZXNBTGVuID4gc2tpcHBlZFN0YXRlc0JMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNraXBwZWRTdGF0ZXNBTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHNraXBwZWRTdGF0ZUEgPSBza2lwcGVkU3RhdGVzQVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHNraXBwZWRTdGF0ZUIgPSBza2lwcGVkU3RhdGVzQltpXTtcbiAgICAgICAgICAgIGlmIChza2lwcGVkU3RhdGVBLmxlbmd0aCA8IHNraXBwZWRTdGF0ZUIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2tpcHBlZFN0YXRlQS5sZW5ndGggPiBza2lwcGVkU3RhdGVCLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIHdpdGggYSBzaW5nbGUgcGF0dGVybiB3aXRoIG11bHRpcGxlIGNvbnNlY3V0aXZlIHN0YXIgc2VnbWVudHMuXG4gICAgICAgIC8vIFRPRE86IHByb2JhYmx5IHdhbnQgdG8gd2FybiBvciBldmVuIHRocm93IGhlcmUsIGJ1dCBsZWF2ZSBpdCBiZSBmb3Igbm93LlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNFbmRwb2ludChjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlLmhlYWQuZW5kcG9pbnQgIT09IG51bGw7XG59XG5mdW5jdGlvbiBjb21wYXJlQ2hhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG59XG5jbGFzcyBSZWNvZ25pemVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHJvb3RTdGF0ZSkge1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jYW5kaWRhdGVzID0gW25ldyBDYW5kaWRhdGUoWycnXSwgW3Jvb3RTdGF0ZV0sIFtdLCB0aGlzKV07XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0U29sdXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLmNhbmRpZGF0ZXMuZmlsdGVyKGhhc0VuZHBvaW50KTtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGUuZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGVzLnNvcnQoY29tcGFyZUNoYWlucyk7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzWzBdO1xuICAgIH1cbiAgICBhZGQoY2FuZGlkYXRlKSB7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIHJlbW92ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy5jYW5kaWRhdGVzLnNwbGljZSh0aGlzLmNhbmRpZGF0ZXMuaW5kZXhPZihjYW5kaWRhdGUpLCAxKTtcbiAgICB9XG4gICAgYWR2YW5jZShjaCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gdGhpcy5jYW5kaWRhdGVzLnNsaWNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5hZHZhbmNlKGNoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSb3V0ZVJlY29nbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJvb3RTdGF0ZSA9IG5ldyBTdGF0ZShudWxsLCBudWxsLCAnJyk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFkZChyb3V0ZU9yUm91dGVzKSB7XG4gICAgICAgIGlmIChyb3V0ZU9yUm91dGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVPclJvdXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGFkZChyb3V0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRhZGQocm91dGVPclJvdXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNhY2hlIHdoZW5ldmVyIHRoZXJlIGFyZSBzdGF0ZSBjaGFuZ2VzLCBiZWNhdXNlIHRoZSByZWNvZ25pemVSZXN1bHRzIGNvdWxkIGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudCBhcyBhIHJlc3VsdFxuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgICRhZGQocm91dGUpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHJvdXRlLnBhdGg7XG4gICAgICAgIGNvbnN0ICRyb3V0ZSA9IG5ldyBDb25maWd1cmFibGVSb3V0ZShyb3V0ZS5wYXRoLCByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLCByb3V0ZS5oYW5kbGVyKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGxlYWRpbmcsIHRyYWlsaW5nIGFuZCBkb3VibGUgc2xhc2hlcyBieSBpZ25vcmluZyBlbXB0eSBzZWdtZW50c1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhdGggPT09ICcnID8gWycnXSA6IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoaXNOb3RFbXB0eSk7XG4gICAgICAgIGNvbnN0IHBhcmFtTmFtZXMgPSBbXTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5yb290U3RhdGU7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgLy8gRWFjaCBzZWdtZW50IGFsd2F5cyBiZWdpbnMgd2l0aCBhIHNsYXNoLCBzbyB3ZSByZXByZXNlbnQgdGhpcyB3aXRoIGEgbm9uLXNlZ21lbnQgc3RhdGVcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYXBwZW5kKG51bGwsICcvJyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnOic6IHsgLy8gcm91dGUgcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBwYXJ0LmVuZHNXaXRoKCc/Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpc09wdGlvbmFsID8gcGFydC5zbGljZSgxLCAtMSkgOiBwYXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gbmV3IER5bmFtaWNTZWdtZW50KG5hbWUsIGlzT3B0aW9uYWwpLmFwcGVuZFRvKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJyonOiB7IC8vIGR5bmFtaWMgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhclNlZ21lbnQobmFtZSkuYXBwZW5kVG8oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogeyAvLyBzdGFuZGFyZCBwYXRoIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRpY1NlZ21lbnQocGFydCwgJHJvdXRlLmNhc2VTZW5zaXRpdmUpLmFwcGVuZFRvKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gbmV3IEVuZHBvaW50KCRyb3V0ZSwgcGFyYW1OYW1lcyk7XG4gICAgICAgIHN0YXRlLnNldEVuZHBvaW50KGVuZHBvaW50KTtcbiAgICB9XG4gICAgcmVjb2duaXplKHBhdGgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KHBhdGgsIHJlc3VsdCA9IHRoaXMuJHJlY29nbml6ZShwYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgJHJlY29nbml6ZShwYXRoKSB7XG4gICAgICAgIHBhdGggPSBkZWNvZGVVUkkocGF0aCk7XG4gICAgICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHBhdGggPSBgLyR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDEgJiYgcGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlY29nbml6ZVJlc3VsdCh0aGlzLnJvb3RTdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSBwYXRoLmNoYXJBdChpKTtcbiAgICAgICAgICAgIHJlc3VsdC5hZHZhbmNlKGNoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHJlc3VsdC5nZXRTb2x1dGlvbigpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGVuZHBvaW50IH0gPSBjYW5kaWRhdGU7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IGNhbmRpZGF0ZS5nZXRQYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWNvZ25pemVkUm91dGUoZW5kcG9pbnQsIHBhcmFtcyk7XG4gICAgfVxufVxuY2xhc3MgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHByZXZTdGF0ZSwgc2VnbWVudCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmV2U3RhdGUgPSBwcmV2U3RhdGU7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZXh0U3RhdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoc2VnbWVudD8ua2luZCkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIGR5bmFtaWMgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBwcmV2U3RhdGUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHNlZ21lbnQub3B0aW9uYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogc3RhciAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHByZXZTdGF0ZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTZXBhcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogc3RhdGljICovOlxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gcHJldlN0YXRlLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NlcGFyYXRvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHByZXZTdGF0ZSA9PT0gbnVsbCA/IDAgOiBwcmV2U3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTZXBhcmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kKHNlZ21lbnQsIHZhbHVlKSB7XG4gICAgICAgIGxldCBzdGF0ZTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXM7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWdtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IG5leHRTdGF0ZXMuZmluZChzID0+IHMudmFsdWUgPT09IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gbmV4dFN0YXRlcy5maW5kKHMgPT4gcy5zZWdtZW50Py5lcXVhbHMoc2VnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGVzLnB1c2goc3RhdGUgPSBuZXcgU3RhdGUodGhpcywgc2VnbWVudCwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHNldEVuZHBvaW50KGVuZHBvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLmVuZHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhZGQgYW1iaWd1b3VzIHJvdXRlLiBUaGUgcGF0dGVybiAnJHtlbmRwb2ludC5yb3V0ZS5wYXRofScgY2xhc2hlcyB3aXRoICcke3RoaXMuZW5kcG9pbnQucm91dGUucGF0aH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICAgICAgICBpZiAodGhpcy5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZTdGF0ZS5zZXRFbmRwb2ludChlbmRwb2ludCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2U3RhdGUuaXNTZXBhcmF0b3IgJiYgdGhpcy5wcmV2U3RhdGUucHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2U3RhdGUucHJldlN0YXRlLnNldEVuZHBvaW50KGVuZHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpc01hdGNoKGNoKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnNlZ21lbnQ7XG4gICAgICAgIHN3aXRjaCAoc2VnbWVudD8ua2luZCkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIGR5bmFtaWMgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLnZhbHVlLmluY2x1ZGVzKGNoKTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBzdGFyICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAzIC8qIHN0YXRpYyAqLzpcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgc2VwYXJhdG9ycyAoc2xhc2hlcykgYXJlIG5vbi1zZWdtZW50cy4gV2UgY291bGQgc2F5IHJldHVybiBjaCA9PT0gJy8nIGFzIHdlbGwsIHRlY2huaWNhbGx5LlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmluY2x1ZGVzKGNoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTm90RW1wdHkoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDA7XG59XG52YXIgU2VnbWVudEtpbmQ7XG4oZnVuY3Rpb24gKFNlZ21lbnRLaW5kKSB7XG4gICAgU2VnbWVudEtpbmRbU2VnbWVudEtpbmRbXCJzdGFyXCJdID0gMV0gPSBcInN0YXJcIjtcbiAgICBTZWdtZW50S2luZFtTZWdtZW50S2luZFtcImR5bmFtaWNcIl0gPSAyXSA9IFwiZHluYW1pY1wiO1xuICAgIFNlZ21lbnRLaW5kW1NlZ21lbnRLaW5kW1wic3RhdGljXCJdID0gM10gPSBcInN0YXRpY1wiO1xufSkoU2VnbWVudEtpbmQgfHwgKFNlZ21lbnRLaW5kID0ge30pKTtcbmNsYXNzIFN0YXRpY1NlZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gY2FzZVNlbnNpdGl2ZTtcbiAgICB9XG4gICAgZ2V0IGtpbmQoKSB7IHJldHVybiAzIC8qIHN0YXRpYyAqLzsgfVxuICAgIGFwcGVuZFRvKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIHZhbHVlOiB7IGxlbmd0aCB9IH0gPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgLyogc2VnbWVudCAqLyB0aGlzLCBcbiAgICAgICAgICAgICAgICAvKiB2YWx1ZSAgICovIHZhbHVlLmNoYXJBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSB2YWx1ZS5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgLyogc2VnbWVudCAqLyB0aGlzLCBcbiAgICAgICAgICAgICAgICAvKiB2YWx1ZSAgICovIGNoLnRvVXBwZXJDYXNlKCkgKyBjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGVxdWFscyhiKSB7XG4gICAgICAgIHJldHVybiAoYi5raW5kID09PSAzIC8qIHN0YXRpYyAqLyAmJlxuICAgICAgICAgICAgYi5jYXNlU2Vuc2l0aXZlID09PSB0aGlzLmNhc2VTZW5zaXRpdmUgJiZcbiAgICAgICAgICAgIGIudmFsdWUgPT09IHRoaXMudmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIER5bmFtaWNTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvcHRpb25hbCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuICAgIGdldCBraW5kKCkgeyByZXR1cm4gMiAvKiBkeW5hbWljICovOyB9XG4gICAgYXBwZW5kVG8oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGF0ZS5hcHBlbmQoXG4gICAgICAgIC8qIHNlZ21lbnQgKi8gdGhpcywgXG4gICAgICAgIC8qIHZhbHVlICAgKi8gJy8nKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBlcXVhbHMoYikge1xuICAgICAgICByZXR1cm4gKGIua2luZCA9PT0gMiAvKiBkeW5hbWljICovICYmXG4gICAgICAgICAgICBiLm9wdGlvbmFsID09PSB0aGlzLm9wdGlvbmFsICYmXG4gICAgICAgICAgICBiLm5hbWUgPT09IHRoaXMubmFtZSk7XG4gICAgfVxufVxuY2xhc3MgU3RhclNlZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgZ2V0IGtpbmQoKSB7IHJldHVybiAxIC8qIHN0YXIgKi87IH1cbiAgICBhcHBlbmRUbyhzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YXRlLmFwcGVuZChcbiAgICAgICAgLyogc2VnbWVudCAqLyB0aGlzLCBcbiAgICAgICAgLyogdmFsdWUgICAqLyAnJyk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZXF1YWxzKGIpIHtcbiAgICAgICAgcmV0dXJuIChiLmtpbmQgPT09IDEgLyogc3RhciAqLyAmJlxuICAgICAgICAgICAgYi5uYW1lID09PSB0aGlzLm5hbWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIGV4cG9ydCBjbGFzcyBPcGVuUHJvbWlzZTxUPiB7XG4vLyAgIHB1YmxpYyBpc1BlbmRpbmc6IGJvb2xlYW4gPSB0cnVlO1xuLy8gICBwdWJsaWMgcHJvbWlzZSE6IFByb21pc2U8VD47XG4vLyAgIHB1YmxpYyByZXNvbHZlITogKHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWQ7XG4vLyAgIHB1YmxpYyByZWplY3QhOiAoKSA9PiB2b2lkO1xuLy8gfVxuaW1wb3J0IHsgT3BlblByb21pc2UgfSBmcm9tICcuL29wZW4tcHJvbWlzZS5qcyc7XG5leHBvcnQgY2xhc3MgQXdhaXRhYmxlTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChvcGVuUHJvbWlzZSBpbnN0YW5jZW9mIE9wZW5Qcm9taXNlKSB7XG4gICAgICAgICAgICBvcGVuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIG9wZW5Qcm9taXNlLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgT3BlblByb21pc2UpIHtcbiAgICAgICAgICAgIGN1cnJlbnQucmVqZWN0KCk7XG4gICAgICAgICAgICAvLyBjdXJyZW50LmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBhd2FpdChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgb3BlblByb21pc2UgPSBuZXcgT3BlblByb21pc2UoKTtcbiAgICAgICAgICAgIC8vIG9wZW5Qcm9taXNlLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIC8vICAgb3BlblByb21pc2UucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIC8vICAgb3BlblByb21pc2UucmVqZWN0ID0gcmVqO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCBvcGVuUHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlblByb21pc2UucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgT3BlblByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhrZXkpICYmICEodGhpcy5tYXAuZ2V0KGtleSkgaW5zdGFuY2VvZiBPcGVuUHJvbWlzZSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBBd2FpdGFibGVNYXAoKTtcbiAgICAgICAgY2xvbmUubWFwID0gbmV3IE1hcCh0aGlzLm1hcCk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hd2FpdGFibGUtbWFwLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgSVdpbmRvdywgSUhpc3RvcnksIElMb2NhdGlvbiwgSVBsYXRmb3JtIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IFRhc2tRdWV1ZSB9IGZyb20gJy4vdGFzay1xdWV1ZS5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG4gKi9cbmxldCBCcm93c2VyVmlld2VyU3RvcmUgPSBjbGFzcyBCcm93c2VyVmlld2VyU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtLCB3aW5kb3csIGhpc3RvcnksIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgPSAyOyAvLyBMaW1pdCBubyBvZiBleGVjdXRlZCBhY3Rpb25zIHdpdGhpbiB0aGUgc2FtZSBSQUYgKGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb24pXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgdXNlVXJsRnJhZ21lbnRIYXNoOiB0cnVlLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHsgcmV0dXJuOyB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvcndhcmRlZFN0YXRlID0geyBldmVudFRhc2s6IG51bGwsIHN1cHByZXNzUG9wc3RhdGU6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9wc3RhdGUgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRUYXNrLCBzdXBwcmVzc1BvcHN0YXRlIH0gPSB0aGlzLmZvcndhcmRlZFN0YXRlO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkZWRTdGF0ZSA9IHsgZXZlbnRUYXNrOiBudWxsLCBzdXBwcmVzc1BvcHN0YXRlOiBmYWxzZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0NhbGxzLmVucXVldWUoYXN5bmMgKHRhc2spID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZXYgPSBldmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBldlRhc2sgPSBldmVudFRhc2s7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VwcHJlc3NQb3BzdGF0ZUV2ZW50ID0gc3VwcHJlc3NQb3BzdGF0ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdG9yZS5wb3BzdGF0ZShldiwgZXZUYXNrLCBzdXBwcmVzc1BvcHN0YXRlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRhc2sucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgMSkud2FpdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlbmRpbmdDYWxscyA9IG5ldyBUYXNrUXVldWUoKTtcbiAgICB9XG4gICAgc3RhcnQob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIG5hdmlnYXRpb24gaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgICAgIGlmIChvcHRpb25zLnVzZVVybEZyYWdtZW50SGFzaCAhPSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy51c2VVcmxGcmFnbWVudEhhc2ggPSBvcHRpb25zLnVzZVVybEZyYWdtZW50SGFzaDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdDYWxscy5zdGFydCh7IHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLCBhbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2s6IHRoaXMuYWxsb3dlZEV4ZWN1dGlvbkNvc3RXaXRoaW5UaWNrIH0pO1xuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wc3RhdGUpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBuYXZpZ2F0aW9uIGhhcyBub3QgYmVlbiBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmhhbmRsZVBvcHN0YXRlKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FsbHMuc3RvcCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IHVzZVVybEZyYWdtZW50SGFzaDogdHJ1ZSwgY2FsbGJhY2s6ICgpID0+IHsgcmV0dXJuOyB9IH07XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHZpZXdlclN0YXRlKCkge1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5OiBzZWFyY2gsXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IHRoaXMub3B0aW9ucy51c2VVcmxGcmFnbWVudEhhc2ggPyBoYXNoLnNsaWNlKDEpIDogcGF0aG5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdvKGRlbHRhLCBzdXBwcmVzc1BvcHN0YXRlRXZlbnQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBkb25lVGFzayA9IHRoaXMucGVuZGluZ0NhbGxzLmNyZWF0ZVF1ZXVlVGFzaygodGFzaykgPT4gdGFzay5yZXNvbHZlKCksIDEpO1xuICAgICAgICB0aGlzLnBlbmRpbmdDYWxscy5lbnF1ZXVlKFtcbiAgICAgICAgICAgICh0YXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFzayA9IGRvbmVUYXNrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1cHByZXNzUG9wc3RhdGUgPSBzdXBwcmVzc1BvcHN0YXRlRXZlbnQ7XG4gICAgICAgICAgICAgICAgc3RvcmUuZm9yd2FyZFN0YXRlKHsgZXZlbnRUYXNrLCBzdXBwcmVzc1BvcHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgIHRhc2sucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICh0YXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwcyA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIGhpc3RvcnkuZ28oc3RlcHMpO1xuICAgICAgICAgICAgICAgIHRhc2sucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXSwgWzAsIDFdKTtcbiAgICAgICAgcmV0dXJuIGRvbmVUYXNrLndhaXQoKTtcbiAgICB9XG4gICAgYXN5bmMgcHVzaE5hdmlnYXRvclN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHsgdGl0bGUsIHBhdGggfSA9IHN0YXRlLmN1cnJlbnRFbnRyeTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLm9wdGlvbnMudXNlVXJsRnJhZ21lbnRIYXNoID8gJyMvJyA6ICcnO1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nQ2FsbHMuZW5xdWV1ZSgodGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlT3JFbXB0eSA9IHRpdGxlIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7ZnJhZ21lbnR9JHtwYXRofWA7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShkYXRhLCB0aXRsZU9yRW1wdHksIHVybCk7XG4gICAgICAgICAgICB0YXNrLnJlc29sdmUoKTtcbiAgICAgICAgfSwgMSkud2FpdCgpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlTmF2aWdhdG9yU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyB0aXRsZSwgcGF0aCB9ID0gc3RhdGUuY3VycmVudEVudHJ5O1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMub3B0aW9ucy51c2VVcmxGcmFnbWVudEhhc2ggPyAnIy8nIDogJyc7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdDYWxscy5lbnF1ZXVlKCh0YXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdGl0bGVPckVtcHR5ID0gdGl0bGUgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtmcmFnbWVudH0ke3BhdGh9YDtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGRhdGEsIHRpdGxlT3JFbXB0eSwgdXJsKTtcbiAgICAgICAgICAgIHRhc2sucmVzb2x2ZSgpO1xuICAgICAgICB9LCAxKS53YWl0KCk7XG4gICAgfVxuICAgIGFzeW5jIHBvcE5hdmlnYXRvclN0YXRlKCkge1xuICAgICAgICBjb25zdCBkb25lVGFzayA9IHRoaXMucGVuZGluZ0NhbGxzLmNyZWF0ZVF1ZXVlVGFzaygodGFzaykgPT4gdGFzay5yZXNvbHZlKCksIDEpO1xuICAgICAgICB0aGlzLnBlbmRpbmdDYWxscy5lbnF1ZXVlKGFzeW5jICh0YXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBldmVudFRhc2sgPSBkb25lVGFzaztcbiAgICAgICAgICAgIGF3YWl0IHN0b3JlLnBvcFN0YXRlKGV2ZW50VGFzayk7XG4gICAgICAgICAgICB0YXNrLnJlc29sdmUoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIHJldHVybiBkb25lVGFzay53YWl0KCk7XG4gICAgfVxuICAgIGFzeW5jIHBvcFN0YXRlKGRvbmVUYXNrKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZ28oLTEsIHRydWUpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuaGlzdG9yeS5zdGF0ZTtcbiAgICAgICAgLy8gVE9ETzogRml4IGJyb3dzZXIgZm9yd2FyZCBidWcgYWZ0ZXIgcG9wIG9uIGZpcnN0IGVudHJ5XG4gICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5jdXJyZW50RW50cnkgJiYgIXN0YXRlLmN1cnJlbnRFbnRyeS5maXJzdEVudHJ5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdvKC0xLCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE5hdmlnYXRvclN0YXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBkb25lVGFzay5leGVjdXRlKCk7XG4gICAgfVxuICAgIGZvcndhcmRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLmZvcndhcmRlZFN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIGFzeW5jIHBvcHN0YXRlKGV2LCBldmVudFRhc2ssIHN1cHByZXNzUG9wc3RhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXN1cHByZXNzUG9wc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy52aWV3ZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuaGlzdG9yeS5zdGF0ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50VGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYXdhaXQgZXZlbnRUYXNrLmV4ZWN1dGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRUaXRsZSh0aXRsZSkge1xuICAgICAgICB0aGlzLndpbmRvdy5kb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuICAgIH1cbn07XG5Ccm93c2VyVmlld2VyU3RvcmUgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElQbGF0Zm9ybSksXG4gICAgX19wYXJhbSgxLCBJV2luZG93KSxcbiAgICBfX3BhcmFtKDIsIElIaXN0b3J5KSxcbiAgICBfX3BhcmFtKDMsIElMb2NhdGlvbilcbl0sIEJyb3dzZXJWaWV3ZXJTdG9yZSk7XG5leHBvcnQgeyBCcm93c2VyVmlld2VyU3RvcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXItdmlld2VyLXN0b3JlLmpzLm1hcCIsImltcG9ydCB7IGFycmF5UmVtb3ZlIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbCAtIEhlbHBlciBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAtMTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5jdXJyZW50SW5kZXggKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1srK3RoaXMuY3VycmVudEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gLTE7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDdXJyZW50KCkge1xuICAgICAgICB0aGlzLnNwbGljZSh0aGlzLmN1cnJlbnRJbmRleC0tLCAxKTtcbiAgICB9XG4gICAgcmVtb3ZlKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGFycmF5UmVtb3ZlKHRoaXMsIHZhbHVlID0+IHZhbHVlID09PSBpbnN0cnVjdGlvbik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBESSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBBcHBUYXNrIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IE5hdkN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3Jlc291cmNlcy9uYXYuanMnO1xuaW1wb3J0IHsgVmlld3BvcnRDdXN0b21FbGVtZW50IH0gZnJvbSAnLi9yZXNvdXJjZXMvdmlld3BvcnQuanMnO1xuaW1wb3J0IHsgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3Jlc291cmNlcy92aWV3cG9ydC1zY29wZS5qcyc7XG5pbXBvcnQgeyBHb3RvQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi9yZXNvdXJjZXMvZ290by5qcyc7XG5pbXBvcnQgeyBMb2FkQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi9yZXNvdXJjZXMvbG9hZC5qcyc7XG5pbXBvcnQgeyBIcmVmQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi9yZXNvdXJjZXMvaHJlZi5qcyc7XG5pbXBvcnQgeyBJUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXIuanMnO1xuZXhwb3J0IGNvbnN0IFJvdXRlclJlZ2lzdHJhdGlvbiA9IElSb3V0ZXI7XG4vKipcbiAqIERlZmF1bHQgcnVudGltZS9lbnZpcm9ubWVudC1hZ25vc3RpYyBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlczpcbiAqIC0gYElSb3V0ZXJgXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0Q29tcG9uZW50cyA9IFtcbiAgICBSb3V0ZXJSZWdpc3RyYXRpb24sXG5dO1xuZXhwb3J0IHsgVmlld3BvcnRDdXN0b21FbGVtZW50LCBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCwgTmF2Q3VzdG9tRWxlbWVudCwgR290b0N1c3RvbUF0dHJpYnV0ZSwgTG9hZEN1c3RvbUF0dHJpYnV0ZSwgSHJlZkN1c3RvbUF0dHJpYnV0ZSwgfTtcbmV4cG9ydCBjb25zdCBWaWV3cG9ydEN1c3RvbUVsZW1lbnRSZWdpc3RyYXRpb24gPSBWaWV3cG9ydEN1c3RvbUVsZW1lbnQ7XG5leHBvcnQgY29uc3QgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnRSZWdpc3RyYXRpb24gPSBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudDtcbmV4cG9ydCBjb25zdCBOYXZDdXN0b21FbGVtZW50UmVnaXN0cmF0aW9uID0gTmF2Q3VzdG9tRWxlbWVudDtcbmV4cG9ydCBjb25zdCBHb3RvQ3VzdG9tQXR0cmlidXRlUmVnaXN0cmF0aW9uID0gR290b0N1c3RvbUF0dHJpYnV0ZTtcbmV4cG9ydCBjb25zdCBMb2FkQ3VzdG9tQXR0cmlidXRlUmVnaXN0cmF0aW9uID0gTG9hZEN1c3RvbUF0dHJpYnV0ZTtcbmV4cG9ydCBjb25zdCBIcmVmQ3VzdG9tQXR0cmlidXRlUmVnaXN0cmF0aW9uID0gSHJlZkN1c3RvbUF0dHJpYnV0ZTtcbi8qKlxuICogRGVmYXVsdCByb3V0ZXIgcmVzb3VyY2VzOlxuICogLSBDdXN0b20gRWxlbWVudHM6IGBhdS12aWV3cG9ydGAsIGBhdS1uYXZgXG4gKiAtIEN1c3RvbSBBdHRyaWJ1dGVzOiBgZ290b2AsIGBsb2FkYCwgYGhyZWZgXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0UmVzb3VyY2VzID0gW1xuICAgIFZpZXdwb3J0Q3VzdG9tRWxlbWVudCxcbiAgICBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCxcbiAgICBOYXZDdXN0b21FbGVtZW50LFxuICAgIEdvdG9DdXN0b21BdHRyaWJ1dGUsXG4gICAgTG9hZEN1c3RvbUF0dHJpYnV0ZSxcbiAgICBIcmVmQ3VzdG9tQXR0cmlidXRlLFxuXTtcbmxldCBjb25maWd1cmF0aW9uT3B0aW9ucyA9IHt9O1xubGV0IGNvbmZpZ3VyYXRpb25DYWxsID0gKHJvdXRlcikgPT4ge1xuICAgIHJvdXRlci5zdGFydChjb25maWd1cmF0aW9uT3B0aW9ucyk7XG59O1xuLyoqXG4gKiBBIERJIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgcm91dGVyIHJlc291cmNlIHJlZ2lzdHJhdGlvbnMuXG4gKi9cbmNvbnN0IHJvdXRlckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhpcyBjb25maWd1cmF0aW9uIHRvIHRoZSBwcm92aWRlZCBjb250YWluZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIucmVnaXN0ZXIoLi4uRGVmYXVsdENvbXBvbmVudHMsIC4uLkRlZmF1bHRSZXNvdXJjZXMsIEFwcFRhc2sud2l0aChJUm91dGVyKS5iZWZvcmVBY3RpdmF0ZSgpLmNhbGwoY29uZmlndXJhdGlvbkNhbGwpLCBBcHBUYXNrLndpdGgoSVJvdXRlcikuYWZ0ZXJBY3RpdmF0ZSgpLmNhbGwocm91dGVyID0+IHJvdXRlci5sb2FkVXJsKCkpLCBBcHBUYXNrLndpdGgoSVJvdXRlcikuYWZ0ZXJEZWFjdGl2YXRlKCkuY2FsbChyb3V0ZXIgPT4gcm91dGVyLnN0b3AoKSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbnRhaW5lciB3aXRoIHRoaXMgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXIoREkuY3JlYXRlQ29udGFpbmVyKCkpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgUm91dGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiBNYWtlIGl0IHBvc3NpYmxlIHRvIHNwZWNpZnkgb3B0aW9ucyB0byBSb3V0ZXIgYWN0aXZhdGlvbi5cbiAgICAgKiBQYXJhbWV0ZXIgaXMgZWl0aGVyIGEgY29uZmlnIG9iamVjdCB0aGF0J3MgcGFzc2VkIHRvIFJvdXRlcidzIHN0YXJ0XG4gICAgICogb3IgYSBjb25maWcgZnVuY3Rpb24gdGhhdCdzIGNhbGxlZCBpbnN0ZWFkIG9mIFJvdXRlcidzIHN0YXJ0LlxuICAgICAqL1xuICAgIGN1c3RvbWl6ZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbkNhbGwgPSAocm91dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcm91dGVyLnN0YXJ0KGNvbmZpZ3VyYXRpb25PcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25DYWxsID0gY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbk9wdGlvbnMgPSBjb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4ucm91dGVyQ29uZmlndXJhdGlvbiB9O1xuICAgIH0sXG4gICAgLi4ucm91dGVyQ29uZmlndXJhdGlvbixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWd1cmF0aW9uLmpzLm1hcCIsIi8qKlxuICogQGludGVybmFsIC0gVXNlZCB3aGVuIGZvdW5kaW5nIHJvdXRlL2luc3RydWN0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgRm91bmRSb3V0ZSB7XG4gICAgY29uc3RydWN0b3IobWF0Y2ggPSBudWxsLCBtYXRjaGluZyA9ICcnLCBpbnN0cnVjdGlvbnMgPSBbXSwgcmVtYWluaW5nID0gJycsIFxuICAgIC8vIHB1YmxpYyByZW1haW5pbmc6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICAgIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy5tYXRjaGluZyA9IG1hdGNoaW5nO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgdGhpcy5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICBnZXQgZm91bmRDb25maWd1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCAhPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGZvdW5kSW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGhhc1JlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nICE9PSBudWxsICYmIHRoaXMucmVtYWluaW5nLmxlbmd0aCA+IDA7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm91bmQtcm91dGUuanMubWFwIiwiaW1wb3J0IHsgSG9vayB9IGZyb20gJy4vaG9vay5qcyc7XG4vKipcbiAqIFB1YmxpYyBBUElcbiAqL1xuZXhwb3J0IHZhciBIb29rVHlwZXM7XG4oZnVuY3Rpb24gKEhvb2tUeXBlcykge1xuICAgIEhvb2tUeXBlc1tcIkJlZm9yZU5hdmlnYXRpb25cIl0gPSBcImJlZm9yZU5hdmlnYXRpb25cIjtcbiAgICBIb29rVHlwZXNbXCJUcmFuc2Zvcm1Gcm9tVXJsXCJdID0gXCJ0cmFuc2Zvcm1Gcm9tVXJsXCI7XG4gICAgSG9va1R5cGVzW1wiVHJhbnNmb3JtVG9VcmxcIl0gPSBcInRyYW5zZm9ybVRvVXJsXCI7XG4gICAgSG9va1R5cGVzW1wiU2V0VGl0bGVcIl0gPSBcInNldFRpdGxlXCI7XG59KShIb29rVHlwZXMgfHwgKEhvb2tUeXBlcyA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG4gKi9cbmV4cG9ydCBjbGFzcyBIb29rTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9va3MgPSB7XG4gICAgICAgICAgICBiZWZvcmVOYXZpZ2F0aW9uOiBbXSxcbiAgICAgICAgICAgIHRyYW5zZm9ybUZyb21Vcmw6IFtdLFxuICAgICAgICAgICAgdHJhbnNmb3JtVG9Vcmw6IFtdLFxuICAgICAgICAgICAgc2V0VGl0bGU6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxhc3RJZGVudGl0eSA9IDA7XG4gICAgfVxuICAgIGFkZEhvb2soaG9va0Z1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGhvb2sgPSBuZXcgSG9vayhob29rRnVuY3Rpb24sIG9wdGlvbnMgfHwge30sICsrdGhpcy5sYXN0SWRlbnRpdHkpO1xuICAgICAgICB0aGlzLmhvb2tzW2hvb2sudHlwZV0ucHVzaChob29rKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdElkZW50aXR5O1xuICAgIH1cbiAgICByZW1vdmVIb29rKGlkKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLmhvb2tzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG9va3MsIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmhvb2tzW3R5cGVdLmZpbmRJbmRleChob29rID0+IGhvb2suaWQgPT09IGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvb2tzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGludm9rZUJlZm9yZU5hdmlnYXRpb24odmlld3BvcnRJbnN0cnVjdGlvbnMsIG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoXCJiZWZvcmVOYXZpZ2F0aW9uXCIgLyogQmVmb3JlTmF2aWdhdGlvbiAqLywgbmF2aWdhdGlvbkluc3RydWN0aW9uLCB2aWV3cG9ydEluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZVRyYW5zZm9ybUZyb21VcmwodXJsLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKFwidHJhbnNmb3JtRnJvbVVybFwiIC8qIFRyYW5zZm9ybUZyb21VcmwgKi8sIG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgdXJsKTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlVHJhbnNmb3JtVG9Vcmwoc3RhdGUsIG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoXCJ0cmFuc2Zvcm1Ub1VybFwiIC8qIFRyYW5zZm9ybVRvVXJsICovLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIHN0YXRlKTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlU2V0VGl0bGUodGl0bGUsIG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoXCJzZXRUaXRsZVwiIC8qIFNldFRpdGxlICovLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIHRpdGxlKTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKHR5cGUsIG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgYXJnKSB7XG4gICAgICAgIGZvciAoY29uc3QgaG9vayBvZiB0aGlzLmhvb2tzW3R5cGVdKSB7XG4gICAgICAgICAgICBpZiAoIWhvb2sud2FudHNNYXRjaCB8fCBob29rLm1hdGNoZXMoYXJnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBob29rLmludm9rZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvdXRjb21lID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRjb21lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IG91dGNvbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9vay1tYW5hZ2VyLmpzLm1hcCIsImltcG9ydCB7IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIsIFZpZXdwb3J0SGFuZGxlUmVzb2x2ZXIgfSBmcm9tICcuL3R5cGUtcmVzb2x2ZXJzLmpzJztcbmltcG9ydCB7IFZpZXdwb3J0SW5zdHJ1Y3Rpb24gfSBmcm9tICcuL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IGNsYXNzIEhvb2sge1xuICAgIGNvbnN0cnVjdG9yKGhvb2ssIG9wdGlvbnMsIGlkKSB7XG4gICAgICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlID0gXCJiZWZvcmVOYXZpZ2F0aW9uXCIgLyogQmVmb3JlTmF2aWdhdGlvbiAqLztcbiAgICAgICAgdGhpcy5pbmNsdWRlVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUYXJnZXRzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIG9wdGlvbnMuaW5jbHVkZSB8fCBbXSkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVGFyZ2V0cy5wdXNoKG5ldyBUYXJnZXQodGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2Ygb3B0aW9ucy5leGNsdWRlIHx8IFtdKSB7XG4gICAgICAgICAgICB0aGlzLmV4Y2x1ZGVUYXJnZXRzLnB1c2gobmV3IFRhcmdldCh0YXJnZXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgd2FudHNNYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5jbHVkZVRhcmdldHMubGVuZ3RoID4gMCB8fCB0aGlzLmV4Y2x1ZGVUYXJnZXRzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIG1hdGNoZXModmlld3BvcnRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhcmdldHMubGVuZ3RoICYmICF0aGlzLmluY2x1ZGVUYXJnZXRzLnNvbWUodGFyZ2V0ID0+IHRhcmdldC5tYXRjaGVzKHZpZXdwb3J0SW5zdHJ1Y3Rpb25zKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5leGNsdWRlVGFyZ2V0cy5zb21lKHRhcmdldCA9PiB0YXJnZXQubWF0Y2hlcyh2aWV3cG9ydEluc3RydWN0aW9ucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGludm9rZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGFyZykge1xuICAgICAgICAvLyBUT0RPOiBGaXggdGhlIHR5cGUgaGVyZVxuICAgICAgICByZXR1cm4gdGhpcy5ob29rKGFyZywgbmF2aWdhdGlvbkluc3RydWN0aW9uKTtcbiAgICB9XG59XG5jbGFzcyBUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3cG9ydE5hbWUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TmFtZSA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmlzVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldE5hbWUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGN2VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGN2VGFyZ2V0LmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNUeXBlKGN2VGFyZ2V0LmNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgPyBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldFR5cGUoY3ZUYXJnZXQuY29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnROYW1lID0gQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5nZXROYW1lKGN2VGFyZ2V0LmNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3ZUYXJnZXQudmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gVmlld3BvcnRIYW5kbGVSZXNvbHZlci5pc0luc3RhbmNlKGN2VGFyZ2V0LnZpZXdwb3J0KSA/IGN2VGFyZ2V0LnZpZXdwb3J0IDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0TmFtZSA9IFZpZXdwb3J0SGFuZGxlUmVzb2x2ZXIuZ2V0TmFtZShjdlRhcmdldC52aWV3cG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2hlcyh2aWV3cG9ydEluc3RydWN0aW9ucykge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB2aWV3cG9ydEluc3RydWN0aW9ucy5zbGljZSgpO1xuICAgICAgICBpZiAoIWluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGluc3RydWN0aW9ucy5wdXNoKG5ldyBWaWV3cG9ydEluc3RydWN0aW9uKCcnKSk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChWaWV3cG9ydEluc3RydWN0aW9uLmNyZWF0ZShudWxsLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuY29tcG9uZW50TmFtZSAhPT0gbnVsbCAmJiB0aGlzLmNvbXBvbmVudE5hbWUgPT09IGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuY29tcG9uZW50VHlwZSAhPT0gbnVsbCAmJiB0aGlzLmNvbXBvbmVudFR5cGUgPT09IGluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMudmlld3BvcnROYW1lICE9PSBudWxsICYmIHRoaXMudmlld3BvcnROYW1lID09PSBpbnN0cnVjdGlvbi52aWV3cG9ydE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMudmlld3BvcnQgIT09IG51bGwgJiYgdGhpcy52aWV3cG9ydCA9PT0gaW5zdHJ1Y3Rpb24udmlld3BvcnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2suanMubWFwIiwiZXhwb3J0IHsgTGlua0hhbmRsZXIsIH0gZnJvbSAnLi9saW5rLWhhbmRsZXIuanMnO1xuZXhwb3J0IHsgSW5zdHJ1Y3Rpb25SZXNvbHZlciwgfSBmcm9tICcuL2luc3RydWN0aW9uLXJlc29sdmVyLmpzJztcbmV4cG9ydCB7IFJlZW50cnlCZWhhdmlvciwgfSBmcm9tICcuL2ludGVyZmFjZXMuanMnO1xuZXhwb3J0IHsgbGlmZWN5Y2xlTG9nZ2VyLCBMaWZlY3ljbGVDbGFzcywgfSBmcm9tICcuL2xpZmVjeWNsZS1sb2dnZXIuanMnO1xuZXhwb3J0IHsgSG9va01hbmFnZXIsIEhvb2tUeXBlcywgfSBmcm9tICcuL2hvb2stbWFuYWdlci5qcyc7XG5leHBvcnQgeyBOYXYsIH0gZnJvbSAnLi9uYXYuanMnO1xuZXhwb3J0IHsgTmF2Um91dGUsIH0gZnJvbSAnLi9uYXYtcm91dGUuanMnO1xuZXhwb3J0IHsgTmF2aWdhdGlvbiwgfSBmcm9tICcuL25hdmlnYXRpb24uanMnO1xuZXhwb3J0IHsgTmF2aWdhdG9yLCB9IGZyb20gJy4vbmF2aWdhdG9yLmpzJztcbmV4cG9ydCB7IFJ1bm5lciwgfSBmcm9tICcuL3J1bm5lci5qcyc7XG5leHBvcnQgeyBRdWV1ZSwgfSBmcm9tICcuL3F1ZXVlLmpzJztcbmV4cG9ydCB7IFJvdXRlUmVjb2duaXplciwgQ29uZmlndXJhYmxlUm91dGUsIFJlY29nbml6ZWRSb3V0ZSwgRW5kcG9pbnQsIH0gZnJvbSAnLi9yb3V0ZS1yZWNvZ25pemVyLmpzJztcbmV4cG9ydCB7IFxuLy8gSVJvdXRlckFjdGl2YXRlT3B0aW9ucyxcbi8vIElSb3V0ZXJPcHRpb25zLFxuLy8gSVJvdXRlclRpdGxlLFxuSVJvdXRlciwgUm91dGVyLCB9IGZyb20gJy4vcm91dGVyLmpzJztcbmV4cG9ydCB7IFJvdXRlck9wdGlvbnMsIH0gZnJvbSAnLi9yb3V0ZXItb3B0aW9ucy5qcyc7XG5leHBvcnQgeyBWaWV3cG9ydCwgfSBmcm9tICcuL3ZpZXdwb3J0LmpzJztcbmV4cG9ydCB7IENvbnRlbnRTdGF0dXMsIFZpZXdwb3J0Q29udGVudCwgfSBmcm9tICcuL3ZpZXdwb3J0LWNvbnRlbnQuanMnO1xuZXhwb3J0IHsgVmlld3BvcnRJbnN0cnVjdGlvbiwgfSBmcm9tICcuL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzJztcbmV4cG9ydCB7IFJvdXRlckNvbmZpZ3VyYXRpb24sIFJvdXRlclJlZ2lzdHJhdGlvbiwgRGVmYXVsdENvbXBvbmVudHMsIERlZmF1bHRSZXNvdXJjZXMsIFZpZXdwb3J0Q3VzdG9tRWxlbWVudCwgVmlld3BvcnRDdXN0b21FbGVtZW50UmVnaXN0cmF0aW9uLCBOYXZDdXN0b21FbGVtZW50LCBOYXZDdXN0b21FbGVtZW50UmVnaXN0cmF0aW9uLCBHb3RvQ3VzdG9tQXR0cmlidXRlLCBHb3RvQ3VzdG9tQXR0cmlidXRlUmVnaXN0cmF0aW9uLCBMb2FkQ3VzdG9tQXR0cmlidXRlLCBMb2FkQ3VzdG9tQXR0cmlidXRlUmVnaXN0cmF0aW9uLCBIcmVmQ3VzdG9tQXR0cmlidXRlLCBIcmVmQ3VzdG9tQXR0cmlidXRlUmVnaXN0cmF0aW9uLCB9IGZyb20gJy4vY29uZmlndXJhdGlvbi5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBWaWV3cG9ydEluc3RydWN0aW9uIH0gZnJvbSAnLi92aWV3cG9ydC1pbnN0cnVjdGlvbi5qcyc7XG5leHBvcnQgY2xhc3MgSW5zdHJ1Y3Rpb25SZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VwYXJhdG9ycyA9IHtcbiAgICAgICAgICAgIHZpZXdwb3J0OiAnQCcsXG4gICAgICAgICAgICBzaWJsaW5nOiAnKycsXG4gICAgICAgICAgICBzY29wZTogJy8nLFxuICAgICAgICAgICAgc2NvcGVTdGFydDogJygnLFxuICAgICAgICAgICAgc2NvcGVFbmQ6ICcpJyxcbiAgICAgICAgICAgIG5vU2NvcGU6ICchJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6ICcoJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnNFbmQ6ICcpJyxcbiAgICAgICAgICAgIHBhcmFtZXRlclNlcGFyYXRvcjogJywnLFxuICAgICAgICAgICAgcGFyYW1ldGVyS2V5U2VwYXJhdG9yOiAnPScsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6ICcmJyxcbiAgICAgICAgICAgIGFkZDogJysnLFxuICAgICAgICAgICAgY2xlYXI6ICctJyxcbiAgICAgICAgICAgIGFjdGlvbjogJy4nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLnNlcGFyYXRvcnMgPSB7IC4uLnRoaXMuc2VwYXJhdG9ycywgLi4ub3B0aW9ucy5zZXBhcmF0b3JzIH07XG4gICAgfVxuICAgIGdldCBjbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcGFyYXRvcnMuY2xlYXI7XG4gICAgfVxuICAgIGdldCBhZGRWaWV3cG9ydEluc3RydWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXBhcmF0b3JzLmFkZDtcbiAgICB9XG4gICAgaXNDbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uIGluc3RhbmNlb2YgVmlld3BvcnRJbnN0cnVjdGlvblxuICAgICAgICAgICAgPyBpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lID09PSB0aGlzLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbiAmJiAhIWluc3RydWN0aW9uLnZpZXdwb3J0TmFtZVxuICAgICAgICAgICAgOiBpbnN0cnVjdGlvbi5zdGFydHNXaXRoKHRoaXMuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uKSAmJiBpbnN0cnVjdGlvbiAhPT0gdGhpcy5jbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb247XG4gICAgfVxuICAgIGlzQWRkVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICA/IGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUgPT09IHRoaXMuYWRkVmlld3BvcnRJbnN0cnVjdGlvblxuICAgICAgICAgICAgOiAoaW5zdHJ1Y3Rpb24gPT09IHRoaXMuYWRkVmlld3BvcnRJbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIHx8IGluc3RydWN0aW9uLnN0YXJ0c1dpdGgoYCR7dGhpcy5zZXBhcmF0b3JzLmFkZH0ke3RoaXMuc2VwYXJhdG9ycy52aWV3cG9ydH1gKSk7XG4gICAgfVxuICAgIGlzQ2xlYXJWaWV3cG9ydFNjb3BlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uIGluc3RhbmNlb2YgVmlld3BvcnRJbnN0cnVjdGlvblxuICAgICAgICAgICAgPyBpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lID09PSB0aGlzLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbiAmJiAhIWluc3RydWN0aW9uLnZpZXdwb3J0U2NvcGVcbiAgICAgICAgICAgIDogaW5zdHJ1Y3Rpb24uc3RhcnRzV2l0aCh0aGlzLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbikgJiYgaW5zdHJ1Y3Rpb24gIT09IHRoaXMuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uO1xuICAgIH1cbiAgICBpc0NsZWFyQWxsVmlld3BvcnRzSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uIGluc3RhbmNlb2YgVmlld3BvcnRJbnN0cnVjdGlvblxuICAgICAgICAgICAgPyBpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lID09PSB0aGlzLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbiAmJiAhaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lXG4gICAgICAgICAgICA6IGluc3RydWN0aW9uID09PSB0aGlzLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbjtcbiAgICB9XG4gICAgaXNBZGRBbGxWaWV3cG9ydHNJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICA/IGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUgPT09IHRoaXMuYWRkVmlld3BvcnRJbnN0cnVjdGlvbiAmJiAhaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lXG4gICAgICAgICAgICA6IGluc3RydWN0aW9uID09PSB0aGlzLmFkZFZpZXdwb3J0SW5zdHJ1Y3Rpb247XG4gICAgfVxuICAgIGNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24oY29tcG9uZW50LCB2aWV3cG9ydCwgcGFyYW1ldGVycywgb3duc1Njb3BlID0gdHJ1ZSwgbmV4dFNjb3BlSW5zdHJ1Y3Rpb25zID0gbnVsbCkge1xuICAgICAgICBpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC50aGVuKChyZXNvbHZlZENvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24ocmVzb2x2ZWRDb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzLCBvd25zU2NvcGUsIG5leHRTY29wZUluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zdCBpbnN0cnVjdGlvbjogVmlld3BvcnRJbnN0cnVjdGlvbiA9IG5ldyBWaWV3cG9ydEluc3RydWN0aW9uKGNvbXBvbmVudCwgdmlld3BvcnQsIHBhcmFtZXRlcnMsIG93bnNTY29wZSwgbmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgLy8gaW5zdHJ1Y3Rpb24uc2V0SW5zdHJ1Y3Rpb25SZXNvbHZlcih0aGlzKTtcbiAgICAgICAgLy8gcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICByZXR1cm4gVmlld3BvcnRJbnN0cnVjdGlvbi5jcmVhdGUodGhpcywgY29tcG9uZW50LCB2aWV3cG9ydCwgcGFyYW1ldGVycywgb3duc1Njb3BlLCBuZXh0U2NvcGVJbnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgICBwYXJzZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9eWy4vXSsvLmV4ZWMoaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSAnJztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2gpICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5zbGljZShjb250ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkSW5zdHJ1Y3Rpb25zID0gdGhpcy5wYXJzZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zV29ya2VyKGluc3RydWN0aW9ucywgdHJ1ZSkuaW5zdHJ1Y3Rpb25zO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHBhcnNlZEluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZEluc3RydWN0aW9ucztcbiAgICB9XG4gICAgcGFyc2VWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMucGFyc2VWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbik7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24oJycpO1xuICAgIH1cbiAgICBzdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMsIGV4Y2x1ZGVWaWV3cG9ydCA9IGZhbHNlLCB2aWV3cG9ydENvbnRleHQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIChpbnN0cnVjdGlvbnMpID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIDogaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAgICAgLm1hcChpbnN0cnVjdGlvbiA9PiB0aGlzLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVWaWV3cG9ydCwgdmlld3BvcnRDb250ZXh0KSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uICYmIGluc3RydWN0aW9uLmxlbmd0aClcbiAgICAgICAgICAgICAgICAuam9pbih0aGlzLnNlcGFyYXRvcnMuc2libGluZyk7XG4gICAgfVxuICAgIHN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVWaWV3cG9ydCA9IGZhbHNlLCB2aWV3cG9ydENvbnRleHQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5QVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVWaWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXhjbHVkZUN1cnJlbnRWaWV3cG9ydCA9IGV4Y2x1ZGVWaWV3cG9ydDtcbiAgICAgICAgICAgIGxldCBleGNsdWRlQ3VycmVudENvbXBvbmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi52aWV3cG9ydCAmJiBpbnN0cnVjdGlvbi52aWV3cG9ydC5vcHRpb25zLm5vTGluaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaW5zdHJ1Y3Rpb24ubmVlZHNWaWV3cG9ydERlc2NyaWJlZCAmJiBpbnN0cnVjdGlvbi52aWV3cG9ydCAmJiAhaW5zdHJ1Y3Rpb24udmlld3BvcnQub3B0aW9ucy5mb3JjZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDdXJyZW50Vmlld3BvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24udmlld3BvcnQgJiYgaW5zdHJ1Y3Rpb24udmlld3BvcnQub3B0aW9ucy5mYWxsYmFjayA9PT0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQ3VycmVudENvbXBvbmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaW5zdHJ1Y3Rpb24ubmVlZHNWaWV3cG9ydERlc2NyaWJlZCAmJiBpbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDdXJyZW50Vmlld3BvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByb3V0ZSA9IGluc3RydWN0aW9uLnJvdXRlID8/IG51bGw7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zO1xuICAgICAgICAgICAgbGV0IHN0cmluZ2lmaWVkID0gaW5zdHJ1Y3Rpb24uY29udGV4dDtcbiAgICAgICAgICAgIC8vIEl0J3MgYSBjb25maWd1cmVkIHJvdXRlXG4gICAgICAgICAgICBpZiAocm91dGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGFkZGVkIGFzIHBhcnQgb2YgYSBjb25maWd1cmF0aW9uLCBza2lwIHRvIG5leHQgc2NvcGVcbiAgICAgICAgICAgICAgICBpZiAocm91dGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG5leHRJbnN0cnVjdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMobmV4dEluc3RydWN0aW9ucywgZXhjbHVkZVZpZXdwb3J0LCB2aWV3cG9ydENvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3V0ZSA9IHJvdXRlLm1hdGNoaW5nO1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkICs9IHJvdXRlLmVuZHNXaXRoKHRoaXMuc2VwYXJhdG9ycy5zY29wZSkgPyByb3V0ZS5zbGljZSgwLCAtdGhpcy5zZXBhcmF0b3JzLnNjb3BlLmxlbmd0aCkgOiByb3V0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkICs9IHRoaXMuc3RyaW5naWZ5QVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVDdXJyZW50Vmlld3BvcnQsIGV4Y2x1ZGVDdXJyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5leHRJbnN0cnVjdGlvbnMpICYmIG5leHRJbnN0cnVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFN0cmluZ2lmaWVkID0gdGhpcy5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9ucyhuZXh0SW5zdHJ1Y3Rpb25zLCBleGNsdWRlVmlld3BvcnQsIHZpZXdwb3J0Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTdHJpbmdpZmllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkICs9IG5leHRJbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxIC8vIFRPRE86IFRoaXMgc2hvdWxkIHJlYWxseSBhbHNvIGNoZWNrIHRoYXQgdGhlIGluc3RydWN0aW9ucyBoYXZlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke3RoaXMuc2VwYXJhdG9ycy5zY29wZX0ke25leHRTdHJpbmdpZmllZH1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGAke3RoaXMuc2VwYXJhdG9ycy5zY29wZX0ke3RoaXMuc2VwYXJhdG9ycy5zY29wZVN0YXJ0fSR7bmV4dFN0cmluZ2lmaWVkfSR7dGhpcy5zZXBhcmF0b3JzLnNjb3BlRW5kfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmluZ2lmeVNjb3BlZFZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdHJ1Y3Rpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5U2NvcGVkVmlld3BvcnRJbnN0cnVjdGlvbnMoW2luc3RydWN0aW9uc10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnMubWFwKChpbnN0cnVjdGlvbikgPT4gdGhpcy5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKSkuam9pbih0aGlzLnNlcGFyYXRvcnMuc2NvcGUpO1xuICAgIH1cbiAgICBlbmNvZGVWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykpLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKTtcbiAgICB9XG4gICAgZGVjb2RlVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbnMoZGVjb2RlVVJJQ29tcG9uZW50KGluc3RydWN0aW9ucykpO1xuICAgIH1cbiAgICBidWlsZFNjb3BlZExpbmsoc2NvcGVDb250ZXh0LCBocmVmKSB7XG4gICAgICAgIGlmIChzY29wZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGhyZWYgPSBgLyR7c2NvcGVDb250ZXh0fSR7dGhpcy5zZXBhcmF0b3JzLnNjb3BlfSR7aHJlZn1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgIH1cbiAgICBzaG91bGRDbGVhclZpZXdwb3J0cyhwYXRoKSB7XG4gICAgICAgIGNvbnN0IGNsZWFyVmlld3BvcnRzID0gKHBhdGggPT09IHRoaXMuc2VwYXJhdG9ycy5jbGVhciB8fCBwYXRoLnN0YXJ0c1dpdGgodGhpcy5zZXBhcmF0b3JzLmNsZWFyICsgdGhpcy5zZXBhcmF0b3JzLmFkZCkpO1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5zdGFydHNXaXRoKHRoaXMuc2VwYXJhdG9ycy5jbGVhcikgPyBwYXRoLnNsaWNlKDIpIDogcGF0aDtcbiAgICAgICAgcmV0dXJuIHsgY2xlYXJWaWV3cG9ydHMsIG5ld1BhdGggfTtcbiAgICB9XG4gICAgbWVyZ2VWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgIGZvciAobGV0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHRoaXMucGFyc2VWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbWVyZ2VkLmZpbmRJbmRleChtZXJnZSA9PiBtZXJnZS5zYW1lVmlld3BvcnQoaW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkLnNwbGljZShpbmRleCwgMSwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIGZsYXR0ZW5WaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmxhdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgZmxhdC5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmbGF0LnB1c2goLi4udGhpcy5mbGF0dGVuVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgfVxuICAgIGNsb25lVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zLCBrZWVwSW5zdGFuY2VzID0gZmFsc2UsIGNvbnRleHQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjbG9uZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gdGhpcy5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUsIGluc3RydWN0aW9uLnZpZXdwb3J0TmFtZSwgaW5zdHJ1Y3Rpb24udHlwZWRQYXJhbWV0ZXJzICE9PSBudWxsID8gaW5zdHJ1Y3Rpb24udHlwZWRQYXJhbWV0ZXJzIDogdm9pZCAwKTtcbiAgICAgICAgICAgIGlmIChrZWVwSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUuc2V0Q29tcG9uZW50KGluc3RydWN0aW9uLmNvbXBvbmVudEluc3RhbmNlID8/IGluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUgPz8gaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgY2xvbmUuc2V0Vmlld3BvcnQoaW5zdHJ1Y3Rpb24udmlld3BvcnQgPz8gaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb25lLm5lZWRzVmlld3BvcnREZXNjcmliZWQgPSBpbnN0cnVjdGlvbi5uZWVkc1ZpZXdwb3J0RGVzY3JpYmVkO1xuICAgICAgICAgICAgY2xvbmUucm91dGUgPSBpbnN0cnVjdGlvbi5yb3V0ZTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY2xvbmUuY29udGV4dCA9IGluc3RydWN0aW9uLmNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9uZS52aWV3cG9ydFNjb3BlID0ga2VlcEluc3RhbmNlcyA/IGluc3RydWN0aW9uLnZpZXdwb3J0U2NvcGUgOiBudWxsO1xuICAgICAgICAgICAgY2xvbmUuc2NvcGUgPSBrZWVwSW5zdGFuY2VzID8gaW5zdHJ1Y3Rpb24uc2NvcGUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNsb25lLm5leHRTY29wZUluc3RydWN0aW9ucyA9IHRoaXMuY2xvbmVWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMsIGtlZXBJbnN0YW5jZXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvbmVzLnB1c2goY2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZXM7XG4gICAgfVxuICAgIC8vIFRPRE86IERlYWwgd2l0aCBzZXBhcmF0b3JzIGluIGRhdGEgYW5kIGNvbXBsZXggdHlwZXNcbiAgICBwYXJzZUNvbXBvbmVudFBhcmFtZXRlcnMocGFyYW1ldGVycywgdXJpQ29tcG9uZW50ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbWV0ZXJzID09PSBudWxsIHx8IHBhcmFtZXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGFyYW1ldGVycy5zcGxpdCh0aGlzLnNlcGFyYXRvcnMucGFyYW1ldGVyU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICAgICAgW2tleSwgdmFsdWVdID0gcGFyYW0uc3BsaXQodGhpcy5zZXBhcmF0b3JzLnBhcmFtZXRlcktleVNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1cmlDb21wb25lbnQgPyBkZWNvZGVVUklDb21wb25lbnQoa2V5KSA6IGtleTtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmlDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5tYXAocGFyYW0gPT4gKHsga2V5OiB2b2lkIDAsIHZhbHVlOiBwYXJhbSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIGtleXMubWFwKGtleSA9PiAoeyBrZXksIHZhbHVlOiBwYXJhbWV0ZXJzW2tleV0gfSkpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBEZWFsIHdpdGggc2VwYXJhdG9ycyBpbiBkYXRhIGFuZCBjb21wbGV4IHR5cGVzXG4gICAgc3RyaW5naWZ5Q29tcG9uZW50UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCB1cmlDb21wb25lbnQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgfHwgcGFyYW1ldGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXBzID0gdGhpcy5zZXBhcmF0b3JzO1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1xuICAgICAgICAgICAgLm1hcChwYXJhbSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJhbS5rZXkgIT09IHZvaWQgMCAmJiB1cmlDb21wb25lbnQgPyBlbmNvZGVVUklDb21wb25lbnQocGFyYW0ua2V5KSA6IHBhcmFtLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXJpQ29tcG9uZW50ID8gZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtLnZhbHVlKSA6IHBhcmFtLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gdmFsdWUgPyBrZXkgKyBzZXBzLnBhcmFtZXRlcktleVNlcGFyYXRvciArIHZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihzZXBzLnBhcmFtZXRlclNlcGFyYXRvcik7XG4gICAgfVxuICAgIG1hdGNoU2NvcGUoaW5zdHJ1Y3Rpb25zLCBzY29wZSkge1xuICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICBtYXRjaGluZy5wdXNoKC4uLmluc3RydWN0aW9ucy5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uc2NvcGUgPT09IHNjb3BlKSk7XG4gICAgICAgIG1hdGNoaW5nLnB1c2goLi4uaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKGluc3RyID0+IGluc3RyLnNjb3BlICE9PSBzY29wZSlcbiAgICAgICAgICAgIC5tYXAoaW5zdHIgPT4gQXJyYXkuaXNBcnJheShpbnN0ci5uZXh0U2NvcGVJbnN0cnVjdGlvbnMpID8gdGhpcy5tYXRjaFNjb3BlKGluc3RyLm5leHRTY29wZUluc3RydWN0aW9ucywgc2NvcGUpIDogW10pXG4gICAgICAgICAgICAuZmxhdCgpKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nO1xuICAgIH1cbiAgICBtYXRjaENoaWxkcmVuKGluc3RydWN0aW9ucywgYWN0aXZlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IGFjdGl2ZS5maWx0ZXIoaW5zdHIgPT4gaW5zdHIuc2FtZUNvbXBvbmVudChpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucylcbiAgICAgICAgICAgICAgICAmJiBpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICYmIHRoaXMubWF0Y2hDaGlsZHJlbihpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMsIG1hdGNoaW5nLm1hcChpbnN0ciA9PiBBcnJheS5pc0FycmF5KGluc3RyLm5leHRTY29wZUluc3RydWN0aW9ucykgPyBpbnN0ci5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgOiBbXSkuZmxhdCgpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbnNXb3JrZXIoaW5zdHJ1Y3Rpb25zLCBncm91cGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RydWN0aW9uczogW10sIHJlbWFpbmluZzogJycgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zLnN0YXJ0c1dpdGgodGhpcy5zZXBhcmF0b3JzLnNjb3BlU3RhcnQpKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBgJHt0aGlzLnNlcGFyYXRvcnMuc2NvcGV9JHtpbnN0cnVjdGlvbnN9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3cG9ydEluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgZ3VhcmQgPSAxMDAwO1xuICAgICAgICB3aGlsZSAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCAmJiBndWFyZCkge1xuICAgICAgICAgICAgZ3VhcmQtLTtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnMuc3RhcnRzV2l0aCh0aGlzLnNlcGFyYXRvcnMuc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLnNsaWNlKHRoaXMuc2VwYXJhdG9ycy5zY29wZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlU3RhcnQgPSBpbnN0cnVjdGlvbnMuc3RhcnRzV2l0aCh0aGlzLnNlcGFyYXRvcnMuc2NvcGVTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLnNsaWNlKHRoaXMuc2VwYXJhdG9ycy5zY29wZVN0YXJ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5zdHJ1Y3Rpb25zOiBmb3VuZCwgcmVtYWluaW5nIH0gPSB0aGlzLnBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbnNXb3JrZXIoaW5zdHJ1Y3Rpb25zLCBzY29wZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnRJbnN0cnVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zW3ZpZXdwb3J0SW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdLm5leHRTY29wZUluc3RydWN0aW9ucyA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucHVzaCguLi5mb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IHJlbWFpbmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9ucy5zdGFydHNXaXRoKHRoaXMuc2VwYXJhdG9ycy5zY29wZUVuZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuc2xpY2UodGhpcy5zZXBhcmF0b3JzLnNjb3BlRW5kLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RydWN0aW9uczogdmlld3BvcnRJbnN0cnVjdGlvbnMsIHJlbWFpbmluZzogaW5zdHJ1Y3Rpb25zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbnMuc3RhcnRzV2l0aCh0aGlzLnNlcGFyYXRvcnMuc2libGluZykgJiYgIXRoaXMuaXNBZGRWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdHJ1Y3Rpb25zOiB2aWV3cG9ydEluc3RydWN0aW9ucywgcmVtYWluaW5nOiBpbnN0cnVjdGlvbnMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLnNsaWNlKHRoaXMuc2VwYXJhdG9ycy5zaWJsaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluc3RydWN0aW9uOiB2aWV3cG9ydEluc3RydWN0aW9uLCByZW1haW5pbmcgfSA9IHRoaXMucGFyc2VBVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnB1c2godmlld3BvcnRJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluc3RydWN0aW9uczogdmlld3BvcnRJbnN0cnVjdGlvbnMsIHJlbWFpbmluZzogaW5zdHJ1Y3Rpb25zIH07XG4gICAgfVxuICAgIGZpbmROZXh0VG9rZW4oaW5zdHJ1Y3Rpb24sIHRva2Vucykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0ge307XG4gICAgICAgIC8vIFRva2VucyBjYW4gaGF2ZSBsZW5ndGggPiAxXG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblBvcyA9IGluc3RydWN0aW9uLmluZGV4T2YodG9rZW4pO1xuICAgICAgICAgICAgaWYgKHRva2VuUG9zID4gLTEpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzW3Rva2VuXSA9IGluc3RydWN0aW9uLmluZGV4T2YodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcyA9IE1hdGgubWluKC4uLk9iamVjdC52YWx1ZXMobWF0Y2hlcykpO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzW3Rva2VuXSA9PT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9rZW4sIHBvcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRva2VuOiAnJywgcG9zOiAtMSB9O1xuICAgIH1cbiAgICBwYXJzZUFWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNlcHMgPSB0aGlzLnNlcGFyYXRvcnM7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtzZXBzLnBhcmFtZXRlcnMsIHNlcHMudmlld3BvcnQsIHNlcHMubm9TY29wZSwgc2Vwcy5zY29wZUVuZCwgc2Vwcy5zY29wZSwgc2Vwcy5zaWJsaW5nXTtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGV0IHBhcmFtZXRlcnNTdHJpbmcgPSB2b2lkIDA7XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IHZvaWQgMDtcbiAgICAgICAgbGV0IHNjb3BlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgcG9zO1xuICAgICAgICBjb25zdCBzcGVjaWFscyA9IFtzZXBzLmFkZCwgc2Vwcy5jbGVhcl07XG4gICAgICAgIGZvciAoY29uc3Qgc3BlY2lhbCBvZiBzcGVjaWFscykge1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uID09PSBzcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSAnJztcbiAgICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKTsgLy8gcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpOyAvLyB2aWV3cG9ydFxuICAgICAgICAgICAgICAgIHRva2VuID0gc2Vwcy52aWV3cG9ydDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lhbCBvZiBzcGVjaWFscykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5zdGFydHNXaXRoKGAke3NwZWNpYWx9JHtzZXBzLnZpZXdwb3J0fWApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IHNwZWNpYWw7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24uc2xpY2UoYCR7c3BlY2lhbH0ke3NlcHMudmlld3BvcnR9YC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKTsgLy8gcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKTsgLy8gdmlld3BvcnRcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBzZXBzLnZpZXdwb3J0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAoeyB0b2tlbiwgcG9zIH0gPSB0aGlzLmZpbmROZXh0VG9rZW4oaW5zdHJ1Y3Rpb24sIHRva2VucykpO1xuICAgICAgICAgICAgY29tcG9uZW50ID0gcG9zICE9PSAtMSA/IGluc3RydWN0aW9uLnNsaWNlKDAsIHBvcykgOiBpbnN0cnVjdGlvbjtcbiAgICAgICAgICAgIGluc3RydWN0aW9uID0gcG9zICE9PSAtMSA/IGluc3RydWN0aW9uLnNsaWNlKHBvcyArIHRva2VuLmxlbmd0aCkgOiAnJztcbiAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpOyAvLyBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHNlcHMucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgICh7IHRva2VuLCBwb3MgfSA9IHRoaXMuZmluZE5leHRUb2tlbihpbnN0cnVjdGlvbiwgW3NlcHMucGFyYW1ldGVyc0VuZF0pKTtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzU3RyaW5nID0gaW5zdHJ1Y3Rpb24uc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uLnNsaWNlKHBvcyArIHRva2VuLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgKHsgdG9rZW4gfSA9IHRoaXMuZmluZE5leHRUb2tlbihpbnN0cnVjdGlvbiwgdG9rZW5zKSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5zbGljZSh0b2tlbi5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KCk7IC8vIHZpZXdwb3J0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSBzZXBzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICAoeyB0b2tlbiwgcG9zIH0gPSB0aGlzLmZpbmROZXh0VG9rZW4oaW5zdHJ1Y3Rpb24sIHRva2VucykpO1xuICAgICAgICAgICAgdmlld3BvcnQgPSBwb3MgIT09IC0xID8gaW5zdHJ1Y3Rpb24uc2xpY2UoMCwgcG9zKSA6IGluc3RydWN0aW9uO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBwb3MgIT09IC0xID8gaW5zdHJ1Y3Rpb24uc2xpY2UocG9zICsgdG9rZW4ubGVuZ3RoKSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5zaGlmdCgpOyAvLyBub1Njb3BlXG4gICAgICAgIGlmICh0b2tlbiA9PT0gc2Vwcy5ub1Njb3BlKSB7XG4gICAgICAgICAgICBzY29wZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RvcmUgdG9rZW4gdGhhdCBiZWxvbmdzIHRvIG5leHQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgaWYgKHRva2VuID09PSBzZXBzLnNjb3BlRW5kIHx8IHRva2VuID09PSBzZXBzLnNjb3BlIHx8IHRva2VuID09PSBzZXBzLnNpYmxpbmcpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uID0gYCR7dG9rZW59JHtpbnN0cnVjdGlvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SW5zdHJ1Y3Rpb24gPSB0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24oY29tcG9uZW50LCB2aWV3cG9ydCwgcGFyYW1ldGVyc1N0cmluZywgc2NvcGUpO1xuICAgICAgICByZXR1cm4geyBpbnN0cnVjdGlvbjogdmlld3BvcnRJbnN0cnVjdGlvbiwgcmVtYWluaW5nOiBpbnN0cnVjdGlvbiB9O1xuICAgIH1cbiAgICBzdHJpbmdpZnlBVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgZXhjbHVkZVZpZXdwb3J0ID0gZmFsc2UsIGV4Y2x1ZGVDb21wb25lbnQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbih0aGlzLnBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiksIGV4Y2x1ZGVWaWV3cG9ydCwgZXhjbHVkZUNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25TdHJpbmcgPSAhZXhjbHVkZUNvbXBvbmVudCA/IGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSBpbnN0cnVjdGlvbi5jb21wb25lbnRUeXBlID8gaW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZS5wYXJhbWV0ZXJzIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnN0cmluZ2lmeUNvbXBvbmVudFBhcmFtZXRlcnMoaW5zdHJ1Y3Rpb24udG9Tb3J0ZWRQYXJhbWV0ZXJzKHNwZWNpZmljYXRpb24pKTtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvblN0cmluZyArPSAhZXhjbHVkZUNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IGAke3RoaXMuc2VwYXJhdG9ycy5wYXJhbWV0ZXJzfSR7cGFyYW1ldGVyc30ke3RoaXMuc2VwYXJhdG9ycy5wYXJhbWV0ZXJzRW5kfWBcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnZpZXdwb3J0TmFtZSAhPT0gbnVsbCAmJiAhZXhjbHVkZVZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25TdHJpbmcgKz0gdGhpcy5zZXBhcmF0b3JzLnZpZXdwb3J0ICsgaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnN0cnVjdGlvbi5vd25zU2NvcGUpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvblN0cmluZyArPSB0aGlzLnNlcGFyYXRvcnMubm9TY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvblN0cmluZyB8fCAnJztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydWN0aW9uLXJlc29sdmVyLmpzLm1hcCIsImV4cG9ydCB2YXIgUmVlbnRyeUJlaGF2aW9yO1xuKGZ1bmN0aW9uIChSZWVudHJ5QmVoYXZpb3IpIHtcbiAgICBSZWVudHJ5QmVoYXZpb3JbXCJkZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XG4gICAgUmVlbnRyeUJlaGF2aW9yW1wiZGlzYWxsb3dcIl0gPSBcImRpc2FsbG93XCI7XG4gICAgUmVlbnRyeUJlaGF2aW9yW1wibG9hZFwiXSA9IFwibG9hZFwiO1xuICAgIFJlZW50cnlCZWhhdmlvcltcInJlZnJlc2hcIl0gPSBcInJlZnJlc2hcIjtcbn0pKFJlZW50cnlCZWhhdmlvciB8fCAoUmVlbnRyeUJlaGF2aW9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZXMuanMubWFwIiwiLyoqXG4gKiBAaW50ZXJuYWwgLSBXaWxsIGJlIHJlbW92ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZUxvZ2dlcihuYW1lKSB7XG4gICAgY29uc3QgbGlmZWN5Y2xlcyA9IFtcbiAgICAgICAgJ2NhblVubG9hZCcsICd1bmxvYWQnLFxuICAgICAgICAnY2FuTG9hZCcsICdsb2FkJyxcbiAgICAgICAgJ2NyZWF0ZWQnLFxuICAgICAgICAnYmluZGluZycsICdib3VuZCcsXG4gICAgICAgICdiZWZvcmVBdHRhY2gnLCAnYXR0YWNoaW5nJyxcbiAgICAgICAgJ2RldGFjaGluZycsXG4gICAgICAgICd1bmJpbmRpbmcnLFxuICAgIF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCBsaWZlY3ljbGUgb2YgbGlmZWN5Y2xlcykge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0YXJnZXQucHJvdG90eXBlW2xpZmVjeWNsZV07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGVbbGlmZWN5Y2xlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke25hbWV9ICR7bGlmZWN5Y2xlfWAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmcuYXBwbHkodGFyZ2V0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZVtsaWZlY3ljbGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7bmFtZX0gJHtsaWZlY3ljbGV9YCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaWZlY3ljbGUuc3RhcnRzV2l0aCgnY2FuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgY2xhc3MgTGlmZWN5Y2xlQ2xhc3Mge1xuICAgIGNhbkxvYWQoKSB7IGNvbnNvbGUubG9nKGBuYW1lIGNhbkxvYWRgKTsgcmV0dXJuIHRydWU7IH1cbiAgICBsb2FkKHBhcmFtcykgeyBjb25zb2xlLmxvZyhgbmFtZSBsb2FkYCk7IH1cbiAgICBjcmVhdGVkKCkgeyBjb25zb2xlLmxvZyhgbmFtZSBjcmVhdGVkYCk7IH1cbiAgICBiaW5kaW5nKCkgeyBjb25zb2xlLmxvZyhgbmFtZSBiaW5kaW5nYCk7IH1cbiAgICBib3VuZCgpIHsgY29uc29sZS5sb2coYG5hbWUgYm91bmRgKTsgfVxuICAgIGJlZm9yZUF0dGFjaCgpIHsgY29uc29sZS5sb2coYG5hbWUgYmVmb3JlQXR0YWNoYCk7IH1cbiAgICBhdHRhY2hpbmcoKSB7IGNvbnNvbGUubG9nKGBuYW1lIGF0dGFjaGluZ2ApOyB9XG4gICAgY2FuVW5sb2FkKCkgeyBjb25zb2xlLmxvZyhgbmFtZSBjYW5VbmxvYWRgKTsgcmV0dXJuIHRydWU7IH1cbiAgICB1bmxvYWQoKSB7IGNvbnNvbGUubG9nKGBuYW1lIHVubG9hZGApOyB9XG4gICAgZGV0YWNoaW5nKCkgeyBjb25zb2xlLmxvZyhgbmFtZSBkZXRhY2hpbmdgKTsgfVxuICAgIHVuYmluZGluZygpIHsgY29uc29sZS5sb2coYG5hbWUgdW5iaW5kaW5nYCk7IH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZmVjeWNsZS1sb2dnZXIuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBJUGxhdGZvcm0sIEN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyBpbnRlcmFjdGlvbnMgdGhhdCBzaG91bGQgdHJpZ2dlciBuYXZpZ2F0aW9uLlxuICpcbiAqIEAgaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseS5cbiAqIFRPRE86IHJlbW92ZSB0aGUgc3BhY2UgYmV0d2VlbiBAIGFuZCBpIGFnYWluIGF0IHNvbWUgcG9pbnQgKHRoaXMgc3RyaXBJbnRlcm5hbCBjdXJyZW50bHkgc2NyZXdzIHVwIHRoZSB0eXBlcyBpbiB0aGUgX190ZXN0c19fIHBhY2thZ2UgZm9yIHNvbWUgcmVhc29uKVxuICovXG5sZXQgTGlua0hhbmRsZXIgPSBjbGFzcyBMaW5rSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IocCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1c2VIcmVmOiB0cnVlLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHsgcmV0dXJuOyB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBMaW5rSGFuZGxlci5nZXRFdmVudEluZm8oZSwgdGhpcy53aW5kb3csIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoaW5mby5zaG91bGRIYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2FsbGJhY2soaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2luZG93ID0gcC53aW5kb3c7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBwLmRvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBocmVmIGFuZCBhIFwic2hvdWxkIGhhbmRsZVwiIHJlY29tbWVuZGF0aW9uLCBnaXZlbiBhbiBFdmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBFdmVudCB0byBpbnNwZWN0IGZvciB0YXJnZXQgYW5jaG9yIGFuZCBocmVmLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRFdmVudEluZm8oZXZlbnQsIHdpbiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgICAgc2hvdWxkSGFuZGxlRXZlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IG51bGwsXG4gICAgICAgICAgICBhbmNob3I6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaW5mby5hbmNob3IgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBmb3IgZGVsZWdhdGlvbjpcbiAgICAgICAgLy8gY29uc3QgdGFyZ2V0ID0gaW5mby5hbmNob3IgPSBMaW5rSGFuZGxlci5jbG9zZXN0QW5jaG9yKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KTtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIUxpbmtIYW5kbGVyLnRhcmdldElzVGhpc1dpbmRvdyh0YXJnZXQsIHdpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKCdleHRlcm5hbCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ290b0F0dHIgPSBDdXN0b21BdHRyaWJ1dGUuZm9yKHRhcmdldCwgJ2dvdG8nKTtcbiAgICAgICAgY29uc3QgZ290byA9IGdvdG9BdHRyICE9PSB2b2lkIDAgPyBnb3RvQXR0ci52aWV3TW9kZWwudmFsdWUgOiBudWxsO1xuICAgICAgICBjb25zdCBsb2FkQXR0ciA9IEN1c3RvbUF0dHJpYnV0ZS5mb3IodGFyZ2V0LCAnbG9hZCcpO1xuICAgICAgICBjb25zdCBsb2FkID0gbG9hZEF0dHIgIT09IHZvaWQgMCA/IGxvYWRBdHRyLnZpZXdNb2RlbC52YWx1ZSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGhyZWYgPSBvcHRpb25zLnVzZUhyZWYgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaHJlZicpID8gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpIDogbnVsbDtcbiAgICAgICAgaWYgKChnb3RvID09PSBudWxsIHx8IGdvdG8ubGVuZ3RoID09PSAwKSAmJiAobG9hZCA9PT0gbnVsbCB8fCBsb2FkLmxlbmd0aCA9PT0gMCkgJiYgKGhyZWYgPT09IG51bGwgfHwgaHJlZi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmFuY2hvciA9IHRhcmdldDtcbiAgICAgICAgaW5mby5pbnN0cnVjdGlvbiA9IGxvYWQgPz8gZ290byA/PyBocmVmO1xuICAgICAgICBjb25zdCBsZWZ0QnV0dG9uQ2xpY2tlZCA9IGV2ZW50LmJ1dHRvbiA9PT0gMDtcbiAgICAgICAgaW5mby5zaG91bGRIYW5kbGVFdmVudCA9IGxlZnRCdXR0b25DbGlja2VkO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgdGhhdCdzIGFuIGFuY2hvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgdG8gc2VhcmNoIHVwd2FyZCBmcm9tLlxuICAgICAqIEByZXR1cm5zIFRoZSBsaW5rIGVsZW1lbnQgdGhhdCBpcyB0aGUgY2xvc2VzdCBhbmNlc3Rvci5cbiAgICAgKi9cbiAgICAvLyBwcml2YXRlIHN0YXRpYyBjbG9zZXN0QW5jaG9yKGVsOiBFbGVtZW50KTogRWxlbWVudCB8IG51bGwge1xuICAgIC8vICAgd2hpbGUgKGVsICE9PSBudWxsICYmIGVsICE9PSB2b2lkIDApIHtcbiAgICAvLyAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdBJykge1xuICAgIC8vICAgICAgIHJldHVybiBlbDtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBlbCA9IGVsLnBhcmVudE5vZGUgYXMgRWxlbWVudDtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbiBhbmNob3IgdGFyZ2V0cyB0aGUgY3VycmVudCB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGFuY2hvciBlbGVtZW50IHdob3NlIHRhcmdldCBzaG91bGQgYmUgaW5zcGVjdGVkLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRhcmdldCBvZiB0aGUgbGluayBlbGVtZW50IGlzIHRoaXMgd2luZG93OyBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIHRhcmdldElzVGhpc1dpbmRvdyh0YXJnZXQsIHdpbikge1xuICAgICAgICBjb25zdCB0YXJnZXRXaW5kb3cgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICAgICAgcmV0dXJuICF0YXJnZXRXaW5kb3cgfHxcbiAgICAgICAgICAgIHRhcmdldFdpbmRvdyA9PT0gd2luLm5hbWUgfHxcbiAgICAgICAgICAgIHRhcmdldFdpbmRvdyA9PT0gJ19zZWxmJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhcnQob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5rIGhhbmRsZXIgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBpbnN0YW5jZS4gRXZlbnQgaGFuZGxlcnMgYW5kIG90aGVyIHJlc291cmNlcyBzaG91bGQgYmUgY2xlYW5lZCB1cCBoZXJlLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5rIGhhbmRsZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgfVxufTtcbkxpbmtIYW5kbGVyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJUGxhdGZvcm0pXG5dLCBMaW5rSGFuZGxlcik7XG5leHBvcnQgeyBMaW5rSGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay1oYW5kbGVyLmpzLm1hcCIsImltcG9ydCB7IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIsIE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyIH0gZnJvbSAnLi90eXBlLXJlc29sdmVycy5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbCAtIFVzZWQgYnkgYXUtbmF2XG4gKi9cbmV4cG9ydCBjbGFzcyBOYXZSb3V0ZSB7XG4gICAgY29uc3RydWN0b3IobmF2LCByb3V0ZSkge1xuICAgICAgICB0aGlzLm5hdiA9IG5hdjtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5rID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5rVmlzaWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlua0FjdGl2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGFyZVBhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gJyc7XG4gICAgICAgIHRoaXMudGl0bGUgPSByb3V0ZS50aXRsZTtcbiAgICAgICAgdGhpcy5tZXRhID0gcm91dGUubWV0YTtcbiAgICAgICAgaWYgKHJvdXRlLnJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IHRoaXMucGFyc2VSb3V0ZShyb3V0ZS5yb3V0ZSk7XG4gICAgICAgICAgICB0aGlzLmxpbmsgPSB0aGlzLmNvbXB1dGVMaW5rKHRoaXMuaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtBY3RpdmUgPSByb3V0ZS5jb25zaWRlcmVkQWN0aXZlICE9PSBudWxsICYmIHJvdXRlLmNvbnNpZGVyZWRBY3RpdmUgIT09IHZvaWQgMCA/IHJvdXRlLmNvbnNpZGVyZWRBY3RpdmUgOiB0aGlzLmxpbms7XG4gICAgICAgIGlmICh0aGlzLmxpbmtBY3RpdmUgIT09IG51bGwgJiYgKCEodGhpcy5saW5rQWN0aXZlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNUeXBlKHRoaXMubGlua0FjdGl2ZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtBY3RpdmUgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMubmF2LnJvdXRlciwgdGhpcy5saW5rQWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4ZWN1dGUgPSByb3V0ZS5leGVjdXRlO1xuICAgICAgICB0aGlzLmNvbXBhcmVQYXJhbWV0ZXJzID0gISFyb3V0ZS5jb21wYXJlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5saW5rVmlzaWJsZSA9IHJvdXRlLmNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHJvdXRlLmNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgZ2V0IGhhc0NoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY2hpbGRyZW4gJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPyAnbmF2LWhhcy1jaGlsZHJlbicgOiAnJyk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdGhpcy5jb21wdXRlVmlzaWJsZSgpO1xuICAgICAgICBpZiAoKHRoaXMubGluayAmJiB0aGlzLmxpbmsubGVuZ3RoKSB8fCB0aGlzLmV4ZWN1dGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5jb21wdXRlQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9ICh0aGlzLmFjdGl2ZSA9PT0gJ25hdi1hY3RpdmUnID8gJ25hdi1hY3RpdmUnIDogKHRoaXMuYWN0aXZlQ2hpbGQoKSA/ICduYXYtYWN0aXZlLWNoaWxkJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhlY3V0ZUFjdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5leGVjdXRlKSB7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRvZ2dsZUFjdGl2ZSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAodGhpcy5hY3RpdmUuc3RhcnRzV2l0aCgnbmF2LWFjdGl2ZScpID8gJycgOiAnbmF2LWFjdGl2ZScpO1xuICAgIH1cbiAgICBwYXJzZVJvdXRlKHJvdXRlcykge1xuICAgICAgICByZXR1cm4gTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIudG9WaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLm5hdi5yb3V0ZXIsIHJvdXRlcyk7XG4gICAgfVxuICAgIGNvbXB1dGVWaXNpYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5saW5rVmlzaWJsZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5rVmlzaWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISF0aGlzLmxpbmtWaXNpYmxlO1xuICAgIH1cbiAgICBjb21wdXRlQWN0aXZlKCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5saW5rQWN0aXZlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlua0FjdGl2ZSh0aGlzKSA/ICduYXYtYWN0aXZlJyA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmxpbmtBY3RpdmU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNvbXBvbmVudHMgPSB0aGlzLm5hdi5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5mbGF0dGVuVmlld3BvcnRJbnN0cnVjdGlvbnModGhpcy5uYXYucm91dGVyLmFjdGl2ZUNvbXBvbmVudHMpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlQ29tcG9uZW50cy5ldmVyeSgoYWN0aXZlKSA9PiAhYWN0aXZlLnNhbWVDb21wb25lbnQoY29tcG9uZW50LCB0aGlzLmNvbXBhcmVQYXJhbWV0ZXJzICYmIGNvbXBvbmVudC50eXBlZFBhcmFtZXRlcnMgIT09IG51bGwpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25hdi1hY3RpdmUnO1xuICAgIH1cbiAgICBjb21wdXRlTGluayhpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2LnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGFjdGl2ZUNoaWxkKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmFjdGl2ZS5zdGFydHNXaXRoKCduYXYtYWN0aXZlJykgfHwgY2hpbGQuYWN0aXZlQ2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdi1yb3V0ZS5qcy5tYXAiLCJpbXBvcnQgeyBOYXZSb3V0ZSB9IGZyb20gJy4vbmF2LXJvdXRlLmpzJztcbi8qKlxuICogUHVibGljIEFQSSAtIFVzZWQgYnkgYXUtbmF2IGFuZCBSb3V0ZXIgYWRkL3NldE5hdlxuICovXG5leHBvcnQgY2xhc3MgTmF2IHtcbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXIsIG5hbWUsIHJvdXRlcyA9IFtdLCBjbGFzc2VzID0ge30pIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucm91dGVzID0gcm91dGVzO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBhZGRSb3V0ZXMocm91dGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJvdXRlKHRoaXMucm91dGVzLCByb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJvdXRlcyh0aGlzLnJvdXRlcyk7XG4gICAgICAgIHRoaXMucm91dGVzID0gdGhpcy5yb3V0ZXMuc2xpY2UoKTtcbiAgICB9XG4gICAgYWRkUm91dGUocm91dGVzLCByb3V0ZSkge1xuICAgICAgICBjb25zdCBuZXdSb3V0ZSA9IG5ldyBOYXZSb3V0ZSh0aGlzLCByb3V0ZSk7XG4gICAgICAgIHJvdXRlcy5wdXNoKG5ld1JvdXRlKTtcbiAgICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBuZXdSb3V0ZS5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiByb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUm91dGUobmV3Um91dGUuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVSb3V0ZXMocm91dGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKSB7XG4gICAgICAgICAgICByb3V0ZS51cGRhdGUoKTtcbiAgICAgICAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJvdXRlcyhyb3V0ZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXYuanMubWFwIiwiaW1wb3J0IHsgU3RhdGVDb29yZGluYXRvciB9IGZyb20gJy4vc3RhdGUtY29vcmRpbmF0b3IuanMnO1xuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Db29yZGluYXRvck9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdOYXZpZ2F0aW9uQ29vcmRpbmF0b3JPcHRpb25zIGNvbnN0cnVjdG9yJywgaW5wdXQpO1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZXMgPSBpbnB1dC5zeW5jU3RhdGVzID8/IFtdO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0aW9uQ29vcmRpbmF0b3IgZXh0ZW5kcyBTdGF0ZUNvb3JkaW5hdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocm91dGVyLCBuYXZpZ2F0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdG9yID0gbmV3IE5hdmlnYXRpb25Db29yZGluYXRvcigpO1xuICAgICAgICBjb29yZGluYXRvci5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIGNvb3JkaW5hdG9yLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgICAgICAvLyBUT0RPOiBTZXQgZmxvdyBvcHRpb25zIGZyb20gcm91dGVyXG4gICAgICAgIG9wdGlvbnMuc3luY1N0YXRlcy5mb3JFYWNoKChzdGF0ZSkgPT4gY29vcmRpbmF0b3IuYWRkU3luY1N0YXRlKHN0YXRlKSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdOYXZpZ2F0aW9uQ29vcmRpbmF0b3IgY3JlYXRlZCcsIGNvb3JkaW5hdG9yKTtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdG9yO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZ2V0IGlzUmVzdHJpY3RlZE5hdmlnYXRpb24oKTogYm9vbGVhbiB7XG4gICAgLy8gICByZXR1cm4gdGhpcy5zeW5jU3RhdGVzLmhhcygnZ3VhcmRlZExvYWQnKSB8fFxuICAgIC8vICAgICB0aGlzLnN5bmNTdGF0ZXMuaGFzKCd1bmxvYWRlZCcpIHx8XG4gICAgLy8gICAgIHRoaXMuc3luY1N0YXRlcy5oYXMoJ2xvYWRlZCcpIHx8XG4gICAgLy8gICAgIHRoaXMuc3luY1N0YXRlcy5oYXMoJ2d1YXJkZWQnKSB8fFxuICAgIC8vICAgICB0aGlzLnN5bmNTdGF0ZXMuaGFzKCdyb3V0ZWQnKTtcbiAgICAvLyB9XG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ05hdmlnYXRpb25Db29yZGluYXRvciBSVU4nIC8qLCB7IC4uLnRoaXMgfSAqLyk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcykge1xuICAgICAgICAgICAgICAgIGlmICghZW50aXR5LnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5LnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuZW50aXR5LnRyYW5zaXRpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVudGl0eShlbnRpdHkpIHtcbiAgICAgICAgY29uc3QgZW50ID0gc3VwZXIuYWRkRW50aXR5KGVudGl0eSk7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGVudC5lbnRpdHkudHJhbnNpdGlvbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50O1xuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5lbnRpdGllcy5mb3JFYWNoKGVudGl0eSA9PiBlbnRpdHkuZW50aXR5LmZpbmFsaXplQ29udGVudENoYW5nZSgpKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICAvLyBUT0RPOiBUYWtlIGNhcmUgb2YgZGlzYWJsaW5nIHZpZXdwb3J0cyB3aGVuIGNhbmNlbGxpbmcgYW5kIHN0YXRlZnVsIVxuICAgICAgICB0aGlzLmVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0ID0gZW50aXR5LmVudGl0eS5hYm9ydENvbnRlbnRDaGFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChhYm9ydCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhYm9ydC5jYXRjaChlcnJvciA9PiB7IHRocm93IGVycm9yOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRvci5jYW5jZWwodGhpcy5uYXZpZ2F0aW9uKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucm91dGVyLnByb2Nlc3NpbmdOYXZpZ2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5yZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgIH1cbiAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHNob3VsZCBjYW5jZWwgcmVwbGFjZWQgaW5zdHJ1Y3Rpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIGNhbmNlbFJlcGxhY2VkKG5hdmlnYXRpb24pIHsgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi1jb29yZGluYXRvci5qcy5tYXAiLCJleHBvcnQgY2xhc3MgTmF2aWdhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZW50cnkgPSB7XG4gICAgICAgIGluc3RydWN0aW9uOiAnJyxcbiAgICAgICAgZnVsbFN0YXRlSW5zdHJ1Y3Rpb246ICcnLFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gZW50cnkubmF2aWdhdGlvbiA/PyB7XG4gICAgICAgICAgICBmaXJzdDogZmFsc2UsXG4gICAgICAgICAgICBuZXc6IGZhbHNlLFxuICAgICAgICAgICAgcmVmcmVzaDogZmFsc2UsXG4gICAgICAgICAgICBmb3J3YXJkOiBmYWxzZSxcbiAgICAgICAgICAgIGJhY2s6IGZhbHNlLFxuICAgICAgICAgICAgcmVwbGFjZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVwZWF0aW5nID0gZW50cnkucmVwZWF0aW5nO1xuICAgICAgICAvLyBJTmF2aWdhdG9yRW50cnlcbiAgICAgICAgdGhpcy5mcm9tQnJvd3NlciA9IGVudHJ5LmZyb21Ccm93c2VyO1xuICAgICAgICB0aGlzLm9yaWdpbiA9IGVudHJ5Lm9yaWdpbjtcbiAgICAgICAgdGhpcy5yZXBsYWNpbmcgPSBlbnRyeS5yZXBsYWNpbmc7XG4gICAgICAgIHRoaXMucmVmcmVzaGluZyA9IGVudHJ5LnJlZnJlc2hpbmc7XG4gICAgICAgIHRoaXMudW50cmFja2VkID0gZW50cnkudW50cmFja2VkO1xuICAgICAgICB0aGlzLmhpc3RvcnlNb3ZlbWVudCA9IGVudHJ5Lmhpc3RvcnlNb3ZlbWVudDtcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gZW50cnkucmVzb2x2ZTtcbiAgICAgICAgdGhpcy5yZWplY3QgPSBlbnRyeS5yZWplY3Q7XG4gICAgICAgIC8vIElTdG9yZWROYXZpZ2F0b3JFbnRyeVxuICAgICAgICB0aGlzLmluc3RydWN0aW9uID0gZW50cnkuaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gPSBlbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy5zY29wZSA9IGVudHJ5LnNjb3BlO1xuICAgICAgICB0aGlzLmluZGV4ID0gZW50cnkuaW5kZXg7XG4gICAgICAgIHRoaXMuZmlyc3RFbnRyeSA9IGVudHJ5LmZpcnN0RW50cnk7XG4gICAgICAgIHRoaXMucm91dGUgPSBlbnRyeS5yb3V0ZTtcbiAgICAgICAgdGhpcy5wYXRoID0gZW50cnkucGF0aDtcbiAgICAgICAgdGhpcy50aXRsZSA9IGVudHJ5LnRpdGxlO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gZW50cnkucXVlcnk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IGVudHJ5LnBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuZGF0YSA9IGVudHJ5LmRhdGE7XG4gICAgfVxuICAgIGdldCB1c2VGdWxsU3RhdGVJbnN0cnVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5hdmlnYXRpb24uYmFjayA/PyBmYWxzZSkgfHwgKHRoaXMubmF2aWdhdGlvbi5mb3J3YXJkID8/IGZhbHNlKTtcbiAgICB9XG4gICAgdG9TdG9yZWQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiB0aGlzLm5hdmlnYXRpb24sXG4gICAgICAgICAgICByZXBlYXRpbmc6IHRoaXMucmVwZWF0aW5nLFxuICAgICAgICAgICAgLy8gSVN0b3JlZE5hdmlnYXRvckVudHJ5XG4gICAgICAgICAgICBpbnN0cnVjdGlvbjogdGhpcy5pbnN0cnVjdGlvbixcbiAgICAgICAgICAgIGZ1bGxTdGF0ZUluc3RydWN0aW9uOiB0aGlzLmZ1bGxTdGF0ZUluc3RydWN0aW9uLFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgIGZpcnN0RW50cnk6IHRoaXMuZmlyc3RFbnRyeSxcbiAgICAgICAgICAgIHJvdXRlOiB0aGlzLnJvdXRlLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgICAgICBxdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoaXMucGFyYW1ldGVycyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCIsImltcG9ydCB7IFF1ZXVlIH0gZnJvbSAnLi9xdWV1ZS5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uIH0gZnJvbSAnLi9uYXZpZ2F0aW9uLmpzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJy4vcnVubmVyLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdmlnYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzdGF0ZWZ1bEhpc3RvcnlMZW5ndGg6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTmF2aWdhdGlvbnMgPSAocUVudHJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHFFbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb25GbGFncyA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmV3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZWZyZXNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3J3YXJkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBiYWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RW50cnkgPT09IHRoaXMudW5pbml0aWFsaXplZEVudHJ5KSB7IC8vIFJlZnJlc2ggb3IgZmlyc3QgZW50cnlcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbnRyeSAhPT0gdGhpcy51bmluaXRpYWxpemVkRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkZsYWdzLnJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkZsYWdzLmZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkZsYWdzLm5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIHJlYWxseSBiZSBjcmVhdGVkIGhlcmU/IFNob3VsZG4ndCBpdCBiZSBpbiB0aGUgdmlld2VyP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRFbnRyeSA9IG5ldyBOYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFN0YXRlSW5zdHJ1Y3Rpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudHJ5LmluZGV4ICE9PSB2b2lkIDAgJiYgIWVudHJ5LnJlcGxhY2luZyAmJiAhZW50cnkucmVmcmVzaGluZykgeyAvLyBIaXN0b3J5IG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICBlbnRyeS5oaXN0b3J5TW92ZW1lbnQgPSBlbnRyeS5pbmRleCAtICh0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCAhPT0gdm9pZCAwID8gdGhpcy5jdXJyZW50RW50cnkuaW5kZXggOiAwKTtcbiAgICAgICAgICAgICAgICBlbnRyeS5pbnN0cnVjdGlvbiA9IHRoaXMuZW50cmllc1tlbnRyeS5pbmRleF0gIT09IHZvaWQgMCAmJiB0aGlzLmVudHJpZXNbZW50cnkuaW5kZXhdICE9PSBudWxsID8gdGhpcy5lbnRyaWVzW2VudHJ5LmluZGV4XS5mdWxsU3RhdGVJbnN0cnVjdGlvbiA6IGVudHJ5LmZ1bGxTdGF0ZUluc3RydWN0aW9uO1xuICAgICAgICAgICAgICAgIGVudHJ5LnJlcGxhY2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmhpc3RvcnlNb3ZlbWVudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkZsYWdzLmZvcndhcmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5oaXN0b3J5TW92ZW1lbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25GbGFncy5iYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5yZWZyZXNoaW5nIHx8IG5hdmlnYXRpb25GbGFncy5yZWZyZXNoKSB7IC8vIFJlZnJlc2hpbmdcbiAgICAgICAgICAgICAgICBlbnRyeS5pbmRleCA9IHRoaXMuY3VycmVudEVudHJ5LmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkucmVwbGFjaW5nKSB7IC8vIFJlcGxhY2luZ1xuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25GbGFncy5yZXBsYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRmxhZ3MubmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbnRyeS5pbmRleCA9IHRoaXMuY3VycmVudEVudHJ5LmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBlbnRyeVxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25GbGFncy5uZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVudHJ5LmluZGV4ID0gdGhpcy5jdXJyZW50RW50cnkuaW5kZXggIT09IHZvaWQgMCA/IHRoaXMuY3VycmVudEVudHJ5LmluZGV4ICsgMSA6IHRoaXMuZW50cmllcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludm9rZUNhbGxiYWNrKGVudHJ5LCBuYXZpZ2F0aW9uRmxhZ3MsIHRoaXMuY3VycmVudEVudHJ5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bmluaXRpYWxpemVkRW50cnkgPSBuZXcgTmF2aWdhdGlvbih7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbjogJ05BVklHQVRPUiBVTklOSVRJQUxJWkVEJyxcbiAgICAgICAgICAgIGZ1bGxTdGF0ZUluc3RydWN0aW9uOiAnJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VycmVudEVudHJ5ID0gdGhpcy51bmluaXRpYWxpemVkRW50cnk7XG4gICAgICAgIHRoaXMucGVuZGluZ05hdmlnYXRpb25zID0gbmV3IFF1ZXVlKHRoaXMucHJvY2Vzc05hdmlnYXRpb25zKTtcbiAgICB9XG4gICAgZ2V0IHF1ZXVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ05hdmlnYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhcnQocm91dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdmlnYXRvciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF2aWdhdG9yIGhhcyBub3QgYmVlbiBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nTmF2aWdhdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBuYXZpZ2F0ZShlbnRyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nTmF2aWdhdGlvbnMuZW5xdWV1ZShlbnRyeSk7XG4gICAgfVxuICAgIGFzeW5jIHJlZnJlc2goKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jdXJyZW50RW50cnk7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gdGhpcy51bmluaXRpYWxpemVkRW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LnJlcGxhY2luZyA9IHRydWU7XG4gICAgICAgIGVudHJ5LnJlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZShlbnRyeSk7XG4gICAgfVxuICAgIGFzeW5jIGdvKG1vdmVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gKHRoaXMuY3VycmVudEVudHJ5LmluZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCA6IDApICsgbW92ZW1lbnQ7XG4gICAgICAgIGlmIChuZXdJbmRleCA+PSB0aGlzLmVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc1tuZXdJbmRleF07XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlKGVudHJ5KTtcbiAgICB9XG4gICAgYXN5bmMgc2V0RW50cnlUaXRsZSh0aXRsZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRFbnRyeS50aXRsZSA9IHRpdGxlO1xuICAgICAgICByZXR1cm4gdGhpcy5zYXZlU3RhdGUoKTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEVudHJ5ID09PSB0aGlzLnVuaW5pdGlhbGl6ZWRFbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jdXJyZW50RW50cnkuaW5kZXggIT09IHZvaWQgMCA/IHRoaXMuY3VycmVudEVudHJ5LmluZGV4IDogMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5zbGljZSgwLCBpbmRleCArIDEpLmZpbHRlcigodmFsdWUpID0+ICEhdmFsdWUudGl0bGUpLm1hcCgodmFsdWUpID0+IHZhbHVlLnRpdGxlID8gdmFsdWUudGl0bGUgOiAnJyk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgc3RvcmVkIG5hdmlnYXRvciBzdGF0ZSAoanNvbiBva2F5KVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMub3B0aW9ucy5zdG9yZSA/IHsgLi4udGhpcy5vcHRpb25zLnN0b3JlLnN0YXRlIH0gOiB7fTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IChzdGF0ZS5lbnRyaWVzID8/IFtdKTtcbiAgICAgICAgY29uc3QgY3VycmVudEVudHJ5ID0gKHN0YXRlLmN1cnJlbnRFbnRyeSA/PyBudWxsKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGUsIGVudHJpZXMsIGN1cnJlbnRFbnRyeSB9O1xuICAgIH1cbiAgICAvLyBMb2FkIGEgc3RvcmVkIHN0YXRlIGludG8gTmF2aWdhdGlvbiBlbnRyaWVzXG4gICAgbG9hZFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gc3RhdGUuZW50cmllcy5tYXAoZW50cnkgPT4gbmV3IE5hdmlnYXRpb24oZW50cnkpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50RW50cnkgPSBzdGF0ZS5jdXJyZW50RW50cnkgIT09IG51bGxcbiAgICAgICAgICAgID8gbmV3IE5hdmlnYXRpb24oc3RhdGUuY3VycmVudEVudHJ5KVxuICAgICAgICAgICAgOiB0aGlzLnVuaW5pdGlhbGl6ZWRFbnRyeTtcbiAgICB9XG4gICAgLy8gU2F2ZSBzdG9yZWFibGUgdmVyc2lvbnMgb2YgTmF2aWdhdGlvbiBlbnRyaWVzXG4gICAgYXN5bmMgc2F2ZVN0YXRlKHB1c2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RW50cnkgPT09IHRoaXMudW5pbml0aWFsaXplZEVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcmVkRW50cnkgPSB0aGlzLmN1cnJlbnRFbnRyeS50b1N0b3JlZCgpO1xuICAgICAgICB0aGlzLmVudHJpZXNbc3RvcmVkRW50cnkuaW5kZXggIT09IHZvaWQgMCA/IHN0b3JlZEVudHJ5LmluZGV4IDogMF0gPSBuZXcgTmF2aWdhdGlvbihzdG9yZWRFbnRyeSk7XG4gICAgICAgIC8vIElmIHByZXNlcnZpbmcgaGlzdG9yeSwgc2VyaWFsaXplIGVudHJpZXMgdGhhdCBhcmVuJ3QgcHJlc2VydmVkXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhdGVmdWxIaXN0b3J5TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmVudHJpZXMubGVuZ3RoIC0gdGhpcy5vcHRpb25zLnN0YXRlZnVsSGlzdG9yeUxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkuaW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXJpYWxpemVFbnRyeShlbnRyeSwgdGhpcy5lbnRyaWVzLnNsaWNlKGluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBlbnRyaWVzOiAodGhpcy5lbnRyaWVzID8/IFtdKS5tYXAoKGVudHJ5KSA9PiB0aGlzLnRvU3RvcmVhYmxlRW50cnkoZW50cnkpKSxcbiAgICAgICAgICAgIGN1cnJlbnRFbnRyeTogdGhpcy50b1N0b3JlYWJsZUVudHJ5KHN0b3JlZEVudHJ5KSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMpIHtcbiAgICAgICAgLy8gICBzdGF0ZS5lbnRyaWVzLnB1c2godGhpcy50b1N0b3JlYWJsZUVudHJ5KGVudHJ5KSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRFbnRyeS50aXRsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RvcmUuc2V0VGl0bGUoc3RhdGUuY3VycmVudEVudHJ5LnRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9yZS5wdXNoTmF2aWdhdG9yU3RhdGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9yZS5yZXBsYWNlTmF2aWdhdG9yU3RhdGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RvcmVkRW50cnkoZW50cnkpIHtcbiAgICAgICAgY29uc3QgeyBwcmV2aW91cywgZnJvbUJyb3dzZXIsIG9yaWdpbiwgcmVwbGFjaW5nLCByZWZyZXNoaW5nLCB1bnRyYWNrZWQsIGhpc3RvcnlNb3ZlbWVudCwgbmF2aWdhdGlvbiwgc2NvcGUsIHJlc29sdmUsIHJlamVjdCwgLi4uc3RvcmFibGVFbnRyeSB9ID0gZW50cnk7XG4gICAgICAgIHJldHVybiBzdG9yYWJsZUVudHJ5O1xuICAgIH1cbiAgICBhc3luYyBmaW5hbGl6ZShpbnN0cnVjdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRFbnRyeSA9IGluc3RydWN0aW9uO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5jdXJyZW50RW50cnkuaW5kZXggOiAwO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RW50cnkudW50cmFja2VkKSB7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uZnJvbUJyb3dzZXIgJiYgdGhpcy5vcHRpb25zLnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLnN0b3JlLnBvcE5hdmlnYXRvclN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RW50cnkuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuZW50cmllc1tpbmRleF0gPSB0aGlzLmN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50RW50cnkucmVwbGFjaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXNbaW5kZXhdID0gdGhpcy5jdXJyZW50RW50cnk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBOZXcgZW50cnkgKGFkZCBhbmQgZGlzY2FyZCBsYXRlciBlbnRyaWVzKVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXJpYWxpemVDYWxsYmFjayAhPT0gdm9pZCAwICYmIHRoaXMub3B0aW9ucy5zdGF0ZWZ1bEhpc3RvcnlMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjbGVhciB0aGUgaW5zdHJ1Y3Rpb25zIHdlIGRpc2NhcmQhXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhQcmVzZXJ2ZSA9IHRoaXMuZW50cmllcy5sZW5ndGggLSB0aGlzLm9wdGlvbnMuc3RhdGVmdWxIaXN0b3J5TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzLnNsaWNlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5Lmluc3RydWN0aW9uICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9wdGlvbnMuc2VyaWFsaXplQ2FsbGJhY2soZW50cnksIHRoaXMuZW50cmllcy5zbGljZShpbmRleFByZXNlcnZlLCBpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbnRyaWVzID0gdGhpcy5lbnRyaWVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5wdXNoKHRoaXMuY3VycmVudEVudHJ5KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZVN0YXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbnRyeS5yZXNvbHZlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRFbnRyeS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2FuY2VsKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbi5mcm9tQnJvd3NlciAmJiB0aGlzLm9wdGlvbnMuc3RvcmUpIHtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5uYXZpZ2F0aW9uICYmIGluc3RydWN0aW9uLm5hdmlnYXRpb24ubmV3KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLnN0b3JlLnBvcE5hdmlnYXRvclN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9wdGlvbnMuc3RvcmUuZ28oLShpbnN0cnVjdGlvbi5oaXN0b3J5TW92ZW1lbnQgfHwgMCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbnRyeS5yZXNvbHZlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRFbnRyeS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlQ2FsbGJhY2soZW50cnksIG5hdmlnYXRpb25GbGFncywgcHJldmlvdXNFbnRyeSkge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBOYXZpZ2F0aW9uKHsgLi4uZW50cnkgfSk7XG4gICAgICAgIGluc3RydWN0aW9uLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uRmxhZ3M7XG4gICAgICAgIGluc3RydWN0aW9uLnByZXZpb3VzID0gcHJldmlvdXNFbnRyeTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNhbGxiYWNrKGluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0b3JlYWJsZUVudHJ5KGVudHJ5KSB7XG4gICAgICAgIGNvbnN0IHN0b3JlYWJsZSA9IGVudHJ5IGluc3RhbmNlb2YgTmF2aWdhdGlvbiA/IGVudHJ5LnRvU3RvcmVkKCkgOiBlbnRyeTtcbiAgICAgICAgc3RvcmVhYmxlLmluc3RydWN0aW9uID0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9ucyhzdG9yZWFibGUuaW5zdHJ1Y3Rpb24pO1xuICAgICAgICBzdG9yZWFibGUuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHN0b3JlYWJsZS5mdWxsU3RhdGVJbnN0cnVjdGlvbik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmVhYmxlLnNjb3BlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3RvcmVhYmxlLnNjb3BlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmVhYmxlO1xuICAgIH1cbiAgICBhc3luYyBzZXJpYWxpemVFbnRyeShlbnRyeSwgcHJlc2VydmVkRW50cmllcykge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvblJlc29sdmVyID0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlcjtcbiAgICAgICAgbGV0IGV4Y2x1ZGVDb21wb25lbnRzID0gW107XG4gICAgICAgIC8vIENvbXBvbmVudHMgaW4gcHJlc2VydmVkIGVudHJpZXMgc2hvdWxkIG5vdCBiZSBzZXJpYWxpemVkL2ZyZWVkXG4gICAgICAgIGZvciAoY29uc3QgcHJlc2VydmVkRW50cnkgb2YgcHJlc2VydmVkRW50cmllcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVzZXJ2ZWRFbnRyeS5pbnN0cnVjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlQ29tcG9uZW50cy5wdXNoKC4uLmluc3RydWN0aW9uUmVzb2x2ZXIuZmxhdHRlblZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHByZXNlcnZlZEVudHJ5Lmluc3RydWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLnZpZXdwb3J0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLmNvbXBvbmVudEluc3RhbmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXNlcnZlZEVudHJ5LmZ1bGxTdGF0ZUluc3RydWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVDb21wb25lbnRzLnB1c2goLi4uaW5zdHJ1Y3Rpb25SZXNvbHZlci5mbGF0dGVuVmlld3BvcnRJbnN0cnVjdGlvbnMocHJlc2VydmVkRW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udmlld3BvcnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uY29tcG9uZW50SW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHVuaXF1ZVxuICAgICAgICBleGNsdWRlQ29tcG9uZW50cyA9IGV4Y2x1ZGVDb21wb25lbnRzLmZpbHRlcigoY29tcG9uZW50LCBpLCBhcnIpID0+IGNvbXBvbmVudCAhPT0gbnVsbCAmJiBhcnIuaW5kZXhPZihjb21wb25lbnQpID09PSBpKTtcbiAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAvLyBUaGUgaW5zdHJ1Y3Rpb25zLCBvbmUgb3IgdHdvLCB3aXRoIHBvc3NpYmxlIGNvbXBvbmVudHMgdG8gZnJlZVxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5LmZ1bGxTdGF0ZUluc3RydWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goLi4uZW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgZW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGVudHJ5LmZ1bGxTdGF0ZUluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5Lmluc3RydWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goLi4uZW50cnkuaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgZW50cnkuaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGVudHJ5Lmluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9jZXNzIG9ubHkgdGhvc2Ugd2l0aCBpbnN0YW5jZXMgYW5kIG1ha2UgdW5pcXVlXG4gICAgICAgIGluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5maWx0ZXIoKGluc3RydWN0aW9uLCBpLCBhcnIpID0+IGluc3RydWN0aW9uICE9PSBudWxsXG4gICAgICAgICAgICAmJiBpbnN0cnVjdGlvbi5jb21wb25lbnRJbnN0YW5jZSAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgYXJyLmluZGV4T2YoaW5zdHJ1Y3Rpb24pID09PSBpKTtcbiAgICAgICAgLy8gQWxyZWFkeSBmcmVlZCBjb21wb25lbnRzICh1cGRhdGVkIHdoZW4gY29tcG9uZW50IGlzIGZyZWVkKVxuICAgICAgICBjb25zdCBhbHJlYWR5RG9uZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mcmVlSW5zdHJ1Y3Rpb25Db21wb25lbnRzKGluc3RydWN0aW9uLCBleGNsdWRlQ29tcG9uZW50cywgYWxyZWFkeURvbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyZWVJbnN0cnVjdGlvbkNvbXBvbmVudHMoaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVDb21wb25lbnRzLCBhbHJlYWR5RG9uZSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBpbnN0cnVjdGlvbi5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBpbnN0cnVjdGlvbi52aWV3cG9ydDtcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gbnVsbCB8fCB2aWV3cG9ydCA9PT0gbnVsbCB8fCBhbHJlYWR5RG9uZS5zb21lKGRvbmUgPT4gZG9uZSA9PT0gY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjbHVkZUNvbXBvbmVudHMuc29tZShleGNsdWRlID0+IGV4Y2x1ZGUgPT09IGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHZpZXdwb3J0LmZyZWVDb250ZW50KGNvbXBvbmVudCksICgpID0+IHtcbiAgICAgICAgICAgICAgICBhbHJlYWR5RG9uZS5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5leHRJbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLmZyZWVJbnN0cnVjdGlvbkNvbXBvbmVudHMobmV4dEluc3RydWN0aW9uLCBleGNsdWRlQ29tcG9uZW50cywgYWxyZWFkeURvbmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRvci5qcy5tYXAiLCJleHBvcnQgY2xhc3MgT3BlblByb21pc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgICAgICB0aGlzLnJlaiA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXModmFsdWUpO1xuICAgICAgICB0aGlzLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZWplY3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZWoodmFsdWUpO1xuICAgICAgICB0aGlzLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW4tcHJvbWlzZS5qcy5tYXAiLCIvKipcbiAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgaWYgKCFxdWVyeSB8fCAhcXVlcnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IHt9O1xuICAgIC8vIFRPRE86IERlYWwgd2l0aCBjb21wbGV4IHBhcmFtZXRlcnMgc3VjaCBhcyBsaXN0cyBhbmQgb2JqZWN0c1xuICAgIGNvbnN0IHBhcmFtcyA9IHF1ZXJ5LnJlcGxhY2UoJysnLCAnICcpLnNwbGl0KCcmJyk7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgICAgcGFyYW1ldGVyc1tkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDoga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgYm91bmQgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuLyoqXG4gKiBBIGZpcnN0LWluLWZpcnN0LW91dCBxdWV1ZSB0aGF0IG9ubHkgcHJvY2Vzc2VzIHRoZSBuZXh0IHF1ZXVlZCBpdGVtXG4gKiB3aGVuIHRoZSBjdXJyZW50IG9uZSBoYXMgYmVlbiByZXNvbHZlZCBvciByZWplY3RlZC4gU2VuZHMgcXVldWVkIGl0ZW1zXG4gKiBvbmUgYXQgYSB0aW1lIHRvIGEgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIHNob3VsZCByZXNvbHZlIG9yIHJlamVjdCB0aGUgcXVldWVkIGl0ZW0gd2hlbiBwcm9jZXNzaW5nIGlzIGRvbmUuXG4gKiBFbnF1ZXVlZCBpdGVtcyBjYW4gYmUgYXdhaXRlZC4gRW5xdWV1ZWQgaXRlbXMgY2FuIHNwZWNpZnkgYW4gKGFyYml0cmFyeSlcbiAqIGV4ZWN1dGlvbiBjb3N0IGFuZCB0aGUgcXVldWUgY2FuIGJlIHNldCB1cCAoc3RhcnRlZCkgdG8gb25seSBwcm9jZXNzXG4gKiBhIHNwZWNpZmljIGFtb3VudCBvZiBleGVjdXRpb24gY29zdCBwZXIgUkFGL3RpY2suXG4gKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRFeGVjdXRpb25Db3N0SW5DdXJyZW50VGljayA9IDA7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2sgIT09IG51bGw7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXVlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBvcHRpb25zLnBsYXRmb3JtO1xuICAgICAgICB0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayA9IG9wdGlvbnMuYWxsb3dlZEV4ZWN1dGlvbkNvc3RXaXRoaW5UaWNrO1xuICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLnBsYXRmb3JtLmRvbVdyaXRlUXVldWUucXVldWVUYXNrKHRoaXMuZGVxdWV1ZSwgeyBwZXJzaXN0ZW50OiB0cnVlIH0pO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVldWUgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhc2suY2FuY2VsKCk7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuYWxsb3dlZEV4ZWN1dGlvbkNvc3RXaXRoaW5UaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICBlbnF1ZXVlKGl0ZW1Pckl0ZW1zLCBjb3N0T3JDb3N0cykge1xuICAgICAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheShpdGVtT3JJdGVtcyk7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gbGlzdCA/IGl0ZW1Pckl0ZW1zIDogW2l0ZW1Pckl0ZW1zXTtcbiAgICAgICAgY29uc3QgY29zdHMgPSBpdGVtc1xuICAgICAgICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiAhQXJyYXkuaXNBcnJheShjb3N0T3JDb3N0cykgPyBjb3N0T3JDb3N0cyA6IGNvc3RPckNvc3RzW2luZGV4XSlcbiAgICAgICAgICAgIC5tYXAodmFsdWUgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogMSk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgY29uc3QgcUl0ZW0gPSB7IC4uLml0ZW0gfTtcbiAgICAgICAgICAgIHFJdGVtLmNvc3QgPSBjb3N0cy5zaGlmdCgpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcUl0ZW0ucmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHFJdGVtLnJlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcucHVzaChxSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgIHJldHVybiBsaXN0ID8gcHJvbWlzZXMgOiBwcm9taXNlc1swXTtcbiAgICB9XG4gICAgZGVxdWV1ZShkZWx0YSkge1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEV4ZWN1dGlvbkNvc3RJbkN1cnJlbnRUaWNrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgIT09IG51bGwgJiYgZGVsdGEgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmN1cnJlbnRFeGVjdXRpb25Db3N0SW5DdXJyZW50VGljayArICh0aGlzLnBlbmRpbmdbMF0uY29zdCB8fCAwKSA+IHRoaXMuYWxsb3dlZEV4ZWN1dGlvbkNvc3RXaXRoaW5UaWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5wZW5kaW5nLnNoaWZ0KCkgfHwgbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RXhlY3V0aW9uQ29zdEluQ3VycmVudFRpY2sgKz0gdGhpcy5wcm9jZXNzaW5nLmNvc3QgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5wcm9jZXNzaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nLnNwbGljZSgwLCB0aGlzLnBlbmRpbmcubGVuZ3RoKTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBib3VuZFxuXSwgUXVldWUucHJvdG90eXBlLCBcImRlcXVldWVcIiwgbnVsbCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGN1c3RvbUF0dHJpYnV0ZSwgSU5vZGUsIGJpbmRhYmxlLCBCaW5kaW5nTW9kZSwgSU9ic2VydmVyTG9jYXRvciwgQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IElSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXIuanMnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIgfSBmcm9tICcuLi90eXBlLXJlc29sdmVycy5qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbldhcm5pbmcgfSBmcm9tICcuLi91dGlscy5qcyc7XG5sZXQgR290b0N1c3RvbUF0dHJpYnV0ZSA9IGNsYXNzIEdvdG9DdXN0b21BdHRyaWJ1dGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHJvdXRlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5oYXNIcmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGFzcyA9ICdnb3RvLWFjdGl2ZSc7XG4gICAgICAgIGRlcHJlY2F0aW9uV2FybmluZygnXCJnb3RvXCIgY3VzdG9tIGF0dHJpYnV0ZScsICdcImxvYWRcIiBjdXN0b20gYXR0cmlidXRlJyk7XG4gICAgfVxuICAgIGJpbmRpbmcoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucm91dGVyLmxpbmtIYW5kbGVyLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyTG9jYXRvciA9IHRoaXMucm91dGVyLmNvbnRhaW5lci5nZXQoSU9ic2VydmVyTG9jYXRvcik7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlckxvY2F0b3IuZ2V0T2JzZXJ2ZXIodGhpcy5yb3V0ZXIsICdhY3RpdmVDb21wb25lbnRzJyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH1cbiAgICB1bmJpbmRpbmcoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucm91dGVyLmxpbmtIYW5kbGVyLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZWQobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzSHJlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oYXNIcmVmID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNIcmVmKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGEgYmV0dGVyIHZhbHVlIGhlcmUgZm9yIG5vbi1zdHJpbmdzICh1c2luZyBJbnN0cnVjdGlvblJlc29sdmVyPylcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnID8gdGhpcy52YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBDdXN0b21BdHRyaWJ1dGUuZm9yKHRoaXMuZWxlbWVudCwgJ2dvdG8nKS5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLnJvdXRlciwgdGhpcy52YWx1ZSwgeyBjb250ZXh0OiBjb250cm9sbGVyIH0pO1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMucm91dGVyLCBjcmVhdGVkLmluc3RydWN0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5zY29wZSA9IGNyZWF0ZWQuc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogVXNlIHJvdXRlciBjb25maWd1cmF0aW9uIGZvciBjbGFzcyBuYW1lIGFuZCB1cGRhdGUgdGFyZ2V0XG4gICAgICAgIGlmICh0aGlzLnJvdXRlci5jaGVja0FjdGl2ZShpbnN0cnVjdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKHsgbW9kZTogQmluZGluZ01vZGUudG9WaWV3IH0pXG5dLCBHb3RvQ3VzdG9tQXR0cmlidXRlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuR290b0N1c3RvbUF0dHJpYnV0ZSA9IF9fZGVjb3JhdGUoW1xuICAgIGN1c3RvbUF0dHJpYnV0ZSgnZ290bycpLFxuICAgIF9fcGFyYW0oMCwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMSwgSVJvdXRlcilcbl0sIEdvdG9DdXN0b21BdHRyaWJ1dGUpO1xuZXhwb3J0IHsgR290b0N1c3RvbUF0dHJpYnV0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z290by5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGN1c3RvbUF0dHJpYnV0ZSwgSU5vZGUsIGJpbmRhYmxlLCBCaW5kaW5nTW9kZSB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG5pbXBvcnQgeyBJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyLmpzJztcbmltcG9ydCB7IEdvdG9DdXN0b21BdHRyaWJ1dGUgfSBmcm9tICcuLi9jb25maWd1cmF0aW9uLmpzJztcbmxldCBIcmVmQ3VzdG9tQXR0cmlidXRlID0gY2xhc3MgSHJlZkN1c3RvbUF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgcm91dGVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgIH1cbiAgICBiaW5kaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXIub3B0aW9ucy51c2VIcmVmICYmICF0aGlzLmhhc0dvdG8oKSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yb3V0ZXIubGlua0hhbmRsZXIuaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICAgIH1cbiAgICB1bmJpbmRpbmcoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucm91dGVyLmxpbmtIYW5kbGVyLmhhbmRsZXIpO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgICB9XG4gICAgdXBkYXRlVmFsdWUoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgaGFzR290bygpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4kY29udHJvbGxlci5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gc2libGluZ3MgIT09IG51bGxcbiAgICAgICAgICAgICYmIHNpYmxpbmdzLnNvbWUoYyA9PiBjLnZtS2luZCA9PT0gMSAvKiBjdXN0b21BdHRyaWJ1dGUgKi8gJiYgYy52aWV3TW9kZWwgaW5zdGFuY2VvZiBHb3RvQ3VzdG9tQXR0cmlidXRlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoeyBtb2RlOiBCaW5kaW5nTW9kZS50b1ZpZXcgfSlcbl0sIEhyZWZDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5IcmVmQ3VzdG9tQXR0cmlidXRlID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tQXR0cmlidXRlKHtcbiAgICAgICAgbmFtZTogJ2hyZWYnLFxuICAgICAgICBub011bHRpQmluZGluZ3M6IHRydWVcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIElOb2RlKSxcbiAgICBfX3BhcmFtKDEsIElSb3V0ZXIpXG5dLCBIcmVmQ3VzdG9tQXR0cmlidXRlKTtcbmV4cG9ydCB7IEhyZWZDdXN0b21BdHRyaWJ1dGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhyZWYuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBjdXN0b21BdHRyaWJ1dGUsIElOb2RlLCBiaW5kYWJsZSwgQmluZGluZ01vZGUsIElPYnNlcnZlckxvY2F0b3IsIEN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG5pbXBvcnQgeyBJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyLmpzJztcbmltcG9ydCB7IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyIH0gZnJvbSAnLi4vdHlwZS1yZXNvbHZlcnMuanMnO1xubGV0IExvYWRDdXN0b21BdHRyaWJ1dGUgPSBjbGFzcyBMb2FkQ3VzdG9tQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCByb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMuaGFzSHJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2xhc3MgPSAnbG9hZC1hY3RpdmUnO1xuICAgIH1cbiAgICBiaW5kaW5nKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnJvdXRlci5saW5rSGFuZGxlci5oYW5kbGVyKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICAgICAgICBjb25zdCBvYnNlcnZlckxvY2F0b3IgPSB0aGlzLnJvdXRlci5jb250YWluZXIuZ2V0KElPYnNlcnZlckxvY2F0b3IpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXJMb2NhdG9yLmdldE9ic2VydmVyKHRoaXMucm91dGVyLCAnYWN0aXZlQ29tcG9uZW50cycpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLnN1YnNjcmliZSh0aGlzKTtcbiAgICB9XG4gICAgdW5iaW5kaW5nKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnJvdXRlci5saW5rSGFuZGxlci5oYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci51bnN1YnNjcmliZSh0aGlzKTtcbiAgICB9XG4gICAgdmFsdWVDaGFuZ2VkKG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgICB9XG4gICAgdXBkYXRlVmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0hyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzSHJlZiA9IHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzSHJlZikge1xuICAgICAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCBhIGJldHRlciB2YWx1ZSBoZXJlIGZvciBub24tc3RyaW5ncyAodXNpbmcgSW5zdHJ1Y3Rpb25SZXNvbHZlcj8pXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJyA/IHRoaXMudmFsdWUgOiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gQ3VzdG9tQXR0cmlidXRlLmZvcih0aGlzLmVsZW1lbnQsICdsb2FkJykucGFyZW50O1xuICAgICAgICBjb25zdCBjcmVhdGVkID0gTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbnModGhpcy5yb3V0ZXIsIHRoaXMudmFsdWUsIHsgY29udGV4dDogY29udHJvbGxlciB9KTtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIudG9WaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLnJvdXRlciwgY3JlYXRlZC5pbnN0cnVjdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uc2NvcGUgPSBjcmVhdGVkLnNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFVzZSByb3V0ZXIgY29uZmlndXJhdGlvbiBmb3IgY2xhc3MgbmFtZSBhbmQgdXBkYXRlIHRhcmdldFxuICAgICAgICBpZiAodGhpcy5yb3V0ZXIuY2hlY2tBY3RpdmUoaW5zdHJ1Y3Rpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5hY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSh7IG1vZGU6IEJpbmRpbmdNb2RlLnRvVmlldyB9KVxuXSwgTG9hZEN1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbkxvYWRDdXN0b21BdHRyaWJ1dGUgPSBfX2RlY29yYXRlKFtcbiAgICBjdXN0b21BdHRyaWJ1dGUoJ2xvYWQnKSxcbiAgICBfX3BhcmFtKDAsIElOb2RlKSxcbiAgICBfX3BhcmFtKDEsIElSb3V0ZXIpXG5dLCBMb2FkQ3VzdG9tQXR0cmlidXRlKTtcbmV4cG9ydCB7IExvYWRDdXN0b21BdHRyaWJ1dGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBiaW5kYWJsZSwgY3VzdG9tRWxlbWVudCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG5pbXBvcnQgeyBJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyLmpzJztcbmxldCBOYXZDdXN0b21FbGVtZW50ID0gY2xhc3MgTmF2Q3VzdG9tRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3Iocm91dGVyKSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJvdXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB7fTtcbiAgICB9XG4gICAgZ2V0IG5hdlJvdXRlcygpIHtcbiAgICAgICAgY29uc3QgbmF2ID0gdGhpcy5yb3V0ZXIubmF2c1t0aGlzLm5hbWVdO1xuICAgICAgICByZXR1cm4gKG5hdiAhPT0gdm9pZCAwICYmIG5hdiAhPT0gbnVsbCA/IG5hdi5yb3V0ZXMgOiBbXSk7XG4gICAgfVxuICAgIGdldCBuYXZDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBuYXYgPSB0aGlzLnJvdXRlci5uYXZzW3RoaXMubmFtZV07XG4gICAgICAgIGNvbnN0IG5hdkNsYXNzZXMgPSAobmF2ICE9PSB2b2lkIDAgJiYgbmF2ICE9PSBudWxsID8gbmF2LmNsYXNzZXMgOiB7fSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgbmF2OiAnJyxcbiAgICAgICAgICAgICAgICB1bDogJycsXG4gICAgICAgICAgICAgICAgbGk6ICcnLFxuICAgICAgICAgICAgICAgIGE6ICcnLFxuICAgICAgICAgICAgICAgIHVsQWN0aXZlOiAnJyxcbiAgICAgICAgICAgICAgICBsaUFjdGl2ZTogJ25hdi1hY3RpdmUnLFxuICAgICAgICAgICAgICAgIGFBY3RpdmU6ICcnLFxuICAgICAgICAgICAgfSwgLi4ubmF2Q2xhc3Nlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhY3RpdmUocm91dGUpIHtcbiAgICAgICAgcmV0dXJuICdBY3RpdmUnO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgTmF2Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIE5hdkN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcInJvdXRlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIE5hdkN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcImxldmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgTmF2Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwiY2xhc3Nlc1wiLCB2b2lkIDApO1xuTmF2Q3VzdG9tRWxlbWVudCA9IF9fZGVjb3JhdGUoW1xuICAgIGN1c3RvbUVsZW1lbnQoe1xuICAgICAgICBuYW1lOiAnYXUtbmF2JywgdGVtcGxhdGU6IGA8dGVtcGxhdGU+XG4gIDxuYXYgaWYuYmluZD1cIm5hbWVcIiBjbGFzcz1cIlxcJHtuYW1lfSBcXCR7bmF2Q2xhc3Nlcy5uYXZ9XCI+XG4gICAgPGF1LW5hdiByb3V0ZXMuYmluZD1cIm5hdlJvdXRlc1wiIGNsYXNzZXMuYmluZD1cIm5hdkNsYXNzZXNcIiBjb250YWluZXJsZXNzPjwvYXUtbmF2PlxuICA8L25hdj5cbiAgPHVsIGlmLmJpbmQ9XCJyb3V0ZXNcIiBjbGFzcz1cIm5hdi1sZXZlbC1cXCR7bGV2ZWx9IFxcJHtjbGFzc2VzLnVsfVwiPlxuICAgIDxsaSByZXBlYXQuZm9yPVwicm91dGUgb2Ygcm91dGVzXCIgaWYuYmluZD1cInJvdXRlLnZpc2libGVcIiBjbGFzcz1cIlxcJHtyb3V0ZS5hY3RpdmUgPyBjbGFzc2VzLmxpQWN0aXZlIDogJyd9IFxcJHtyb3V0ZS5oYXNDaGlsZHJlbn0gXFwke2NsYXNzZXMubGl9XCI+XG4gICAgICA8YSBpZi5iaW5kPVwicm91dGUubGluayAmJiByb3V0ZS5saW5rLmxlbmd0aFwiIGxvYWQ9XCJcXCR7cm91dGUubGlua31cIiBjbGFzcz1cIlxcJHtyb3V0ZS5hY3RpdmUgPyBjbGFzc2VzLmFBY3RpdmUgOiAnJ30gXFwke2NsYXNzZXMuYX1cIiBpbm5lcmh0bWwuYmluZD1cInJvdXRlLnRpdGxlXCI+PC9hPlxuICAgICAgPGEgaWYuYmluZD1cInJvdXRlLmV4ZWN1dGVcIiBjbGljay50cmlnZ2VyPVwicm91dGUuZXhlY3V0ZUFjdGlvbigkZXZlbnQpXCIgaHJlZj1cIlwiIGNsYXNzPVwiXFwke3JvdXRlLmFjdGl2ZSA/IGNsYXNzZXMuYUFjdGl2ZSA6ICcnfSBcXCR7Y2xhc3Nlcy5hfVwiIGlubmVyaHRtbC5iaW5kPVwicm91dGUudGl0bGVcIj48L2E+XG4gICAgICA8c3BhbiBpZi5iaW5kPVwiKCFyb3V0ZS5saW5rIHx8ICFyb3V0ZS5saW5rLmxlbmd0aCkgJiYgIXJvdXRlLmV4ZWN1dGUgJiYgIXJvdXRlLmNoaWxkcmVuXCIgY2xhc3M9XCJcXCR7cm91dGUuYWN0aXZlID8gY2xhc3Nlcy5hQWN0aXZlIDogJyd9IFxcJHtjbGFzc2VzLnNwYW59IG5hdi1zZXBhcmF0b3JcIiBpbm5lcmh0bWwuYmluZD1cInJvdXRlLnRpdGxlXCI+PC9zcGFuPlxuICAgICAgPGEgaWYuYmluZD1cIighcm91dGUubGluayB8fCAhcm91dGUubGluay5sZW5ndGgpICYmICFyb3V0ZS5leGVjdXRlICYmIHJvdXRlLmNoaWxkcmVuXCIgY2xpY2suZGVsZWdhdGU9XCJyb3V0ZS50b2dnbGVBY3RpdmUoKVwiIGhyZWY9XCJcIiBjbGFzcz1cIlxcJHtyb3V0ZS5hY3RpdmUgPyBjbGFzc2VzLmFBY3RpdmUgOiAnJ30gXFwke2NsYXNzZXMuYX1cIiBpbm5lcmh0bWwuYmluZD1cInJvdXRlLnRpdGxlXCI+PC9hPlxuICAgICAgPGF1LW5hdiBpZi5iaW5kPVwicm91dGUuY2hpbGRyZW5cIiByb3V0ZXMuYmluZD1cInJvdXRlLmNoaWxkcmVuXCIgbGV2ZWwuYmluZD1cImxldmVsICsgMVwiIGNsYXNzZXMuYmluZD1cImNsYXNzZXNcIiBjb250YWluZXJsZXNzPjwvYXUtbmF2PlxuICAgIDwvbGk+XG4gIDwvdWw+XG48L3RlbXBsYXRlPmBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIElSb3V0ZXIpXG5dLCBOYXZDdXN0b21FbGVtZW50KTtcbmV4cG9ydCB7IE5hdkN1c3RvbUVsZW1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdi5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudF8xO1xuaW1wb3J0IHsgYmluZGFibGUsIElOb2RlLCBjdXN0b21FbGVtZW50LCBDdXN0b21FbGVtZW50LCBJQ29udHJvbGxlciwgaXNDdXN0b21FbGVtZW50Q29udHJvbGxlciwgaXNDdXN0b21FbGVtZW50Vmlld01vZGVsLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG5pbXBvcnQgeyBJQ29udGFpbmVyIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IElSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXIuanMnO1xuaW1wb3J0IHsgVmlld3BvcnRDdXN0b21FbGVtZW50IH0gZnJvbSAnLi92aWV3cG9ydC5qcyc7XG5leHBvcnQgY29uc3QgUGFyZW50Vmlld3BvcnRTY29wZSA9IEN1c3RvbUVsZW1lbnQuY3JlYXRlSW5qZWN0YWJsZSgpO1xubGV0IFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50ID0gVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnRfMSA9IGNsYXNzIFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXIsIGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50LCBwYXJlbnRDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50Q29udHJvbGxlciA9IHBhcmVudENvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMubmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgdGhpcy5jYXRjaGVzID0gJyc7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld3BvcnRTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBNYXliZSB0aGlzIHJlYWxseSBzaG91bGQgYmUgaGVyZS4gQ2hlY2sgd2l0aCBGcmVkXG4gICAgLy8gcHVibGljIGNyZWF0ZShcbiAgICAvLyAgIGNvbnRyb2xsZXI6IElEcnlDdXN0b21FbGVtZW50Q29udHJvbGxlcjx0aGlzPixcbiAgICAvLyAgIHBhcmVudENvbnRhaW5lcjogSUNvbnRhaW5lcixcbiAgICAvLyAgIGRlZmluaXRpb246IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLFxuICAgIC8vICAgcGFydHM6IFBhcnRpYWxDdXN0b21FbGVtZW50RGVmaW5pdGlvblBhcnRzIHwgdW5kZWZpbmVkLFxuICAgIC8vICk6IFBhcnRpYWxDdXN0b21FbGVtZW50RGVmaW5pdGlvbiB7XG4gICAgLy8gICAvLyBUT0RPKGZrbGV1dmVyKTogZGVzY3JpYmUgdGhpcyBzb21ld2hlcmUgaW4gdGhlIGRvY3MgaW5zdGVhZFxuICAgIC8vICAgLy8gVW5kZXIgdGhlIGNvbmRpdGlvbiB0aGF0IHRoZXJlIGlzIG5vIGByZXBsYWNlYCBhdHRyaWJ1dGUgb24gdGhpcyBjdXN0b20gZWxlbWVudCdzIGRlY2xhcmF0aW9uLFxuICAgIC8vICAgLy8gYW5kIHRoaXMgY3VzdG9tIGVsZW1lbnQgaXMgY29udGFpbmVybGVzcywgaXRzIGNvbnRlbnQgd2lsbCBiZSBwbGFjZWQgaW4gYSBwYXJ0IG5hbWVkICdkZWZhdWx0J1xuICAgIC8vICAgLy8gU2VlIHBhY2thZ2VzL2ppdC1odG1sL3NyYy90ZW1wbGF0ZS1iaW5kZXIudHMgbGluZSA0MTEgKGByZXBsYWNlID0gJ2RlZmF1bHQnO2ApIGZvciB0aGUgbG9naWMgdGhhdCBnb3Zlcm5zIHRoaXMuXG4gICAgLy8gICAvLyBXZSBjb3VsZCB0aWR5IHRoaXMgdXAgaW50byBhIGZvcm1hbCBhcGkgaW4gdGhlIGZ1dHVyZS4gRm9yIG5vdywgdGhlcmUgYXJlIHR3byB3YXlzIHRvIGRvIHRoaXM6XG4gICAgLy8gICAvLyAxLiBpbmplY3QgdGhlIGBASUluc3RydWN0aW9uYCAoSUh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24pIGFuZCBncmFiIC5wYXJ0c1snZGVmYXVsdCddIGZyb20gdGhlcmUsIG1hbnVhbGx5IGNyZWF0aW5nIGEgdmlldyBmYWN0b3J5IGZyb20gdGhhdCwgZXRjLlxuICAgIC8vICAgLy8gMi4gd2hhdCB3ZSdyZSBkb2luZyByaWdodCBoZXJlOiBncmFiIHRoZSAnZGVmYXVsdCcgcGFydCBmcm9tIHRoZSBjcmVhdGUgaG9vayBhbmQgcmV0dXJuIGl0IGFzIHRoZSBkZWZpbml0aW9uLCB0ZWxsaW5nIHRoZSByZW5kZXIgY29udGV4dCB0byB1c2UgdGhhdCBwYXJ0IHRvIGNvbXBpbGUgdGhpcyBlbGVtZW50IGluc3RlYWRcbiAgICAvLyAgIC8vIFRoaXMgZWZmZWN0aXZlbHkgY2F1c2VzIHRoaXMgZWxlbWVudCB0byByZW5kZXIgaXRzIGRlY2xhcmVkIGNvbnRlbnQgYXMgaWYgaXQgd2FzIGl0cyBvd24gdGVtcGxhdGUuXG4gICAgLy8gICAvLyBXZSBkbyBuZWVkIHRvIHNldCBgY29udGFpbmVybGVzc2AgdG8gdHJ1ZSBvbiB0aGUgcGFydCBkZWZpbml0aW9uIHNvIHRoYXQgdGhlIGNvcnJlY3QgcHJvamVjdG9yIGlzIHVzZWQgc2luY2UgcGFydHMgZGVmYXVsdCB0byBub24tY29udGFpbmVybGVzcy5cbiAgICAvLyAgIC8vIE90aGVyd2lzZSwgdGhlIGNvbnRyb2xsZXIgd2lsbCB0cnkgdG8gZG8gYGFwcGVuZENoaWxkYCBvbiBhIGNvbW1lbnQgbm9kZSB3aGVuIGl0IGhhcyB0byBkbyBgaW5zZXJ0QmVmb3JlYC5cbiAgICAvLyAgIC8vIEFsc28sIGluIHRoaXMgcGFydGljdWxhciBzY2VuYXJpbyAoc3BlY2lmaWMgdG8gdmlld3BvcnQtc2NvcGUpIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHBhcnQgc28gYXMgdG8gcHJldmVudCB0aGUgcmVzdWx0aW5nIGNvbXBpbGVkIGRlZmluaXRpb25cbiAgICAvLyAgIC8vIGZyb20gZXZlciBiZWluZyBjYWNoZWQuIFRoYXQncyB0aGUgb25seSByZWFzb24gd2h5IHdlJ3JlIHNwcmVhZGluZyB0aGUgcGFydCBpbnRvIGEgbmV3IG9iamVjdCBmb3IgYGdldE9yQ3JlYXRlYC4gSWYgd2UgZGlkbid0IGNsb25lIHRoZSBvYmplY3QsIHRoaXMgc3BlY2lmaWMgZWxlbWVudCB3b3VsZG4ndCB3b3JrIGNvcnJlY3RseS5cbiAgICAvLyAgIGNvbnN0IHBhcnQgPSBwYXJ0cyFbJ2RlZmF1bHQnXTtcbiAgICAvLyAgIHJldHVybiBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5nZXRPckNyZWF0ZSh7IC4uLnBhcnQsIGNvbnRhaW5lcmxlc3M6IHRydWUgfSk7XG4gICAgLy8gfVxuICAgIGh5ZHJhdGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBjb250YWluZXIgaGVyZSAocHJvYmFibHkgYmVjYXVzZSBpdCB3YW50cyB0byBiZSBhIHBhcnQgb2YgdGhlIHN0cnVjdHVyZSlcbiAgICAgICAgLy8gdGhpcy5jb250YWluZXIgPSBjb250cm9sbGVyLmNvbnRleHQuZ2V0KElDb250YWluZXIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVmlld3BvcnRTY29wZSBjcmVhdGluZycsIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJywgdGhpcy5uYW1lKSwgdGhpcy5jb250YWluZXIsIHRoaXMucGFyZW50LCBjb250cm9sbGVyLCB0aGlzKTtcbiAgICAgICAgLy8gdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIGJvdW5kKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLiRjb250cm9sbGVyLnNjb3BlID0gdGhpcy5wYXJlbnRDb250cm9sbGVyLnNjb3BlO1xuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnRTY29wZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydFNjb3BlLmJpbmRpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmJpbmRpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0U2NvcGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRTY29wZS51bmJpbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGFmdGVyVW5iaW5kKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhZnRlclVuYm91bmQoKSB7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXIucm9vdFNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJywgdGhpcy5uYW1lKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY2F0Y2hlcycsIHRoaXMuY2F0Y2hlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhdGNoZXMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjb2xsZWN0aW9uJywgdGhpcy5jb2xsZWN0aW9uLCB0cnVlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY29sbGVjdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IE5lZWRzIHRvIGJlIGJvdW5kPyBIb3cgdG8gc29sdmU/XG4gICAgICAgIG9wdGlvbnMuc291cmNlID0gdGhpcy5zb3VyY2UgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnJvdXRpbmdDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy52aWV3cG9ydFNjb3BlID0gdGhpcy5yb3V0ZXIuY29ubmVjdFZpZXdwb3J0U2NvcGUodGhpcy52aWV3cG9ydFNjb3BlLCB0aGlzLCBuYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnRTY29wZSkge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIuZGlzY29ubmVjdFZpZXdwb3J0U2NvcGUodGhpcy52aWV3cG9ydFNjb3BlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0U2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBnZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSwgY2hlY2tFeGlzdHMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0V4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlzQ3VzdG9tRWxlbWVudENvbnRyb2xsZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudENvbnRyb2xsZXIodmFsdWUpO1xuICAgIH1cbiAgICBpc0N1c3RvbUVsZW1lbnRWaWV3TW9kZWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudFZpZXdNb2RlbCh2YWx1ZSk7XG4gICAgfVxuICAgIGdldENsb3Nlc3RDdXN0b21FbGVtZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5jb250cm9sbGVyLnBhcmVudDtcbiAgICAgICAgbGV0IGN1c3RvbUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIGN1c3RvbUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudmlld01vZGVsIGluc3RhbmNlb2YgVmlld3BvcnRDdXN0b21FbGVtZW50IHx8IHBhcmVudC52aWV3TW9kZWwgaW5zdGFuY2VvZiBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudF8xKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudCA9IHBhcmVudC52aWV3TW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXN0b21FbGVtZW50O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwiY2F0Y2hlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJjb2xsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcInNvdXJjZVwiLCB2b2lkIDApO1xuVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQgPSBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tRWxlbWVudCh7XG4gICAgICAgIG5hbWU6ICdhdS12aWV3cG9ydC1zY29wZScsXG4gICAgICAgIHRlbXBsYXRlOiAnPHRlbXBsYXRlPjwvdGVtcGxhdGU+JyxcbiAgICAgICAgY29udGFpbmVybGVzczogZmFsc2UsXG4gICAgICAgIGluamVjdGFibGU6IFBhcmVudFZpZXdwb3J0U2NvcGVcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIElSb3V0ZXIpLFxuICAgIF9fcGFyYW0oMSwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMiwgSUNvbnRhaW5lciksXG4gICAgX19wYXJhbSgzLCBQYXJlbnRWaWV3cG9ydFNjb3BlKSxcbiAgICBfX3BhcmFtKDQsIElDb250cm9sbGVyKVxuXSwgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQpO1xuZXhwb3J0IHsgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdwb3J0LXNjb3BlLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIFZpZXdwb3J0Q3VzdG9tRWxlbWVudF8xO1xuaW1wb3J0IHsgSUNvbnRhaW5lciB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBiaW5kYWJsZSwgSU5vZGUsIGN1c3RvbUVsZW1lbnQsIEN1c3RvbUVsZW1lbnQsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IElSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXIuanMnO1xuaW1wb3J0IHsgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3ZpZXdwb3J0LXNjb3BlLmpzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJy4uL3J1bm5lci5qcyc7XG5leHBvcnQgY29uc3QgUGFyZW50Vmlld3BvcnQgPSBDdXN0b21FbGVtZW50LmNyZWF0ZUluamVjdGFibGUoKTtcbmxldCBWaWV3cG9ydEN1c3RvbUVsZW1lbnQgPSBWaWV3cG9ydEN1c3RvbUVsZW1lbnRfMSA9IGNsYXNzIFZpZXdwb3J0Q3VzdG9tRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3Iocm91dGVyLCBlbGVtZW50LCBjb250YWluZXIsIHBhcmVudFZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5wYXJlbnRWaWV3cG9ydCA9IHBhcmVudFZpZXdwb3J0O1xuICAgICAgICB0aGlzLm5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIHRoaXMudXNlZEJ5ID0gJyc7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9ICcnO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gJyc7XG4gICAgICAgIHRoaXMubm9TY29wZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vTGluayA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vVGl0bGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub0hpc3RvcnkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZWZ1bCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGh5ZHJhdGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2h5ZHJhdGVkJywgdGhpcy5uYW1lLCB0aGlzLnJvdXRlci5pc0FjdGl2ZSk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udHJvbGxlci5jb250ZXh0LmdldChJQ29udGFpbmVyKTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHZpZXdwb3J0KHMpIG1pZ2h0IGJlIGNvbXBpbGVkIGJlZm9yZSB0aGUgcm91dGVyIGlzIGFjdGl2ZVxuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLndhaXRGb3JSb3V0ZXJTdGFydCgpLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3V0ZXIuaXNSZXN0cmljdGVkTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy53YWl0Rm9yUm91dGVyU3RhcnQoKSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvdXRlci5pc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0ICE9PSBudWxsICYmICh0aGlzLnZpZXdwb3J0Lm5leHRDb250ZW50ID8/IG51bGwpID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYXR0YWNoaW5nJywgdGhpcy52aWV3cG9ydD8udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuYWN0aXZhdGUoaW5pdGlhdG9yLCB0aGlzLiRjb250cm9sbGVyLCBmbGFncywgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXN0b3JlIHNjcm9sbCBzdGF0ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQgIT09IG51bGwgJiYgKHRoaXMudmlld3BvcnQubmV4dENvbnRlbnQgPz8gbnVsbCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1bmJpbmRpbmcnLCB0aGlzLnZpZXdwb3J0Py50b1N0cmluZygpKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFNhdmUgdG8gY2FjaGUsIHNvbWV0aGluZyBsaWtlXG4gICAgICAgICAgICAvLyB0aGlzLnZpZXdwb3J0LmNhY2hlQ29udGVudCgpO1xuICAgICAgICAgICAgLy8gRnJvbSB2aWV3cG9ydC1jb250ZW50OlxuICAgICAgICAgICAgLy8gcHVibGljIHVubG9hZENvbXBvbmVudChjYWNoZTogVmlld3BvcnRDb250ZW50W10sIHN0YXRlZnVsOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgICAgIC8vICAgLy8gVE9ETzogV2UgbWlnaHQgd2FudCB0byBkbyBzb21ldGhpbmcgaGVyZSBldmVudHVhbGx5LCB3aG8ga25vd3M/XG4gICAgICAgICAgICAvLyAgIGlmICh0aGlzLmNvbnRlbnRTdGF0dXMgIT09IENvbnRlbnRTdGF0dXMubG9hZGVkKSB7XG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyAgIC8vIERvbid0IHVubG9hZCBjb21wb25lbnRzIHdoZW4gc3RhdGVmdWxcbiAgICAgICAgICAgIC8vICAgaWYgKCFzdGF0ZWZ1bCkge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuY29udGVudFN0YXR1cyA9IENvbnRlbnRTdGF0dXMuY3JlYXRlZDtcbiAgICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICBjYWNoZS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBUT0RPOiBTYXZlIHNjcm9sbCBzdGF0ZSBiZWZvcmUgZGV0YWNoXG4gICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLnZpZXdwb3J0LmRlYWN0aXZhdGUoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHRoaXMudmlld3BvcnQuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMudmlld3BvcnQuZGVhY3RpdmF0ZShpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpO1xuICAgICAgICAgICAgLy8gLy8gdGhpcy52aWV3cG9ydC5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVibGljIGRldGFjaGluZyhpbml0aWF0b3I6IElIeWRyYXRlZENvbnRyb2xsZXIsIHBhcmVudDogSVN5bnRoZXRpY1ZpZXcgfCBJQ3VzdG9tRWxlbWVudENvbnRyb2xsZXI8SUN1c3RvbUVsZW1lbnRWaWV3TW9kZWw+IHwgbnVsbCwgZmxhZ3M6IExpZmVjeWNsZUZsYWdzKTogdm9pZCB8IFByb21pc2U8dm9pZD4ge1xuICAgIC8vICAgaWYgKHRoaXMudmlld3BvcnQgIT09IG51bGwgJiYgKHRoaXMudmlld3BvcnQubmV4dENvbnRlbnQgPz8gbnVsbCkgPT09IG51bGwpIHtcbiAgICAvLyAgICAgY29uc29sZS5sb2coJ2RldGFjaGluZycsIHRoaXMudmlld3BvcnQ/LnRvU3RyaW5nKCkpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gKHRoaXMudmlld3BvcnQ/Lm5leHRDb250ZW50ID8/IG51bGwpID09PSBudWxsID8gdGhpcy52aWV3cG9ydD8uZGlzcG9zZSgpIDogdm9pZCAwLCAoKSA9PiB0aGlzLmRpc2Nvbm5lY3QoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVyLnJvb3RTY29wZSA9PT0gbnVsbCB8fCAodGhpcy52aWV3cG9ydCAhPT0gbnVsbCAmJiB0aGlzLnJvdXRlci5pc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxldCBjb250cm9sbGVyQ29udGFpbmVyID0gKHRoaXMuY29udHJvbGxlci5jb250ZXh0IGFzIGFueSkuY29udGFpbmVyO1xuICAgICAgICAvLyBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIC8vIGRvIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZyhvdXRwdXQsICc6JywgY29udHJvbGxlckNvbnRhaW5lciA9PT0gdGhpcy5jb250YWluZXIsIHRoaXMuY29udHJvbGxlciwgY29udHJvbGxlckNvbnRhaW5lciwgdGhpcy5jb250YWluZXIpO1xuICAgICAgICAvLyAgIGlmIChjb250cm9sbGVyQ29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAvLyAgICAgYnJlYWs7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyAgIGNvbnRyb2xsZXJDb250YWluZXIgPSBjb250cm9sbGVyQ29udGFpbmVyLnBhcmVudDtcbiAgICAgICAgLy8gICBvdXRwdXQgKz0gJy5wYXJlbnQnO1xuICAgICAgICAvLyB9IHdoaWxlIChjb250cm9sbGVyQ29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJywgdGhpcy5uYW1lKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25vLXNjb3BlJywgdGhpcy5ub1Njb3BlKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgc2NvcGU6IHZhbHVlID09PSB2b2lkIDAgfHwgIXZhbHVlID8gdHJ1ZSA6IGZhbHNlIH07XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3VzZWQtYnknLCB0aGlzLnVzZWRCeSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLnVzZWRCeSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RlZmF1bHQnLCB0aGlzLmRlZmF1bHQpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZmFsbGJhY2snLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCduby1saW5rJywgdGhpcy5ub0xpbmssIHRydWUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5ub0xpbmsgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCduby10aXRsZScsIHRoaXMubm9UaXRsZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm5vVGl0bGUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCduby1oaXN0b3J5JywgdGhpcy5ub0hpc3RvcnksIHRydWUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5ub0hpc3RvcnkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0ZWZ1bCcsIHRoaXMuc3RhdGVmdWwsIHRydWUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdGF0ZWZ1bCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5yb3V0aW5nQ29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLnJvdXRlci5jb25uZWN0Vmlld3BvcnQodGhpcy52aWV3cG9ydCwgdGhpcywgbmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlci5kaXNjb25uZWN0Vmlld3BvcnQodGhpcy52aWV3cG9ydCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG51bGw7XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZShrZXksIHZhbHVlLCBjaGVja0V4aXN0cyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kICYmICFjaGVja0V4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0V4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0Q2xvc2VzdEN1c3RvbUVsZW1lbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRyb2xsZXIucGFyZW50O1xuICAgICAgICBsZXQgY3VzdG9tRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgY3VzdG9tRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC52aWV3TW9kZWwgaW5zdGFuY2VvZiBWaWV3cG9ydEN1c3RvbUVsZW1lbnRfMSB8fCBwYXJlbnQudmlld01vZGVsIGluc3RhbmNlb2YgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50ID0gcGFyZW50LnZpZXdNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1c3RvbUVsZW1lbnQ7XG4gICAgfVxuICAgIC8vIFRPRE86IFN3aXRjaCB0aGlzIHRvIHVzZSAocHJvYmFibHkpIGFuIGV2ZW50IGluc3RlYWRcbiAgICB3YWl0Rm9yUm91dGVyU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvdXRlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIuc3RhcnRlcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydEN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydEN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcInVzZWRCeVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwiZGVmYXVsdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwiZmFsbGJhY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydEN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcIm5vU2NvcGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydEN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcIm5vTGlua1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibm9UaXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibm9IaXN0b3J5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJzdGF0ZWZ1bFwiLCB2b2lkIDApO1xuVmlld3BvcnRDdXN0b21FbGVtZW50ID0gVmlld3BvcnRDdXN0b21FbGVtZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBjdXN0b21FbGVtZW50KHtcbiAgICAgICAgbmFtZTogJ2F1LXZpZXdwb3J0JyxcbiAgICAgICAgaW5qZWN0YWJsZTogUGFyZW50Vmlld3BvcnRcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIElSb3V0ZXIpLFxuICAgIF9fcGFyYW0oMSwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMiwgSUNvbnRhaW5lciksXG4gICAgX19wYXJhbSgzLCBQYXJlbnRWaWV3cG9ydClcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudCk7XG5leHBvcnQgeyBWaWV3cG9ydEN1c3RvbUVsZW1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdwb3J0LmpzLm1hcCIsImltcG9ydCB7IFJvdXRlUmVjb2duaXplciBhcyAkUm91dGVSZWNvZ25pemVyLCBDb25maWd1cmFibGVSb3V0ZSBhcyAkQ29uZmlndXJhYmxlUm91dGUsIFJlY29nbml6ZWRSb3V0ZSBhcyAkUmVjb2duaXplZFJvdXRlLCBFbmRwb2ludCBhcyAkRW5kcG9pbnQsIH0gZnJvbSAnQGF1cmVsaWEvcm91dGUtcmVjb2duaXplcic7XG5leHBvcnQgY29uc3QgUm91dGVSZWNvZ25pemVyID0gJFJvdXRlUmVjb2duaXplcjtcbmV4cG9ydCBjb25zdCBDb25maWd1cmFibGVSb3V0ZSA9ICRDb25maWd1cmFibGVSb3V0ZTtcbmV4cG9ydCBjb25zdCBSZWNvZ25pemVkUm91dGUgPSAkUmVjb2duaXplZFJvdXRlO1xuZXhwb3J0IGNvbnN0IEVuZHBvaW50ID0gJEVuZHBvaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtcmVjb2duaXplci5qcy5tYXAiLCJleHBvcnQgY2xhc3MgUm91dGVyT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VwYXJhdG9ycyA9IHtcbiAgICAgICAgICAgIHZpZXdwb3J0OiAnQCcsXG4gICAgICAgICAgICBzaWJsaW5nOiAnKycsXG4gICAgICAgICAgICBzY29wZTogJy8nLFxuICAgICAgICAgICAgc2NvcGVTdGFydDogJygnLFxuICAgICAgICAgICAgc2NvcGVFbmQ6ICcpJyxcbiAgICAgICAgICAgIG5vU2NvcGU6ICchJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6ICcoJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnNFbmQ6ICcpJyxcbiAgICAgICAgICAgIHBhcmFtZXRlclNlcGFyYXRvcjogJywnLFxuICAgICAgICAgICAgcGFyYW1ldGVyS2V5U2VwYXJhdG9yOiAnPScsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6ICcmJyxcbiAgICAgICAgICAgIGFkZDogJysnLFxuICAgICAgICAgICAgY2xlYXI6ICctJyxcbiAgICAgICAgICAgIGFjdGlvbjogJy4nLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVzZVVybEZyYWdtZW50SGFzaCA9IHRydWU7XG4gICAgICAgIHRoaXMudXNlSHJlZiA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGVmdWxIaXN0b3J5TGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy51c2VEaXJlY3RSb3V0ZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnVzZUNvbmZpZ3VyZWRSb3V0ZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZGl0aXZlSW5zdHJ1Y3Rpb25EZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aXRsZSA9IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgICAgICAgICAgYXBwVGl0bGU6IFwiJHtjb21wb25lbnRUaXRsZXN9XFwke2FwcFRpdGxlU2VwYXJhdG9yfUF1cmVsaWFcIixcbiAgICAgICAgICAgIGFwcFRpdGxlU2VwYXJhdG9yOiAnIHwgJyxcbiAgICAgICAgICAgIGNvbXBvbmVudFRpdGxlT3JkZXI6ICd0b3AtZG93bicsXG4gICAgICAgICAgICBjb21wb25lbnRUaXRsZVNlcGFyYXRvcjogJyA+ICcsXG4gICAgICAgICAgICB1c2VDb21wb25lbnROYW1lczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFByZWZpeDogJ2FwcC0nLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TeW5jU3RhdGVzID0gWydndWFyZGVkVW5sb2FkJywgJ3N3YXBwZWQnLCAnY29tcGxldGVkJ107XG4gICAgICAgIHRoaXMuc3dhcFN0cmF0ZWd5ID0gJ2FkZC1maXJzdC1zZXF1ZW50aWFsJztcbiAgICAgICAgdGhpcy5yb3V0aW5nSG9va0ludGVncmF0aW9uID0gJ2ludGVncmF0ZWQnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci1vcHRpb25zLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXRlbXBsYXRlLWN1cmx5LWluLXN0cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXRlbXBsYXRlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uICovXG5pbXBvcnQgeyBESSwgSUNvbnRhaW5lciwgUmVnaXN0cmF0aW9uLCBNZXRhZGF0YSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50LCBJQXBwUm9vdCwgaXNSZW5kZXJDb250ZXh0LCBnZXRFZmZlY3RpdmVQYXJlbnROb2RlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IEluc3RydWN0aW9uUmVzb2x2ZXIgfSBmcm9tICcuL2luc3RydWN0aW9uLXJlc29sdmVyLmpzJztcbmltcG9ydCB7IExpbmtIYW5kbGVyIH0gZnJvbSAnLi9saW5rLWhhbmRsZXIuanMnO1xuaW1wb3J0IHsgTmF2IH0gZnJvbSAnLi9uYXYuanMnO1xuaW1wb3J0IHsgTmF2aWdhdG9yIH0gZnJvbSAnLi9uYXZpZ2F0b3IuanMnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIgfSBmcm9tICcuL3R5cGUtcmVzb2x2ZXJzLmpzJztcbmltcG9ydCB7IGFycmF5UmVtb3ZlLCBkZXByZWNhdGlvbldhcm5pbmcgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IFZpZXdwb3J0IH0gZnJvbSAnLi92aWV3cG9ydC5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydEluc3RydWN0aW9uIH0gZnJvbSAnLi92aWV3cG9ydC1pbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQgeyBGb3VuZFJvdXRlIH0gZnJvbSAnLi9mb3VuZC1yb3V0ZS5qcyc7XG5pbXBvcnQgeyBIb29rTWFuYWdlciB9IGZyb20gJy4vaG9vay1tYW5hZ2VyLmpzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi9zY29wZS5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydFNjb3BlIH0gZnJvbSAnLi92aWV3cG9ydC1zY29wZS5qcyc7XG5pbXBvcnQgeyBCcm93c2VyVmlld2VyU3RvcmUgfSBmcm9tICcuL2Jyb3dzZXItdmlld2VyLXN0b3JlLmpzJztcbmltcG9ydCB7IE5hdmlnYXRpb24gfSBmcm9tICcuL25hdmlnYXRpb24uanMnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNvb3JkaW5hdG9yIH0gZnJvbSAnLi9uYXZpZ2F0aW9uLWNvb3JkaW5hdG9yLmpzJztcbmltcG9ydCB7IFJvdXRlck9wdGlvbnMgfSBmcm9tICcuL3JvdXRlci1vcHRpb25zLmpzJztcbmltcG9ydCB7IE9wZW5Qcm9taXNlIH0gZnJvbSAnLi9vcGVuLXByb21pc2UuanMnO1xuLy8gZXhwb3J0IHR5cGUgU3dhcFN0cmF0ZWd5ID0gJ2FkZC1maXJzdC1zZXF1ZW50aWFsJyB8ICdhZGQtZmlyc3QtcGFyYWxsZWwnIHwgJ3JlbW92ZS1maXJzdC1zZXF1ZW50aWFsJyB8ICdyZW1vdmUtZmlyc3QtcGFyYWxsZWwnO1xuLy8gZXhwb3J0IHR5cGUgUm91dGluZ0hvb2tJbnRlZ3JhdGlvbiA9ICdpbnRlZ3JhdGVkJyB8ICdzZXBhcmF0ZSc7XG4vLyAvKipcbi8vICAqIFB1YmxpYyBBUElcbi8vICAqL1xuLy8gZXhwb3J0IGludGVyZmFjZSBJUm91dGVyQWN0aXZhdGVPcHRpb25zIGV4dGVuZHMgT21pdDxQYXJ0aWFsPElSb3V0ZXJPcHRpb25zPiwgJ3RpdGxlJz4ge1xuLy8gICB0aXRsZT86IHN0cmluZyB8IElSb3V0ZXJUaXRsZTtcbi8vIH1cbi8vIC8qKlxuLy8gICogUHVibGljIEFQSVxuLy8gICovXG4vLyBleHBvcnQgaW50ZXJmYWNlIElSb3V0ZXJPcHRpb25zIGV4dGVuZHMgSU5hdmlnYXRvck9wdGlvbnMge1xuLy8gICBzZXBhcmF0b3JzPzogSVJvdXRlU2VwYXJhdG9ycztcbi8vICAgdXNlVXJsRnJhZ21lbnRIYXNoOiBib29sZWFuO1xuLy8gICB1c2VIcmVmOiBib29sZWFuO1xuLy8gICBzdGF0ZWZ1bEhpc3RvcnlMZW5ndGg6IG51bWJlcjtcbi8vICAgdXNlRGlyZWN0Um91dGVzOiBib29sZWFuO1xuLy8gICB1c2VDb25maWd1cmVkUm91dGVzOiBib29sZWFuO1xuLy8gICBhZGRpdGl2ZUluc3RydWN0aW9uRGVmYXVsdDogYm9vbGVhbjtcbi8vICAgdGl0bGU6IElUaXRsZUNvbmZpZ3VyYXRpb247XG4vLyAgIGhvb2tzPzogSUhvb2tEZWZpbml0aW9uW107XG4vLyAgIHJlcG9ydENhbGxiYWNrPyhpbnN0cnVjdGlvbjogTmF2aWdhdGlvbik6IHZvaWQ7XG4vLyAgIG5hdmlnYXRpb25TeW5jU3RhdGVzOiBOYXZpZ2F0aW9uU3RhdGVbXTtcbi8vICAgc3dhcFN0cmF0ZWd5OiBTd2FwU3RyYXRlZ3k7XG4vLyAgIHJvdXRpbmdIb29rSW50ZWdyYXRpb246IFJvdXRpbmdIb29rSW50ZWdyYXRpb247XG4vLyB9XG4vLyAvKipcbi8vICAqIFB1YmxpYyBBUElcbi8vICAqL1xuLy8gZXhwb3J0IGludGVyZmFjZSBJUm91dGVyVGl0bGUgZXh0ZW5kcyBQYXJ0aWFsPElUaXRsZUNvbmZpZ3VyYXRpb24+IHsgfVxuLy8gLyoqXG4vLyAgKiBQdWJsaWMgQVBJXG4vLyAgKi9cbi8vIGV4cG9ydCBpbnRlcmZhY2UgSVRpdGxlQ29uZmlndXJhdGlvbiB7XG4vLyAgIGFwcFRpdGxlOiBzdHJpbmc7XG4vLyAgIGFwcFRpdGxlU2VwYXJhdG9yOiBzdHJpbmc7XG4vLyAgIGNvbXBvbmVudFRpdGxlT3JkZXI6ICd0b3AtZG93bicgfCAnYm90dG9tLXVwJztcbi8vICAgY29tcG9uZW50VGl0bGVTZXBhcmF0b3I6IHN0cmluZztcbi8vICAgdXNlQ29tcG9uZW50TmFtZXM6IGJvb2xlYW47XG4vLyAgIGNvbXBvbmVudFByZWZpeDogc3RyaW5nO1xuLy8gICB0cmFuc2Zvcm1UaXRsZT86ICh0aXRsZTogc3RyaW5nLCBpbnN0cnVjdGlvbjogc3RyaW5nIHwgVmlld3BvcnRJbnN0cnVjdGlvbiB8IEZvdW5kUm91dGUpID0+IHN0cmluZztcbi8vIH1cbi8qKlxuICogUHVibGljIEFQSVxuICovXG5leHBvcnQgY29uc3QgSVJvdXRlciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVJvdXRlcicsIHggPT4geC5zaW5nbGV0b24oUm91dGVyKSk7XG5jbGFzcyBDbG9zZXN0Vmlld3BvcnRDdXN0b21FbGVtZW50IHtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIENsb3Nlc3RTY29wZSB7XG59XG5leHBvcnQgY2xhc3MgUm91dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBjb250YWluZXIsIFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIG5hdmlnYXRvciwgbmF2aWdhdGlvbiwgXG4gICAgLyoqXG4gICAgICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICovXG4gICAgbGlua0hhbmRsZXIsIFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5LiBQcm9iYWJseS5cbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvblJlc29sdmVyLCBcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseS4gUHJvYmFibHkuXG4gICAgICovXG4gICAgaG9va01hbmFnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMubmF2aWdhdG9yID0gbmF2aWdhdG9yO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLmxpbmtIYW5kbGVyID0gbGlua0hhbmRsZXI7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlciA9IGluc3RydWN0aW9uUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuaG9va01hbmFnZXIgPSBob29rTWFuYWdlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5yb290U2NvcGUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgaG9va01hbmFnZXI6IEhvb2tNYW5hZ2VyO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFB1YmxpYyBBUElcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGVuZGVkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIC8vIC8qKlxuICAgICAgICAvLyAgKiBAaW50ZXJuYWxcbiAgICAgICAgLy8gICovXG4gICAgICAgIC8vIHB1YmxpYyBvcHRpb25zOiBJUm91dGVyT3B0aW9ucyA9IHtcbiAgICAgICAgLy8gICB1c2VVcmxGcmFnbWVudEhhc2g6IHRydWUsXG4gICAgICAgIC8vICAgdXNlSHJlZjogdHJ1ZSxcbiAgICAgICAgLy8gICBzdGF0ZWZ1bEhpc3RvcnlMZW5ndGg6IDAsXG4gICAgICAgIC8vICAgdXNlRGlyZWN0Um91dGVzOiB0cnVlLFxuICAgICAgICAvLyAgIHVzZUNvbmZpZ3VyZWRSb3V0ZXM6IHRydWUsXG4gICAgICAgIC8vICAgYWRkaXRpdmVJbnN0cnVjdGlvbkRlZmF1bHQ6IHRydWUsXG4gICAgICAgIC8vICAgdGl0bGU6IHtcbiAgICAgICAgLy8gICAgIGFwcFRpdGxlOiBcIiR7Y29tcG9uZW50VGl0bGVzfVxcJHthcHBUaXRsZVNlcGFyYXRvcn1BdXJlbGlhXCIsXG4gICAgICAgIC8vICAgICBhcHBUaXRsZVNlcGFyYXRvcjogJyB8ICcsXG4gICAgICAgIC8vICAgICBjb21wb25lbnRUaXRsZU9yZGVyOiAndG9wLWRvd24nLFxuICAgICAgICAvLyAgICAgY29tcG9uZW50VGl0bGVTZXBhcmF0b3I6ICcgPiAnLFxuICAgICAgICAvLyAgICAgdXNlQ29tcG9uZW50TmFtZXM6IHRydWUsXG4gICAgICAgIC8vICAgICBjb21wb25lbnRQcmVmaXg6ICdhcHAtJyxcbiAgICAgICAgLy8gICB9LFxuICAgICAgICAvLyAgIHN3YXBTdHJhdGVneTogJ2FkZC1maXJzdC1zZXF1ZW50aWFsJyxcbiAgICAgICAgLy8gICByb3V0aW5nSG9va0ludGVncmF0aW9uOiAnaW50ZWdyYXRlZCcsXG4gICAgICAgIC8vICAgbmF2aWdhdGlvblN5bmNTdGF0ZXM6IFsnZ3VhcmRlZFVubG9hZCcsICdzd2FwcGVkJywgJ2NvbXBsZXRlZCddLFxuICAgICAgICAvLyB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdOYXZpZ2F0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2FkZWRGaXJzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3ROYXZpZ2F0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFsZUNoZWNrcyA9IHt9O1xuICAgICAgICAvLyBUT0RPOiBTd2l0Y2ggdGhpcyB0byB1c2UgKHByb2JhYmx5KSBhbiBldmVudCBpbnN0ZWFkXG4gICAgICAgIHRoaXMuc3RhcnRlcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogdXNlIEBib3VuZCBhbmQgaW1wcm92ZSBuYW1lIChlc2xpbnQtZGlzYWJsZSBpcyB0ZW1wKVxuICAgICAgICB0aGlzLmxpbmtDYWxsYmFjayA9IChpbmZvKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSBpbmZvLmluc3RydWN0aW9uIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ3N0cmluZycgJiYgaW5zdHJ1Y3Rpb24uc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAvLyAnIycgPT09ICcvJyA9PT0gJyMvJ1xuICAgICAgICAgICAgICAgIGlmICghaW5zdHJ1Y3Rpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gXCIvXCIgKyBpbnN0cnVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGRzIHRvIE5hdmlnYXRvcidzIFF1ZXVlLCB3aGljaCBtYWtlcyBzdXJlIGl0J3Mgc2VyaWFsXG4gICAgICAgICAgICB0aGlzLmxvYWQoaW5zdHJ1Y3Rpb24sIHsgb3JpZ2luOiBpbmZvLmFuY2hvciB9KS5jYXRjaChlcnJvciA9PiB7IHRocm93IGVycm9yOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogdXNlIEBib3VuZCBhbmQgaW1wcm92ZSBuYW1lIChlc2xpbnQtZGlzYWJsZSBpcyB0ZW1wKVxuICAgICAgICB0aGlzLm5hdmlnYXRvckNhbGxiYWNrID0gKGluc3RydWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAvLyBJbnN0cnVjdGlvbnMgZXh0cmFjdGVkIGZyb20gcXVldWUsIG9uZSBhdCBhIHRpbWVcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05hdmlnYXRpb25zKGluc3RydWN0aW9uKS5jYXRjaChlcnJvciA9PiB7IHRocm93IGVycm9yOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogdXNlIEBib3VuZCBhbmQgaW1wcm92ZSBuYW1lIChlc2xpbnQtZGlzYWJsZSBpcyB0ZW1wKVxuICAgICAgICB0aGlzLm5hdmlnYXRvclNlcmlhbGl6ZUNhbGxiYWNrID0gYXN5bmMgKGVudHJ5LCBwcmVzZXJ2ZWRFbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXhjbHVkZUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlc2VydmVkRW50cnkgb2YgcHJlc2VydmVkRW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlc2VydmVkRW50cnkuaW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDb21wb25lbnRzLnB1c2goLi4udGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmZsYXR0ZW5WaWV3cG9ydEluc3RydWN0aW9ucyhwcmVzZXJ2ZWRFbnRyeS5pbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udmlld3BvcnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLmNvbXBvbmVudEluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlc2VydmVkRW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDb21wb25lbnRzLnB1c2goLi4udGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmZsYXR0ZW5WaWV3cG9ydEluc3RydWN0aW9ucyhwcmVzZXJ2ZWRFbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udmlld3BvcnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLmNvbXBvbmVudEluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhjbHVkZUNvbXBvbmVudHMgPSBleGNsdWRlQ29tcG9uZW50cy5maWx0ZXIoKGNvbXBvbmVudCwgaSwgYXJyKSA9PiBjb21wb25lbnQgIT09IG51bGwgJiYgYXJyLmluZGV4T2YoY29tcG9uZW50KSA9PT0gaSk7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0geyAuLi5lbnRyeSB9O1xuICAgICAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWQuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gJiYgdHlwZW9mIHNlcmlhbGl6ZWQuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goLi4uc2VyaWFsaXplZC5mdWxsU3RhdGVJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5mdWxsU3RhdGVJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9ucyhzZXJpYWxpemVkLmZ1bGxTdGF0ZUluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkLmluc3RydWN0aW9uICYmIHR5cGVvZiBzZXJpYWxpemVkLmluc3RydWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKC4uLnNlcmlhbGl6ZWQuaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQuaW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMoc2VyaWFsaXplZC5pbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuZmlsdGVyKChpbnN0cnVjdGlvbiwgaSwgYXJyKSA9PiBpbnN0cnVjdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICYmIGluc3RydWN0aW9uLmNvbXBvbmVudEluc3RhbmNlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgJiYgYXJyLmluZGV4T2YoaW5zdHJ1Y3Rpb24pID09PSBpKTtcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlEb25lID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZnJlZUNvbXBvbmVudHMoaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVDb21wb25lbnRzLCBhbHJlYWR5RG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogdXNlIEBib3VuZCBhbmQgaW1wcm92ZSBuYW1lIChlc2xpbnQtZGlzYWJsZSBpcyB0ZW1wKVxuICAgICAgICB0aGlzLmJyb3dzZXJOYXZpZ2F0b3JDYWxsYmFjayA9IChicm93c2VyTmF2aWdhdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IG5ldyBOYXZpZ2F0aW9uKGJyb3dzZXJOYXZpZ2F0aW9uRXZlbnQuc3RhdGU/LmN1cnJlbnRFbnRyeSk7XG4gICAgICAgICAgICBlbnRyeS5pbnN0cnVjdGlvbiA9IGJyb3dzZXJOYXZpZ2F0aW9uRXZlbnQuaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICBlbnRyeS5mcm9tQnJvd3NlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRvci5uYXZpZ2F0ZShlbnRyeSkuY2F0Y2goZXJyb3IgPT4geyB0aHJvdyBlcnJvcjsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE86IHVzZSBAYm91bmQgYW5kIGltcHJvdmUgbmFtZSAoZXNsaW50LWRpc2FibGUgaXMgdGVtcClcbiAgICAgICAgdGhpcy5wcm9jZXNzTmF2aWdhdGlvbnMgPSBhc3luYyAocUluc3RydWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHRoaXMucHJvY2Vzc2luZ05hdmlnYXRpb24gPSBxSW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncGVuZGluZ0Nvbm5lY3RzJywgWy4uLnRoaXMucGVuZGluZ0Nvbm5lY3RzXSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0cy5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXBvcnRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZXBvcnRDYWxsYmFjayhpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsZXQge1xuICAgICAgICAgICAgLy8gICBmdWxsU3RhdGVJbnN0cnVjdGlvbixcbiAgICAgICAgICAgIC8vICAgaW5zdHJ1Y3Rpb25OYXZpZ2F0aW9uLFxuICAgICAgICAgICAgLy8gICBjb25maWd1cmVkUm91dGUsXG4gICAgICAgICAgICAvLyAgIGNvbmZpZ3VyZWRSb3V0ZVBhdGgsXG4gICAgICAgICAgICAvLyAgIGluc3RydWN0aW9ucyxcbiAgICAgICAgICAgIC8vICAgY2xlYXJTY29wZU93bmVycyxcbiAgICAgICAgICAgIC8vICAgY2xlYXJWaWV3cG9ydFNjb3BlcyxcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdG9yID0gTmF2aWdhdGlvbkNvb3JkaW5hdG9yLmNyZWF0ZSh0aGlzLCBpbnN0cnVjdGlvbiwgeyBzeW5jU3RhdGVzOiB0aGlzLm9wdGlvbnMubmF2aWdhdGlvblN5bmNTdGF0ZXMgfSk7XG4gICAgICAgICAgICAvLyBjb25zdCBzdGVwcyA9IFtcbiAgICAgICAgICAgIC8vICAgKCkgPT4gY29vcmRpbmF0b3Iuc3luY1N0YXRlKCdsb2FkZWQnKSxcbiAgICAgICAgICAgIC8vICAgKCkgPT4geyBjb25zb2xlLmxvZygnU3luY1N0YXRlIGxvYWRlZCByZXNvbHZlZCEnLCBzdGVwcyk7IH0sXG4gICAgICAgICAgICAvLyAgICgpID0+IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgnc3dhcHBlZCcpLFxuICAgICAgICAgICAgLy8gICAoKSA9PiB7IGNvbnNvbGUubG9nKCdTeW5jU3RhdGUgc3dhcHBlZCByZXNvbHZlZCEnLCBzdGVwcyk7IH0sXG4gICAgICAgICAgICAvLyAgICgpID0+IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgnbGVmdCcpLFxuICAgICAgICAgICAgLy8gICAoKSA9PiB7IGNvbnNvbGUubG9nKCdTeW5jU3RhdGUgbGVmdCByZXNvbHZlZCEnLCBzdGVwcyk7IH0sXG4gICAgICAgICAgICAvLyBdO1xuICAgICAgICAgICAgLy8gcnVuKC4uLnN0ZXBzKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGxvYWRlZFByb21pc2UgPSA7XG4gICAgICAgICAgICAvLyBpZiAobG9hZGVkUHJvbWlzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAvLyAgIGxvYWRlZFByb21pc2UudGhlbigodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdTeW5jU3RhdGUgbG9hZGVkIHJlc29sdmVkIScsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vICAgfSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnJvb3RTY29wZT8uc2NvcGUudG9TdHJpbmcodHJ1ZSkpO1xuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkSW5zdHJ1Y3Rpb24gPSB0eXBlb2YgaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnICYmICFpbnN0cnVjdGlvbi51c2VGdWxsU3RhdGVJbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5ob29rTWFuYWdlci5pbnZva2VUcmFuc2Zvcm1Gcm9tVXJsKGluc3RydWN0aW9uLmluc3RydWN0aW9uLCB0aGlzLnByb2Nlc3NpbmdOYXZpZ2F0aW9uKVxuICAgICAgICAgICAgICAgIDogaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXZpZXcgdGhpc1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkSW5zdHJ1Y3Rpb24gPT09ICcvJykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkSW5zdHJ1Y3Rpb24gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RydWN0aW9uLnNjb3BlID0gaW5zdHJ1Y3Rpb24uc2NvcGUgPz8gdGhpcy5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgICAgICBsZXQgY29uZmlndXJlZFJvdXRlID0gaW5zdHJ1Y3Rpb24uc2NvcGUuZmluZEluc3RydWN0aW9ucyh0cmFuc2Zvcm1lZEluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIGxldCBjb25maWd1cmVkUm91dGVQYXRoID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGxldCBjb25maWd1cmVkUm91dGUgPSBhd2FpdCB0aGlzLmZpbmRJbnN0cnVjdGlvbnMoXG4gICAgICAgICAgICAvLyAgIHRoaXMucm9vdFNjb3BlIS5zY29wZSxcbiAgICAgICAgICAgIC8vICAgaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICAvLyAgIGluc3RydWN0aW9uLnNjb3BlID8/IHRoaXMucm9vdFNjb3BlIS5zY29wZSxcbiAgICAgICAgICAgIC8vICAgIWluc3RydWN0aW9uLnVzZUZ1bGxTdGF0ZUluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbi5sZW5ndGggPiAwICYmICFjb25maWd1cmVkUm91dGUuZm91bmRDb25maWd1cmF0aW9uICYmICFjb25maWd1cmVkUm91dGUuZm91bmRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBEbyBzb21ldGhpbmcgaGVyZSFcbiAgICAgICAgICAgICAgICB0aGlzLnVua25vd25Sb3V0ZShjb25maWd1cmVkUm91dGUucmVtYWluaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnN0cnVjdGlvbnMgPSBjb25maWd1cmVkUm91dGUuaW5zdHJ1Y3Rpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyZWRSb3V0ZS5mb3VuZENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5wYXRoID0gaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24uc3RhcnRzV2l0aCgnLycpXG4gICAgICAgICAgICAgICAgICAgID8gaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24uc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgOiBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkUm91dGVQYXRoID0gKGNvbmZpZ3VyZWRSb3V0ZVBhdGggPz8gJycpICsgY29uZmlndXJlZFJvdXRlLm1hdGNoaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdFNjb3BlLnBhdGggPSBjb25maWd1cmVkUm91dGVQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogVXNlZCB0byBoYXZlIGFuIGVhcmx5IGV4aXQgaWYgbm8gaW5zdHJ1Y3Rpb25zLiBSZXN0b3JlIGl0P1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWRkaXRpdmVJbnN0cnVjdGlvbkRlZmF1bHQgJiZcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuaXNBZGRBbGxWaWV3cG9ydHNJbnN0cnVjdGlvbihpbnN0cnVjdGlvbnNbMF0pICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0NsZWFyQWxsVmlld3BvcnRzSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25zWzBdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RyID0gdGhpcy5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgIGluc3RyLnNjb3BlID0gaW5zdHJ1Y3Rpb25zWzBdLnNjb3BlO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy51bnNoaWZ0KGluc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsZWFyU2NvcGVPd25lcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjbGVhclZpZXdwb3J0U2NvcGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsZWFySW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zLmZpbHRlcihpbnN0ciA9PiB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuaXNDbGVhckFsbFZpZXdwb3J0c0luc3RydWN0aW9uKGluc3RyKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29wZSA9IGNsZWFySW5zdHJ1Y3Rpb24uc2NvcGUgfHwgdGhpcy5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVzID0gc2NvcGUuYWxsU2NvcGVzKCkuZmlsdGVyKHNjb3BlID0+ICFzY29wZS5vd25lci5pc0VtcHR5KS5tYXAoc2NvcGUgPT4gc2NvcGUub3duZXIpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRlbGwgRnJlZCBhYm91dCB0aGUgbmVlZCBmb3IgcmV2ZXJzZVxuICAgICAgICAgICAgICAgIC8vIHNjb3Blcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgY2xlYXJTY29wZU93bmVycy5wdXNoKC4uLnNjb3Blcyk7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLnZpZXdwb3J0U2NvcGUgIT09IG51bGwgJiYgc2NvcGUudmlld3BvcnRTY29wZSAhPT0gdGhpcy5yb290U2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJWaWV3cG9ydFNjb3Blcy5wdXNoKHNjb3BlLnZpZXdwb3J0U2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5maWx0ZXIoaW5zdHIgPT4gIXRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0NsZWFyQWxsVmlld3BvcnRzSW5zdHJ1Y3Rpb24oaW5zdHIpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkSW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zLmZpbHRlcihpbnN0ciA9PiB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuaXNBZGRBbGxWaWV3cG9ydHNJbnN0cnVjdGlvbihpbnN0cikpKSB7XG4gICAgICAgICAgICAgICAgYWRkSW5zdHJ1Y3Rpb24uc2V0Vmlld3BvcnQoKGFkZEluc3RydWN0aW9uLnNjb3BlIHx8IHRoaXMucm9vdFNjb3BlLnNjb3BlKS52aWV3cG9ydFNjb3BlLm5hbWUpO1xuICAgICAgICAgICAgICAgIGFkZEluc3RydWN0aW9uLnNjb3BlID0gYWRkSW5zdHJ1Y3Rpb24uc2NvcGUub3duaW5nU2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RyIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGluc3RyLnRvcEluc3RydWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTY29wZU93bmVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeUZvdW5kSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgICAvLyBUT0RPOiBUYWtlIGNhcmUgb2YgY2FuY2VsbGF0aW9ucyBkb3duIGluIHN1YnNldHMvaXRlcmF0aW9uc1xuICAgICAgICAgICAgbGV0IHsgZm91bmQ6IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLCByZW1haW5pbmc6IHJlbWFpbmluZ0luc3RydWN0aW9ucyB9ID0gdGhpcy5maW5kVmlld3BvcnRzKGluc3RydWN0aW9ucywgYWxyZWFkeUZvdW5kSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgIGxldCBndWFyZCA9IDEwMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoIWd1YXJkLS0pIHsgLy8gR3VhcmQgYWdhaW5zdCBlbmRsZXNzIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKHJlbWFpbmluZ0luc3RydWN0aW9ucy5sZW5ndGggKyAnIHJlbWFpbmluZyBpbnN0cnVjdGlvbnMgYWZ0ZXIgMTAwIGl0ZXJhdGlvbnM7IHRoZXJlIGlzIGxpa2VseSBhbiBpbmZpbml0ZSBsb29wLicpO1xuICAgICAgICAgICAgICAgICAgICBlcnJbJ3JlbWFpbmluZ0luc3RydWN0aW9ucyddID0gcmVtYWluaW5nSW5zdHJ1Y3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVtYWluaW5nSW5zdHJ1Y3Rpb25zJywgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkU2NvcGVPd25lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZpZXcgd2hldGhlciB0aGlzIGF3YWl0IHBvc2VzIGEgcHJvYmxlbSAoaXQncyBjdXJyZW50bHkgbmVjZXNzYXJ5IGZvciBuZXcgdmlld3BvcnRzIHRvIGxvYWQpXG4gICAgICAgICAgICAgICAgY29uc3QgaG9va2VkID0gYXdhaXQgdGhpcy5ob29rTWFuYWdlci5pbnZva2VCZWZvcmVOYXZpZ2F0aW9uKHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGhvb2tlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0b3IuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuY2FuY2VsTmF2aWdhdGlvbihbLi4uY2hhbmdlZFNjb3BlT3duZXJzLCAuLi51cGRhdGVkU2NvcGVPd25lcnNdLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucyA9IGhvb2tlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2aWV3cG9ydEluc3RydWN0aW9uIG9mIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlT3duZXIgPSB2aWV3cG9ydEluc3RydWN0aW9uLm93bmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVPd25lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVPd25lci5wYXRoID0gY29uZmlndXJlZFJvdXRlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHNjb3BlT3duZXIuc2V0TmV4dENvbnRlbnQodmlld3BvcnRJbnN0cnVjdGlvbiwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3NraXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFNjb3BlT3duZXJzLnB1c2goc2NvcGVPd25lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0b3IuYWRkRW50aXR5KHNjb3BlT3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9udENsZWFyID0gW3Njb3BlT3duZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3N3YXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9udENsZWFyLnB1c2goLi4uc2NvcGVPd25lci5zY29wZS5hbGxTY29wZXModHJ1ZSwgdHJ1ZSkubWFwKHNjb3BlID0+IHNjb3BlLm93bmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVJlbW92ZShjbGVhclNjb3BlT3duZXJzLCB2YWx1ZSA9PiBkb250Q2xlYXIuaW5jbHVkZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5UmVtb3ZlKGNsZWFyU2NvcGVPd25lcnMsIHZhbHVlID0+IHZhbHVlID09PSBzY29wZU93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmlzQ2xlYXJWaWV3cG9ydEluc3RydWN0aW9uKHZpZXdwb3J0SW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdmlld3BvcnRJbnN0cnVjdGlvbi5zY29wZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHZpZXdwb3J0SW5zdHJ1Y3Rpb24uc2NvcGUucGFyZW50ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdmlld3BvcnRJbnN0cnVjdGlvbi5zY29wZS5wYXJlbnQuaXNWaWV3cG9ydFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlSZW1vdmUoY2xlYXJWaWV3cG9ydFNjb3BlcywgdmFsdWUgPT4gdmFsdWUgPT09IHZpZXdwb3J0SW5zdHJ1Y3Rpb24uc2NvcGUucGFyZW50LnZpZXdwb3J0U2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdG9yLmZpbmFsRW50aXR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdG9yLnJ1bigpO1xuICAgICAgICAgICAgICAgIC8vIGF3YWl0IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgncm91dGVkJyk7XG4gICAgICAgICAgICAgICAgLy8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICAvLyBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGNoYW5nZWRTY29wZU93bmVycy5tYXAoKHNjb3BlT3duZXIpID0+IHNjb3BlT3duZXIuY2FuVW5sb2FkKCkpKTtcbiAgICAgICAgICAgICAgICAvLyBpZiAocmVzdWx0cy5zb21lKHJlc3VsdCA9PiByZXN1bHQgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vICAgcmV0dXJuIHRoaXMuY2FuY2VsTmF2aWdhdGlvbihbLi4uY2hhbmdlZFNjb3BlT3duZXJzLCAuLi51cGRhdGVkU2NvcGVPd25lcnNdLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGNoYW5nZWRTY29wZU93bmVycy5tYXAoYXN5bmMgKHNjb3BlT3duZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGNhbkxvYWQgPSBhd2FpdCBzY29wZU93bmVyLmNhbkxvYWQoKTtcbiAgICAgICAgICAgICAgICAvLyAgIGlmICh0eXBlb2YgY2FuTG9hZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChjYW5Mb2FkKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUoc2NvcGVPd25lciwgJ2xvYWRlZCcpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgIHJldHVybiBzY29wZU93bmVyLmxvYWQoKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAvLyAgIGF3YWl0IHRoaXMubG9hZChjYW5Mb2FkLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAvLyAgIGF3YWl0IHNjb3BlT3duZXIuYWJvcnRDb250ZW50Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgLy8gICAvLyBUT0RPOiBBYm9ydCBjb250ZW50IGNoYW5nZSBpbiB0aGUgdmlld3BvcnRzXG4gICAgICAgICAgICAgICAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB9KSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHJlc3VsdHMuc29tZShyZXN1bHQgPT4gcmVzdWx0ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyAgIHJldHVybiB0aGlzLmNhbmNlbE5hdmlnYXRpb24oWy4uLmNoYW5nZWRTY29wZU93bmVycywgLi4udXBkYXRlZFNjb3BlT3duZXJzXSwgcUluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2aWV3cG9ydCBvZiBjaGFuZ2VkU2NvcGVPd25lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWRTY29wZU93bmVycy5ldmVyeShzY29wZU93bmVyID0+IHNjb3BlT3duZXIgIT09IHZpZXdwb3J0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFNjb3BlT3duZXJzLnB1c2godmlld3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpeCBtdWx0aSBsZXZlbCByZWN1cnNpdmVuZXNzIVxuICAgICAgICAgICAgICAgIGFscmVhZHlGb3VuZEluc3RydWN0aW9ucy5wdXNoKC4uLnZpZXdwb3J0SW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgICAgICAoeyBmb3VuZDogdmlld3BvcnRJbnN0cnVjdGlvbnMsIHJlbWFpbmluZzogcmVtYWluaW5nSW5zdHJ1Y3Rpb25zIH0gPSB0aGlzLmZpbmRWaWV3cG9ydHMocmVtYWluaW5nSW5zdHJ1Y3Rpb25zLCBhbHJlYWR5Rm91bmRJbnN0cnVjdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBjb25maWd1cmVkIGNoaWxkIHJvdXRlcyAob25jZSB3ZSd2ZSBsb2FkZWQgZXZlcnl0aGluZyBzbyBmYXI/KVxuICAgICAgICAgICAgICAgIGlmIChjb25maWd1cmVkUm91dGUuaGFzUmVtYWluaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdJbnN0cnVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maWd1cmVkID0gbmV3IEZvdW5kUm91dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVTY29wZU93bmVycyA9IGFscmVhZHlGb3VuZEluc3RydWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpbnN0ciA9PiBpbnN0ci5vd25lciAhPT0gbnVsbCAmJiBpbnN0ci5vd25lci5wYXRoID09PSBjb25maWd1cmVkUm91dGVQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChpbnN0ciA9PiBpbnN0ci5vd25lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbHVlLCBpbmRleCwgYXJyKSA9PiBhcnIuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhd2FpdCBuZXcgdmlld3BvcnRzIGJlaW5nIGJvdW5kXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdBd2FpdGluZyBzd2FwcGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb29yZGluYXRvci5zeW5jU3RhdGUoJ3N3YXBwZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdBd2FpdGVkIHN3YXBwZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwZW5kaW5nQ29ubmVjdHMgYmVmb3JlIGZpbmQgbmV3JywgWy4uLnRoaXMucGVuZGluZ0Nvbm5lY3RzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBwZW5kaW5nID0gWy4uLnRoaXMucGVuZGluZ0Nvbm5lY3RzLnZhbHVlcygpXS5maWx0ZXIoY29ubmVjdCA9PiBjb25uZWN0LmlzUGVuZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAocGVuZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdCZWdpbm5pbmcgYXdhaXQgZm9yICcsIHBlbmRpbmcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYXdhaXQgUHJvbWlzZS5hbGwocGVuZGluZy5tYXAoY29ubmVjdCA9PiBjb25uZWN0LnByb21pc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ0F3YWl0IGRvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG93bmVyIG9mIHJvdXRlU2NvcGVPd25lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWQgPSBvd25lci5zY29wZS5maW5kSW5zdHJ1Y3Rpb25zKGNvbmZpZ3VyZWRSb3V0ZS5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlndXJlZCA9IGF3YWl0IHRoaXMuZmluZEluc3RydWN0aW9ucyhvd25lci5zY29wZSwgY29uZmlndXJlZFJvdXRlLnJlbWFpbmluZywgb3duZXIuc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyZWQuZm91bmRDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyZWQuZm91bmRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRSb3V0ZSA9IGNvbmZpZ3VyZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmVkUm91dGVQYXRoID0gKGNvbmZpZ3VyZWRSb3V0ZVBhdGggPz8gJycpICsgXCIvXCIgKyBjb25maWd1cmVkUm91dGUubWF0Y2hpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBEbyBzb21ldGhpbmcgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5rbm93blJvdXRlKGNvbmZpZ3VyZWQucmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEluc3RydWN0aW9ucyhjb25maWd1cmVkLmluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERvbid0IHVzZSBkZWZhdWx0cyB3aGVuIGl0J3MgYSBmdWxsIHN0YXRlIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24udXNlRnVsbFN0YXRlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZEluc3RydWN0aW9ucyA9IHRoaXMuYXBwZW5kZWRJbnN0cnVjdGlvbnMuZmlsdGVyKGluc3RydWN0aW9uID0+ICFpbnN0cnVjdGlvbi5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBub24tZGVmYXVsdHMgZmlyc3RcbiAgICAgICAgICAgICAgICBsZXQgYXBwZW5kZWRJbnN0cnVjdGlvbnMgPSB0aGlzLmFwcGVuZGVkSW5zdHJ1Y3Rpb25zLmZpbHRlcihpbnN0cnVjdGlvbiA9PiAhaW5zdHJ1Y3Rpb24uZGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZEluc3RydWN0aW9ucyA9IHRoaXMuYXBwZW5kZWRJbnN0cnVjdGlvbnMuZmlsdGVyKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChhcHBlbmRlZEluc3RydWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmFwcGVuZGVkSW5zdHJ1Y3Rpb25zLmZpbmRJbmRleChpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZGVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5hcHBlbmRlZEluc3RydWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChhcHBlbmRlZEluc3RydWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcGVuZGVkSW5zdHJ1Y3Rpb24gPSBhcHBlbmRlZEluc3RydWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0FscmVhZHlGb3VuZCA9IGFscmVhZHlGb3VuZEluc3RydWN0aW9ucy5zb21lKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLnNhbWVWaWV3cG9ydChhcHBlbmRlZEluc3RydWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRm91bmQgPSB2aWV3cG9ydEluc3RydWN0aW9ucy5maW5kKHZhbHVlID0+IHZhbHVlLnNhbWVWaWV3cG9ydChhcHBlbmRlZEluc3RydWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVtYWluaW5nID0gcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLmZpbmQodmFsdWUgPT4gdmFsdWUuc2FtZVZpZXdwb3J0KGFwcGVuZGVkSW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcGVuZGVkSW5zdHJ1Y3Rpb24uZGVmYXVsdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGV4aXN0aW5nQWxyZWFkeUZvdW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4aXN0aW5nRm91bmQgIT09IHZvaWQgMCAmJiAhZXhpc3RpbmdGb3VuZC5kZWZhdWx0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGlzdGluZ1JlbWFpbmluZyAhPT0gdm9pZCAwICYmICFleGlzdGluZ1JlbWFpbmluZy5kZWZhdWx0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0ZvdW5kICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5UmVtb3ZlKHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLCB2YWx1ZSA9PiB2YWx1ZSA9PT0gZXhpc3RpbmdGb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUmVtYWluaW5nICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5UmVtb3ZlKHJlbWFpbmluZ0luc3RydWN0aW9ucywgdmFsdWUgPT4gdmFsdWUgPT09IGV4aXN0aW5nUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwZW5kZWRJbnN0cnVjdGlvbi52aWV3cG9ydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucHVzaChhcHBlbmRlZEluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5wdXNoKGFwcGVuZGVkSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2aWV3cG9ydEluc3RydWN0aW9ucy5sZW5ndGggPT09IDAgJiYgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucyA9IGNsZWFyU2NvcGVPd25lcnMubWFwKG93bmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb24sIG93bmVyLmlzVmlld3BvcnQgPyBvd25lciA6IHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIuaXNWaWV3cG9ydFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24udmlld3BvcnRTY29wZSA9IG93bmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucHVzaCguLi5jbGVhclZpZXdwb3J0U2NvcGVzLm1hcCh2aWV3cG9ydFNjb3BlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RyID0gdGhpcy5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHIudmlld3BvcnRTY29wZSA9IHZpZXdwb3J0U2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHI7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJWaWV3cG9ydFNjb3BlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodmlld3BvcnRJbnN0cnVjdGlvbnMubGVuZ3RoID4gMCB8fCByZW1haW5pbmdJbnN0cnVjdGlvbnMubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBjb29yZGluYXRvci5maW5hbEVudGl0eSgpO1xuICAgICAgICAgICAgLy8gYXdhaXQgUHJvbWlzZS5hbGwodXBkYXRlZFNjb3BlT3duZXJzLm1hcCgodmFsdWUpID0+IHZhbHVlLmxvYWRDb250ZW50KCkpKTtcbiAgICAgICAgICAgIGF3YWl0IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgnY29tcGxldGVkJyk7XG4gICAgICAgICAgICBjb29yZGluYXRvci5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgLy8gdXBkYXRlZFNjb3BlT3duZXJzLmZvckVhY2goKHZpZXdwb3J0KSA9PiB7XG4gICAgICAgICAgICAvLyAgIHZpZXdwb3J0LmZpbmFsaXplQ29udGVudENoYW5nZSgpO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlcGxhY2VQYXRocyhpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAvLyB0aGlzLnVwZGF0ZU5hdigpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGhpc3RvcnkgZW50cnkgaWYgbm8gaGlzdG9yeSB2aWV3cG9ydHMgdXBkYXRlZFxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLm5hdmlnYXRpb24ubmV3ICYmICFpbnN0cnVjdGlvbi5uYXZpZ2F0aW9uLmZpcnN0ICYmICFpbnN0cnVjdGlvbi5yZXBlYXRpbmcgJiYgdXBkYXRlZFNjb3BlT3duZXJzLmV2ZXJ5KHZpZXdwb3J0ID0+IHZpZXdwb3J0Lm9wdGlvbnMubm9IaXN0b3J5KSkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnVudHJhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cGRhdGVkU2NvcGVPd25lcnMuZm9yRWFjaCgodmlld3BvcnQpID0+IHtcbiAgICAgICAgICAgIC8vICAgdmlld3BvcnQuZmluYWxpemVDb250ZW50Q2hhbmdlKCk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIHRoaXMubGFzdE5hdmlnYXRpb24gPSB0aGlzLnByb2Nlc3NpbmdOYXZpZ2F0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdE5hdmlnYXRpb24/LnJlcGVhdGluZyA/PyBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdE5hdmlnYXRpb24ucmVwZWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdOYXZpZ2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubmF2aWdhdG9yLmZpbmFsaXplKGluc3RydWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdGhpcy5ob29rTWFuYWdlciA9IG5ldyBIb29rTWFuYWdlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgZ2V0IGlzTmF2aWdhdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZ05hdmlnYXRpb24gIT09IG51bGw7XG4gICAgfVxuICAgIGdldCBpc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBzeW5jU3RhdGVzID0gdGhpcy5vcHRpb25zLm5hdmlnYXRpb25TeW5jU3RhdGVzO1xuICAgICAgICByZXR1cm4gc3luY1N0YXRlcy5pbmNsdWRlcygnZ3VhcmRlZExvYWQnKSB8fFxuICAgICAgICAgICAgc3luY1N0YXRlcy5pbmNsdWRlcygndW5sb2FkZWQnKSB8fFxuICAgICAgICAgICAgc3luY1N0YXRlcy5pbmNsdWRlcygnbG9hZGVkJykgfHxcbiAgICAgICAgICAgIHN5bmNTdGF0ZXMuaW5jbHVkZXMoJ2d1YXJkZWQnKSB8fFxuICAgICAgICAgICAgc3luY1N0YXRlcy5pbmNsdWRlcygncm91dGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBzdGF0ZWZ1bEhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RhdGVmdWxIaXN0b3J5TGVuZ3RoICE9PSB2b2lkIDAgJiYgdGhpcy5vcHRpb25zLnN0YXRlZnVsSGlzdG9yeUxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIGNvbnN0IHRpdGxlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgIC4uLih0eXBlb2Ygb3B0aW9ucy50aXRsZSA9PT0gJ3N0cmluZycgPyB7IGFwcFRpdGxlOiBvcHRpb25zLnRpdGxlIH0gOiBvcHRpb25zLnRpdGxlKSxcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy50aXRsZSA9IHRpdGxlT3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5zZXBhcmF0b3JzLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5zZXBhcmF0b3JzID8/IHt9LFxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnNlcGFyYXRvcnMgPSBzZXBhcmF0b3JPcHRpb25zO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG9va3MgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5hZGRIb29rcyh0aGlzLm9wdGlvbnMuaG9va3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5zdGFydCh7IHNlcGFyYXRvcnM6IHRoaXMub3B0aW9ucy5zZXBhcmF0b3JzIH0pO1xuICAgICAgICB0aGlzLm5hdmlnYXRvci5zdGFydCh0aGlzLCB7XG4gICAgICAgICAgICBjYWxsYmFjazogdGhpcy5uYXZpZ2F0b3JDYWxsYmFjayxcbiAgICAgICAgICAgIHN0b3JlOiB0aGlzLm5hdmlnYXRpb24sXG4gICAgICAgICAgICBzdGF0ZWZ1bEhpc3RvcnlMZW5ndGg6IHRoaXMub3B0aW9ucy5zdGF0ZWZ1bEhpc3RvcnlMZW5ndGgsXG4gICAgICAgICAgICBzZXJpYWxpemVDYWxsYmFjazogdGhpcy5zdGF0ZWZ1bEhpc3RvcnkgPyB0aGlzLm5hdmlnYXRvclNlcmlhbGl6ZUNhbGxiYWNrIDogdm9pZCAwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5saW5rSGFuZGxlci5zdGFydCh7IGNhbGxiYWNrOiB0aGlzLmxpbmtDYWxsYmFjaywgdXNlSHJlZjogdGhpcy5vcHRpb25zLnVzZUhyZWYgfSk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5zdGFydCh7XG4gICAgICAgICAgICBjYWxsYmFjazogdGhpcy5icm93c2VyTmF2aWdhdG9yQ2FsbGJhY2ssXG4gICAgICAgICAgICB1c2VVcmxGcmFnbWVudEhhc2g6IHRoaXMub3B0aW9ucy51c2VVcmxGcmFnbWVudEhhc2hcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5zdXJlUm9vdFNjb3BlKCk7XG4gICAgICAgIC8vIFRPRE86IFN3aXRjaCB0aGlzIHRvIHVzZSAocHJvYmFibHkpIGFuIGV2ZW50IGluc3RlYWRcbiAgICAgICAgZm9yIChjb25zdCBzdGFydGVyIG9mIHRoaXMuc3RhcnRlcnMpIHtcbiAgICAgICAgICAgIHN0YXJ0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgYXN5bmMgbG9hZFVybCgpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBuZXcgTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLm5hdmlnYXRpb24udmlld2VyU3RhdGUsXG4gICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgZnVsbFN0YXRlSW5zdHJ1Y3Rpb246ICcnLFxuICAgICAgICAgICAgICAgIHJlcGxhY2luZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmcm9tQnJvd3NlcjogZmFsc2UsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm5hdmlnYXRvci5uYXZpZ2F0ZShlbnRyeSk7XG4gICAgICAgIHRoaXMubG9hZGVkRmlyc3QgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlciBoYXMgbm90IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlua0hhbmRsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLm5hdmlnYXRvci5zdG9wKCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5zdG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZpbmRTY29wZShvcmlnaW4pIHtcbiAgICAgICAgLy8gdGhpcy5lbnN1cmVSb290U2NvcGUoKTtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gdm9pZCAwIHx8IG9yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdFNjb3BlLnNjb3BlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4gaW5zdGFuY2VvZiBTY29wZSB8fCBvcmlnaW4gaW5zdGFuY2VvZiBWaWV3cG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbi5zY29wZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDbG9zZXN0U2NvcGUob3JpZ2luKSB8fCB0aGlzLnJvb3RTY29wZS5zY29wZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZmluZFBhcmVudFNjb3BlKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxyZWFkeSAocHJlbWF0dXJlbHkpIHNldCBvbiB0aGlzIHZpZXcgbW9kZWwgc28gZ2V0IGl0IGZyb20gY29udGFpbmVyJ3MgcGFyZW50IGluc3RlYWRcbiAgICAgICAgaWYgKGNvbnRhaW5lci5oYXMoQ2xvc2VzdFNjb3BlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdFNjb3BlLnNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIuaGFzKENsb3Nlc3RTY29wZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIuZ2V0KENsb3Nlc3RTY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdFNjb3BlLnNjb3BlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIC0gR2V0IHZpZXdwb3J0IGJ5IG5hbWVcbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFZpZXdwb3J0cygpLmZpbmQodmlld3BvcnQgPT4gdmlld3BvcnQubmFtZSA9PT0gbmFtZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSSAobm90IHlldCBpbXBsZW1lbnRlZClcbiAgICAgKi9cbiAgICBhZGRWaWV3cG9ydCguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUEkgKG5vdCB5ZXQgaW1wbGVtZW50ZWQpXG4gICAgICovXG4gICAgZmluZFZpZXdwb3J0U2NvcGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIChub3QgeWV0IGltcGxlbWVudGVkKVxuICAgICAqL1xuICAgIGFkZFZpZXdwb3J0U2NvcGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBDYWxsZWQgZnJvbSB0aGUgdmlld3BvcnQgc2NvcGUgY3VzdG9tIGVsZW1lbnQgaW4gY3JlYXRlZCgpXG4gICAgICovXG4gICAgc2V0Q2xvc2VzdFNjb3BlKHZpZXdNb2RlbE9yQ29udGFpbmVyLCBzY29wZSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcih2aWV3TW9kZWxPckNvbnRhaW5lcik7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShDbG9zZXN0U2NvcGUsIHNjb3BlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRDbG9zZXN0U2NvcGUodmlld01vZGVsT3JFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICdyZXNvdXJjZVJlc29sdmVycycgaW4gdmlld01vZGVsT3JFbGVtZW50XG4gICAgICAgICAgICA/IHZpZXdNb2RlbE9yRWxlbWVudFxuICAgICAgICAgICAgOiB0aGlzLmdldENsb3Nlc3RDb250YWluZXIodmlld01vZGVsT3JFbGVtZW50KTtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzKENsb3Nlc3RTY29wZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXIuZ2V0KENsb3Nlc3RTY29wZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5zZXRDbG9zZXN0U2NvcGUodmlld01vZGVsT3JDb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIodmlld01vZGVsT3JDb250YWluZXIpO1xuICAgICAgICAvLyBUT0RPOiBHZXQgYW4gJ3VucmVnaXN0ZXInIG9uIGNvbnRhaW5lclxuICAgICAgICBjb250YWluZXIucmVzb2x2ZXJzLmRlbGV0ZShDbG9zZXN0U2NvcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBDYWxsZWQgZnJvbSB0aGUgdmlld3BvcnQgY3VzdG9tIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25uZWN0Vmlld3BvcnQodmlld3BvcnQsIGNvbm5lY3RlZENFLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFNjb3BlID0gdGhpcy5maW5kUGFyZW50U2NvcGUoY29ubmVjdGVkQ0UuY29udGFpbmVyKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZpZXdwb3J0IHBhcmVudFNjb3BlJywgcGFyZW50U2NvcGUudG9TdHJpbmcoKSwgKGNvbm5lY3RlZENFIGFzIGFueSkuZ2V0Q2xvc2VzdEN1c3RvbUVsZW1lbnQoKSk7XG4gICAgICAgIGNvbnN0IHBhcmVudFZpZXdwb3J0U2NvcGUgPSAoY29ubmVjdGVkQ0UucGFyZW50Vmlld3BvcnQ/LnZpZXdwb3J0ID8/IHRoaXMucm9vdFNjb3BlKS5zY29wZTtcbiAgICAgICAgaWYgKHBhcmVudFNjb3BlICE9PSBwYXJlbnRWaWV3cG9ydFNjb3BlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdWaWV3cG9ydCBwYXJlbnRTY29wZSAhPT0gcGFyZW50Vmlld3BvcnRTY29wZScsIHBhcmVudFNjb3BlLnRvU3RyaW5nKHRydWUpLCBwYXJlbnRWaWV3cG9ydFNjb3BlLnRvU3RyaW5nKHRydWUpLCBjb25uZWN0ZWRDRS5nZXRDbG9zZXN0Q3VzdG9tRWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld3BvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gcGFyZW50U2NvcGUuYWRkVmlld3BvcnQobmFtZSwgY29ubmVjdGVkQ0UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zZXRDbG9zZXN0U2NvcGUoY29ubmVjdGVkQ0UuY29udGFpbmVyLCB2aWV3cG9ydC5jb25uZWN0ZWRTY29wZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZXN0cmljdGVkTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3RzLnNldChjb25uZWN0ZWRDRSwgbmV3IE9wZW5Qcm9taXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdHMuZ2V0KGNvbm5lY3RlZENFKT8ucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIC0gQ2FsbGVkIGZyb20gdGhlIHZpZXdwb3J0IGN1c3RvbSBlbGVtZW50XG4gICAgICovXG4gICAgZGlzY29ubmVjdFZpZXdwb3J0KHZpZXdwb3J0LCBjb25uZWN0ZWRDRSkge1xuICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbm5lY3RlZFNjb3BlLnBhcmVudC5yZW1vdmVWaWV3cG9ydCh2aWV3cG9ydCwgY29ubmVjdGVkQ0UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmVtb3ZlIHZpZXdwb3J0OiBcIiArIHZpZXdwb3J0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zZXRDbG9zZXN0U2NvcGUoY29ubmVjdGVkQ0UuY29udGFpbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIC0gQ2FsbGVkIGZyb20gdGhlIHZpZXdwb3J0IHNjb3BlIGN1c3RvbSBlbGVtZW50XG4gICAgICovXG4gICAgY29ubmVjdFZpZXdwb3J0U2NvcGUodmlld3BvcnRTY29wZSwgY29ubmVjdGVkQ0UsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50U2NvcGUgPSB0aGlzLmZpbmRQYXJlbnRTY29wZShjb25uZWN0ZWRDRS5jb250YWluZXIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVmlld3BvcnRTY29wZSBwYXJlbnRTY29wZScsIHBhcmVudFNjb3BlLnRvU3RyaW5nKCksIChjb25uZWN0ZWRDRSBhcyBhbnkpLmdldENsb3Nlc3RDdXN0b21FbGVtZW50KCkpO1xuICAgICAgICBpZiAodmlld3BvcnRTY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld3BvcnRTY29wZSA9IHBhcmVudFNjb3BlLmFkZFZpZXdwb3J0U2NvcGUobmFtZSwgY29ubmVjdGVkQ0UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zZXRDbG9zZXN0U2NvcGUoY29ubmVjdGVkQ0UuY29udGFpbmVyLCB2aWV3cG9ydFNjb3BlLmNvbm5lY3RlZFNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnRTY29wZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIC0gQ2FsbGVkIGZyb20gdGhlIHZpZXdwb3J0IHNjb3BlIGN1c3RvbSBlbGVtZW50XG4gICAgICovXG4gICAgZGlzY29ubmVjdFZpZXdwb3J0U2NvcGUodmlld3BvcnRTY29wZSwgY29ubmVjdGVkQ0UpIHtcbiAgICAgICAgaWYgKCF2aWV3cG9ydFNjb3BlLmNvbm5lY3RlZFNjb3BlLnBhcmVudC5yZW1vdmVWaWV3cG9ydFNjb3BlKHZpZXdwb3J0U2NvcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmVtb3ZlIHZpZXdwb3J0IHNjb3BlOiBcIiArIHZpZXdwb3J0U2NvcGUucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnNldENsb3Nlc3RTY29wZShjb25uZWN0ZWRDRS5jb250YWluZXIpO1xuICAgIH1cbiAgICBhbGxWaWV3cG9ydHMoaW5jbHVkZURpc2FibGVkID0gZmFsc2UsIGluY2x1ZGVSZXBsYWNlZCA9IGZhbHNlKSB7XG4gICAgICAgIC8vIHRoaXMuZW5zdXJlUm9vdFNjb3BlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RTY29wZS5zY29wZS5hbGxWaWV3cG9ydHMoaW5jbHVkZURpc2FibGVkLCBpbmNsdWRlUmVwbGFjZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIC0gVEhFIG5hdmlnYXRpb24gQVBJXG4gICAgICovXG4gICAgYXN5bmMgZ290byhpbnN0cnVjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKCdcImdvdG9cIiBtZXRob2QnLCAnXCJsb2FkXCIgbWV0aG9kJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWQoaW5zdHJ1Y3Rpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZChpbnN0cnVjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIC8vIFRPRE86IFJldmlldyBxdWVyeSBleHRyYWN0aW9uOyBkaWZmZXJlbnQgcG9zIGZvciBwYXRoIGFuZCBmcmFnbWVudCFcbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbnMgPT09ICdzdHJpbmcnICYmICFvcHRpb25zLnF1ZXJ5KSB7XG4gICAgICAgICAgICBjb25zdCBbcGF0aCwgc2VhcmNoXSA9IGluc3RydWN0aW9ucy5zcGxpdCgnPycpO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gcGF0aDtcbiAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSBzZWFyY2g7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9PcHRpb25zID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLm9yaWdpbikge1xuICAgICAgICAgICAgdG9PcHRpb25zLmNvbnRleHQgPSBvcHRpb25zLm9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NvcGUgPSBudWxsO1xuICAgICAgICAoeyBpbnN0cnVjdGlvbnMsIHNjb3BlIH0gPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLCBpbnN0cnVjdGlvbnMsIHRvT3B0aW9ucykpO1xuICAgICAgICBpZiAob3B0aW9ucy5hcHBlbmQgJiYgdGhpcy5wcm9jZXNzaW5nTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIudG9WaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLCBpbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zLCBzY29wZSk7XG4gICAgICAgICAgICAvLyBDYW4ndCByZXR1cm4gY3VycmVudCBuYXZpZ2F0aW9uIHByb21pc2Ugc2luY2UgaXQgY2FuIGxlYWQgdG8gZGVhZGxvY2sgaW4gbG9hZFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IGluc3RydWN0aW9ucyxcbiAgICAgICAgICAgIGZ1bGxTdGF0ZUluc3RydWN0aW9uOiAnJyxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgIHRpdGxlOiBvcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhLFxuICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICByZXBsYWNpbmc6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgICAgIHJlcGVhdGluZzogb3B0aW9ucy5hcHBlbmQsXG4gICAgICAgICAgICBmcm9tQnJvd3NlcjogZmFsc2UsXG4gICAgICAgICAgICBvcmlnaW46IG9wdGlvbnMub3JpZ2luLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLm5hdmlnYXRlKGVudHJ5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5yZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuZ28oLTEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgZm9yd2FyZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmdvKDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmdvKGRlbHRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIGNoZWNrQWN0aXZlKGluc3RydWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIubWF0Y2hTY29wZSh0aGlzLmFjdGl2ZUNvbXBvbmVudHMsIGluc3RydWN0aW9uLnNjb3BlKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gc2NvcGVJbnN0cnVjdGlvbnMuZmlsdGVyKGluc3RyID0+IGluc3RyLnNhbWVDb21wb25lbnQoaW5zdHJ1Y3Rpb24sIHRydWUpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMpXG4gICAgICAgICAgICAgICAgJiYgaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIubWF0Y2hDaGlsZHJlbihpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMsIG1hdGNoaW5nLm1hcChpbnN0ciA9PiBBcnJheS5pc0FycmF5KGluc3RyLm5leHRTY29wZUluc3RydWN0aW9ucykgPyBpbnN0ci5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgOiBbXSkuZmxhdCgpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBzZXROYXYobmFtZSwgcm91dGVzLCBjbGFzc2VzKSB7XG4gICAgICAgIGNvbnN0IG5hdiA9IHRoaXMuZmluZE5hdihuYW1lKTtcbiAgICAgICAgaWYgKG5hdiAhPT0gdm9pZCAwICYmIG5hdiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmF2LnJvdXRlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTmF2KG5hbWUsIHJvdXRlcywgY2xhc3Nlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBhZGROYXYobmFtZSwgcm91dGVzLCBjbGFzc2VzKSB7XG4gICAgICAgIGxldCBuYXYgPSB0aGlzLm5hdnNbbmFtZV07XG4gICAgICAgIGlmIChuYXYgPT09IHZvaWQgMCB8fCBuYXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5hdiA9IHRoaXMubmF2c1tuYW1lXSA9IG5ldyBOYXYodGhpcywgbmFtZSwgW10sIGNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgICAgIG5hdi5hZGRSb3V0ZXMocm91dGVzKTtcbiAgICAgICAgbmF2LnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgdXBkYXRlTmF2KG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmF2cyA9IG5hbWVcbiAgICAgICAgICAgID8gW25hbWVdXG4gICAgICAgICAgICA6IE9iamVjdC5rZXlzKHRoaXMubmF2cyk7XG4gICAgICAgIGZvciAoY29uc3QgbmF2IG9mIG5hdnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hdnNbbmF2XSAhPT0gdm9pZCAwICYmIHRoaXMubmF2c1tuYXZdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZzW25hdl0udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIGZpbmROYXYobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZzW25hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgYWRkUm91dGVzKHJvdXRlcywgY29udGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBhZGQgdG8gdGhlIGNvbnRleHQgaW5zdGVhZFxuICAgICAgICAvLyBUT0RPOiBBZGQgcm91dGVzIHdpdGhvdXQgY29udGV4dCB0byByb290U2NvcGUgY29udGVudCAod2hpY2ggbmVlZHMgdG8gYmUgY3JlYXRlZCk/XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgLy8gY29uc3Qgdmlld3BvcnQgPSAoY29udGV4dCAhPT0gdm9pZCAwID8gdGhpcy5jbG9zZXN0Vmlld3BvcnQoY29udGV4dCkgOiB0aGlzLnJvb3RTY29wZSkgfHwgdGhpcy5yb290U2NvcGUgYXMgVmlld3BvcnQ7XG4gICAgICAgIC8vIHJldHVybiB2aWV3cG9ydC5hZGRSb3V0ZXMocm91dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIHJlbW92ZVJvdXRlcyhyb3V0ZXMsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgcmVtb3ZlIGZyb20gdGhlIGNvbnRleHQgaW5zdGVhZFxuICAgICAgICAvLyBjb25zdCB2aWV3cG9ydCA9IChjb250ZXh0ICE9PSB2b2lkIDAgPyB0aGlzLmNsb3Nlc3RWaWV3cG9ydChjb250ZXh0KSA6IHRoaXMucm9vdFNjb3BlKSB8fCB0aGlzLnJvb3RTY29wZSBhcyBWaWV3cG9ydDtcbiAgICAgICAgLy8gcmV0dXJuIHZpZXdwb3J0LnJlbW92ZVJvdXRlcyhyb3V0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgYWRkSG9va3MoaG9va3MpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tzLm1hcChob29rID0+IHRoaXMuYWRkSG9vayhob29rLmhvb2ssIGhvb2sub3B0aW9ucykpO1xuICAgIH1cbiAgICBhZGRIb29rKGhvb2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9va01hbmFnZXIuYWRkSG9vayhob29rLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIHJlbW92ZUhvb2tzKGhvb2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSSAtIFRoZSByaWdodCB3YXkgdG8gY3JlYXRlIFZpZXdwb3J0SW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbihjb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzLCBvd25zU2NvcGUgPSB0cnVlLCBuZXh0U2NvcGVJbnN0cnVjdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbihjb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzLCBvd25zU2NvcGUsIG5leHRTY29wZUluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGhhc1NpYmxpbmdJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnMuc29tZShpbnN0cnVjdGlvbiA9PiB0aGlzLmhhc1NpYmxpbmdJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKSk7XG4gICAgfVxuICAgIGFwcGVuZEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMsIHNjb3BlID0gbnVsbCkge1xuICAgICAgICBpZiAoc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNjb3BlID0gdGhpcy5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5zY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRlZEluc3RydWN0aW9ucy5wdXNoKC4uLmluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGNoZWNrU3RhbGUobmFtZSwgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0YWxlQ2hlY2sgPSB0aGlzLnN0YWxlQ2hlY2tzW25hbWVdO1xuICAgICAgICBpZiAoc3RhbGVDaGVjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWxlQ2hlY2tzW25hbWVdID0gaW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWxlQ2hlY2subGVuZ3RoICE9PSBpbnN0cnVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWxlQ2hlY2tzW25hbWVdID0gaW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFsZUNoZWNrW2ldICE9PSBpbnN0cnVjdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWxlQ2hlY2tzW25hbWVdID0gaW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1bmtub3duUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByb3V0ZSAhPT0gJ3N0cmluZycgfHwgcm91dGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VDb25maWd1cmVkUm91dGVzICYmIHRoaXMub3B0aW9ucy51c2VEaXJlY3RSb3V0ZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBtaXNzaW5nL3Vua25vd24gcm91dGUgaGFuZGxpbmdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1hdGNoaW5nIGNvbmZpZ3VyZWQgcm91dGUgb3IgY29tcG9uZW50IGZvdW5kIGZvciAnXCIgKyByb3V0ZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMudXNlQ29uZmlndXJlZFJvdXRlcykge1xuICAgICAgICAgICAgLy8gVE9ETzogQWRkIG1pc3NpbmcvdW5rbm93biByb3V0ZSBoYW5kbGluZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWF0Y2hpbmcgY29uZmlndXJlZCByb3V0ZSBmb3VuZCBmb3IgJ1wiICsgcm91dGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBZGQgbWlzc2luZy91bmtub3duIHJvdXRlIGhhbmRsaW5nXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtYXRjaGluZyByb3V0ZS9jb21wb25lbnQgZm91bmQgZm9yICdcIiArIHJvdXRlICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRWaWV3cG9ydHMoaW5zdHJ1Y3Rpb25zLCBhbHJlYWR5Rm91bmQsIHdpdGhvdXRWaWV3cG9ydHMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBmb3VuZCA9IFtdO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBbXTtcbiAgICAgICAgd2hpbGUgKGluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnNbMF0uc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnNbMF0uc2NvcGUgPSB0aGlzLnJvb3RTY29wZS5zY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gaW5zdHJ1Y3Rpb25zWzBdLnNjb3BlO1xuICAgICAgICAgICAgY29uc3QgeyBmb3VuZFZpZXdwb3J0cywgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zIH0gPSBzY29wZS5maW5kVmlld3BvcnRzKGluc3RydWN0aW9ucy5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uc2NvcGUgPT09IHNjb3BlKSwgYWxyZWFkeUZvdW5kLCB3aXRob3V0Vmlld3BvcnRzKTtcbiAgICAgICAgICAgIGZvdW5kLnB1c2goLi4uZm91bmRWaWV3cG9ydHMpO1xuICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goLi4ucmVtYWluaW5nSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uc2NvcGUgIT09IHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3VuZDogZm91bmQuc2xpY2UoKSwgcmVtYWluaW5nIH07XG4gICAgfVxuICAgIGFzeW5jIGNhbmNlbE5hdmlnYXRpb24odXBkYXRlZFNjb3BlT3duZXJzLCBxSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgLy8gVE9ETzogVGFrZSBjYXJlIG9mIGRpc2FibGluZyB2aWV3cG9ydHMgd2hlbiBjYW5jZWxsaW5nIGFuZCBzdGF0ZWZ1bCFcbiAgICAgICAgdXBkYXRlZFNjb3BlT3duZXJzLmZvckVhY2goKHZpZXdwb3J0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydCA9IHZpZXdwb3J0LmFib3J0Q29udGVudENoYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGFib3J0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGFib3J0LmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0b3IuY2FuY2VsKHFJbnN0cnVjdGlvbik7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ05hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICBxSW5zdHJ1Y3Rpb24ucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBlbnN1cmVSb290U2NvcGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290U2NvcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmNvbnRhaW5lci5nZXQoSUFwcFJvb3QpO1xuICAgICAgICAgICAgLy8gcm9vdC5jb25maWcuY29tcG9uZW50IHNob3VsZG4ndCBiZSB1c2VkIGluIHRoZSBlbmQuIE1ldGFkYXRhIHdpbGwgcHJvYmFibHkgZWxpbWluYXRlIGl0XG4gICAgICAgICAgICB0aGlzLnJvb3RTY29wZSA9IG5ldyBWaWV3cG9ydFNjb3BlKCdyb290U2NvcGUnLCB0aGlzLCByb290LmNvbnRyb2xsZXIudmlld01vZGVsLCBudWxsLCB0cnVlLCByb290LmNvbmZpZy5jb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RTY29wZTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVBhdGhzKGluc3RydWN0aW9uKSB7XG4gICAgICAgIHRoaXMucm9vdFNjb3BlLnNjb3BlLnJlcGFyZW50Vmlld3BvcnRJbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IHRoaXMucm9vdFNjb3BlLnNjb3BlLmhvaXN0ZWRDaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcihzY29wZSA9PiBzY29wZS52aWV3cG9ydEluc3RydWN0aW9uICE9PSBudWxsICYmICFzY29wZS52aWV3cG9ydEluc3RydWN0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIC5tYXAoc2NvcGUgPT4gc2NvcGUudmlld3BvcnRJbnN0cnVjdGlvbik7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jbG9uZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucywgdHJ1ZSk7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWFrZXMgc3VyZSByaWdodCB2aWV3cG9ydC92aWV3cG9ydCBzY29wZXMgYXJlIHNldCBhbmQgdXBkYXRlXG4gICAgICAgIC8vIHdoZXRoZXIgdmlld3BvcnQgbmFtZSBpcyBuZWNlc3Nhcnkgb3Igbm90XG4gICAgICAgIGNvbnN0IGFscmVhZHlGb3VuZCA9IFtdO1xuICAgICAgICBsZXQgeyBmb3VuZCwgcmVtYWluaW5nIH0gPSB0aGlzLmZpbmRWaWV3cG9ydHMoaW5zdHJ1Y3Rpb25zLCBhbHJlYWR5Rm91bmQsIHRydWUpO1xuICAgICAgICBsZXQgZ3VhcmQgPSAxMDA7XG4gICAgICAgIHdoaWxlIChyZW1haW5pbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCBlbmRsZXNzIGxvb3BcbiAgICAgICAgICAgIGlmIChndWFyZC0tID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCB2aWV3cG9ydCB3aGVuIHVwZGF0aW5nIHZpZXdlciBwYXRocy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFscmVhZHlGb3VuZC5wdXNoKC4uLmZvdW5kKTtcbiAgICAgICAgICAgICh7IGZvdW5kLCByZW1haW5pbmcgfSA9IHRoaXMuZmluZFZpZXdwb3J0cyhyZW1haW5pbmcsIGFscmVhZHlGb3VuZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlQ29tcG9uZW50cyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgdGhpcy5hY3RpdmVSb3V0ZSA9IGluc3RydWN0aW9uLnJvdXRlO1xuICAgICAgICAvLyBGaXJzdCBpbnZva2Ugd2l0aCB2aWV3cG9ydCBpbnN0cnVjdGlvbnMgKHNob3VsZCBpdCBwZXJoYXBzIGdldCBmdWxsIHN0YXRlPylcbiAgICAgICAgbGV0IHN0YXRlID0gYXdhaXQgdGhpcy5ob29rTWFuYWdlci5pbnZva2VUcmFuc2Zvcm1Ub1VybChpbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMoc3RhdGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnZva2UgYWdhaW4gd2l0aCBzdHJpbmdcbiAgICAgICAgc3RhdGUgPSBhd2FpdCB0aGlzLmhvb2tNYW5hZ2VyLmludm9rZVRyYW5zZm9ybVRvVXJsKHN0YXRlLCBpbnN0cnVjdGlvbik7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gKGluc3RydWN0aW9uLnF1ZXJ5ICYmIGluc3RydWN0aW9uLnF1ZXJ5Lmxlbmd0aCA/IFwiP1wiICsgaW5zdHJ1Y3Rpb24ucXVlcnkgOiAnJyk7XG4gICAgICAgIC8vIGlmIChpbnN0cnVjdGlvbi5wYXRoID09PSB2b2lkIDAgfHwgaW5zdHJ1Y3Rpb24ucGF0aC5sZW5ndGggPT09IDAgfHwgaW5zdHJ1Y3Rpb24ucGF0aCA9PT0gJy8nKSB7XG4gICAgICAgIGluc3RydWN0aW9uLnBhdGggPSBzdGF0ZSArIHF1ZXJ5O1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IGZ1bGxWaWV3cG9ydFN0YXRlcyA9IFt0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24odGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbildO1xuICAgICAgICBmdWxsVmlld3BvcnRTdGF0ZXMucHVzaCguLi50aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuY2xvbmVWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMsIHRoaXMuc3RhdGVmdWxIaXN0b3J5KSk7XG4gICAgICAgIGluc3RydWN0aW9uLmZ1bGxTdGF0ZUluc3RydWN0aW9uID0gZnVsbFZpZXdwb3J0U3RhdGVzO1xuICAgICAgICBpZiAoKGluc3RydWN0aW9uLnRpdGxlID8/IG51bGwpID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGF3YWl0IHRoaXMuZ2V0VGl0bGUoaW5zdHJ1Y3Rpb25zLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBpZiAodGl0bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi50aXRsZSA9IHRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VGl0bGUoaW5zdHJ1Y3Rpb25zLCBpbnN0cnVjdGlvbikge1xuICAgICAgICAvLyBGaXJzdCBpbnZva2Ugd2l0aCB2aWV3cG9ydCBpbnN0cnVjdGlvbnNcbiAgICAgICAgbGV0IHRpdGxlID0gYXdhaXQgdGhpcy5ob29rTWFuYWdlci5pbnZva2VTZXRUaXRsZShpbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aXRsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIEhvb2sgZGlkbid0IHJldHVybiBhIHRpdGxlLCBzbyBydW4gdGl0bGUgbG9naWNcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFRpdGxlcyA9IHRoaXMuc3RyaW5naWZ5VGl0bGVzKHRpdGxlLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB0aXRsZSA9IHRoaXMub3B0aW9ucy50aXRsZS5hcHBUaXRsZTtcbiAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShcIiR7Y29tcG9uZW50VGl0bGVzfVwiLCBjb21wb25lbnRUaXRsZXMpO1xuICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKFwiJHthcHBUaXRsZVNlcGFyYXRvcn1cIiwgY29tcG9uZW50VGl0bGVzICE9PSAnJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnRpdGxlLmFwcFRpdGxlU2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52b2tlIGFnYWluIHdpdGggY29tcGxldGUgc3RyaW5nXG4gICAgICAgIHRpdGxlID0gYXdhaXQgdGhpcy5ob29rTWFuYWdlci5pbnZva2VTZXRUaXRsZSh0aXRsZSwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgfVxuICAgIHN0cmluZ2lmeVRpdGxlcyhpbnN0cnVjdGlvbnMsIG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCB0aXRsZXMgPSBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIC5tYXAoaW5zdHJ1Y3Rpb24gPT4gdGhpcy5zdHJpbmdpZnlUaXRsZShpbnN0cnVjdGlvbiwgbmF2aWdhdGlvbkluc3RydWN0aW9uKSlcbiAgICAgICAgICAgIC5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gKGluc3RydWN0aW9uPy5sZW5ndGggPz8gMCkgPiAwKTtcbiAgICAgICAgcmV0dXJuIHRpdGxlcy5qb2luKCcgKyAnKTtcbiAgICB9XG4gICAgc3RyaW5naWZ5VGl0bGUoaW5zdHJ1Y3Rpb24sIG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVRpdGxlKGluc3RydWN0aW9uLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gaW5zdHJ1Y3Rpb24ucm91dGUgPz8gbnVsbDtcbiAgICAgICAgY29uc3QgbmV4dEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucztcbiAgICAgICAgbGV0IHN0cmluZ2lmaWVkID0gJyc7XG4gICAgICAgIC8vIEl0J3MgYSBjb25maWd1cmVkIHJvdXRlXG4gICAgICAgIGlmIChyb3V0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBhZGRlZCBhcyBwYXJ0IG9mIGEgY29uZmlndXJhdGlvbiwgc2tpcCB0byBuZXh0IHNjb3BlXG4gICAgICAgICAgICBpZiAocm91dGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobmV4dEluc3RydWN0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnN0cmluZ2lmeVRpdGxlcyhuZXh0SW5zdHJ1Y3Rpb25zLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllZCArPSB0aGlzLnJlc29sdmVUaXRsZShyb3V0ZSwgbmF2aWdhdGlvbkluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkICs9IHRoaXMucmVzb2x2ZVRpdGxlKGluc3RydWN0aW9uLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5leHRJbnN0cnVjdGlvbnMpICYmIG5leHRJbnN0cnVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IG5leHRTdHJpbmdpZmllZCA9IHRoaXMuc3RyaW5naWZ5VGl0bGVzKG5leHRJbnN0cnVjdGlvbnMsIG5hdmlnYXRpb25JbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBpZiAobmV4dFN0cmluZ2lmaWVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEluc3RydWN0aW9ucy5sZW5ndGggIT09IDEpIHsgLy8gVE9ETzogVGhpcyBzaG91bGQgcmVhbGx5IGFsc28gY2hlY2sgdGhhdCB0aGUgaW5zdHJ1Y3Rpb25zIGhhdmUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0cmluZ2lmaWVkID0gXCJbIFwiICsgbmV4dFN0cmluZ2lmaWVkICsgXCIgXVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5naWZpZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZCA9IHRoaXMub3B0aW9ucy50aXRsZS5jb21wb25lbnRUaXRsZU9yZGVyID09PSAndG9wLWRvd24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0cmluZ2lmaWVkICsgdGhpcy5vcHRpb25zLnRpdGxlLmNvbXBvbmVudFRpdGxlU2VwYXJhdG9yICsgbmV4dFN0cmluZ2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTdHJpbmdpZmllZCArIHRoaXMub3B0aW9ucy50aXRsZS5jb21wb25lbnRUaXRsZVNlcGFyYXRvciArIHN0cmluZ2lmaWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBuZXh0U3RyaW5naWZpZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICB9XG4gICAgcmVzb2x2ZVRpdGxlKGluc3RydWN0aW9uLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgbGV0IHRpdGxlID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aXRsZSA9IGluc3RydWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uIGluc3RhbmNlb2YgVmlld3BvcnRJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uLnZpZXdwb3J0LmdldFRpdGxlKG5hdmlnYXRpb25JbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBGb3VuZFJvdXRlKSB7XG4gICAgICAgICAgICBjb25zdCByb3V0ZVRpdGxlID0gaW5zdHJ1Y3Rpb24ubWF0Y2g/LnRpdGxlO1xuICAgICAgICAgICAgaWYgKHJvdXRlVGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygcm91dGVUaXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSByb3V0ZVRpdGxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSByb3V0ZVRpdGxlLmNhbGwoaW5zdHJ1Y3Rpb24sIGluc3RydWN0aW9uLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRpdGxlLnRyYW5zZm9ybVRpdGxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlLnRyYW5zZm9ybVRpdGxlLmNhbGwodGhpcywgdGl0bGUsIGluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgfVxuICAgIGFzeW5jIGZyZWVDb21wb25lbnRzKGluc3RydWN0aW9uLCBleGNsdWRlQ29tcG9uZW50cywgYWxyZWFkeURvbmUpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gaW5zdHJ1Y3Rpb24udmlld3BvcnQ7XG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IG51bGwgfHwgdmlld3BvcnQgPT09IG51bGwgfHwgYWxyZWFkeURvbmUuc29tZShkb25lID0+IGRvbmUgPT09IGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4Y2x1ZGVDb21wb25lbnRzLnNvbWUoZXhjbHVkZSA9PiBleGNsdWRlID09PSBjb21wb25lbnQpKSB7XG4gICAgICAgICAgICBhd2FpdCB2aWV3cG9ydC5mcmVlQ29udGVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgYWxyZWFkeURvbmUucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEluc3RydWN0aW9uIG9mIGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZnJlZUNvbXBvbmVudHMobmV4dEluc3RydWN0aW9uLCBleGNsdWRlQ29tcG9uZW50cywgYWxyZWFkeURvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldENsb3Nlc3RDb250YWluZXIodmlld01vZGVsT3JFbGVtZW50KSB7XG4gICAgICAgIGlmICgnY29udGV4dCcgaW4gdmlld01vZGVsT3JFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld01vZGVsT3JFbGVtZW50LmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCckY29udHJvbGxlcicgaW4gdmlld01vZGVsT3JFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld01vZGVsT3JFbGVtZW50LiRjb250cm9sbGVyLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuQ3VzdG9tRWxlbWVudEZvcih2aWV3TW9kZWxPckVsZW1lbnQpO1xuICAgICAgICBpZiAoY29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5jb250ZXh0O1xuICAgIH1cbiAgICBnZXRDb250YWluZXIodmlld01vZGVsT3JDb250YWluZXIpIHtcbiAgICAgICAgaWYgKCdyZXNvdXJjZVJlc29sdmVycycgaW4gdmlld01vZGVsT3JDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3TW9kZWxPckNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZW5kZXJDb250ZXh0KHZpZXdNb2RlbE9yQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbE9yQ29udGFpbmVyLmdldChJQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJyRjb250cm9sbGVyJyBpbiB2aWV3TW9kZWxPckNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbE9yQ29udGFpbmVyLiRjb250cm9sbGVyLmNvbnRleHQuZ2V0KElDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGlzIGlzIHByb2JhYmx5IHdyb25nIHNpbmNlIGl0IGNhdXNlZCB0ZXN0IGZhaWxzIHdoZW4gaW4gQ3VzdG9tRWxlbWVudC5mb3JcbiAgICAvLyBGcmVkIHByb2JhYmx5IGtub3dzIGFuZCB3aWxsIG5lZWQgdG8gbG9vayBhdCBpdFxuICAgIC8vIFRoaXMgY2FuIG1vc3QgbGlrZWx5IGFsc28gYmUgY2hhbmdlZCBzbyB0aGF0IHRoZSBub2RlIHRyYXZlcnNhbCBpc24ndCBuZWNlc3NhcnlcbiAgICBDdXN0b21FbGVtZW50Rm9yKG5vZGUpIHtcbiAgICAgICAgbGV0IGN1ciA9IG5vZGU7XG4gICAgICAgIHdoaWxlIChjdXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVSZXNvdXJjZU5hbWUgPSBjdXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBNZXRhZGF0YS5nZXRPd24oQ3VzdG9tRWxlbWVudC5uYW1lICsgXCI6XCIgKyBub2RlUmVzb3VyY2VOYW1lLCBjdXIpXG4gICAgICAgICAgICAgICAgfHwgTWV0YWRhdGEuZ2V0T3duKEN1c3RvbUVsZW1lbnQubmFtZSwgY3VyKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGdldEVmZmVjdGl2ZVBhcmVudE5vZGUoY3VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZvaWQgMCk7XG4gICAgfVxufVxuUm91dGVyLmluamVjdCA9IFtJQ29udGFpbmVyLCBOYXZpZ2F0b3IsIEJyb3dzZXJWaWV3ZXJTdG9yZSwgTGlua0hhbmRsZXIsIEluc3RydWN0aW9uUmVzb2x2ZXIsIEhvb2tNYW5hZ2VyLCBSb3V0ZXJPcHRpb25zXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiLCIvKipcbiAqIENsYXNzIGZvciBydW5uaW5nIGEgc2VxdWVuY2Ugb2Ygc3RlcHMgd2l0aCB2YWx1ZXMsXG4gKiBmdW5jdGlvbnMgYW5kIHByb21pc2VzLiBTdGF5cyBzeW5jIGlmIHBvc3NpYmxlLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBwcm9taXNlID0gUnVubmVyLnJ1bihcbiAqICAgJ29uZScsXG4gKiAgIHByZXYgPT4gYCR7cHJldmlvdXN9LCB0d29gLFxuICogICBwcmV2ID0+IGNyZWF0ZVByb21pc2UocHJldiksIC8vIGNyZWF0ZXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYCR7cHJldn0sIHRocmVlYFxuICogKTtcbiAqXG4gKiAvLyBSdW4gY2FuIGJlIGNhbmNlbGxlZCB3aXRoIFJ1bm5lci5jYW5jZWwocHJvbWlzZSk7XG4gKlxuICogY29uc3Qgc3RlcHNSdW5uZXIgPSBSdW5uZXIucnVubmVyKHByb21pc2UpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAqIGlmIChzdGVwc1J1bm5lcj8uaXNSZXNvbHZlZCkgeyAvLyBNYWtlIHN1cmUgcHJvbWlzZSB3YXNuJ3QgcmVqZWN0ZWRcbiAqICAgLy8gcmVzdWx0ID09PSAnb25lLCB0d28sIHRocmVlJ1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0FzeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NhbmNlbGxlZCB8fCB0aGlzLmlzUmVqZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzZXQgb2Ygc3RlcHMgYW5kIHJldHVucyB0aGUgbGFzdCB2YWx1ZVxuICAgICAqXG4gICAgICogU3RlcHMgYXJlIHByb2Nlc3NlZCBpbiBzZXF1ZW5jZSBhbmQgY2FuIGJlIGVpdGhlciBhXG4gICAgICpcbiAgICAgKiAtIHZhbHVlIC0gd2hpY2ggaXMgdGhlbiBwcm9wYWdhdGVkIGFzIGlucHV0IGludG8gdGhlIG5leHQgc3RlcFxuICAgICAqIC0gZnVuY3Rpb24gLSB3aGljaCBpcyBleGVjdXRlZCBpbiB0aW1lLiBUaGUgcmVzdWx0IGlzIHJlcGxhY2luZyB0aGUgc3RlcCB3aGljaCBpcyB0aGVuIHJlcHJvY2Vzc2VkXG4gICAgICogLSBwcm9taXNlIC0gd2hpY2ggaXMgYXdhaXRlZFxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiByZXN1bHQgPSBhd2FpdCBSdW5uZXIucnVuKFxuICAgICAqICAgJ29uZScsXG4gICAgICogICBwcmV2ID0+IGAke3ByZXZpb3VzfSwgdHdvYCxcbiAgICAgKiAgIHByZXYgPT4gY3JlYXRlUHJvbWlzZShwcmV2KSwgLy8gY3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBgJHtwcmV2fSwgdGhyZWVgXG4gICAgICogKTsgLy8gcmVzdWx0ID09PSAnb25lLCB0d28sIHRocmVlJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJ1biguLi5zdGVwcykge1xuICAgICAgICAvLyBkZWJ1Z2dlcjsgLy8gRklYIEFSUkFZIENIRUNLIVxuICAgICAgICBjb25zdCAkcnVubmVyID0gbmV3IFJ1bm5lcigpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFJ1bm5lci4kcnVuKCRydW5uZXIsIC4uLnN0ZXBzKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5ydW5uZXJzLnNldCh2YWx1ZSwgJHJ1bm5lcik7XG4gICAgICAgICAgICB2YWx1ZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAkcnVubmVyLmlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCRydW5uZXIuaXNBc3luYyAmJiAhJHJ1bm5lci5zdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICRydW5uZXIuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucnVubmVycy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCckcnVubmVyIGRvbmUnLCAkcnVubmVyLCB0aGlzLnJ1bm5lcnMpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJ1bm5lciBmb3IgYSBwcm9taXNlIHJldHVybmVkIGJ5IFJ1bm5lci5ydW5cbiAgICAgKlxuICAgICAqIFRoZSBydW5uZXIgY2FuIGJlIHVzZWQgdG8gY2hlY2sgc3RhdHVzIGFuZCBvdXRjb21lIG9mXG4gICAgICogdGhlIHJ1biBhcyB3ZWxsIGFzIGNhbmNlbCBpdFxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJ1bm5lcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bm5lcnMuZ2V0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIHRoZSBydW5uZXIgZm9yIGEgcHJvbWlzZSByZXR1cm5lZCBieSBSdW5uZXIucnVuXG4gICAgICpcbiAgICAgKiBPbmNlIGEgcnVubmVyIGhhcyBiZWVuIGNhbmNlbGxlZCwgaXQncyBubyBsb25nZXIgcG9zc2libGVcbiAgICAgKiB0byByZXRyaWV2ZSBpdCBmcm9tIHRoZSBwcm9taXNlXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FuY2VsKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0ICRydW5uZXIgPSBSdW5uZXIucnVubmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKCRydW5uZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgJHJ1bm5lci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcnVuQWxsKHN0ZXBzKSB7XG4gICAgICAgIGNvbnN0ICRydW5uZXIgPSBuZXcgUnVubmVyKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFJ1bm5lci4kcnVuQWxsKCRydW5uZXIsIHN0ZXBzKTtcbiAgICAgICAgaWYgKCRydW5uZXIuaXNBc3luYykge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UuYWxsKHZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5lcnMuc2V0KHByb21pc2UsICRydW5uZXIpO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAkcnVubmVyLmlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCRydW5uZXIuaXNBc3luYyAmJiAhJHJ1bm5lci5zdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICRydW5uZXIuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucnVubmVycy5kZWxldGUocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyRydW5uZXIgZG9uZScsICRydW5uZXIsIHRoaXMucnVubmVycyk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4geyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgc3RhdGljIHJ1bk9uZShzdGVwKSB7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgLy8gSXRlcmF0aXZlbHkgcmVzb2x2ZSBGdW5jdGlvbnMgKHVudGlsIHZhbHVlIG9yIFByb21pc2UpXG4gICAgICAgIHdoaWxlIChzdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIShzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSkpIHsgLy8gPT09IGlzVmFsdWUoc3RlcClcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSB3YXNuJ3QgYSBGdW5jdGlvbiBiZWZvcmUgdGhlIHZhbHVlXG4gICAgICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIShzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSkpIHsgLy8gPT09IGlzVmFsdWUoc3RlcClcbiAgICAgICAgICAgIHZhbHVlID0gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3QgYSBQcm9taXNlLCBydW4gdGhlIHJlbWFpbmluZ1xuICAgICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwLnRoZW4oKHJlc29sdmVkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bk9uZShyZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHN0YXRpYyAkcnVuKCRydW5uZXIsIC4uLnN0ZXBzKSB7XG4gICAgICAgIGxldCBzdGVwO1xuICAgICAgICB3aGlsZSAoc3RlcHMubGVuZ3RoID4gMCAmJiAhJHJ1bm5lci5zdG9wKSB7XG4gICAgICAgICAgICBzdGVwID0gc3RlcHMuc2hpZnQoKTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGl2ZWx5IHJlc29sdmUgRnVuY3Rpb25zICh1bnRpbCB2YWx1ZSBvciBQcm9taXNlKVxuICAgICAgICAgICAgd2hpbGUgKHN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiAhJHJ1bm5lci5zdG9wKSB7XG4gICAgICAgICAgICAgICAgc3RlcCA9IHN0ZXAoJHJ1bm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBQcm9taXNlKSkgeyAvLyA9PT0gaXNWYWx1ZShzdGVwKVxuICAgICAgICAgICAgICAgICAgICAkcnVubmVyLnZhbHVlID0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIHdhc24ndCBhIEZ1bmN0aW9uIGJlZm9yZSB0aGUgdmFsdWVcbiAgICAgICAgICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIShzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSkpIHsgLy8gPT09IGlzVmFsdWUoc3RlcClcbiAgICAgICAgICAgICAgICAkcnVubmVyLnZhbHVlID0gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJ1biBzdGVwcyB1bnRpbCBkb25lIG9yIHdlIGdldCBhIFByb21pc2VcbiAgICAgICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdCBhIFByb21pc2UsIHJ1biB0aGUgcmVtYWluaW5nXG4gICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSAmJiAhJHJ1bm5lci5zdG9wKSB7XG4gICAgICAgICAgICAkcnVubmVyLmlzQXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAudGhlbigocmVzb2x2ZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBSdW5uZXIuJHJ1bigkcnVubmVyLCByZXNvbHZlZFZhbHVlLCAuLi5zdGVwcyk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgJHJ1bm5lci5pc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHJ1bm5lci52YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljICRydW5BbGwoJHJ1bm5lciwgc3RlcHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShzdGVwcy5sZW5ndGgpO1xuICAgICAgICBzdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gSXRlcmF0aXZlbHkgcmVzb2x2ZSBGdW5jdGlvbnMgKHVudGlsIHZhbHVlIG9yIFByb21pc2UpXG4gICAgICAgICAgICB3aGlsZSAoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3RlcCA9IHN0ZXAocmVzdWx0c1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIShzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSkpIHsgLy8gPT09IGlzVmFsdWUoc3RlcClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlcmUgd2Fzbid0IGEgRnVuY3Rpb24gYmVmb3JlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgeyAvLyA9PT0gaXNWYWx1ZShzdGVwKVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGdvdCBhIFByb21pc2UsIHJ1biB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAkcnVubmVyLmlzQXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxufVxuUnVubmVyLnJ1bm5lcnMgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVubmVyLmpzLm1hcCIsImltcG9ydCB7IFZpZXdwb3J0U2NvcGUgfSBmcm9tICcuL3ZpZXdwb3J0LXNjb3BlLmpzJztcbmltcG9ydCB7IEZvdW5kUm91dGUgfSBmcm9tICcuL2ZvdW5kLXJvdXRlLmpzJztcbmltcG9ydCB7IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyIH0gZnJvbSAnLi90eXBlLXJlc29sdmVycy5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydCB9IGZyb20gJy4vdmlld3BvcnQuanMnO1xuaW1wb3J0IHsgYXJyYXlSZW1vdmUgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL2NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgUm91dGVSZWNvZ25pemVyIH0gZnJvbSAnLi9yb3V0ZS1yZWNvZ25pemVyLmpzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJy4vcnVubmVyLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IGNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXIsIGhhc1Njb3BlLCBvd25pbmdTY29wZSwgdmlld3BvcnQgPSBudWxsLCB2aWV3cG9ydFNjb3BlID0gbnVsbCwgcm9vdENvbXBvbmVudFR5cGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLmhhc1Njb3BlID0gaGFzU2NvcGU7XG4gICAgICAgIHRoaXMub3duaW5nU2NvcGUgPSBvd25pbmdTY29wZTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnZpZXdwb3J0U2NvcGUgPSB2aWV3cG9ydFNjb3BlO1xuICAgICAgICB0aGlzLnJvb3RDb21wb25lbnRUeXBlID0gcm9vdENvbXBvbmVudFR5cGU7XG4gICAgICAgIHRoaXMuaWQgPSAnLic7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnJlcGxhY2VkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gU3VwcG9ydCBjb2xsZWN0aW9uIGZlYXR1cmUgaW4gdmlld3BvcnQgc2NvcGVzXG4gICAgICAgIHRoaXMuY2hpbGRDb2xsZWN0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLm93bmluZ1Njb3BlID0gb3duaW5nU2NvcGUgPz8gdGhpcztcbiAgICAgICAgdGhpcy5zY29wZSA9IHRoaXMuaGFzU2NvcGUgPyB0aGlzIDogdGhpcy5vd25pbmdTY29wZS5zY29wZTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NyZWF0ZWQgc2NvcGUnLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0b1N0cmluZyhyZWN1cnNlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMub3duaW5nU2NvcGUgIT09IHRoaXMgPyB0aGlzLm93bmluZ1Njb3BlLnRvU3RyaW5nKCkgOiAnJ30vJHt0aGlzLm93bmVyLnRvU3RyaW5nKCl9YCArXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICAgICBgJHtyZWN1cnNlID8gYFxcbmAgKyB0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC50b1N0cmluZyh0cnVlKSkuam9pbignJykgOiAnJ31gO1xuICAgIH1cbiAgICBnZXQgaXNWaWV3cG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQgIT09IG51bGw7XG4gICAgfVxuICAgIGdldCBpc1ZpZXdwb3J0U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0U2NvcGUgIT09IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXNzVGhyb3VnaFNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZpZXdwb3J0U2NvcGUgJiYgdGhpcy52aWV3cG9ydFNjb3BlLnBhc3NUaHJvdWdoU2NvcGU7XG4gICAgfVxuICAgIGdldCBvd25lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3cG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3cG9ydFNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFNjb3BlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlZENoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoc2NvcGUgPT4gc2NvcGUuZW5hYmxlZCk7XG4gICAgfVxuICAgIGdldCBob2lzdGVkQ2hpbGRyZW4oKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuZW5hYmxlZENoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoc2NvcGVzLnNvbWUoc2NvcGUgPT4gc2NvcGUucGFzc1Rocm91Z2hTY29wZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzLnNsaWNlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUucGFzc1Rocm91Z2hTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHNjb3Blcy5pbmRleE9mKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzLnNwbGljZShpbmRleCwgMSwgLi4uc2NvcGUuZW5hYmxlZENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlcztcbiAgICB9XG4gICAgZ2V0IGVuYWJsZWRWaWV3cG9ydHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXG4gICAgICAgICAgICAuZmlsdGVyKHNjb3BlID0+IHNjb3BlLmlzVmlld3BvcnQgJiYgc2NvcGUuZW5hYmxlZClcbiAgICAgICAgICAgIC5tYXAoc2NvcGUgPT4gc2NvcGUudmlld3BvcnQpO1xuICAgIH1cbiAgICBnZXQgdmlld3BvcnRJbnN0cnVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3cG9ydFNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFNjb3BlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3cG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuY29udGVudC5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50TmV4dENvbnRlbnRBY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudEFjdGlvbiA9IHRoaXMucGFyZW50Lm93bmVyLm5leHRDb250ZW50QWN0aW9uO1xuICAgICAgICBpZiAocGFyZW50QWN0aW9uID09PSAnc3dhcCcgfHwgcGFyZW50QWN0aW9uID09PSAnc2tpcCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRBY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBhcmVudE5leHRDb250ZW50QWN0aW9uO1xuICAgIH1cbiAgICBnZXRFbmFibGVkVmlld3BvcnRzKHZpZXdwb3J0U2NvcGVzKSB7XG4gICAgICAgIHJldHVybiB2aWV3cG9ydFNjb3Blc1xuICAgICAgICAgICAgLmZpbHRlcihzY29wZSA9PiAhc2NvcGUuaXNWaWV3cG9ydFNjb3BlKVxuICAgICAgICAgICAgLm1hcChzY29wZSA9PiBzY29wZS52aWV3cG9ydClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHZpZXdwb3J0cywgdmlld3BvcnQpID0+IHtcbiAgICAgICAgICAgIHZpZXdwb3J0c1t2aWV3cG9ydC5uYW1lXSA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdwb3J0cztcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICBnZXRPd25lZFZpZXdwb3J0cyhpbmNsdWRlRGlzYWJsZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxWaWV3cG9ydHMoaW5jbHVkZURpc2FibGVkKS5maWx0ZXIodmlld3BvcnQgPT4gdmlld3BvcnQub3duaW5nU2NvcGUgPT09IHRoaXMpO1xuICAgIH1cbiAgICBnZXRPd25lZFNjb3BlcyhpbmNsdWRlRGlzYWJsZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzY29wZXMgPSB0aGlzLmFsbFNjb3BlcyhpbmNsdWRlRGlzYWJsZWQpLmZpbHRlcihzY29wZSA9PiBzY29wZS5vd25pbmdTY29wZSA9PT0gdGhpcyk7XG4gICAgICAgIC8vIEhvaXN0IGNoaWxkcmVuIHRvIHBhc3MgdGhyb3VnaCBzY29wZXNcbiAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMuc2xpY2UoKSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLnBhc3NUaHJvdWdoU2NvcGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHNjb3Blcy5pbmRleE9mKHNjb3BlKTtcbiAgICAgICAgICAgICAgICBzY29wZXMuc3BsaWNlKGluZGV4LCAxLCAuLi5zY29wZS5nZXRPd25lZFNjb3BlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH1cbiAgICBmaW5kSW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGxldCByb3V0ZSA9IG5ldyBGb3VuZFJvdXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLnBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMucm91dGVyLm9wdGlvbnMudXNlQ29uZmlndXJlZFJvdXRlcyAmJiAhdGhpcy5yb3V0ZXIuaGFzU2libGluZ0luc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRSb3V0ZSA9IHRoaXMuZmluZE1hdGNoaW5nUm91dGUoaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZFJvdXRlPy5mb3VuZENvbmZpZ3VyYXRpb24gPz8gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBmb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm91dGVyLm9wdGlvbnMudXNlRGlyZWN0Um91dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZS5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGUuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5zdHJ1Y3Rpb25zID0gcm91dGUuaW5zdHJ1Y3Rpb25zWzBdLm5leHRTY29wZUluc3RydWN0aW9ucyA/PyBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZS5yZW1haW5pbmcgPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKG5leHRJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFZlcmlmeSB0aGF0IGl0J3Mgb2theSB0byBsZWF2ZSB0aGlzIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUuaW5zdHJ1Y3Rpb25zWzBdLm5leHRTY29wZUluc3RydWN0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJvdXRlci5vcHRpb25zLnVzZURpcmVjdFJvdXRlcykge1xuICAgICAgICAgICAgICAgIHJvdXRlLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHIgb2Ygcm91dGUuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoaW5zdHIuc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnN0ci5zY29wZSA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH1cbiAgICAvLyBOb3RlOiBUaGlzIGNhbid0IGNoYW5nZSBzdGF0ZSBvdGhlciB0aGFuIHRoZSBpbnN0cnVjdGlvbnMhXG4gICAgZmluZFZpZXdwb3J0cyhpbnN0cnVjdGlvbnMsIGFscmVhZHlGb3VuZCwgZGlzcmVnYXJkVmlld3BvcnRzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZm91bmRWaWV3cG9ydHMgPSBbXTtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0luc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBvd25lZFNjb3BlcyA9IHRoaXMuZ2V0T3duZWRTY29wZXMoKTtcbiAgICAgICAgLy8gR2V0IGEgc2hhbGxvdyBjb3B5IG9mIGFsbCBhdmFpbGFibGUgbWFudWFsIHZpZXdwb3J0IHNjb3Blc1xuICAgICAgICBjb25zdCB2aWV3cG9ydFNjb3BlcyA9IG93bmVkU2NvcGVzLmZpbHRlcihzY29wZSA9PiBzY29wZS5pc1ZpZXdwb3J0U2NvcGUpLm1hcChzY29wZSA9PiBzY29wZS52aWV3cG9ydFNjb3BlKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlVmlld3BvcnRTY29wZXMgPSB2aWV3cG9ydFNjb3Blcy5maWx0ZXIodmlld3BvcnRTY29wZSA9PiBhbHJlYWR5Rm91bmQuZXZlcnkoZm91bmQgPT4gZm91bmQudmlld3BvcnRTY29wZSAhPT0gdmlld3BvcnRTY29wZSkpO1xuICAgICAgICAvLyBHZXQgYSBzaGFsbG93IGNvcHkgb2YgYWxsIGF2YWlsYWJsZSB2aWV3cG9ydHNcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlVmlld3BvcnRzID0geyAuLi50aGlzLmdldEVuYWJsZWRWaWV3cG9ydHMob3duZWRTY29wZXMpIH07XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgYWxyZWFkeUZvdW5kLmZpbHRlcihmb3VuZCA9PiBmb3VuZC5zY29wZSA9PT0gdGhpcykpIHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVZpZXdwb3J0c1tpbnN0cnVjdGlvbi52aWV3cG9ydE5hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3cG9ydEluc3RydWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKC4uLmluc3RydWN0aW9ucy5zbGljZSgpKTtcbiAgICAgICAgbGV0IGluc3RydWN0aW9uID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIHZpZXdwb3J0IHNjb3BlIGlzIGFscmVhZHkga25vd25cbiAgICAgICAgd2hpbGUgKChpbnN0cnVjdGlvbiA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLm5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlICE9PSBudWxsICYmICF0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmlzQWRkVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdJbnN0cnVjdGlvbnMucHVzaCguLi50aGlzLmZvdW5kVmlld3BvcnRTY29wZShpbnN0cnVjdGlvbiwgaW5zdHJ1Y3Rpb24udmlld3BvcnRTY29wZSkpO1xuICAgICAgICAgICAgICAgIGZvdW5kVmlld3BvcnRzLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgIGFycmF5UmVtb3ZlKGF2YWlsYWJsZVZpZXdwb3J0U2NvcGVzLCBhdmFpbGFibGUgPT4gYXZhaWxhYmxlID09PSBpbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucy5yZW1vdmVDdXJyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHZpZXdwb3J0IGlzIGFscmVhZHkga25vd25cbiAgICAgICAgaWYgKCFkaXNyZWdhcmRWaWV3cG9ydHMpIHtcbiAgICAgICAgICAgIHdoaWxlICgoaW5zdHJ1Y3Rpb24gPSB2aWV3cG9ydEluc3RydWN0aW9ucy5uZXh0KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnZpZXdwb3J0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5wdXNoKC4uLnRoaXMuZm91bmRWaWV3cG9ydChpbnN0cnVjdGlvbiwgaW5zdHJ1Y3Rpb24udmlld3BvcnQsIGRpc3JlZ2FyZFZpZXdwb3J0cykpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFZpZXdwb3J0cy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlVmlld3BvcnRzW2luc3RydWN0aW9uLnZpZXdwb3J0Lm5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWaWV3cG9ydCBzY29wZXMgaGF2ZSBwcmlvcml0eVxuICAgICAgICB3aGlsZSAoKGluc3RydWN0aW9uID0gdmlld3BvcnRJbnN0cnVjdGlvbnMubmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdmlld3BvcnRTY29wZSBvZiB2aWV3cG9ydFNjb3Blcykge1xuICAgICAgICAgICAgICAgIGlmICh2aWV3cG9ydFNjb3BlLmFjY2VwdFNlZ21lbnQoaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmlld3BvcnRTY29wZS5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYXZhaWxhYmxlJywgdmlld3BvcnRTY29wZS5hdmFpbGFibGUsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXZhaWxhYmxlID0gYXZhaWxhYmxlVmlld3BvcnRTY29wZXMuZmluZChhdmFpbGFibGUgPT4gYXZhaWxhYmxlLm5hbWUgPT09IHZpZXdwb3J0U2NvcGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlID09PSB2b2lkIDAgfHwgdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0FkZFZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZpZXdwb3J0U2NvcGUuYWRkU291cmNlSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSA9IHRoaXMuZ2V0T3duZWRTY29wZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNjb3BlID0+IHNjb3BlLmlzVmlld3BvcnRTY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChzY29wZSA9PiBzY29wZS52aWV3cG9ydFNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZCh2aWV3cG9ydFNjb3BlID0+IHZpZXdwb3J0U2NvcGUuc291cmNlSXRlbSA9PT0gaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFNjb3BlID0gYXZhaWxhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5wdXNoKC4uLnRoaXMuZm91bmRWaWV3cG9ydFNjb3BlKGluc3RydWN0aW9uLCB2aWV3cG9ydFNjb3BlKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kVmlld3BvcnRzLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBhcnJheVJlbW92ZShhdmFpbGFibGVWaWV3cG9ydFNjb3BlcywgYXZhaWxhYmxlID0+IGF2YWlsYWJsZSA9PT0gaW5zdHJ1Y3Rpb24udmlld3BvcnRTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbmZpZ3VyZWQgdmlld3BvcnQgaXMgcnVsaW5nXG4gICAgICAgIHdoaWxlICgoaW5zdHJ1Y3Rpb24gPSB2aWV3cG9ydEluc3RydWN0aW9ucy5uZXh0KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5uZWVkc1ZpZXdwb3J0RGVzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBhdmFpbGFibGVWaWV3cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGF2YWlsYWJsZVZpZXdwb3J0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbHNvIGNoZWNrIGlmIChyZXNvbHZlZCkgY29tcG9uZW50IHdhbnRzIGEgc3BlY2lmaWMgdmlld3BvcnRcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnQ/LndhbnRDb21wb25lbnQoaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5mb3VuZFZpZXdwb3J0KGluc3RydWN0aW9uLCB2aWV3cG9ydCwgZGlzcmVnYXJkVmlld3BvcnRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRWaWV3cG9ydHMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5wdXNoKC4uLnJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVZpZXdwb3J0c1tuYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5leHQgaW4gbGluZSBpcyBzcGVjaWZpZWQgdmlld3BvcnQgKGJ1dCBub3QgaWYgd2UncmUgZGlzcmVnYXJkaW5nIHZpZXdwb3J0cylcbiAgICAgICAgaWYgKCFkaXNyZWdhcmRWaWV3cG9ydHMpIHtcbiAgICAgICAgICAgIHdoaWxlICgoaW5zdHJ1Y3Rpb24gPSB2aWV3cG9ydEluc3RydWN0aW9ucy5uZXh0KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGluc3RydWN0aW9uLnZpZXdwb3J0TmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUgfHwgIW5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTY29wZSA9IGluc3RydWN0aW9uLm93bnNTY29wZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0RW5hYmxlZFZpZXdwb3J0cyhvd25lZFNjb3BlcylbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE5vIGxvbmdlciBwcmUtY3JlYXRpbmcgdmlld3BvcnRzLiBFdmFsdWF0ZSFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWaWV3cG9ydChuYW1lLCBudWxsLCB7IHNjb3BlOiBuZXdTY29wZSwgZm9yY2VEZXNjcmlwdGlvbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlVmlld3BvcnRzW25hbWVdID0gdGhpcy5nZXRFbmFibGVkVmlld3BvcnRzKG93bmVkU2NvcGVzKVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBhdmFpbGFibGVWaWV3cG9ydHNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0Py5hY2NlcHRDb21wb25lbnQoaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5mb3VuZFZpZXdwb3J0KGluc3RydWN0aW9uLCB2aWV3cG9ydCwgZGlzcmVnYXJkVmlld3BvcnRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRWaWV3cG9ydHMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5wdXNoKC4uLnJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVZpZXdwb3J0c1tuYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSwgb25seSBvbmUgYWNjZXB0aW5nIHZpZXdwb3J0IGxlZnQ/XG4gICAgICAgIHdoaWxlICgoaW5zdHJ1Y3Rpb24gPSB2aWV3cG9ydEluc3RydWN0aW9ucy5uZXh0KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdWaWV3cG9ydHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBhdmFpbGFibGVWaWV3cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGF2YWlsYWJsZVZpZXdwb3J0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnQ/LmFjY2VwdENvbXBvbmVudChpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdWaWV3cG9ydHMucHVzaCh2aWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1ZpZXdwb3J0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHJlbWFpbmluZ1ZpZXdwb3J0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMuZm91bmRWaWV3cG9ydChpbnN0cnVjdGlvbiwgdmlld3BvcnQsIGRpc3JlZ2FyZFZpZXdwb3J0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZm91bmRWaWV3cG9ydHMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLnB1c2goLi4ucmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVWaWV3cG9ydHNbdmlld3BvcnQubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBpZ25vcmluZyB2aWV3cG9ydHMsIHdlIG5vdyBtYXRjaCB0aGVtIGFueXdheVxuICAgICAgICBpZiAoZGlzcmVnYXJkVmlld3BvcnRzKSB7XG4gICAgICAgICAgICB3aGlsZSAoKGluc3RydWN0aW9uID0gdmlld3BvcnRJbnN0cnVjdGlvbnMubmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3cG9ydCA9IGluc3RydWN0aW9uLnZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGlmICghdmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGluc3RydWN0aW9uLnZpZXdwb3J0TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuYW1lPy5sZW5ndGggPz8gMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3BlID0gaW5zdHJ1Y3Rpb24ub3duc1Njb3BlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0RW5hYmxlZFZpZXdwb3J0cyhvd25lZFNjb3BlcylbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTm8gbG9uZ2VyIHByZS1jcmVhdGluZyB2aWV3cG9ydHMuIEV2YWx1YXRlIVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWaWV3cG9ydChuYW1lLCBudWxsLCB7IHNjb3BlOiBuZXdTY29wZSwgZm9yY2VEZXNjcmlwdGlvbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVZpZXdwb3J0c1tuYW1lXSA9IHRoaXMuZ2V0RW5hYmxlZFZpZXdwb3J0cyhvd25lZFNjb3BlcylbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQgPSBhdmFpbGFibGVWaWV3cG9ydHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2aWV3cG9ydD8uYWNjZXB0Q29tcG9uZW50KGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMuZm91bmRWaWV3cG9ydChpbnN0cnVjdGlvbiwgdmlld3BvcnQsIGRpc3JlZ2FyZFZpZXdwb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kVmlld3BvcnRzLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdJbnN0cnVjdGlvbnMucHVzaCguLi5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVWaWV3cG9ydHNbdmlld3BvcnQubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucy5yZW1vdmVDdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucyA9IFsuLi52aWV3cG9ydEluc3RydWN0aW9ucywgLi4ucmVtYWluaW5nSW5zdHJ1Y3Rpb25zXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvdW5kVmlld3BvcnRzLFxuICAgICAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmb3VuZFZpZXdwb3J0U2NvcGUoaW5zdHJ1Y3Rpb24sIHZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb24udmlld3BvcnRTY29wZSA9IHZpZXdwb3J0U2NvcGU7XG4gICAgICAgIGluc3RydWN0aW9uLm5lZWRzVmlld3BvcnREZXNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zPy5zbGljZSgpID8/IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlbSBvZiByZW1haW5pbmcpIHtcbiAgICAgICAgICAgIGlmIChyZW0uc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZW0uc2NvcGUgPSB2aWV3cG9ydFNjb3BlLnNjb3BlLnNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgfVxuICAgIGZvdW5kVmlld3BvcnQoaW5zdHJ1Y3Rpb24sIHZpZXdwb3J0LCB3aXRob3V0Vmlld3BvcnRzLCBkb2VzbnROZWVkVmlld3BvcnREZXNjcmliZWQgPSBmYWxzZSkge1xuICAgICAgICBpbnN0cnVjdGlvbi5zZXRWaWV3cG9ydCh2aWV3cG9ydCk7XG4gICAgICAgIGlmIChkb2VzbnROZWVkVmlld3BvcnREZXNjcmliZWQpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLm5lZWRzVmlld3BvcnREZXNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnM/LnNsaWNlKCkgPz8gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVtIG9mIHJlbWFpbmluZykge1xuICAgICAgICAgICAgaWYgKHJlbS5zY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbS5zY29wZSA9IHZpZXdwb3J0LnNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgfVxuICAgIGFkZFZpZXdwb3J0KG5hbWUsIGNvbm5lY3RlZENFLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gdGhpcy5nZXRFbmFibGVkVmlld3BvcnRzKHRoaXMuZ2V0T3duZWRTY29wZXMoKSlbbmFtZV07XG4gICAgICAgIC8vIEVhY2ggYXUtdmlld3BvcnQgZWxlbWVudCBoYXMgaXRzIG93biBWaWV3cG9ydFxuICAgICAgICBpZiAoKChjb25uZWN0ZWRDRSA/PyBudWxsKSAhPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICgodmlld3BvcnQ/LmNvbm5lY3RlZENFID8/IG51bGwpICE9PSBudWxsKSAmJlxuICAgICAgICAgICAgdmlld3BvcnQuY29ubmVjdGVkQ0UgIT09IGNvbm5lY3RlZENFKSB7XG4gICAgICAgICAgICB2aWV3cG9ydC5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0T3duZWRWaWV3cG9ydHModHJ1ZSkuZmluZChjaGlsZCA9PiBjaGlsZC5uYW1lID09PSBuYW1lICYmIGNoaWxkLmNvbm5lY3RlZENFID09PSBjb25uZWN0ZWRDRSkgPz8gbnVsbDtcbiAgICAgICAgICAgIGlmICgodmlld3BvcnQgPz8gbnVsbCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHZpZXdwb3J0ID8/IG51bGwpID09PSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydCh0aGlzLnJvdXRlciwgbmFtZSwgY29ubmVjdGVkQ0UsIHRoaXMuc2NvcGUsICEhb3B0aW9ucy5zY29wZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKHZpZXdwb3J0LmNvbm5lY3RlZFNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNvbm5lY3RlZENFID8/IG51bGwpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3cG9ydC5zZXRDb25uZWN0ZWRDRShjb25uZWN0ZWRDRSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgICByZW1vdmVWaWV3cG9ydCh2aWV3cG9ydCwgY29ubmVjdGVkQ0UpIHtcbiAgICAgICAgaWYgKCgoY29ubmVjdGVkQ0UgPz8gbnVsbCkgIT09IG51bGwpIHx8IHZpZXdwb3J0LnJlbW92ZShjb25uZWN0ZWRDRSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodmlld3BvcnQuY29ubmVjdGVkU2NvcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGRWaWV3cG9ydFNjb3BlKG5hbWUsIGNvbm5lY3RlZENFLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRTY29wZSA9IG5ldyBWaWV3cG9ydFNjb3BlKG5hbWUsIHRoaXMucm91dGVyLCBjb25uZWN0ZWRDRSwgdGhpcy5zY29wZSwgdHJ1ZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodmlld3BvcnRTY29wZS5jb25uZWN0ZWRTY29wZSk7XG4gICAgICAgIHJldHVybiB2aWV3cG9ydFNjb3BlO1xuICAgIH1cbiAgICByZW1vdmVWaWV3cG9ydFNjb3BlKHZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgLy8gdmlld3BvcnRTY29wZS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh2aWV3cG9ydFNjb3BlLmNvbm5lY3RlZFNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFkZENoaWxkKHNjb3BlKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbi5zb21lKHZwID0+IHZwID09PSBzY29wZSkpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5wYXJlbnQucmVtb3ZlQ2hpbGQoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKHNjb3BlKTtcbiAgICAgICAgICAgIHNjb3BlLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGQoc2NvcGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2Yoc2NvcGUpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgc2NvcGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhclJlcGxhY2VkQ2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZWRDaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICBkaXNhYmxlUmVwbGFjZWRDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlZENoaWxkcmVuID0gdGhpcy5lbmFibGVkQ2hpbGRyZW47XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgdGhpcy5yZXBsYWNlZENoaWxkcmVuKSB7XG4gICAgICAgICAgICBzY29wZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVlbmFibGVSZXBsYWNlZENoaWxkcmVuKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHRoaXMucmVwbGFjZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgc2NvcGUuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsVmlld3BvcnRzKGluY2x1ZGVEaXNhYmxlZCA9IGZhbHNlLCBpbmNsdWRlUmVwbGFjZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxTY29wZXMoaW5jbHVkZURpc2FibGVkLCBpbmNsdWRlUmVwbGFjZWQpLmZpbHRlcihzY29wZSA9PiBzY29wZS5pc1ZpZXdwb3J0KS5tYXAoc2NvcGUgPT4gc2NvcGUudmlld3BvcnQpO1xuICAgIH1cbiAgICBhbGxTY29wZXMoaW5jbHVkZURpc2FibGVkID0gZmFsc2UsIGluY2x1ZGVSZXBsYWNlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IGluY2x1ZGVEaXNhYmxlZCA/IHRoaXMuY2hpbGRyZW4uc2xpY2UoKSA6IHRoaXMuZW5hYmxlZENoaWxkcmVuO1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcy5zbGljZSgpKSB7XG4gICAgICAgICAgICBzY29wZXMucHVzaCguLi5zY29wZS5hbGxTY29wZXMoaW5jbHVkZURpc2FibGVkLCBpbmNsdWRlUmVwbGFjZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH1cbiAgICByZXBhcmVudFZpZXdwb3J0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICBjb25zdCBzY29wZXMgPSB0aGlzLmhvaXN0ZWRDaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcihzY29wZSA9PiBzY29wZS52aWV3cG9ydEluc3RydWN0aW9uICE9PSBudWxsICYmIHNjb3BlLnZpZXdwb3J0SW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGlmICghc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSW5zdHJ1Y3Rpb25zID0gc2NvcGUucmVwYXJlbnRWaWV3cG9ydEluc3RydWN0aW9ucygpO1xuICAgICAgICAgICAgc2NvcGUudmlld3BvcnRJbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgPVxuICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb25zICE9PSBudWxsICYmIGNoaWxkSW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDAgPyBjaGlsZEluc3RydWN0aW9ucyA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3Blcy5tYXAoc2NvcGUgPT4gc2NvcGUudmlld3BvcnRJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIGZpbmRNYXRjaGluZ1JvdXRlKHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3cG9ydFNjb3BlICYmICF0aGlzLnBhc3NUaHJvdWdoU2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRNYXRjaGluZ1JvdXRlSW5Sb3V0ZXMocGF0aCwgdGhpcy52aWV3cG9ydFNjb3BlLmdldFJvdXRlcygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kTWF0Y2hpbmdSb3V0ZUluUm91dGVzKHBhdGgsIHRoaXMudmlld3BvcnQuZ2V0Um91dGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IE1hdGNoIHNwZWNpZmllZCBuYW1lcyBoZXJlXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lbmFibGVkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gY2hpbGQuZmluZE1hdGNoaW5nUm91dGUocGF0aCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhbkxvYWQocmVjdXJzZSkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gUnVubmVyLnJ1bkFsbCh0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aWV3cG9ydCAhPT0gbnVsbFxuICAgICAgICAgICAgPyBjaGlsZC52aWV3cG9ydC5jYW5Mb2FkKHJlY3Vyc2UpXG4gICAgICAgICAgICA6IGNoaWxkLmNhbkxvYWQocmVjdXJzZSkpKTtcbiAgICAgICAgaWYgKHJlc3VsdHMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cy50aGVuKHJlc29sdmVkUmVzdWx0cyA9PiByZXNvbHZlZFJlc3VsdHMuZXZlcnkocmVzdWx0ID0+IHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBjYW5VbmxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBSdW5uZXIucnVuQWxsKHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpZXdwb3J0ICE9PSBudWxsXG4gICAgICAgICAgICA/IGNoaWxkLnZpZXdwb3J0LmNhblVubG9hZCgpXG4gICAgICAgICAgICA6IGNoaWxkLmNhblVubG9hZCgpKSk7XG4gICAgICAgIGlmIChyZXN1bHRzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMudGhlbihyZXNvbHZlZFJlc3VsdHMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZFJlc3VsdHMuZXZlcnkocmVzdWx0ID0+IHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgbG9hZChyZWN1cnNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBSdW5uZXIucnVuQWxsKHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpZXdwb3J0ICE9PSBudWxsXG4gICAgICAgICAgICA/IGNoaWxkLnZpZXdwb3J0LmxvYWQocmVjdXJzZSlcbiAgICAgICAgICAgIDogY2hpbGQubG9hZChyZWN1cnNlKSkpO1xuICAgICAgICBpZiAocmVzdWx0cyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubG9hZChyZWN1cnNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBSdW5uZXIucnVuQWxsKHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpZXdwb3J0ICE9PSBudWxsXG4gICAgICAgICAgICA/IGNoaWxkLnZpZXdwb3J0LnVubG9hZChyZWN1cnNlKVxuICAgICAgICAgICAgOiBjaGlsZC51bmxvYWQocmVjdXJzZSkpKTtcbiAgICAgICAgaWYgKHJlc3VsdHMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDb250ZW50KCkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gUnVubmVyLnJ1bkFsbCh0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aWV3cG9ydCAhPT0gbnVsbFxuICAgICAgICAgICAgPyBjaGlsZC52aWV3cG9ydC5yZW1vdmVDb250ZW50KClcbiAgICAgICAgICAgIDogY2hpbGQucmVtb3ZlQ29udGVudCgpKSk7XG4gICAgICAgIGlmIChyZXN1bHRzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1hdGNoaW5nUm91dGVJblJvdXRlcyhwYXRoLCByb3V0ZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJvdXRlcyA9IHJvdXRlcy5tYXAocm91dGUgPT4gdGhpcy5lbnN1cmVQcm9wZXJSb3V0ZShyb3V0ZSkpO1xuICAgICAgICBjb25zdCBjUm91dGVzID0gcm91dGVzLm1hcChyb3V0ZSA9PiAoe1xuICAgICAgICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgICAgICAgIGhhbmRsZXI6IHJvdXRlLFxuICAgICAgICB9KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNSb3V0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY1JvdXRlID0gY1JvdXRlc1tpXTtcbiAgICAgICAgICAgIGNSb3V0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4uY1JvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGg6IGAke2NSb3V0ZS5wYXRofS8qcmVtYWluaW5nUGF0aGAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3VuZCA9IG5ldyBGb3VuZFJvdXRlKCk7XG4gICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJysnKSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcbiAgICAgICAgcmVjb2duaXplci5hZGQoY1JvdXRlcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlY29nbml6ZXIucmVjb2duaXplKHBhdGgpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3VuZC5tYXRjaCA9IHJlc3VsdC5lbmRwb2ludC5yb3V0ZS5oYW5kbGVyO1xuICAgICAgICAgICAgZm91bmQubWF0Y2hpbmcgPSBwYXRoO1xuICAgICAgICAgICAgY29uc3QgJHBhcmFtcyA9IHsgLi4ucmVzdWx0LnBhcmFtcyB9O1xuICAgICAgICAgICAgaWYgKCRwYXJhbXMucmVtYWluaW5nUGF0aCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmQucmVtYWluaW5nID0gJHBhcmFtcy5yZW1haW5pbmdQYXRoO1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkoJHBhcmFtcywgJ3JlbWFpbmluZ1BhdGgnKTtcbiAgICAgICAgICAgICAgICBmb3VuZC5tYXRjaGluZyA9IGZvdW5kLm1hdGNoaW5nLnNsaWNlKDAsIGZvdW5kLm1hdGNoaW5nLmluZGV4T2YoZm91bmQucmVtYWluaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZC5wYXJhbXMgPSAkcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZC5mb3VuZENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGNsb25lIGl0IHNvIGNvbmZpZyBkb2Vzbid0IGdldCBtb2RpZmllZFxuICAgICAgICAgICAgZm91bmQuaW5zdHJ1Y3Rpb25zID0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jbG9uZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGZvdW5kLm1hdGNoLmluc3RydWN0aW9ucywgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gZm91bmQuaW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFkZFBhcmFtZXRlcnMoZm91bmQucGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5yb3V0ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnVuc2hpZnQoLi4uaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3VuZC5pbnN0cnVjdGlvbnNbMF0ucm91dGUgPSBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGVuc3VyZVByb3BlclJvdXRlKHJvdXRlKSB7XG4gICAgICAgIGlmIChyb3V0ZS5pZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByb3V0ZS5pZCA9IHJvdXRlLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlLmluc3RydWN0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByb3V0ZS5pbnN0cnVjdGlvbnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJvdXRlLmNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQ6IHJvdXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiByb3V0ZS5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgcm91dGUuaW5zdHJ1Y3Rpb25zID0gTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIudG9WaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLnJvdXRlciwgcm91dGUuaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcCIsImltcG9ydCB7IE9wZW5Qcm9taXNlIH0gZnJvbSAnLi9vcGVuLXByb21pc2UuanMnO1xuZXhwb3J0IGNsYXNzIEVudGl0eSB7XG4gICAgY29uc3RydWN0b3IoZW50aXR5KSB7XG4gICAgICAgIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGVja2VkU3RhdGVzID0gW107XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jUHJvbWlzZSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFN0YXRlQ29vcmRpbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVudGl0aWVzID0gW107XG4gICAgICAgIHRoaXMuaGFzQWxsRW50aXRpZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNoZWNrZWRTeW5jU3RhdGVzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoQElMb2dnZXIgcHJpdmF0ZSByZWFkb25seSBsb2dnZXI6IElMb2dnZXIpIHtcbiAgICAvLyAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLnJvb3Quc2NvcGVUbygnU3RhdGVDb29yZGluYXRvcicpO1xuICAgIC8vICAgdGhpcy5sb2dnZXIudHJhY2UoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAvLyB9XG4gICAgYWRkU3luY1N0YXRlKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gbmV3IE9wZW5Qcm9taXNlKCk7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlcy5zZXQoc3RhdGUsIG9wZW5Qcm9taXNlKTtcbiAgICB9XG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnRW50aXR5IHJlY2VpdmVkJywgZW50aXR5KTtcbiAgICAgICAgY29uc3QgZW50ID0gbmV3IEVudGl0eShlbnRpdHkpO1xuICAgICAgICB0aGlzLmVudGl0aWVzLnB1c2goZW50KTtcbiAgICAgICAgdGhpcy5yZXNldFN5bmNTdGF0ZXMoKTtcbiAgICAgICAgcmV0dXJuIGVudDtcbiAgICB9XG4gICAgYWRkRW50aXR5U3RhdGUoZW50aXR5LCBzdGF0ZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgIyMjIyBFbnRpdHlTdGF0ZSByZWNlaXZlZCAke3N0YXRlfWAsIChlbnRpdHkgYXMgYW55KS5uYW1lKTtcbiAgICAgICAgbGV0IGVudCA9IHRoaXMuZW50aXRpZXMuZmluZChlID0+IGUuZW50aXR5ID09PSBlbnRpdHkpO1xuICAgICAgICBpZiAoZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGVudCA9IHRoaXMuYWRkRW50aXR5KGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZW50LnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgdGhpcy5jaGVja1N5bmNTdGF0ZShzdGF0ZSk7XG4gICAgfVxuICAgIHN5bmNTdGF0ZShzdGF0ZSwgZW50aXR5ID0gbnVsbCkge1xuICAgICAgICBjb25zdCBvcGVuUHJvbWlzZSA9IHRoaXMuc3luY1N0YXRlcy5nZXQoc3RhdGUpO1xuICAgICAgICBpZiAob3BlblByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudCA9IHRoaXMuZW50aXRpZXMuZmluZChlID0+IGUuZW50aXR5ID09PSBlbnRpdHkpO1xuICAgICAgICAgICAgaWYgKGVudD8uc3luY1Byb21pc2UgPT09IG51bGwgJiYgb3BlblByb21pc2UuaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgZW50LnN5bmNTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGVudC5zeW5jUHJvbWlzZSA9IG5ldyBPcGVuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIGVudC5jaGVja2VkU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZFN5bmNTdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHsgdGhpcy5jaGVja1N5bmNTdGF0ZShzdGF0ZSk7IH0pLmNhdGNoKGVyciA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudC5zeW5jUHJvbWlzZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuY2hlY2tTeW5jU3RhdGUoc3RhdGUpO1xuICAgICAgICByZXR1cm4gb3BlblByb21pc2UucHJvbWlzZTtcbiAgICB9XG4gICAgY2hlY2tpbmdTeW5jU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY1N0YXRlcy5oYXMoc3RhdGUpO1xuICAgIH1cbiAgICBmaW5hbEVudGl0eSgpIHtcbiAgICAgICAgdGhpcy5oYXNBbGxFbnRpdGllcyA9IHRydWU7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdGaW5hbCBlbnRpdHkgcmVjZWl2ZWQnLCB0aGlzLmVudGl0aWVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlcy5mb3JFYWNoKChfcHJvbWlzZSwgc3RhdGUpID0+IHRoaXMuY2hlY2tTeW5jU3RhdGUoc3RhdGUpKTtcbiAgICB9XG4gICAgZmluYWxpemUoKSB7IH1cbiAgICBjYW5jZWwoKSB7IH1cbiAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHNob3VsZCBjYW5jZWwgcmVwbGFjZWQgaW5zdHJ1Y3Rpb25zXG4gICAgY2FuY2VsUmVwbGFjZWQobmF2aWdhdGlvbikgeyB9XG4gICAgY2hlY2tTeW5jU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1N0YXRlQ29vcmRpbmF0b3IgY2hlY2sgc3RhdGUnLCBzdGF0ZSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gdGhpcy5zeW5jU3RhdGVzLmdldChzdGF0ZSk7XG4gICAgICAgIGlmIChvcGVuUHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQWxsRW50aXRpZXMgJiZcbiAgICAgICAgICAgIG9wZW5Qcm9taXNlLmlzUGVuZGluZyAmJlxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIHN0YXRlIGhhcyBiZWVuIGRvbmUgYnkgYWxsIHN0YXRlIGVudGl0aWVzIGFuZCBpZiBzbyByZXNvbHZlIHRoZSBwcm9taXNlXG4gICAgICAgICAgICB0aGlzLmVudGl0aWVzLmV2ZXJ5KGVudCA9PiBlbnQuc3RhdGVzLmluY2x1ZGVzKHN0YXRlKSkgJiZcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBzdGF0ZSBoYXMgYmVlbiBjaGVja2VkIChyZWFjaGVkKSBieSBhbGwgc3RhdGUgZW50aXRpZXMgYW5kIGlmIHNvIHJlc29sdmUgdGhlIHByb21pc2VcbiAgICAgICAgICAgICghdGhpcy5jaGVja2VkU3luY1N0YXRlcy5oYXMoc3RhdGUpIHx8IHRoaXMuZW50aXRpZXMuZXZlcnkoZW50ID0+IGVudC5jaGVja2VkU3RhdGVzLmluY2x1ZGVzKHN0YXRlKSkpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eS5zeW5jU3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZXNvbHZpbmcgZW50aXR5IHByb21pc2UgZm9yICcsIHN0YXRlLCAoZW50aXR5LmVudGl0eSBhcyBhbnkpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuc3luY1Byb21pc2U/LnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5LnN5bmNQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5LnN5bmNTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BlblByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyMjIyMgU3RhdGVDb29yZGluYXRvciBzdGF0ZSByZXNvbHZlZCcsIHN0YXRlIC8qLCB0aGlzICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldFN5bmNTdGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlcy5mb3JFYWNoKChwcm9taXNlLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcm9taXNlLmlzUGVuZGluZyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmVudGl0aWVzLmV2ZXJ5KGVudGl0eSA9PiBlbnRpdHkuc3RhdGVzLmluY2x1ZGVzKHN0YXRlKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN5bmNTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLWNvb3JkaW5hdG9yLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IGJvdW5kIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXVlVGFzayB7XG4gICAgY29uc3RydWN0b3IodGFza1F1ZXVlLCBpdGVtLCBjb3N0ID0gMCkge1xuICAgICAgICB0aGlzLnRhc2tRdWV1ZSA9IHRhc2tRdWV1ZTtcbiAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5jb3N0ID0gY29zdDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tRdWV1ZS5yZXNvbHZlKHRoaXMsIHJlc29sdmUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLnJlamVjdCh0aGlzLCByZWplY3QsIHJlYXNvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICAgICAgaWYgKCdleGVjdXRlJyBpbiB0aGlzLml0ZW0pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaXRlbS5leGVjdXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pdGVtKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxufVxuLyoqXG4gKiBBIGZpcnN0LWluLWZpcnN0LW91dCB0YXNrIHF1ZXVlIHRoYXQgb25seSBwcm9jZXNzZXMgdGhlIG5leHQgcXVldWVkIGl0ZW1cbiAqIHdoZW4gdGhlIGN1cnJlbnQgb25lIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBpcyBzcGVjaWZpZWQsIGl0IHJlY2VpdmVzIHRoZSBxdWV1ZWQgaXRlbXMgYXMgdGFza3Mgb25lIGF0IGEgdGltZS4gSWYgbm9cbiAqIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgdGhlIHRhc2tzIHRoZW1zZWx2ZXMgYXJlIGVpdGhlciBleGVjdXRlZCAoaWYgYVxuICogZnVuY3Rpb24pIG9yIHRoZSBleGVjdXRlIG1ldGhvZCBpbiB0aGVtIGFyZSBydW4uIFRoZSBleGVjdXRlZCBmdW5jdGlvblxuICogc2hvdWxkIHJlc29sdmUgb3IgcmVqZWN0IHRoZSB0YXNrIHdoZW4gcHJvY2Vzc2luZyBpcyBkb25lLlxuICogRW5xdWV1ZWQgaXRlbXMnIHRhc2tzIGNhbiBiZSBhd2FpdGVkLiBFbnF1ZXVlZCBpdGVtcyBjYW4gc3BlY2lmeSBhblxuICogKGFyYml0cmFyeSkgZXhlY3V0aW9uIGNvc3QgYW5kIHRoZSBxdWV1ZSBjYW4gYmUgc2V0IHVwIChzdGFydGVkKSB0b1xuICogb25seSBwcm9jZXNzIGEgc3BlY2lmaWMgYW1vdW50IG9mIGV4ZWN1dGlvbiBjb3N0IHBlciBSQUYvdGljay5cbiAqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRFeGVjdXRpb25Db3N0SW5DdXJyZW50VGljayA9IDA7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2sgIT09IG51bGw7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rhc2tRdWV1ZSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYXRmb3JtID0gb3B0aW9ucy5wbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgPSBvcHRpb25zLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljaztcbiAgICAgICAgdGhpcy50YXNrID0gdGhpcy5wbGF0Zm9ybS5kb21Xcml0ZVF1ZXVlLnF1ZXVlVGFzayh0aGlzLmRlcXVldWUsIHsgcGVyc2lzdGVudDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rhc2tRdWV1ZSBoYXMgbm90IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFzay5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuICAgIGVucXVldWUoaXRlbU9ySXRlbXMsIGNvc3RPckNvc3RzKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KGl0ZW1Pckl0ZW1zKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSAobGlzdCA/IGl0ZW1Pckl0ZW1zIDogW2l0ZW1Pckl0ZW1zXSk7XG4gICAgICAgIGNvbnN0IGNvc3RzID0gaXRlbXNcbiAgICAgICAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4gIUFycmF5LmlzQXJyYXkoY29zdE9yQ29zdHMpID8gY29zdE9yQ29zdHMgOiBjb3N0T3JDb3N0c1tpbmRleF0pXG4gICAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogMSk7XG4gICAgICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgdGFza3MucHVzaChpdGVtIGluc3RhbmNlb2YgUXVldWVUYXNrXG4gICAgICAgICAgICAgICAgPyBpdGVtXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNyZWF0ZVF1ZXVlVGFzayhpdGVtLCBjb3N0cy5zaGlmdCgpKSk7IC8vIFRPRE86IEdldCBjYW5jZWxsYWJsZSBpbiBhcyB3ZWxsXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nLnB1c2goLi4udGFza3MpO1xuICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgcmV0dXJuIGxpc3QgPyB0YXNrcyA6IHRhc2tzWzBdO1xuICAgIH1cbiAgICBjcmVhdGVRdWV1ZVRhc2soaXRlbSwgY29zdCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXVlVGFzayh0aGlzLCBpdGVtLCBjb3N0KTtcbiAgICB9XG4gICAgZGVxdWV1ZShkZWx0YSkge1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEV4ZWN1dGlvbkNvc3RJbkN1cnJlbnRUaWNrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgIT09IG51bGwgJiYgZGVsdGEgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmN1cnJlbnRFeGVjdXRpb25Db3N0SW5DdXJyZW50VGljayArICh0aGlzLnBlbmRpbmdbMF0uY29zdCB8fCAwKSA+IHRoaXMuYWxsb3dlZEV4ZWN1dGlvbkNvc3RXaXRoaW5UaWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5wZW5kaW5nLnNoaWZ0KCkgfHwgbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RXhlY3V0aW9uQ29zdEluQ3VycmVudFRpY2sgKz0gdGhpcy5wcm9jZXNzaW5nLmNvc3QgPz8gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMucHJvY2Vzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBuZWVkIHRvIGF3YWl0IHRoaXMgc2luY2UgbmV4dCB0YXNrIHdvbid0IGJlIGRlcXVldWVkIHVudGlsXG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0ZWQgZnVuY3Rpb24gaXMgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcuZXhlY3V0ZSgpLmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnBlbmRpbmcuc3BsaWNlKDAsIHRoaXMucGVuZGluZy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhc2ssIHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9XG4gICAgcmVqZWN0KHRhc2ssIHJlamVjdCwgcmVhc29uKSB7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBib3VuZFxuXSwgVGFza1F1ZXVlLnByb3RvdHlwZSwgXCJkZXF1ZXVlXCIsIG51bGwpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFzay1xdWV1ZS5qcy5tYXAiLCJpbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IFZpZXdwb3J0IH0gZnJvbSAnLi92aWV3cG9ydC5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydEluc3RydWN0aW9uIH0gZnJvbSAnLi92aWV3cG9ydC1pbnN0cnVjdGlvbi5qcyc7XG5leHBvcnQgY29uc3QgQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlciA9IHtcbiAgICBpc05hbWUoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJztcbiAgICB9LFxuICAgIGlzVHlwZShjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIEN1c3RvbUVsZW1lbnQuaXNUeXBlKGNvbXBvbmVudCk7XG4gICAgfSxcbiAgICBpc0luc3RhbmNlKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gIUNvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNOYW1lKGNvbXBvbmVudCkgJiYgIUNvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNUeXBlKGNvbXBvbmVudCk7XG4gICAgfSxcbiAgICBnZXROYW1lKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc05hbWUoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmlzVHlwZShjb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKGNvbXBvbmVudCkubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldE5hbWUoY29tcG9uZW50LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0VHlwZShjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNOYW1lKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNUeXBlKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRJbnN0YW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNOYW1lKGNvbXBvbmVudCkgfHwgQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc1R5cGUoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgVmlld3BvcnRIYW5kbGVSZXNvbHZlciA9IHtcbiAgICBpc05hbWUodmlld3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2aWV3cG9ydCA9PT0gJ3N0cmluZyc7XG4gICAgfSxcbiAgICBpc0luc3RhbmNlKHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiB2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0O1xuICAgIH0sXG4gICAgZ2V0TmFtZSh2aWV3cG9ydCkge1xuICAgICAgICBpZiAoVmlld3BvcnRIYW5kbGVSZXNvbHZlci5pc05hbWUodmlld3BvcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld3BvcnQgPyAodmlld3BvcnQpLm5hbWUgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRJbnN0YW5jZSh2aWV3cG9ydCkge1xuICAgICAgICBpZiAoVmlld3BvcnRIYW5kbGVSZXNvbHZlci5pc05hbWUodmlld3BvcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyID0ge1xuICAgIGNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHJvdXRlciwgbmF2aWdhdGlvbkluc3RydWN0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IHNjb3BlID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgc2NvcGUgPSByb3V0ZXIuZmluZFNjb3BlKG9wdGlvbnMuY29udGV4dCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRpb25JbnN0cnVjdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBub3QgZnJvbSBzY29wZSByb290LCBmaWd1cmUgb3V0IHdoaWNoIHNjb3BlXG4gICAgICAgICAgICAgICAgaWYgKCFuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTY29wZSBtb2RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNhbWUgYXMgbm8gc2NvcGUgbW9kaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmF2aWdhdGlvbkluc3RydWN0aW9ucy5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkluc3RydWN0aW9ucyA9IG5hdmlnYXRpb25JbnN0cnVjdGlvbnMuc2xpY2UoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG91dCBob3cgbWFueSBzY29wZXMgdXB3YXJkcyB3ZSBzaG91bGQgbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5hdmlnYXRpb25JbnN0cnVjdGlvbnMuc3RhcnRzV2l0aCgnLi4vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHNjb3BlLnBhcmVudCB8fCBzY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zID0gbmF2aWdhdGlvbkluc3RydWN0aW9ucy5zbGljZSgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUucGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkluc3RydWN0aW9ucyA9IGAke3Njb3BlLnBhdGh9LyR7bmF2aWdhdGlvbkluc3RydWN0aW9uc31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSByb3V0ZXIucm9vdFNjb3BlLnNjb3BlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBTcGVjaWZpZWQgcm9vdCBzY29wZSB3aXRoIC9cbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSByb3V0ZXIucm9vdFNjb3BlLnNjb3BlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JbnN0cnVjdGlvbnMgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHJvdXRlciwgbmF2aWdhdGlvbkluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5zY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHJvdXRlciwgbmF2aWdhdGlvbkluc3RydWN0aW9ucykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmF2aWdhdGlvbkluc3RydWN0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHJvdXRlciwgW25hdmlnYXRpb25JbnN0cnVjdGlvbnNdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKC4uLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLnBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uIGluc3RhbmNlb2YgVmlld3BvcnRJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0Q29tcG9uZW50ID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SW5zdHJ1Y3Rpb24gPSByb3V0ZXIuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbih2aWV3cG9ydENvbXBvbmVudC5jb21wb25lbnQsIHZpZXdwb3J0Q29tcG9uZW50LnZpZXdwb3J0LCB2aWV3cG9ydENvbXBvbmVudC5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnRDb21wb25lbnQuY2hpbGRyZW4gIT09IHZvaWQgMCAmJiB2aWV3cG9ydENvbXBvbmVudC5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdJbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHJvdXRlciwgdmlld3BvcnRDb21wb25lbnQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChuZXdJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChyb3V0ZXIuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlLXJlc29sdmVycy5qcy5tYXAiLCIvKipcbiAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVJlbW92ZShhcnIsIGZ1bmMpIHtcbiAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgbGV0IGFyckluZGV4ID0gYXJyLmZpbmRJbmRleChmdW5jKTtcbiAgICB3aGlsZSAoYXJySW5kZXggPj0gMCkge1xuICAgICAgICByZW1vdmVkLnB1c2goYXJyLnNwbGljZShhcnJJbmRleCwgMSlbMF0pO1xuICAgICAgICBhcnJJbmRleCA9IGFyci5maW5kSW5kZXgoZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQb3NzaWJsZVByb21pc2UodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgLy8gSWYgd2UndmUgZ290IGEgUHJvbWlzZSwgd2FpdCBmb3IgaXQncyByZXNvbHZlXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudGhlbigocmVzb2x2ZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZFZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKG9sZEZlYXR1cmUsIG5ld0ZlYXR1cmUpIHtcbiAgICBjb25zb2xlLndhcm4oYFtEZXByZWNhdGVkXSBUaGUgJHtvbGRGZWF0dXJlfSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSAke25ld0ZlYXR1cmV9IGluc3RlYWQuYCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IHBhcnNlUXVlcnkgfSBmcm9tICcuL3BhcnNlci5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydEluc3RydWN0aW9uIH0gZnJvbSAnLi92aWV3cG9ydC1pbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uIH0gZnJvbSAnLi9uYXZpZ2F0aW9uLmpzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJy4vcnVubmVyLmpzJztcbmltcG9ydCB7IEF3YWl0YWJsZU1hcCB9IGZyb20gJy4vYXdhaXRhYmxlLW1hcC5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG4gKi9cbmV4cG9ydCB2YXIgQ29udGVudFN0YXR1cztcbihmdW5jdGlvbiAoQ29udGVudFN0YXR1cykge1xuICAgIENvbnRlbnRTdGF0dXNbQ29udGVudFN0YXR1c1tcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgIENvbnRlbnRTdGF0dXNbQ29udGVudFN0YXR1c1tcImNyZWF0ZWRcIl0gPSAxXSA9IFwiY3JlYXRlZFwiO1xuICAgIENvbnRlbnRTdGF0dXNbQ29udGVudFN0YXR1c1tcImFjdGl2YXRlZFwiXSA9IDNdID0gXCJhY3RpdmF0ZWRcIjtcbn0pKENvbnRlbnRTdGF0dXMgfHwgKENvbnRlbnRTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuICovXG5leHBvcnQgY2xhc3MgVmlld3BvcnRDb250ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBDYW4gKGFuZCB3YW50cykgYmUgYSAocmVzb2x2ZWQpIHR5cGUgb3IgYSBzdHJpbmcgKHRvIGJlIHJlc29sdmVkIGxhdGVyKVxuICAgIC8vIHB1YmxpYyBjb250ZW50OiBWaWV3cG9ydEluc3RydWN0aW9uID0gbmV3IFZpZXdwb3J0SW5zdHJ1Y3Rpb24oJycpLFxuICAgIGNvbnRlbnQgPSBWaWV3cG9ydEluc3RydWN0aW9uLmNyZWF0ZShudWxsLCAnJyksIGluc3RydWN0aW9uID0gbmV3IE5hdmlnYXRpb24oe1xuICAgICAgICBpbnN0cnVjdGlvbjogJycsXG4gICAgICAgIGZ1bGxTdGF0ZUluc3RydWN0aW9uOiAnJyxcbiAgICB9KSwgY29ubmVjdGVkQ0UgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgLy8gcHVibGljIGNvbnRlbnRTdGF0dXM6IENvbnRlbnRTdGF0dXMgPSBDb250ZW50U3RhdHVzLm5vbmU7XG4gICAgICAgIHRoaXMuY29udGVudFN0YXRlcyA9IG5ldyBBd2FpdGFibGVNYXAoKTtcbiAgICAgICAgLy8gcHVibGljIGNvbnRlbnRTdGF0ZXM6IE1hcDxDb250ZW50U3RhdGUsIHVuZGVmaW5lZD4gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJvbUNhY2hlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJvbUhpc3RvcnkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWVudHJ5ID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdCBhIGNvbnRhaW5lciwgd2UncmUgZ29vZCB0byByZXNvbHZlIHR5cGVcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuaXNDb21wb25lbnRUeXBlKCkgJiYgKGNvbm5lY3RlZENFPy5jb250YWluZXIgPz8gbnVsbCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5jb21wb25lbnRUeXBlID0gdGhpcy50b0NvbXBvbmVudFR5cGUoY29ubmVjdGVkQ0UuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29tcG9uZW50SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfVxuICAgIGdldCB2aWV3cG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC52aWV3cG9ydDtcbiAgICB9XG4gICAgZXF1YWxDb21wb25lbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zYW1lQ29tcG9uZW50KG90aGVyLmNvbnRlbnQpO1xuICAgIH1cbiAgICBlcXVhbFBhcmFtZXRlcnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zYW1lQ29tcG9uZW50KG90aGVyLmNvbnRlbnQsIHRydWUpICYmXG4gICAgICAgICAgICAvLyBUT0RPOiBSZXZpZXcgd2hldGhlciBxdWVyeSBpcyByZWxldmFudFxuICAgICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbi5xdWVyeSA9PT0gb3RoZXIuaW5zdHJ1Y3Rpb24ucXVlcnk7XG4gICAgfVxuICAgIHJlZW50cnlCZWhhdmlvcigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICAgICAgICAgICdyZWVudHJ5QmVoYXZpb3InIGluIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlLnJlZW50cnlCZWhhdmlvciAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UucmVlbnRyeUJlaGF2aW9yXG4gICAgICAgICAgICA6IFwiZGVmYXVsdFwiIC8qIGRlZmF1bHQgKi87XG4gICAgfVxuICAgIGlzQ2FjaGVFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNhbWVDb21wb25lbnQob3RoZXIuY29udGVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnRlbnRDb250cm9sbGVyKGNvbm5lY3RlZENFKSB7XG4gICAgICAgIHJldHVybiBDb250cm9sbGVyLmZvckN1c3RvbUVsZW1lbnQobnVsbCwgY29ubmVjdGVkQ0UuY29udGFpbmVyLCB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UsIGNvbm5lY3RlZENFLmVsZW1lbnQsIG51bGwsIHZvaWQgMCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbXBvbmVudChjb25uZWN0ZWRDRSwgZmFsbGJhY2spIHtcbiAgICAgICAgLy8gaWYgKHRoaXMuY29udGVudFN0YXR1cyAhPT0gQ29udGVudFN0YXR1cy5ub25lKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdjcmVhdGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCBsb2FkIGNhY2hlZCBjb250ZW50IG9yIGluc3RhbnRpYXRlZCBoaXN0b3J5IGNvbnRlbnRcbiAgICAgICAgaWYgKCF0aGlzLmZyb21DYWNoZSAmJiAhdGhpcy5mcm9tSGlzdG9yeSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLnRvQ29tcG9uZW50SW5zdGFuY2UoY29ubmVjdGVkQ0UuY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnNldFBhcmFtZXRlcnMoeyBpZDogdGhpcy5jb250ZW50LmNvbXBvbmVudE5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5zZXRDb21wb25lbnQoZmFsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy50b0NvbXBvbmVudEluc3RhbmNlKGNvbm5lY3RlZENFLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRlbnRTdGF0ZXMuc2V0KCdjcmVhdGVkJywgdm9pZCAwKTtcbiAgICAgICAgLy8gdGhpcy5jb250ZW50U3RhdHVzID0gQ29udGVudFN0YXR1cy5jcmVhdGVkO1xuICAgICAgICAvLyBpZiAodGhpcy5jb250ZW50U3RhdHVzICE9PSBDb250ZW50U3RhdHVzLmNyZWF0ZWQgfHwgIXRoaXMubG9hZGVkIHx8ICF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgLy8gaWYgKHRoaXMuY29udGVudFN0YXR1cyAhPT0gQ29udGVudFN0YXR1cy5jcmVhdGVkIHx8IHRoaXMubG9hZGVkIHx8ICF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2xvYWRlZCcpIHx8ICF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmNvbnRlbnRTdGF0dXMgPSBDb250ZW50U3RhdHVzLmxvYWRlZDtcbiAgICAgICAgLy8gRG9uJ3QgbG9hZCBjYWNoZWQgY29udGVudCBvciBpbnN0YW50aWF0ZWQgaGlzdG9yeSBjb250ZW50XG4gICAgICAgIGlmICghdGhpcy5mcm9tQ2FjaGUgfHwgIXRoaXMuZnJvbUhpc3RvcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNvbnRlbnRDb250cm9sbGVyKGNvbm5lY3RlZENFKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucGFyZW50ID0gY29ubmVjdGVkQ0UuY29udHJvbGxlcjsgLy8gQ3VzdG9tRWxlbWVudC5mb3IoY29ubmVjdGVkQ0UuZWxlbWVudCkhO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHB1YmxpYyBkZXN0cm95Q29tcG9uZW50KCk6IHZvaWQge1xuICAgIC8vICAgLy8gVE9ETzogV2UgbWlnaHQgd2FudCB0byBkbyBzb21ldGhpbmcgaGVyZSBldmVudHVhbGx5LCB3aG8ga25vd3M/XG4gICAgLy8gICAvLyBpZiAodGhpcy5jb250ZW50U3RhdHVzICE9PSBDb250ZW50U3RhdHVzLmNyZWF0ZWQpIHtcbiAgICAvLyAgIGlmICghdGhpcy5jb250ZW50U3RhdGVzLmhhcygnY3JlYXRlZCcpKSB7XG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyAgIH1cbiAgICAvLyAgIC8vIERvbid0IGRlc3Ryb3kgY29tcG9uZW50cyB3aGVuIHN0YXRlZnVsXG4gICAgLy8gICAvLyB0aGlzLmNvbnRlbnRTdGF0dXMgPSBDb250ZW50U3RhdHVzLm5vbmU7XG4gICAgLy8gICB0aGlzLmNvbnRlbnRTdGF0ZXMuZGVsZXRlKCdjcmVhdGVkJyk7XG4gICAgLy8gfVxuICAgIGNhbkxvYWQodmlld3BvcnQsIHByZXZpb3VzSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdjcmVhdGVkJykgfHwgKHRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2d1YXJkZWQnKSAmJiAhdGhpcy5yZWVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZW50U3RhdGVzLnNldCgnZ3VhcmRlZCcsIHZvaWQgMCk7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UuY2FuTG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLmNvbnRlbnQuY29tcG9uZW50VHlwZSA/IHRoaXMuY29udGVudC5jb21wb25lbnRUeXBlLnBhcmFtZXRlcnMgOiBudWxsO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uLnBhcmFtZXRlcnMgPSB0aGlzLmNvbnRlbnQudG9TcGVjaWZpZWRQYXJhbWV0ZXJzKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0geyAuLi5wYXJzZVF1ZXJ5KHRoaXMuaW5zdHJ1Y3Rpb24ucXVlcnkpLCAuLi50aGlzLmluc3RydWN0aW9uLnBhcmFtZXRlcnMgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlLmNhbkxvYWQobWVyZ2VkLCB0aGlzLmluc3RydWN0aW9uLCBwcmV2aW91c0luc3RydWN0aW9uKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmlld3BvcnQucm91dGVyLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24ocmVzdWx0LCB2aWV3cG9ydCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhblVubG9hZChuZXh0SW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgfHwgIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5jYW5VbmxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50U3RhdGVzLmhhcygnbG9hZGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UuY2FuVW5sb2FkKG5leHRJbnN0cnVjdGlvbiwgdGhpcy5pbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBhc3luYyBjYW5VbmxvYWQobmV4dEluc3RydWN0aW9uOiBOYXZpZ2F0aW9uIHwgbnVsbCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vICAgaWYgKCF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgfHwgIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5jYW5VbmxvYWQpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gICB9XG4gICAgLy8gICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UuY2FuVW5sb2FkKG5leHRJbnN0cnVjdGlvbiwgdGhpcy5pbnN0cnVjdGlvbik7XG4gICAgLy8gICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gICAgIHJldHVybiByZXN1bHQ7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gcmVzdWx0O1xuICAgIC8vIH1cbiAgICBsb2FkKHByZXZpb3VzSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgLy8gaWYgKCF0aGlzLnJlZW50cnkgJiYgKHRoaXMuY29udGVudFN0YXR1cyAhPT0gQ29udGVudFN0YXR1cy5jcmVhdGVkIHx8IHRoaXMubG9hZGVkKSkge1xuICAgICAgICAvLyBpZiAoIXRoaXMucmVlbnRyeSAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICAvLyBpZiAoIXRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2NyZWF0ZWQnKSB8fCAodGhpcy5jb250ZW50U3RhdGVzLmhhcygnbG9hZGVkJykgJiYgIXRoaXMucmVlbnRyeSkpIHtcbiAgICAgICAgLy8gICByZXR1cm47XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gdGhpcy5yZWVudHJ5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHRoaXMuY29udGVudFN0YXRlcy5hd2FpdCgnZ3VhcmRlZCcpLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2NyZWF0ZWQnKSB8fCAodGhpcy5jb250ZW50U3RhdGVzLmhhcygnbG9hZGVkJykgJiYgIXRoaXMucmVlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsb2FkZWQnLCB0aGlzLmNvbnRlbnQuY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTdGF0ZXMuc2V0KCdsb2FkZWQnLCB2b2lkIDApO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSAmJiB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UubG9hZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5jb250ZW50LmNvbXBvbmVudFR5cGUgPyB0aGlzLmNvbnRlbnQuY29tcG9uZW50VHlwZS5wYXJhbWV0ZXJzIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RydWN0aW9uLnBhcmFtZXRlcnMgPSB0aGlzLmNvbnRlbnQudG9TcGVjaWZpZWRQYXJhbWV0ZXJzKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWQgPSB7IC4uLnBhcnNlUXVlcnkodGhpcy5pbnN0cnVjdGlvbi5xdWVyeSksIC4uLnRoaXMuaW5zdHJ1Y3Rpb24ucGFyYW1ldGVycyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UubG9hZChtZXJnZWQsIHRoaXMuaW5zdHJ1Y3Rpb24sIHByZXZpb3VzSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5sb2FkKG5leHRJbnN0cnVjdGlvbikge1xuICAgICAgICAvLyBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50U3RhdGVzLmhhcygnbG9hZGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnbG9hZGVkJywgdGhpcy5jb250ZW50LmNvbXBvbmVudE5hbWUsICdkZWxldGVkJyk7XG4gICAgICAgIHRoaXMuY29udGVudFN0YXRlcy5kZWxldGUoJ2xvYWRlZCcpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlICYmIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS51bmxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UudW5sb2FkKG5leHRJbnN0cnVjdGlvbiwgdGhpcy5pbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVibGljIHVubG9hZENvbXBvbmVudChjYWNoZTogVmlld3BvcnRDb250ZW50W10sIHN0YXRlZnVsOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAvLyAgIC8vIFRPRE86IFdlIG1pZ2h0IHdhbnQgdG8gZG8gc29tZXRoaW5nIGhlcmUgZXZlbnR1YWxseSwgd2hvIGtub3dzP1xuICAgIC8vICAgLy8gaWYgKHRoaXMuY29udGVudFN0YXR1cyAhPT0gQ29udGVudFN0YXR1cy5hY3RpdmF0ZWQpIHtcbiAgICAvLyAgIGlmICghdGhpcy5jb250ZW50U3RhdGVzLmhhcygnY3JlYXRlZCcpKSB7XG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyAgIH1cbiAgICAvLyAgIC8vIERvbid0IHVubG9hZCBjb21wb25lbnRzIHdoZW4gc3RhdGVmdWxcbiAgICAvLyAgIC8vIFRPRE86IFdlJ3JlIG1pc3Npbmcgc3R1ZmYgaGVyZVxuICAgIC8vICAgaWYgKCFzdGF0ZWZ1bCkge1xuICAgIC8vICAgICAvLyB0aGlzLmNvbnRlbnRTdGF0dXMgPSBDb250ZW50U3RhdHVzLmNyZWF0ZWQ7XG4gICAgLy8gICAgIHRoaXMuY29udGVudFN0YXRlcy5kZWxldGUoJ2NyZWF0ZWQnKTtcbiAgICAvLyAgIH0gZWxzZSB7XG4gICAgLy8gICAgIGNhY2hlLnB1c2godGhpcyk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIGFjdGl2YXRlQ29tcG9uZW50KGluaXRpYXRvciwgcGFyZW50LCBmbGFncywgY29ubmVjdGVkQ0UsIHBhcmVudEFjdGl2YXRlZCkge1xuICAgICAgICAvLyBpZiAodGhpcy5jb250ZW50U3RhdGVzLmhhcygnYWN0aXZhdGVkJykgfHwgIXRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2NyZWF0ZWQnKSkge1xuICAgICAgICAvLyBpZiAodGhpcy5jb250ZW50U3RhdGVzLmhhcygnYWN0aXZhdGVkJykpIHtcbiAgICAgICAgLy8gICByZXR1cm47XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gdGhpcy5jb250ZW50U3RhdGVzLnNldCgnYWN0aXZhdGVkJywgdm9pZCAwKTtcbiAgICAgICAgLy8gLy8gaWYgKHBhcmVudEFjdGl2YXRlZCkgeyAvLyBQYXJlbnQgaXMgYWxyZWFkeSBwYXJ0IG9mIGFuIGFjdGl2YXRpb25cbiAgICAgICAgLy8gLy8gICByZXR1cm4gO1xuICAgICAgICAvLyAvLyB9XG4gICAgICAgIC8vIGNvbnN0IGNvbnRlbnRDb250cm9sbGVyID0gdGhpcy5jb250ZW50Q29udHJvbGxlcihjb25uZWN0ZWRDRSk7XG4gICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHRoaXMuY29udGVudFN0YXRlcy5hd2FpdCgnbG9hZGVkJyksICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdhY3RpdmF0ZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGVudFN0YXRlcy5zZXQoJ2FjdGl2YXRlZCcsIHZvaWQgMCk7XG4gICAgICAgICAgICAvLyBpZiAocGFyZW50QWN0aXZhdGVkKSB7IC8vIFBhcmVudCBpcyBhbHJlYWR5IHBhcnQgb2YgYW4gYWN0aXZhdGlvblxuICAgICAgICAgICAgLy8gICByZXR1cm4gO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRyb2xsZXIgPSB0aGlzLmNvbnRlbnRDb250cm9sbGVyKGNvbm5lY3RlZENFKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Q29udHJvbGxlci5hY3RpdmF0ZShpbml0aWF0b3IgPz8gY29udGVudENvbnRyb2xsZXIsIG51bGwgLyogVE9ETzogdGFrZSBiYWNrOiBwYXJlbnQhICovLCBmbGFncyk7XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb21DYWNoZSB8fCB0aGlzLmZyb21IaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5mcm9tKGNvbm5lY3RlZENFLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKCdhdS1lbGVtZW50LXNjcm9sbCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3RvcCwgbGVmdF0gPSBhdHRyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2F1LWVsZW1lbnQtc2Nyb2xsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zY3JvbGxUbygrbGVmdCwgK3RvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgYXN5bmMgYWN0aXZhdGVDb21wb25lbnQoaW5pdGlhdG9yOiBJSHlkcmF0ZWRDb250cm9sbGVyIHwgbnVsbCwgcGFyZW50OiBJQ3VzdG9tRWxlbWVudENvbnRyb2xsZXI8SUN1c3RvbUVsZW1lbnRWaWV3TW9kZWw+IHwgbnVsbCwgZmxhZ3M6IExpZmVjeWNsZUZsYWdzLCBjb25uZWN0ZWRDRTogSUNvbm5lY3RlZEN1c3RvbUVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyAgIC8vIGlmICh0aGlzLmNvbnRlbnRTdGF0dXMgIT09IENvbnRlbnRTdGF0dXMuY3JlYXRlZCkge1xuICAgIC8vICAgaWYgKCF0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdjcmVhdGVkJykpIHtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vICAgfVxuICAgIC8vICAgLy8gdGhpcy5jb250ZW50U3RhdHVzID0gQ29udGVudFN0YXR1cy5hY3RpdmF0ZWQ7XG4gICAgLy8gICB0aGlzLmNvbnRlbnRTdGF0ZXMuYWRkKCdhY3RpdmF0ZWQnKTtcbiAgICAvLyAgIGNvbnN0IGNvbnRlbnRDb250cm9sbGVyID0gdGhpcy5jb250ZW50Q29udHJvbGxlcihjb25uZWN0ZWRDRSk7XG4gICAgLy8gICBhd2FpdCBjb250ZW50Q29udHJvbGxlci5hY3RpdmF0ZShpbml0aWF0b3IgPz8gY29udGVudENvbnRyb2xsZXIsIHBhcmVudCEsIGZsYWdzKTtcbiAgICAvLyAgIGlmICh0aGlzLmZyb21DYWNoZSB8fCB0aGlzLmZyb21IaXN0b3J5KSB7XG4gICAgLy8gICAgIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShjb25uZWN0ZWRDRS5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgIC8vICAgICBmb3IgKGNvbnN0IGVsIG9mIGVsZW1lbnRzKSB7XG4gICAgLy8gICAgICAgY29uc3QgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgnYXUtZWxlbWVudC1zY3JvbGwnKTtcbiAgICAvLyAgICAgICBpZiAoYXR0cikge1xuICAgIC8vICAgICAgICAgY29uc3QgW3RvcCwgbGVmdF0gPSBhdHRyLnNwbGl0KCcsJyk7XG4gICAgLy8gICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2F1LWVsZW1lbnQtc2Nyb2xsJyk7XG4gICAgLy8gICAgICAgICBlbC5zY3JvbGxUbygrbGVmdCwgK3RvcCk7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIGRlYWN0aXZhdGVDb21wb25lbnQoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzLCBjb25uZWN0ZWRDRSwgc3RhdGVmdWwgPSBmYWxzZSkge1xuICAgICAgICAvLyBpZiAodGhpcy5jb250ZW50U3RhdHVzICE9PSBDb250ZW50U3RhdHVzLmFjdGl2YXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2FjdGl2YXRlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5jb250ZW50U3RhdHVzID0gQ29udGVudFN0YXR1cy5jcmVhdGVkO1xuICAgICAgICB0aGlzLmNvbnRlbnRTdGF0ZXMuZGVsZXRlKCdhY3RpdmF0ZWQnKTtcbiAgICAgICAgaWYgKHN0YXRlZnVsICYmIGNvbm5lY3RlZENFLmVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGNvbnRlbnRDb250cm9sbGVyID0gdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlIS4kY29udHJvbGxlciE7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmZyb20oY29ubmVjdGVkQ0UuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wID4gMCB8fCBlbC5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXUtZWxlbWVudC1zY3JvbGwnLCBgJHtlbC5zY3JvbGxUb3B9LCR7ZWwuc2Nyb2xsTGVmdH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudENvbnRyb2xsZXIgPSB0aGlzLmNvbnRlbnRDb250cm9sbGVyKGNvbm5lY3RlZENFKTtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gY29udGVudENvbnRyb2xsZXIuZGVhY3RpdmF0ZShpbml0aWF0b3IgPz8gY29udGVudENvbnRyb2xsZXIsIHBhcmVudCwgZmxhZ3MpKTtcbiAgICB9XG4gICAgZGlzcG9zZUNvbXBvbmVudChjb25uZWN0ZWRDRSwgY2FjaGUsIHN0YXRlZnVsID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdjcmVhdGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCB1bmxvYWQgY29tcG9uZW50cyB3aGVuIHN0YXRlZnVsXG4gICAgICAgIC8vIFRPRE86IFdlJ3JlIG1pc3Npbmcgc3R1ZmYgaGVyZVxuICAgICAgICBpZiAoIXN0YXRlZnVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTdGF0ZXMuZGVsZXRlKCdjcmVhdGVkJyk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udHJvbGxlciA9IHRoaXMuY29udGVudENvbnRyb2xsZXIoY29ubmVjdGVkQ0UpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRDb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJlZUNvbnRlbnQoY29ubmVjdGVkQ0UsIG5leHRJbnN0cnVjdGlvbiwgY2FjaGUsIHN0YXRlZnVsID0gZmFsc2UpIHtcbiAgICAgICAgLy8gc3dpdGNoICh0aGlzLmNvbnRlbnRTdGF0dXMpIHtcbiAgICAgICAgLy8gICBjYXNlIENvbnRlbnRTdGF0dXMuYWN0aXZhdGVkOlxuICAgICAgICAvLyAgICAgYXdhaXQgdGhpcy51bmxvYWQobmV4dEluc3RydWN0aW9uKTtcbiAgICAgICAgLy8gICAgIGF3YWl0IHRoaXMuZGVhY3RpdmF0ZUNvbXBvbmVudChudWxsLCBjb25uZWN0ZWRDRSEuY29udHJvbGxlciwgTGlmZWN5Y2xlRmxhZ3Mubm9uZSwgY29ubmVjdGVkQ0UhLCBzdGF0ZWZ1bCk7XG4gICAgICAgIC8vICAgICB0aGlzLnVubG9hZENvbXBvbmVudChjYWNoZSwgc3RhdGVmdWwpOyAvLyBUT0RPOiBIb29rIHVwIHRvIG5ldyBkaXNwb3NlXG4gICAgICAgIC8vICAgY2FzZSBDb250ZW50U3RhdHVzLmNyZWF0ZWQ6XG4gICAgICAgIC8vICAgICB0aGlzLmRlc3Ryb3lDb21wb25lbnQoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBUT0RPOiBGaXggZXhlY3V0aW9uIG9yZGVyIG9uIHRoZXNlXG4gICAgICAgIC8vIFRoZXNlIGFyZSBhbGwgc2FmZSB0byBydW5cbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy51bmxvYWQobmV4dEluc3RydWN0aW9uKSwgKCkgPT4gdGhpcy5kZWFjdGl2YXRlQ29tcG9uZW50KG51bGwsIGNvbm5lY3RlZENFLmNvbnRyb2xsZXIsIDAgLyogbm9uZSAqLywgY29ubmVjdGVkQ0UsIHN0YXRlZnVsKSwgXG4gICAgICAgIC8vICgpID0+IHRoaXMudW5sb2FkQ29tcG9uZW50KGNhY2hlLCBzdGF0ZWZ1bCksIC8vIFRPRE86IEhvb2sgdXAgdG8gbmV3IGRpc3Bvc2VcbiAgICAgICAgLy8gKCkgPT4gdGhpcy5kZXN0cm95Q29tcG9uZW50KCksXG4gICAgICAgICgpID0+IHRoaXMuZGlzcG9zZUNvbXBvbmVudChjb25uZWN0ZWRDRSwgY2FjaGUsIHN0YXRlZnVsKSk7XG4gICAgfVxuICAgIHRvQ29tcG9uZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jb21wb25lbnROYW1lO1xuICAgIH1cbiAgICB0b0NvbXBvbmVudFR5cGUoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRvQ29tcG9uZW50VHlwZShjb250YWluZXIpO1xuICAgIH1cbiAgICB0b0NvbXBvbmVudEluc3RhbmNlKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC50b0NvbXBvbmVudEluc3RhbmNlKGNvbnRhaW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3BvcnQtY29udGVudC5qcy5tYXAiLCJpbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIgfSBmcm9tICcuL3R5cGUtcmVzb2x2ZXJzLmpzJztcbmltcG9ydCB7IFJvdXRlck9wdGlvbnMgfSBmcm9tICcuL3JvdXRlci1vcHRpb25zLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IHZhciBQYXJhbWV0ZXJzVHlwZTtcbihmdW5jdGlvbiAoUGFyYW1ldGVyc1R5cGUpIHtcbiAgICBQYXJhbWV0ZXJzVHlwZVtcIm5vbmVcIl0gPSBcIm5vbmVcIjtcbiAgICBQYXJhbWV0ZXJzVHlwZVtcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XG4gICAgUGFyYW1ldGVyc1R5cGVbXCJhcnJheVwiXSA9IFwiYXJyYXlcIjtcbiAgICBQYXJhbWV0ZXJzVHlwZVtcIm9iamVjdFwiXSA9IFwib2JqZWN0XCI7XG59KShQYXJhbWV0ZXJzVHlwZSB8fCAoUGFyYW1ldGVyc1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBQdWJsaWMgQVBJIC0gVGhlIHZpZXdwb3J0IGluc3RydWN0aW9ucyBhcmUgdGhlIGNvcmUgb2YgdGhlIHJvdXRlcidzIG5hdmlnYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWV3cG9ydEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnROYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld3BvcnROYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyc1N0cmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyc1JlY29yZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyc0xpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnNUeXBlID0gXCJub25lXCIgLyogbm9uZSAqLztcbiAgICAgICAgdGhpcy5vd25zU2NvcGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5leHRTY29wZUluc3RydWN0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAnJztcbiAgICAgICAgdGhpcy52aWV3cG9ydFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZWVkc1ZpZXdwb3J0RGVzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm91dGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3BJbnN0cnVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIgPSBudWxsO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgLy8gICBjb21wb25lbnQ6IENvbXBvbmVudEFwcGVsbGF0aW9uLFxuICAgIC8vICAgdmlld3BvcnQ/OiBWaWV3cG9ydEhhbmRsZSxcbiAgICAvLyAgIHBhcmFtZXRlcnM/OiBDb21wb25lbnRQYXJhbWV0ZXJzLFxuICAgIC8vICAgcHVibGljIG93bnNTY29wZTogYm9vbGVhbiA9IHRydWUsXG4gICAgLy8gICBwdWJsaWMgbmV4dFNjb3BlSW5zdHJ1Y3Rpb25zOiBWaWV3cG9ydEluc3RydWN0aW9uW10gfCBudWxsID0gbnVsbCxcbiAgICAvLyApIHtcbiAgICAvLyAgIHRoaXMuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgLy8gICB0aGlzLnNldFZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgICAvLyAgIHRoaXMuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAvLyB9XG4gICAgc3RhdGljIGNyZWF0ZShpbnN0cnVjdGlvblJlc29sdmVyLCBjb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzLCBvd25zU2NvcGUgPSB0cnVlLCBuZXh0U2NvcGVJbnN0cnVjdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIC8vIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIGNvbXBvbmVudC50aGVuKChyZXNvbHZlZENvbXBvbmVudCkgPT4ge1xuICAgICAgICAvLyAgICAgcmV0dXJuIFZpZXdwb3J0SW5zdHJ1Y3Rpb24uY3JlYXRlKGluc3RydWN0aW9uUmVzb2x2ZXIsIHJlc29sdmVkQ29tcG9uZW50LCB2aWV3cG9ydCwgcGFyYW1ldGVycywgb3duc1Njb3BlLCBuZXh0U2NvcGVJbnN0cnVjdGlvbnMpO1xuICAgICAgICAvLyAgIH0pO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFZpZXdwb3J0SW5zdHJ1Y3Rpb24oKTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24uc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgIGluc3RydWN0aW9uLnNldFZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24uc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24ub3duc1Njb3BlID0gb3duc1Njb3BlO1xuICAgICAgICBpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgPSBuZXh0U2NvcGVJbnN0cnVjdGlvbnM7XG4gICAgICAgIGluc3RydWN0aW9uLnNldEluc3RydWN0aW9uUmVzb2x2ZXIoaW5zdHJ1Y3Rpb25SZXNvbHZlcik7XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICB9XG4gICAgZ2V0IG93bmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydCA/PyB0aGlzLnZpZXdwb3J0U2NvcGUgPz8gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHR5cGVkUGFyYW1ldGVycygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBhcmFtZXRlcnNUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCIgLyogc3RyaW5nICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnNTdHJpbmc7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIiAvKiBhcnJheSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzTGlzdDtcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIiAvKiBvYmplY3QgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyc1JlY29yZDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIucGFyc2VDb21wb25lbnRQYXJhbWV0ZXJzKHRoaXMudHlwZWRQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldCBub3JtYWxpemVkUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlciAhPT0gbnVsbCAmJiB0aGlzLnR5cGVkUGFyYW1ldGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5zdHJpbmdpZnlDb21wb25lbnRQYXJhbWV0ZXJzKHRoaXMucGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBzZXRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmlzTmFtZShjb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldE5hbWUoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmlzVHlwZShjb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSB0aGlzLmdldE5ld05hbWUoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0VHlwZShjb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc0luc3RhbmNlKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0TmV3TmFtZShDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldFR5cGUoY29tcG9uZW50KSk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldFR5cGUoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldEluc3RhbmNlKGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0ID09PSB1bmRlZmluZWQgfHwgdmlld3BvcnQgPT09ICcnKSB7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnROYW1lID0gdmlld3BvcnQ7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnROYW1lID0gdmlld3BvcnQubmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlID0gdmlld3BvcnQub3duaW5nU2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB1bmRlZmluZWQgfHwgcGFyYW1ldGVycyA9PT0gbnVsbCB8fCBwYXJhbWV0ZXJzID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzVHlwZSA9IFwibm9uZVwiIC8qIG5vbmUgKi87XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1ldGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyc1R5cGUgPSBcInN0cmluZ1wiIC8qIHN0cmluZyAqLztcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyc1N0cmluZyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzVHlwZSA9IFwiYXJyYXlcIiAvKiBhcnJheSAqLztcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyc0xpc3QgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzVHlwZSA9IFwib2JqZWN0XCIgLyogb2JqZWN0ICovO1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzUmVjb3JkID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIG9ubHkgd29ya3Mgd2l0aCBvYmplY3RzIGFkZGVkIHRvIG9iamVjdHMhXG4gICAgYWRkUGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNUeXBlID09PSBcIm5vbmVcIiAvKiBub25lICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNUeXBlICE9PSBcIm9iamVjdFwiIC8qIG9iamVjdCAqLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGFkZCBvYmplY3QgcGFyYW1ldGVycyB0byBleGlzdGluZyBub24tb2JqZWN0IHBhcmFtZXRlcnMhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHsgLi4udGhpcy5wYXJhbWV0ZXJzUmVjb3JkLCAuLi5wYXJhbWV0ZXJzIH0pO1xuICAgIH1cbiAgICBzZXRJbnN0cnVjdGlvblJlc29sdmVyKGluc3RydWN0aW9uUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyID0gaW5zdHJ1Y3Rpb25SZXNvbHZlcjtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ29tcG9uZW50TmFtZSgpICYmICF0aGlzLmlzQ29tcG9uZW50VHlwZSgpICYmICF0aGlzLmlzQ29tcG9uZW50SW5zdGFuY2UoKTtcbiAgICB9XG4gICAgaXNDb21wb25lbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNvbXBvbmVudE5hbWUgJiYgIXRoaXMuaXNDb21wb25lbnRUeXBlKCkgJiYgIXRoaXMuaXNDb21wb25lbnRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICBpc0NvbXBvbmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFR5cGUgIT09IG51bGwgJiYgIXRoaXMuaXNDb21wb25lbnRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICBpc0NvbXBvbmVudEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZSAhPT0gbnVsbDtcbiAgICB9XG4gICAgdG9Db21wb25lbnRUeXBlKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudE5hbWUgIT09IG51bGxcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGlzLmNvbXBvbmVudE5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiBjb250YWluZXIgIT09IG51bGxcbiAgICAgICAgICAgICYmIGNvbnRhaW5lci5oYXMoQ3VzdG9tRWxlbWVudC5rZXlGcm9tKHRoaXMuY29tcG9uZW50TmFtZSksIHRydWUpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGNvbnRhaW5lci5nZXRSZXNvbHZlcihDdXN0b21FbGVtZW50LmtleUZyb20odGhpcy5jb21wb25lbnROYW1lKSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgIT09IG51bGwgJiYgcmVzb2x2ZXIuZ2V0RmFjdG9yeSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IHJlc29sdmVyLmdldEZhY3RvcnkoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5UeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9Db21wb25lbnRJbnN0YW5jZShjb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIgIT09IHZvaWQgMCAmJiBjb250YWluZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5pc0NvbXBvbmVudFR5cGUoKVxuICAgICAgICAgICAgICAgID8gY29udGFpbmVyLmdldCh0aGlzLmNvbXBvbmVudFR5cGUpXG4gICAgICAgICAgICAgICAgOiBjb250YWluZXIuZ2V0KEN1c3RvbUVsZW1lbnQua2V5RnJvbSh0aGlzLmNvbXBvbmVudE5hbWUpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50VHlwZSgpICYmXG4gICAgICAgICAgICAgICAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMuY29tcG9uZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBpbnN0YW50aWF0ZScsIHRoaXMuY29tcG9uZW50VHlwZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvVmlld3BvcnRJbnN0YW5jZShyb3V0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZXIuZ2V0Vmlld3BvcnQodGhpcy52aWV3cG9ydE5hbWUpO1xuICAgIH1cbiAgICB0b1NwZWNpZmllZFBhcmFtZXRlcnMoc3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgc3BlY2lmaWNhdGlvbnMgPSBzcGVjaWZpY2F0aW9ucyB8fCBbXTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgc3BlY2lmaWVkID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgc3BlYyBvZiBzcGVjaWZpY2F0aW9ucykge1xuICAgICAgICAgICAgLy8gRmlyc3QgZ2V0IG5hbWVkIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFyYW1ldGVycy5maW5kSW5kZXgocGFyYW0gPT4gcGFyYW0ua2V5ID09PSBzcGVjKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BhcmFtZXRlcl0gPSBwYXJhbWV0ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkW3NwZWNdID0gcGFyYW1ldGVyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGdldCBmaXJzdCB1bm5hbWVkXG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXJhbWV0ZXJzLmZpbmRJbmRleChwYXJhbSA9PiBwYXJhbS5rZXkgPT09IHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3BhcmFtZXRlcl0gPSBwYXJhbWV0ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZFtzcGVjXSA9IHBhcmFtZXRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGFsbCByZW1haW5pbmcgbmFtZWRcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2YgcGFyYW1ldGVycy5maWx0ZXIocGFyYW0gPT4gcGFyYW0ua2V5ICE9PSB2b2lkIDApKSB7XG4gICAgICAgICAgICBzcGVjaWZpZWRbcGFyYW1ldGVyLmtleV0gPSBwYXJhbWV0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gc3BlY2lmaWNhdGlvbnMubGVuZ3RoO1xuICAgICAgICAvLyBBZGQgYWxsIHJlbWFpbmluZyB1bm5hbWVkLi4uXG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIHBhcmFtZXRlcnMuZmlsdGVyKHBhcmFtID0+IHBhcmFtLmtleSA9PT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgLy8gLi53aXRoIGFuIGluZGV4XG4gICAgICAgICAgICBzcGVjaWZpZWRbaW5kZXgrK10gPSBwYXJhbWV0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwZWNpZmllZDtcbiAgICB9XG4gICAgdG9Tb3J0ZWRQYXJhbWV0ZXJzKHNwZWNpZmljYXRpb25zKSB7XG4gICAgICAgIHNwZWNpZmljYXRpb25zID0gc3BlY2lmaWNhdGlvbnMgfHwgW107XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWMgb2Ygc3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGdldCBuYW1lZCBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHBhcmFtZXRlcnMuZmluZEluZGV4KHBhcmFtID0+IHBhcmFtLmtleSA9PT0gc3BlYyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IHsgLi4ucGFyYW1ldGVycy5zcGxpY2UoaW5kZXgsIDEpWzBdIH07XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyLmtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBzb3J0ZWQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGdldCBmaXJzdCB1bm5hbWVkXG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXJhbWV0ZXJzLmZpbmRJbmRleChwYXJhbSA9PiBwYXJhbS5rZXkgPT09IHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0geyAuLi5wYXJhbWV0ZXJzLnNwbGljZShpbmRleCwgMSlbMF0gfTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkLnB1c2gocGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9yIGFuIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZC5wdXNoKHsgdmFsdWU6IHZvaWQgMCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGFsbCByZW1haW5pbmcgbmFtZWRcbiAgICAgICAgY29uc3QgcGFyYW1zID0gcGFyYW1ldGVycy5maWx0ZXIocGFyYW0gPT4gcGFyYW0ua2V5ICE9PSB2b2lkIDApO1xuICAgICAgICBwYXJhbXMuc29ydCgoYSwgYikgPT4gKGEua2V5IHx8ICcnKSA8IChiLmtleSB8fCAnJykgPyAxIDogKGIua2V5IHx8ICcnKSA8IChhLmtleSB8fCAnJykgPyAtMSA6IDApO1xuICAgICAgICBzb3J0ZWQucHVzaCguLi5wYXJhbXMpO1xuICAgICAgICAvLyBBZGQgYWxsIHJlbWFpbmluZyB1bm5hbWVkLi4uXG4gICAgICAgIHNvcnRlZC5wdXNoKC4uLnBhcmFtZXRlcnMuZmlsdGVyKHBhcmFtID0+IHBhcmFtLmtleSA9PT0gdm9pZCAwKSk7XG4gICAgICAgIHJldHVybiBzb3J0ZWQ7XG4gICAgfVxuICAgIHNhbWVDb21wb25lbnQob3RoZXIsIGNvbXBhcmVQYXJhbWV0ZXJzID0gZmFsc2UsIGNvbXBhcmVUeXBlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGNvbXBhcmVQYXJhbWV0ZXJzICYmICF0aGlzLnNhbWVQYXJhbWV0ZXJzKG90aGVyLCBjb21wYXJlVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGUgPyB0aGlzLmNvbXBvbmVudFR5cGUgPT09IG90aGVyLmNvbXBvbmVudFR5cGUgOiB0aGlzLmNvbXBvbmVudE5hbWUgPT09IG90aGVyLmNvbXBvbmVudE5hbWU7XG4gICAgfVxuICAgIC8vIFRPRE86IFNvbWV3aGVyZSB3ZSBuZWVkIHRvIGNoZWNrIGZvciBmb3JtYXQgc3VjaCBhcyBzcGFjZXMgZXRjXG4gICAgc2FtZVBhcmFtZXRlcnMob3RoZXIsIGNvbXBhcmVUeXBlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNhbWVDb21wb25lbnQob3RoZXIsIGZhbHNlLCBjb21wYXJlVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMuY29tcG9uZW50VHlwZSA/IHRoaXMuY29tcG9uZW50VHlwZS5wYXJhbWV0ZXJzIDogW107XG4gICAgICAgIGNvbnN0IG1pbmUgPSB0aGlzLnRvU3BlY2lmaWVkUGFyYW1ldGVycyh0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IG90aGVyLnRvU3BlY2lmaWVkUGFyYW1ldGVycyh0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtaW5lKS5ldmVyeShrZXkgPT4gbWluZVtrZXldID09PSBvdGhlcnNba2V5XSlcbiAgICAgICAgICAgICYmIE9iamVjdC5rZXlzKG90aGVycykuZXZlcnkoa2V5ID0+IG90aGVyc1trZXldID09PSBtaW5lW2tleV0pO1xuICAgIH1cbiAgICBzYW1lVmlld3BvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQgIT09IG51bGwgJiYgb3RoZXIudmlld3BvcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0ID09PSBvdGhlci52aWV3cG9ydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY29wZSA9PT0gb3RoZXIuc2NvcGUgJiZcbiAgICAgICAgICAgICh0aGlzLnZpZXdwb3J0ID8gdGhpcy52aWV3cG9ydC5uYW1lIDogdGhpcy52aWV3cG9ydE5hbWUpID09PSAob3RoZXIudmlld3BvcnQgPyBvdGhlci52aWV3cG9ydC5uYW1lIDogb3RoZXIudmlld3BvcnROYW1lKTtcbiAgICB9XG4gICAgZ2V0TmV3TmFtZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudE5hbWUgPT09IG51bGxcbiAgICAgICAgLy8gfHwgIXR5cGUuYWxpYXNlcz8uaW5jbHVkZXModGhpcy5jb21wb25lbnROYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldE5hbWUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50TmFtZTtcbiAgICB9XG59XG5WaWV3cG9ydEluc3RydWN0aW9uLmluamVjdCA9IFtSb3V0ZXJPcHRpb25zXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdwb3J0LWluc3RydWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi9zY29wZS5qcyc7XG5pbXBvcnQgeyBhcnJheVJlbW92ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnLi9ydW5uZXIuanMnO1xuZXhwb3J0IGNsYXNzIFZpZXdwb3J0U2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHJvdXRlciwgY29ubmVjdGVkQ0UsIG93bmluZ1Njb3BlLCBzY29wZSwgcm9vdENvbXBvbmVudFR5cGUgPSBudWxsLCAvLyB0ZW1wb3JhcnkuIE1ldGFkYXRhIHdpbGwgcHJvYmFibHkgZWxpbWluYXRlIGl0XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICAgY2F0Y2hlczogW10sXG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICB9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZENFID0gY29ubmVjdGVkQ0U7XG4gICAgICAgIHRoaXMucm9vdENvbXBvbmVudFR5cGUgPSByb290Q29tcG9uZW50VHlwZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0Q29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VJdGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2VJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZSA9IG5ldyBTY29wZShyb3V0ZXIsIHNjb3BlLCBvd25pbmdTY29wZSwgbnVsbCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gcm91dGVyLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24odGhpcy5jYXRjaGVzWzBdLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkU2NvcGUuc2NvcGU7XG4gICAgfVxuICAgIGdldCBvd25pbmdTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkU2NvcGUub3duaW5nU2NvcGU7XG4gICAgfVxuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRTY29wZS5lbmFibGVkO1xuICAgIH1cbiAgICBzZXQgZW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkU2NvcGUuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIGdldCBpc1ZpZXdwb3J0KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBpc1ZpZXdwb3J0U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudCA9PT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhc3NUaHJvdWdoU2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RDb21wb25lbnRUeXBlID09PSBudWxsICYmIHRoaXMuY2F0Y2hlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGdldCBzaWJsaW5ncygpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5jb25uZWN0ZWRTY29wZS5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudC5lbmFibGVkQ2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoY2hpbGQgPT4gY2hpbGQuaXNWaWV3cG9ydFNjb3BlICYmIGNoaWxkLnZpZXdwb3J0U2NvcGUubmFtZSA9PT0gdGhpcy5uYW1lKVxuICAgICAgICAgICAgLm1hcChjaGlsZCA9PiBjaGlsZC52aWV3cG9ydFNjb3BlKTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb3VyY2UgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IGNhdGNoZXMoKSB7XG4gICAgICAgIGxldCBjYXRjaGVzID0gdGhpcy5vcHRpb25zLmNhdGNoZXMgfHwgW107XG4gICAgICAgIGlmICh0eXBlb2YgY2F0Y2hlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNhdGNoZXMgPSBjYXRjaGVzLnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhdGNoZXM7XG4gICAgfVxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICBpZiAodGhpcy5jYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhdGNoZXNbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5leHRDb250ZW50QWN0aXZhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5wYXJlbnQ/Lm93bmVyPy5uZXh0Q29udGVudEFjdGl2YXRlZCA/PyBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudE5leHRDb250ZW50QWN0aXZhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5wYXJlbnQ/Lm93bmVyPy5uZXh0Q29udGVudEFjdGl2YXRlZCA/PyBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5leHRDb250ZW50QWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBjb250ZW50TmFtZSA9IHRoaXMuY29udGVudD8uY29tcG9uZW50TmFtZSA/PyAnJztcbiAgICAgICAgY29uc3QgbmV4dENvbnRlbnROYW1lID0gdGhpcy5uZXh0Q29udGVudD8uY29tcG9uZW50TmFtZSA/PyAnJztcbiAgICAgICAgcmV0dXJuIGB2czoke3RoaXMubmFtZX1bJHtjb250ZW50TmFtZX0tPiR7bmV4dENvbnRlbnROYW1lfV1gO1xuICAgIH1cbiAgICBzZXROZXh0Q29udGVudCh2aWV3cG9ydEluc3RydWN0aW9uLCBuYXZpZ2F0aW9uKSB7XG4gICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb24udmlld3BvcnRTY29wZSA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVtb3ZlID0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0NsZWFyVmlld3BvcnRJbnN0cnVjdGlvbih2aWV3cG9ydEluc3RydWN0aW9uKVxuICAgICAgICAgICAgfHwgdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0NsZWFyQWxsVmlld3BvcnRzSW5zdHJ1Y3Rpb24odmlld3BvcnRJbnN0cnVjdGlvbik7XG4gICAgICAgIHRoaXMuYWRkID0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0FkZFZpZXdwb3J0SW5zdHJ1Y3Rpb24odmlld3BvcnRJbnN0cnVjdGlvbilcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkodGhpcy5zb3VyY2UpO1xuICAgICAgICBpZiAodGhpcy5hZGQpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwICYmIHZpZXdwb3J0SW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbi5jb21wb25lbnROYW1lID0gdGhpcy5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dENvbnRlbnQgPSB2aWV3cG9ydEluc3RydWN0aW9uO1xuICAgICAgICByZXR1cm4gJ3N3YXAnO1xuICAgIH1cbiAgICB0cmFuc2l0aW9uKGNvb3JkaW5hdG9yKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdWaWV3cG9ydFNjb3BlIHN3YXAnLyosIHRoaXMsIGNvb3JkaW5hdG9yKi8pO1xuICAgICAgICBSdW5uZXIucnVuKCgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdndWFyZGVkVW5sb2FkJyksICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdndWFyZGVkTG9hZCcpLCAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnZ3VhcmRlZCcpLCAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnbG9hZGVkJyksICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICd1bmxvYWRlZCcpLCAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAncm91dGVkJyksICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdzd2FwcGVkJyksICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9ICF0aGlzLnJlbW92ZSA/IHRoaXMubmV4dENvbnRlbnQgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudCA9IG51bGw7XG4gICAgICAgICAgICBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnY29tcGxldGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYW5VbmxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYW5Mb2FkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdW5sb2FkKCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcHVibGljIGxvYWRDb250ZW50KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vICAgdGhpcy5jb250ZW50ID0gIXRoaXMucmVtb3ZlID8gdGhpcy5uZXh0Q29udGVudCA6IG51bGw7XG4gICAgLy8gICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAvLyAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgLy8gfVxuICAgIGZpbmFsaXplQ29udGVudENoYW5nZSgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZpZXdwb3J0U2NvcGUgZmluYWxpemluZycsIHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZSAmJiBBcnJheS5pc0FycmF5KHRoaXMuc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTb3VyY2VJdGVtKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWJvcnRDb250ZW50Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYWRkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc291cmNlLmluZGV4T2YodGhpcy5zb3VyY2VJdGVtKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUl0ZW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgYWNjZXB0U2VnbWVudChzZWdtZW50KSB7XG4gICAgICAgIGlmIChzZWdtZW50ID09PSBudWxsICYmIHNlZ21lbnQgPT09IHZvaWQgMCB8fCBzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZ21lbnQgPT09IHRoaXMucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICB8fCBzZWdtZW50ID09PSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmFkZFZpZXdwb3J0SW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIHx8IHNlZ21lbnQgPT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2F0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhdGNoZXMuaW5jbHVkZXMoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhdGNoZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuaW5jbHVkZXMoJyonKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGJpbmRpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlIHx8IFtdO1xuICAgICAgICBpZiAoc291cmNlLmxlbmd0aCA+IDAgJiYgdGhpcy5zb3VyY2VJdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUl0ZW0gPSB0aGlzLmdldEF2YWlsYWJsZVNvdXJjZUl0ZW0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmJpbmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUl0ZW0gIT09IG51bGwgJiYgdGhpcy5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5UmVtb3ZlKHRoaXMuc291cmNlLCAoaXRlbSkgPT4gaXRlbSA9PT0gdGhpcy5zb3VyY2VJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUl0ZW0gPSBudWxsO1xuICAgIH1cbiAgICBnZXRBdmFpbGFibGVTb3VyY2VJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5zaWJsaW5ncztcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc2libGluZ3MuZXZlcnkoc2libGluZyA9PiBzaWJsaW5nLnNvdXJjZUl0ZW0gIT09IGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFkZFNvdXJjZUl0ZW0oKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2UucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIHJlbW92ZVNvdXJjZUl0ZW0oKSB7XG4gICAgICAgIHRoaXMuc291cmNlSXRlbUluZGV4ID0gdGhpcy5zb3VyY2UuaW5kZXhPZih0aGlzLnNvdXJjZUl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VJdGVtSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3BsaWNlKHRoaXMuc291cmNlSXRlbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSb3V0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RDb21wb25lbnRUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290Q29tcG9uZW50VHlwZS5yb3V0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3BvcnQtc2NvcGUuanMubWFwIiwiaW1wb3J0IHsgQ3VzdG9tRWxlbWVudCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG5pbXBvcnQgeyBhcnJheVJlbW92ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgVmlld3BvcnRDb250ZW50IH0gZnJvbSAnLi92aWV3cG9ydC1jb250ZW50LmpzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi9zY29wZS5qcyc7XG5pbXBvcnQgeyBSdW5uZXIgfSBmcm9tICcuL3J1bm5lci5qcyc7XG5leHBvcnQgY2xhc3MgVmlld3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKHJvdXRlciwgbmFtZSwgY29ubmVjdGVkQ0UsIG93bmluZ1Njb3BlLCBzY29wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZENFID0gY29ubmVjdGVkQ0U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubmV4dENvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJyc7XG4gICAgICAgIHRoaXMuZm9yY2VSZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGVhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25SZXNvbHZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZpZXdwb3J0U3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNhY2hlID0gW107XG4gICAgICAgIHRoaXMuaGlzdG9yeUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuY29udGVudCA9IG5ldyBWaWV3cG9ydENvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZSA9IG5ldyBTY29wZShyb3V0ZXIsIHNjb3BlLCBvd25pbmdTY29wZSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkU2NvcGUuc2NvcGU7XG4gICAgfVxuICAgIGdldCBvd25pbmdTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkU2NvcGUub3duaW5nU2NvcGU7XG4gICAgfVxuICAgIGdldCBjb25uZWN0ZWRDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRDRT8uJGNvbnRyb2xsZXIgPz8gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZFNjb3BlLmVuYWJsZWQ7XG4gICAgfVxuICAgIHNldCBlbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZS5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB9XG4gICAgZ2V0IGlzVmlld3BvcnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgaXNWaWV3cG9ydFNjb3BlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlID09PSBudWxsO1xuICAgIH1cbiAgICBnZXQgZG9Gb3JjZVJlbW92ZSgpIHtcbiAgICAgICAgbGV0IHNjb3BlID0gdGhpcy5jb25uZWN0ZWRTY29wZTtcbiAgICAgICAgd2hpbGUgKHNjb3BlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUudmlld3BvcnQgIT09IG51bGwgJiYgc2NvcGUudmlld3BvcnQuZm9yY2VSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50ID8/IHRoaXMuY29udGVudDtcbiAgICB9XG4gICAgZ2V0IG5leHRDb250ZW50QWN0aXZhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29udGVudD8uY29udGVudFN0YXRlcy5oYXMoJ2FjdGl2YXRlZCcpID8/IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcGFyZW50TmV4dENvbnRlbnRBY3RpdmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnBhcmVudD8ub3duZXI/Lm5leHRDb250ZW50QWN0aXZhdGVkID8/IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcGVyZm9ybUxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiAhPT0gJ3NraXAnICYmIHRoaXMuY29ubmVjdGVkU2NvcGUucGFyZW50TmV4dENvbnRlbnRBY3Rpb24gIT09ICdzd2FwJztcbiAgICAgICAgLy8gLy8gcmV0dXJuIHRoaXMubmV4dENvbnRlbnRBY3Rpb24gIT09ICdza2lwJyAmJiAoKHRoaXMubmV4dENvbnRlbnQ/LmNvbnRlbnQudG9wSW5zdHJ1Y3Rpb24gPz8gZmFsc2UpIHx8IHRoaXMuY2xlYXIpO1xuICAgIH1cbiAgICBnZXQgcGVyZm9ybVN3YXAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiAhPT0gJ3NraXAnICYmIHRoaXMuY29ubmVjdGVkU2NvcGUucGFyZW50TmV4dENvbnRlbnRBY3Rpb24gIT09ICdzd2FwJztcbiAgICAgICAgLy8gLy8gcmV0dXJuIHRoaXMubmV4dENvbnRlbnRBY3Rpb24gIT09ICdza2lwJyAmJiAoKHRoaXMubmV4dENvbnRlbnQ/LmNvbnRlbnQudG9wSW5zdHJ1Y3Rpb24gPz8gZmFsc2UpIHx8IHRoaXMuY2xlYXIpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgY29udGVudE5hbWUgPSB0aGlzLmNvbnRlbnQ/LmNvbnRlbnQuY29tcG9uZW50TmFtZSA/PyAnJztcbiAgICAgICAgY29uc3QgbmV4dENvbnRlbnROYW1lID0gdGhpcy5uZXh0Q29udGVudD8uY29udGVudC5jb21wb25lbnROYW1lID8/ICcnO1xuICAgICAgICByZXR1cm4gYHY6JHt0aGlzLm5hbWV9WyR7Y29udGVudE5hbWV9LT4ke25leHRDb250ZW50TmFtZX1dYDtcbiAgICB9XG4gICAgc2V0TmV4dENvbnRlbnQodmlld3BvcnRJbnN0cnVjdGlvbiwgbmF2aWdhdGlvbikge1xuICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9uLnNldFZpZXdwb3J0KHRoaXMpO1xuICAgICAgICB0aGlzLmNsZWFyID0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0NsZWFyVmlld3BvcnRJbnN0cnVjdGlvbih2aWV3cG9ydEluc3RydWN0aW9uKTtcbiAgICAgICAgLy8gQ2FuIGhhdmUgYSAocmVzb2x2ZWQpIHR5cGUgb3IgYSBzdHJpbmcgKHRvIGJlIHJlc29sdmVkIGxhdGVyKVxuICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbmV3IFZpZXdwb3J0Q29udGVudCghdGhpcy5jbGVhciA/IHZpZXdwb3J0SW5zdHJ1Y3Rpb24gOiB2b2lkIDAsIG5hdmlnYXRpb24sIHRoaXMuY29ubmVjdGVkQ0UgPz8gbnVsbCk7XG4gICAgICAgIHRoaXMubmV4dENvbnRlbnQuZnJvbUhpc3RvcnkgPSB0aGlzLm5leHRDb250ZW50LmNvbXBvbmVudEluc3RhbmNlICYmIG5hdmlnYXRpb24ubmF2aWdhdGlvblxuICAgICAgICAgICAgPyAhIW5hdmlnYXRpb24ubmF2aWdhdGlvbi5iYWNrIHx8ICEhbmF2aWdhdGlvbi5uYXZpZ2F0aW9uLmZvcndhcmRcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhdGVmdWwpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBhIHBhcmFtZXRlciBoZXJlIHRvIGRlY2lkZSByZXF1aXJlZCBlcXVhbGl0eVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5jYWNoZS5maW5kKChpdGVtKSA9PiB0aGlzLm5leHRDb250ZW50LmlzQ2FjaGVFcXVhbChpdGVtKSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudCA9IGNhY2hlZDtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDb250ZW50LmZyb21DYWNoZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnB1c2godGhpcy5uZXh0Q29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpbGRyZW4gdGhhdCB3aWxsIGJlIHJlcGxhY2VkICh1bmxlc3MgYWRkZWQgYWdhaW4pIGJ5IG5leHQgY29udGVudC4gV2lsbFxuICAgICAgICAvLyBiZSByZS1lbmFibGVkIG9uIGNhbmNlbFxuICAgICAgICB0aGlzLmNvbm5lY3RlZFNjb3BlLmNsZWFyUmVwbGFjZWRDaGlsZHJlbigpO1xuICAgICAgICAvLyBJZiB3ZSBnZXQgdGhlIHNhbWUgX2luc3RhbmNlXywgZG9uJ3QgZG8gYW55dGhpbmcgKGhhcHBlbnMgd2l0aCBjYWNoZWQgYW5kIGhpc3RvcnkpXG4gICAgICAgIGlmICh0aGlzLm5leHRDb250ZW50LmNvbXBvbmVudEluc3RhbmNlICE9PSBudWxsICYmIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSA9PT0gdGhpcy5uZXh0Q29udGVudC5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiA9ICdza2lwJzsgLy8gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuZXF1YWxDb21wb25lbnQodGhpcy5uZXh0Q29udGVudCkgfHxcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkU2NvcGUucGFyZW50TmV4dENvbnRlbnRBY3Rpb24gPT09ICdzd2FwJyB8fCAvLyBTb21lIHBhcmVudCBoYXMgYmVlbiBzd2FwcGVkLCBuZWVkIHRvIGJlIG5ldyBjb21wb25lbnRcbiAgICAgICAgICAgIG5hdmlnYXRpb24ubmF2aWdhdGlvbi5yZWZyZXNoIHx8IC8vIE5hdmlnYXRpb24gJ3JlZnJlc2gnIHBlcmZvcm1lZFxuICAgICAgICAgICAgdGhpcy5jb250ZW50LnJlZW50cnlCZWhhdmlvcigpID09PSBcInJlZnJlc2hcIiAvKiByZWZyZXNoICovIC8vIFJlZW50cnlCZWhhdmlvciAncmVmcmVzaCcgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkU2NvcGUuZGlzYWJsZVJlcGxhY2VkQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJ3N3YXAnOyAvLyB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBvbmVudCBpcyB0aGUgc2FtZSBuYW1lL3R5cGVcbiAgICAgICAgLy8gRXhwbGljaXRseSBkb24ndCBhbGxvdyBuYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIHNhbWUgY29tcG9uZW50IGFnYWluXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQucmVlbnRyeUJlaGF2aW9yKCkgPT09IFwiZGlzYWxsb3dcIiAvKiBkaXNhbGxvdyAqLykge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiA9ICdza2lwJzsgLy8gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhwbGljaXRseSByZS1sb2FkIHNhbWUgY29tcG9uZW50IGFnYWluXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQucmVlbnRyeUJlaGF2aW9yKCkgPT09IFwibG9hZFwiIC8qIGxvYWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5yZWVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmV4dENvbnRlbnQuY29udGVudC5zZXRDb21wb25lbnQodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIC8vIHRoaXMubmV4dENvbnRlbnQuY29udGVudFN0YXR1cyA9IHRoaXMuY29udGVudC5jb250ZW50U3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudC5jb250ZW50U3RhdGVzID0gdGhpcy5jb250ZW50LmNvbnRlbnRTdGF0ZXMuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vIHRoaXMubmV4dENvbnRlbnQuY29udGVudFN0YXRlcyA9IG5ldyBNYXAodGhpcy5jb250ZW50LmNvbnRlbnRTdGF0ZXMpO1xuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudC5yZWVudHJ5ID0gdGhpcy5jb250ZW50LnJlZW50cnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiA9ICdyZWxvYWQnOyAvLyB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZW50cnlCZWhhdmlvciBpcyBub3cgJ2RlZmF1bHQnXG4gICAgICAgIC8vIFJlcXVpcmVzIHVwZGF0ZWQgcGFyYW1ldGVycyBpZiB2aWV3cG9ydCBzdGF0ZWZ1bFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXRlZnVsICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuZXF1YWxQYXJhbWV0ZXJzKHRoaXMubmV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJ3NraXAnOyAvLyBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5lcXVhbFBhcmFtZXRlcnModGhpcy5uZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEZpeCBhIGNvbmZpZyBvcHRpb24gZm9yIHRoaXNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgICAgIGlmIChmYWxzZSkgeyAvLyBSZS11c2UgY29tcG9uZW50LCBvbmx5IHJlbG9hZCB3aXRoIG5ldyBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnJlZW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENvbnRlbnQuY29udGVudC5zZXRDb21wb25lbnQodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDb250ZW50LmNvbnRlbnRTdGF0ZXMgPSB0aGlzLmNvbnRlbnQuY29udGVudFN0YXRlcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENvbnRlbnQucmVlbnRyeSA9IHRoaXMuY29udGVudC5yZWVudHJ5O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJ3JlbG9hZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gUGVyZm9ybSBhIGZ1bGwgc3dhcFxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkU2NvcGUuZGlzYWJsZVJlcGxhY2VkQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiA9ICdzd2FwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmdcbiAgICAgICAgcmV0dXJuICdza2lwJztcbiAgICAgICAgLy8gLy8gRGVmYXVsdCBpcyB0byB0cmlnZ2VyIGEgcmVmcmVzaCAod2l0aG91dCBhIGNoZWNrIG9mIHBhcmFtZXRlcnMpXG4gICAgICAgIC8vIHRoaXMuY29ubmVjdGVkU2NvcGUuZGlzYWJsZVJlcGxhY2VkQ2hpbGRyZW4oKTtcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMubmV4dENvbnRlbnRBY3Rpb24gPSAncmVsb2FkJzsgLy8gdHJ1ZTtcbiAgICB9XG4gICAgc2V0Q29ubmVjdGVkQ0UoY29ubmVjdGVkQ0UsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZENFICE9PSBjb25uZWN0ZWRDRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVzdG9yZSB0aGlzIHN0YXRlIG9uIG5hdmlnYXRpb24gY2FuY2VsXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzVmlld3BvcnRTdGF0ZSA9IHsgLi4udGhpcyB9O1xuICAgICAgICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZENFID0gY29ubmVjdGVkQ0U7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51c2VkQnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudXNlZEJ5ID0gb3B0aW9ucy51c2VkQnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRlZmF1bHQgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mYWxsYmFjayA9IG9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ub0xpbmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubm9MaW5rID0gb3B0aW9ucy5ub0xpbms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ub1RpdGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm5vVGl0bGUgPSBvcHRpb25zLm5vVGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ub0hpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubm9IaXN0b3J5ID0gb3B0aW9ucy5ub0hpc3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0ZWZ1bCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdGF0ZWZ1bCA9IG9wdGlvbnMuc3RhdGVmdWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uUmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBNaWdodCBub3QgbmVlZCB0aGlzPyBGaWd1cmUgaXQgb3V0XG4gICAgICAgIC8vIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgLy8gICBjb250YWluZXJbJ3ZpZXdwb3J0TmFtZSddID0gdGhpcy5uYW1lO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlICYmICghdGhpcy5uZXh0Q29udGVudCB8fCAhdGhpcy5uZXh0Q29udGVudC5jb21wb25lbnRJbnN0YW5jZSkgJiYgdGhpcy5vcHRpb25zLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIucGFyc2VWaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLm9wdGlvbnMuZGVmYXVsdCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIFNldCB0byBuYW1lIHRvIGJlIGRlbGF5ZWQgb25lIHR1cm5cbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5zZXRWaWV3cG9ydCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnNjb3BlID0gdGhpcy5vd25pbmdTY29wZTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5kZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm91dGVyLmxvYWQoaW5zdHJ1Y3Rpb25zLCB7IGFwcGVuZDogdHJ1ZSB9KS5jYXRjaChlcnJvciA9PiB7IHRocm93IGVycm9yOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoY29ubmVjdGVkQ0UpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkQ0UgPT09IGNvbm5lY3RlZENFKSB7XG4gICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmZyZWVDb250ZW50KHRoaXMuY29ubmVjdGVkQ0UsICh0aGlzLm5leHRDb250ZW50ID8gdGhpcy5uZXh0Q29udGVudC5pbnN0cnVjdGlvbiA6IG51bGwpLCB0aGlzLmhpc3RvcnlDYWNoZSwgdGhpcy5kb0ZvcmNlUmVtb3ZlID8gZmFsc2UgOiB0aGlzLnJvdXRlci5zdGF0ZWZ1bEhpc3RvcnkgfHwgdGhpcy5vcHRpb25zLnN0YXRlZnVsKTsgLy8gLmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb0ZvcmNlUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIHRoaXMuaGlzdG9yeUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVzLnB1c2goKCkgPT4gY29udGVudC5mcmVlQ29udGVudChudWxsLCBudWxsLCB0aGlzLmhpc3RvcnlDYWNoZSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVzLnB1c2goKCkgPT4geyB0aGlzLmhpc3RvcnlDYWNoZSA9IFtdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oLi4ucmVtb3Zlcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmhpc3RvcnlDYWNoZS5tYXAoY29udGVudCA9PiBjb250ZW50LmZyZWVDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICAvLyAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICB0aGlzLmhpc3RvcnlDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gKSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmhpc3RvcnlDYWNoZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJhbnNpdGlvbihjb29yZGluYXRvcikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVmlld3BvcnQgdHJhbnNpdGlvbicsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIC8vIGxldCBydW46IHVua25vd247XG4gICAgICAgIGNvbnN0IGd1YXJkZWQgPSBjb29yZGluYXRvci5jaGVja2luZ1N5bmNTdGF0ZSgnZ3VhcmRlZCcpO1xuICAgICAgICBjb25zdCBwZXJmb3JtTG9hZCA9IHRoaXMucGVyZm9ybUxvYWQgfHwgIWd1YXJkZWQ7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1Td2FwID0gdGhpcy5wZXJmb3JtU3dhcCB8fCAhZ3VhcmRlZDtcbiAgICAgICAgLy8gY29uc3QgcGVyZm9ybVN3YXAgPSB0aGlzLnBlcmZvcm1Td2FwIHx8ICF0aGlzLnJvdXRlci5pc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uIHx8IHRoaXMuY2xlYXI7XG4gICAgICAgIGNvbnN0IGd1YXJkU3RlcHMgPSBbXG4gICAgICAgICAgICAoKSA9PiBwZXJmb3JtTG9hZCA/IHRoaXMuY2FuVW5sb2FkKCkgOiB0cnVlLFxuICAgICAgICAgICAgKGNhblVubG9hZFJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY2FuVW5sb2FkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIFJ1bm5lci5jYW5jZWwodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0b3IuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm91dGVyLmlzUmVzdHJpY3RlZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudC5jcmVhdGVDb21wb25lbnQodGhpcy5jb25uZWN0ZWRDRSwgdGhpcy5vcHRpb25zLmZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ2d1YXJkZWRVbmxvYWQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiBjb29yZGluYXRvci5zeW5jU3RhdGUoJ2d1YXJkZWRVbmxvYWQnLCB0aGlzKSxcbiAgICAgICAgICAgICgpID0+IHBlcmZvcm1Mb2FkID8gdGhpcy5jYW5Mb2FkKGd1YXJkZWQpIDogdHJ1ZSxcbiAgICAgICAgICAgIChjYW5Mb2FkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW5Mb2FkUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5Mb2FkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSdW5uZXIuY2FuY2VsKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnZ3VhcmRlZExvYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ2d1YXJkZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIERlbmllZCBhbmQgKHByb2JhYmx5KSByZWRpcmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy5yb3V0ZXIubG9hZChjYW5Mb2FkUmVzdWx0LCB7IGFwcGVuZDogdHJ1ZSB9KSwgKCkgPT4gdGhpcy5hYm9ydENvbnRlbnRDaGFuZ2UoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgcm91dGluZ1N0ZXBzID0gW1xuICAgICAgICAgICAgLy8gKCkgPT4geyBjb25zb2xlLmxvZyhcIkknbSB3YWl0aW5nIGZvciBndWFyZGVkXCIsIHRoaXMudG9TdHJpbmcoKSk7IH0sXG4gICAgICAgICAgICAoKSA9PiBjb29yZGluYXRvci5zeW5jU3RhdGUoJ2d1YXJkZWQnLCB0aGlzKSxcbiAgICAgICAgICAgIC8vICgpID0+IHsgY29uc29sZS5sb2coXCJJJ20gZ3VhcmRlZFwiLCB0aGlzLnRvU3RyaW5nKCkpOyB9LFxuICAgICAgICAgICAgLy8gVE9ETzogRm9yIGNvbnNpc3RlbmN5IGl0IHNob3VsZCBwcm9iYWJseSBiZSB0aGlzIG9wdGlvbiB3aXRoICdyb3V0ZWQnXG4gICAgICAgICAgICAvLyAoKSA9PiBwZXJmb3JtU3dhcCA/IHRoaXMudW5sb2FkKGNvb3JkaW5hdG9yLmNoZWNraW5nU3luY1N0YXRlKCdyb3V0ZWQnKSkgOiB0cnVlLFxuICAgICAgICAgICAgKCkgPT4gcGVyZm9ybUxvYWQgPyB0aGlzLnVubG9hZCh0cnVlKSA6IHRydWUsXG4gICAgICAgICAgICAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAndW5sb2FkZWQnKSxcbiAgICAgICAgICAgIC8vICgpID0+IHsgY29uc29sZS5sb2coXCJJJ20gd2FpdGluZyBmb3IgdW5sb2FkZWRcIiwgdGhpcy50b1N0cmluZygpKTsgfSxcbiAgICAgICAgICAgICgpID0+IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgndW5sb2FkZWQnLCB0aGlzKSxcbiAgICAgICAgICAgIC8vICgpID0+IHsgY29uc29sZS5sb2coXCJJJ20gZG9uZSB3YWl0aW5nIGZvciB1bmxvYWRlZFwiLCB0aGlzLnRvU3RyaW5nKCkpOyB9LFxuICAgICAgICAgICAgKCkgPT4gcGVyZm9ybUxvYWQgPyB0aGlzLmxvYWQoY29vcmRpbmF0b3IuY2hlY2tpbmdTeW5jU3RhdGUoJ3JvdXRlZCcpKSA6IHRydWUsXG4gICAgICAgICAgICAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnbG9hZGVkJyksXG4gICAgICAgICAgICAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAncm91dGVkJyksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZVN0ZXBzID0gW1xuICAgICAgICAgICAgKCkgPT4gY29vcmRpbmF0b3Iuc3luY1N0YXRlKCdyb3V0ZWQnLCB0aGlzKSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHBlcmZvcm1Td2FwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3V0ZXIub3B0aW9ucy5zd2FwU3RyYXRlZ3kuaW5jbHVkZXMoJ3BhcmFsbGVsJykpIHtcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVTdGVwcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm91dGVyLm9wdGlvbnMuc3dhcFN0cmF0ZWd5LmluY2x1ZGVzKCdhZGQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4odGhpcy5hZGRDb250ZW50KCksIHRoaXMucmVtb3ZlQ29udGVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuKHRoaXMucmVtb3ZlQ29udGVudCgpLCB0aGlzLmFkZENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpZmVjeWNsZVN0ZXBzLnB1c2goKCkgPT4gcGVyZm9ybVN3YXAgPyAodGhpcy5yb3V0ZXIub3B0aW9ucy5zd2FwU3RyYXRlZ3kuaW5jbHVkZXMoJ2FkZCcpID8gdGhpcy5hZGRDb250ZW50KCkgOiB0aGlzLnJlbW92ZUNvbnRlbnQoKSkgOiB2b2lkIDAsICgpID0+IHBlcmZvcm1Td2FwID8gKHRoaXMucm91dGVyLm9wdGlvbnMuc3dhcFN0cmF0ZWd5LmluY2x1ZGVzKCdhZGQnKSA/IHRoaXMucmVtb3ZlQ29udGVudCgpIDogdGhpcy5hZGRDb250ZW50KCkpIDogdm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaWZlY3ljbGVTdGVwcy5wdXNoKCgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdzd2FwcGVkJykpO1xuICAgICAgICAvLyBjb25zdCBsaWZlY3ljbGVTdGVwcyA9IFtcbiAgICAgICAgLy8gICAoKSA9PiBjb29yZGluYXRvci5zeW5jU3RhdGUoJ3JvdXRlZCcpLFxuICAgICAgICAvLyAgIC8vICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdib3VuZCcpLFxuICAgICAgICAvLyAgICgpID0+IHBlcmZvcm1Td2FwID8gKHRoaXMucm91dGVyLm9wdGlvbnMuc3dhcFN0cmF0ZWd5LmluY2x1ZGVzKCdhZGQnKSA/IHRoaXMuYWRkQ29udGVudCgpIDogdGhpcy5yZW1vdmVDb250ZW50KCkpIDogdHJ1ZSxcbiAgICAgICAgLy8gICAoKSA9PiBwZXJmb3JtU3dhcCA/ICh0aGlzLnJvdXRlci5vcHRpb25zLnN3YXBTdHJhdGVneS5pbmNsdWRlcygnYWRkJykgPyB0aGlzLnJlbW92ZUNvbnRlbnQoKSA6IHRoaXMuYWRkQ29udGVudCgpKSA6IHRydWUsXG4gICAgICAgIC8vICAgKCkgPT4gY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ3N3YXBwZWQnKSxcbiAgICAgICAgLy8gXTtcbiAgICAgICAgLy8gcnVuID1cbiAgICAgICAgUnVubmVyLnJ1biguLi5ndWFyZFN0ZXBzLCAuLi5yb3V0aW5nU3RlcHMsIC4uLmxpZmVjeWNsZVN0ZXBzLCAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnY29tcGxldGVkJykpO1xuICAgIH1cbiAgICBjYW5VbmxvYWQoKSB7XG4gICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd2aWV3cG9ydCBjYW5VbmxvYWQgcnVuJywgdGhpcy5uYW1lLCAnYmVmb3JlJyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbm5lY3RlZFNjb3BlLmNhblVubG9hZCgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZpZXdwb3J0IGNhblVubG9hZCBydW4nLCB0aGlzLm5hbWUsICdhZnRlcicpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgKGNhblVubG9hZENoaWxkcmVuKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndmlld3BvcnQgY2FuVW5sb2FkIHJlc3VsdCcsIHRoaXMubmFtZSwgY2FuVW5sb2FkQ2hpbGRyZW4pO1xuICAgICAgICAgICAgaWYgKCFjYW5VbmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAgICAgLy8gLy8gRG9uJ3Qgc3RvcCBpdCBiZWNhdXNlIHdlJ3JlIG5vdCBnb2luZyB0byBhY3R1YWxseSBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSA9PT0gdGhpcy5uZXh0Q29udGVudD8uY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmNhblVubG9hZCh0aGlzLm5leHRDb250ZW50Py5pbnN0cnVjdGlvbiA/PyBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbkxvYWQocmVjdXJzZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvbm5lY3RlZFNjb3BlLnRvU3RyaW5nKCksICd2aWV3cG9ydCBjb250ZW50IGNhbkxvYWQnLCB0aGlzLm5leHRDb250ZW50Py5jb250ZW50Py5jb21wb25lbnROYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuY2xlYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5uZXh0Q29udGVudD8uY29udGVudCA/PyBudWxsKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy53YWl0Rm9yQ29ubmVjdGVkKCksICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dENvbnRlbnQuY3JlYXRlQ29tcG9uZW50KHRoaXMuY29ubmVjdGVkQ0UsIHRoaXMub3B0aW9ucy5mYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW5cbiAgICAgICAgICAgIC8vIC8vIERvbid0IHN0b3AgaXQgYmVjYXVzZSB3ZSdyZSBub3QgZ29pbmcgdG8gYWN0dWFsbHkgZG8gYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgPT09IHRoaXMubmV4dENvbnRlbnQhLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dENvbnRlbnQuY2FuTG9hZCh0aGlzLCB0aGlzLmNvbnRlbnQuaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9hZChyZWN1cnNlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY29ubmVjdGVkU2NvcGUudG9TdHJpbmcoKSwgJ3ZpZXdwb3J0IGNvbnRlbnQgbG9hZCcsIHRoaXMubmV4dENvbnRlbnQ/LmNvbnRlbnQ/LmNvbXBvbmVudE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5jbGVhciB8fCAodGhpcy5uZXh0Q29udGVudD8uY29tcG9uZW50SW5zdGFuY2UgPz8gbnVsbCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW5cbiAgICAgICAgLy8gLy8gVE9ETzogVmVyaWZ5IHRoaXNcbiAgICAgICAgLy8gaWYgKHRoaXMubmV4dENvbnRlbnQgPT09IHRoaXMuY29udGVudCkge1xuICAgICAgICAvLyAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLm5leHRDb250ZW50Py5sb2FkKHRoaXMuY29udGVudC5pbnN0cnVjdGlvbikpO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5uZXh0Q29udGVudD8ubG9hZCh0aGlzLmNvbnRlbnQuaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAvLyBhd2FpdCB0aGlzLm5leHRDb250ZW50LmFjdGl2YXRlQ29tcG9uZW50KG51bGwsIHRoaXMuY29ubmVjdGVkQ0UhLiRjb250cm9sbGVyIGFzIElDdXN0b21FbGVtZW50Q29udHJvbGxlcjxJQ3VzdG9tRWxlbWVudFZpZXdNb2RlbD4sIExpZmVjeWNsZUZsYWdzLm5vbmUsIHRoaXMuY29ubmVjdGVkQ0UhKTtcbiAgICAgICAgLy8gcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFkZENvbnRlbnQoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdhZGRDb250ZW50JywgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy5hY3RpdmF0ZShudWxsLCB0aGlzLmNvbm5lY3RlZENvbnRyb2xsZXIsIDAgLyogbm9uZSAqLywgdGhpcy5wYXJlbnROZXh0Q29udGVudEFjdGl2YXRlZCkpO1xuICAgIH1cbiAgICByZW1vdmVDb250ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZUNvbnRlbnQnLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLmNvbm5lY3RlZFNjb3BlLnJlbW92ZUNvbnRlbnQoKSwgKCkgPT4gdGhpcy5kZWFjdGl2YXRlKG51bGwsIG51bGwgLyogVE9ETzogdmVyaWZ5IHRoaXMuY29ubmVjdGVkQ29udHJvbGxlciAqLywgMCAvKiBub25lICovKSwgKCkgPT4gdGhpcy5kaXNwb3NlKCkpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZHJlbkNvbnRlbnQoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ3JlbW92ZUNvbnRlbnQnLCB0aGlzLmNvbnRlbnQuY29udGVudCk7XG4gICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+ICF0aGlzLmlzRW1wdHkgPyB0aGlzLmNvbm5lY3RlZFNjb3BlLnJlbW92ZUNvbnRlbnQoKSA6IHZvaWQgMCk7XG4gICAgfVxuICAgIGFjdGl2YXRlKGluaXRpYXRvciwgcGFyZW50LCBmbGFncywgZnJvbVBhcmVudCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnYWN0aXZhdGUnIC8qICwgeyAuLi50aGlzIH0gKi8pO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDb250ZW50LmNvbXBvbmVudEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZFNjb3BlLnJlZW5hYmxlUmVwbGFjZWRDaGlsZHJlbigpO1xuICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy5hY3RpdmVDb250ZW50LmxvYWQodGhpcy5hY3RpdmVDb250ZW50Lmluc3RydWN0aW9uKSwgLy8gT25seSBhY3RzIGlmIG5vdCBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5hY3RpdmVDb250ZW50LmFjdGl2YXRlQ29tcG9uZW50KGluaXRpYXRvciwgcGFyZW50LCBmbGFncywgdGhpcy5jb25uZWN0ZWRDRSwgZnJvbVBhcmVudCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICF0aGlzLmNvbnRlbnQucmVlbnRyeSAmJlxuICAgICAgICAgICAgdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlICE9PSB0aGlzLm5leHRDb250ZW50Py5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy5jb250ZW50Py51bmxvYWQodGhpcy5jb250ZW50Lmluc3RydWN0aW9uKSwgLy8gT25seSBhY3RzIGlmIG5vdCBhbHJlYWR5IHVubG9hZGVkXG4gICAgICAgICAgICAoKSA9PiB0aGlzLmNvbnRlbnQ/LmRlYWN0aXZhdGVDb21wb25lbnQoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzLCB0aGlzLmNvbm5lY3RlZENFLCB0aGlzLnJvdXRlci5zdGF0ZWZ1bEhpc3RvcnkgfHwgdGhpcy5vcHRpb25zLnN0YXRlZnVsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5sb2FkKHJlY3Vyc2UpIHtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gcmVjdXJzZSA/IHRoaXMuY29ubmVjdGVkU2NvcGUudW5sb2FkKHJlY3Vyc2UpIDogdHJ1ZSwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jb25uZWN0ZWRTY29wZS50b1N0cmluZygpLCAndmlld3BvcnQgY29udGVudCB1bmxvYWQnLCB0aGlzLmNvbnRlbnQuY29udGVudC5jb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAgICAgLy8gLy8gVE9ETzogVmVyaWZ5IHRoaXNcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLm5leHRDb250ZW50ID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudW5sb2FkKHRoaXMubmV4dENvbnRlbnQ/Lmluc3RydWN0aW9uID8/IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgIXRoaXMuY29udGVudC5yZWVudHJ5ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgIT09IHRoaXMubmV4dENvbnRlbnQ/LmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bihcbiAgICAgICAgICAgIC8vICgpID0+IHRoaXMuY29udGVudCEudW5sb2FkQ29tcG9uZW50KFxuICAgICAgICAgICAgLy8gICB0aGlzLmhpc3RvcnlDYWNoZSxcbiAgICAgICAgICAgIC8vICAgdGhpcy5yb3V0ZXIuc3RhdGVmdWxIaXN0b3J5IHx8IHRoaXMub3B0aW9ucy5zdGF0ZWZ1bCksXG4gICAgICAgICAgICAvLyAoKSA9PiB0aGlzLmNvbnRlbnQhLmRlc3Ryb3lDb21wb25lbnQoKSxcbiAgICAgICAgICAgICgpID0+IHRoaXMuY29udGVudC5kaXNwb3NlQ29tcG9uZW50KHRoaXMuY29ubmVjdGVkQ0UsIHRoaXMuaGlzdG9yeUNhY2hlLCB0aGlzLnJvdXRlci5zdGF0ZWZ1bEhpc3RvcnkgfHwgdGhpcy5vcHRpb25zLnN0YXRlZnVsKSk7XG4gICAgICAgICAgICAvLyBhd2FpdCB0aGlzLmNvbnRlbnQhLmZyZWVDb250ZW50KFxuICAgICAgICAgICAgLy8gICB0aGlzLmNvbm5lY3RlZENFLFxuICAgICAgICAgICAgLy8gICB0aGlzLm5leHRDb250ZW50IS5pbnN0cnVjdGlvbixcbiAgICAgICAgICAgIC8vICAgdGhpcy5oaXN0b3J5Q2FjaGUsXG4gICAgICAgICAgICAvLyAgIHRoaXMucm91dGVyLnN0YXRlZnVsSGlzdG9yeSB8fCB0aGlzLm9wdGlvbnMuc3RhdGVmdWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsaXplQ29udGVudENoYW5nZSgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZpbmFsaXplQ29udGVudCcsIHRoaXMubmV4dENvbnRlbnQhLmNvbnRlbnQ/LmNvbXBvbmVudE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5uZXh0Q29udGVudC5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5uZXh0Q29udGVudDtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5yZWVudHJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IG5ldyBWaWV3cG9ydENvbnRlbnQodm9pZCAwLCB0aGlzLm5leHRDb250ZW50Lmluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0Q29udGVudEFjdGlvbiA9ICcnO1xuICAgICAgICB0aGlzLnByZXZpb3VzVmlld3BvcnRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkU2NvcGUuY2xlYXJSZXBsYWNlZENoaWxkcmVuKCk7XG4gICAgfVxuICAgIGFib3J0Q29udGVudENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZS5yZWVuYWJsZVJlcGxhY2VkQ2hpbGRyZW4oKTtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy5uZXh0Q29udGVudC5mcmVlQ29udGVudCh0aGlzLmNvbm5lY3RlZENFLCB0aGlzLm5leHRDb250ZW50Lmluc3RydWN0aW9uLCB0aGlzLmhpc3RvcnlDYWNoZSwgdGhpcy5yb3V0ZXIuc3RhdGVmdWxIaXN0b3J5IHx8IHRoaXMub3B0aW9ucy5zdGF0ZWZ1bCksICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzVmlld3BvcnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgdGhpcy5wcmV2aW91c1ZpZXdwb3J0U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudEFjdGlvbiA9ICcnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogRGVhbCB3aXRoIG5vbi1zdHJpbmcgY29tcG9uZW50c1xuICAgIHdhbnRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCB1c2VkQnkgPSB0aGlzLm9wdGlvbnMudXNlZEJ5IHx8IFtdO1xuICAgICAgICBpZiAodHlwZW9mIHVzZWRCeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHVzZWRCeSA9IHVzZWRCeS5zcGxpdCgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VkQnkuaW5jbHVkZXMoY29tcG9uZW50KTtcbiAgICB9XG4gICAgLy8gVE9ETzogRGVhbCB3aXRoIG5vbi1zdHJpbmcgY29tcG9uZW50c1xuICAgIGFjY2VwdENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJy0nIHx8IGNvbXBvbmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZWRCeSA9IHRoaXMub3B0aW9ucy51c2VkQnk7XG4gICAgICAgIGlmICghdXNlZEJ5IHx8ICF1c2VkQnkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVzZWRCeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHVzZWRCeSA9IHVzZWRCeS5zcGxpdCgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VkQnkuaW5jbHVkZXMoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZWRCeS5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZS5pbmNsdWRlcygnKicpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnJlZUNvbnRlbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmhpc3RvcnlDYWNoZS5maW5kKGNhY2hlZCA9PiBjYWNoZWQuY29tcG9uZW50SW5zdGFuY2UgPT09IGNvbXBvbmVudCk7XG4gICAgICAgIGlmIChjb250ZW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudC5mcmVlQ29udGVudChudWxsLCBudWxsLCB0aGlzLmhpc3RvcnlDYWNoZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcnJheVJlbW92ZSh0aGlzLmhpc3RvcnlDYWNoZSwgKGNhY2hlZCA9PiBjYWNoZWQgPT09IGNvbnRlbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJvdXRlcygpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IHRoaXMuZ2V0Q29tcG9uZW50VHlwZSgpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVzID0gY29tcG9uZW50VHlwZS5yb3V0ZXM7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJvdXRlcykgPyByb3V0ZXMgOiBudWxsO1xuICAgIH1cbiAgICBnZXRUaXRsZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1RpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IHRoaXMuZ2V0Q29tcG9uZW50VHlwZSgpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aXRsZSA9ICcnO1xuICAgICAgICBjb25zdCB0eXBlVGl0bGUgPSBjb21wb25lbnRUeXBlLnRpdGxlO1xuICAgICAgICBpZiAodHlwZVRpdGxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVRpdGxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gdHlwZVRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5nZXRDb21wb25lbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gdHlwZVRpdGxlLmNhbGwoY29tcG9uZW50LCBjb21wb25lbnQsIG5hdmlnYXRpb25JbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yb3V0ZXIub3B0aW9ucy50aXRsZS51c2VDb21wb25lbnROYW1lcykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmdldENvbnRlbnRJbnN0cnVjdGlvbigpLmNvbXBvbmVudE5hbWUgPz8gJyc7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLnJvdXRlci5vcHRpb25zLnRpdGxlLmNvbXBvbmVudFByZWZpeCA/PyAnJztcbiAgICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgnLScsICcgJyk7XG4gICAgICAgICAgICB0aXRsZSA9IG5hbWUuc2xpY2UoMCwgMSkudG9Mb2NhbGVVcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm91dGVyLm9wdGlvbnMudGl0bGUudHJhbnNmb3JtVGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLnJvdXRlci5vcHRpb25zLnRpdGxlLnRyYW5zZm9ybVRpdGxlLmNhbGwodGhpcywgdGl0bGUsIHRoaXMuZ2V0Q29udGVudEluc3RydWN0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gICAgZ2V0Q29tcG9uZW50VHlwZSgpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudFR5cGUgPSB0aGlzLmdldENvbnRlbnRJbnN0cnVjdGlvbigpLmNvbXBvbmVudFR5cGUgPz8gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBnb2luZyBhd2F5IG9uY2UgTWV0YWRhdGEgaXMgaW4hXG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gQ3VzdG9tRWxlbWVudC5mb3IodGhpcy5jb25uZWN0ZWRDRS5lbGVtZW50KTtcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBjb250cm9sbGVyLmNvbnRleHRcbiAgICAgICAgICAgICAgICAuY29tcG9uZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50VHlwZSA/PyBudWxsO1xuICAgIH1cbiAgICBnZXRDb21wb25lbnRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGVudEluc3RydWN0aW9uKCkuY29tcG9uZW50SW5zdGFuY2UgPz8gbnVsbDtcbiAgICB9XG4gICAgZ2V0Q29udGVudEluc3RydWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29udGVudD8uY29udGVudCA/PyB0aGlzLmNvbnRlbnQuY29udGVudCA/PyBudWxsO1xuICAgIH1cbiAgICBjbGVhclN0YXRlKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbmV3IFZpZXdwb3J0Q29udGVudCgpO1xuICAgICAgICB0aGlzLmNhY2hlID0gW107XG4gICAgfVxuICAgIHdhaXRGb3JDb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZENFID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3BvcnQuanMubWFwIiwiaW1wb3J0IHsgREksIFJlZ2lzdHJhdGlvbiwgb25SZXNvbHZlLCByZXNvbHZlQWxsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IElOb2RlIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgSUFwcFRhc2sgfSBmcm9tICcuL2FwcC10YXNrLmpzJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnLi90ZW1wbGF0aW5nL2NvbnRyb2xsZXIuanMnO1xuZXhwb3J0IGNvbnN0IElBcHBSb290ID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJQXBwUm9vdCcpO1xuZXhwb3J0IGNsYXNzIEFwcFJvb3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgcGxhdGZvcm0sIGNvbnRhaW5lciwgcm9vdFByb3ZpZGVyLCBlbmhhbmNlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9ICh2b2lkIDApO1xuICAgICAgICB0aGlzLmh5ZHJhdGVQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmhvc3QgPSBjb25maWcuaG9zdDtcbiAgICAgICAgcm9vdFByb3ZpZGVyLnByZXBhcmUodGhpcyk7XG4gICAgICAgIGlmIChjb250YWluZXIuaGFzKElOb2RlLCBmYWxzZSkgJiYgY29udGFpbmVyLmdldChJTm9kZSkgIT09IGNvbmZpZy5ob3N0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVDaGlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShJTm9kZSwgY29uZmlnLmhvc3QpKTtcbiAgICAgICAgaWYgKGVuaGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbmZpZy5jb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLmVuaGFuY2VEZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKEN1c3RvbUVsZW1lbnQuaXNUeXBlKGNvbXBvbmVudClcbiAgICAgICAgICAgICAgICA/IEN1c3RvbUVsZW1lbnQuZGVmaW5lKHsgLi4uQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKGNvbXBvbmVudCksIHRlbXBsYXRlOiB0aGlzLmhvc3QsIGVuaGFuY2U6IHRydWUgfSwgY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIDogQ3VzdG9tRWxlbWVudC5kZWZpbmUoeyBuYW1lOiAodm9pZCAwKSwgdGVtcGxhdGU6IHRoaXMuaG9zdCwgZW5oYW5jZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oeWRyYXRlUHJvbWlzZSA9IG9uUmVzb2x2ZSh0aGlzLnJ1bkFwcFRhc2tzKCdiZWZvcmVDcmVhdGUnKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBDdXN0b21FbGVtZW50LmlzVHlwZShjb25maWcuY29tcG9uZW50KVxuICAgICAgICAgICAgICAgID8gdGhpcy5jb250YWluZXIuZ2V0KGNvbmZpZy5jb21wb25lbnQpXG4gICAgICAgICAgICAgICAgOiBjb25maWcuY29tcG9uZW50O1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9ICh0aGlzLmNvbnRyb2xsZXIgPSBDb250cm9sbGVyLmZvckN1c3RvbUVsZW1lbnQodGhpcywgY29udGFpbmVyLCBpbnN0YW5jZSwgdGhpcy5ob3N0LCBudWxsLCAwIC8qIG5vbmUgKi8sIGZhbHNlLCB0aGlzLmVuaGFuY2VEZWZpbml0aW9uKSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmh5ZHJhdGVDdXN0b21FbGVtZW50KGNvbnRhaW5lciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHRoaXMucnVuQXBwVGFza3MoJ2h5ZHJhdGluZycpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5oeWRyYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5ydW5BcHBUYXNrcygnaHlkcmF0ZWQnKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmh5ZHJhdGVDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmh5ZHJhdGVQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSh0aGlzLmh5ZHJhdGVQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHRoaXMucnVuQXBwVGFza3MoJ2JlZm9yZUFjdGl2YXRlJyksICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHRoaXMuY29udHJvbGxlci5hY3RpdmF0ZSh0aGlzLmNvbnRyb2xsZXIsIG51bGwsIDMyIC8qIGZyb21CaW5kICovLCB2b2lkIDApLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bkFwcFRhc2tzKCdhZnRlckFjdGl2YXRlJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5ydW5BcHBUYXNrcygnYmVmb3JlRGVhY3RpdmF0ZScpLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHRoaXMuY29udHJvbGxlci5kZWFjdGl2YXRlKHRoaXMuY29udHJvbGxlciwgbnVsbCwgMCAvKiBub25lICovKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bkFwcFRhc2tzKCdhZnRlckRlYWN0aXZhdGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHJ1bkFwcFRhc2tzKHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBbGwoLi4udGhpcy5jb250YWluZXIuZ2V0QWxsKElBcHBUYXNrKS5yZWR1Y2UoKHJlc3VsdHMsIHRhc2spID0+IHtcbiAgICAgICAgICAgIGlmICh0YXNrLnNsb3QgPT09IHNsb3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGFzay5ydW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSwgW10pKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyPy5kaXNwb3NlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvb3QuanMubWFwIiwiaW1wb3J0IHsgREksIFJlZ2lzdHJhdGlvbiwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IGNvbnN0IElBcHBUYXNrID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJQXBwVGFzaycpO1xuY2xhc3MgJEFwcFRhc2sge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zbG90ID0gKHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSAodm9pZCAwKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgc3RhdGljIHdpdGgoa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgJEFwcFRhc2soa2V5KTtcbiAgICB9XG4gICAgYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdCgnYmVmb3JlQ3JlYXRlJyk7XG4gICAgfVxuICAgIGh5ZHJhdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoJ2h5ZHJhdGluZycpO1xuICAgIH1cbiAgICBoeWRyYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoJ2h5ZHJhdGVkJyk7XG4gICAgfVxuICAgIGJlZm9yZUFjdGl2YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdCgnYmVmb3JlQWN0aXZhdGUnKTtcbiAgICB9XG4gICAgYWZ0ZXJBY3RpdmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoJ2FmdGVyQWN0aXZhdGUnKTtcbiAgICB9XG4gICAgYmVmb3JlRGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoJ2JlZm9yZURlYWN0aXZhdGUnKTtcbiAgICB9XG4gICAgYWZ0ZXJEZWFjdGl2YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdCgnYWZ0ZXJEZWFjdGl2YXRlJyk7XG4gICAgfVxuICAgIGF0KHNsb3QpIHtcbiAgICAgICAgdGhpcy5zbG90ID0gc2xvdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNhbGwoZm4pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGZuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lci5yZWdpc3RlcihSZWdpc3RyYXRpb24uaW5zdGFuY2UoSUFwcFRhc2ssIHRoaXMpKTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5jb250YWluZXIuZ2V0KHRoaXMua2V5KTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgQXBwVGFzayA9ICRBcHBUYXNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXRhc2suanMubWFwIiwiaW1wb3J0IHsgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IGNvbnN0IElBdHRyU3ludGF4VHJhbnNmb3JtZXIgPSBESVxuICAgIC5jcmVhdGVJbnRlcmZhY2UoJ0lBdHRyU3ludGF4VHJhbnNmb3JtZXInLCB4ID0+IHguc2luZ2xldG9uKEF0dHJTeW50YXhUcmFuc2Zvcm1lcikpO1xuZXhwb3J0IGNsYXNzIEF0dHJTeW50YXhUcmFuc2Zvcm1lciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm5zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGdpdmVuIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBmbnMgdGhhdCB3aWxsIGJlIHVzZWRcbiAgICAgKiB0byBjaGVjayBpZiBgJ2JpbmQnYCBjb21tYW5kIGNhbiBiZSB0cmFuc2Zvcm1lZCB0byBgJ3R3by13YXknYCBjb21tYW5kLlxuICAgICAqXG4gICAgICogSWYgb25lIG9mIHRob3NlIGZ1bmN0aW9ucyBpbiB0aGlzIGxpc3RzIHJldHVybnMgdHJ1ZSwgdGhlIGAnYmluZCdgIGNvbW1hbmRcbiAgICAgKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gYCd0d28td2F5J2AgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIDIgcGFyYW1ldGVyczpcbiAgICAgKiAtIGVsZW1lbnQ6IHRoZSBlbGVtZW50IHRoYXQgdGhlIHRlbXBsYXRlIGNvbXBpbGVyIGlzIGN1cnJlbnRseSB3b3JraW5nIHdpdGhcbiAgICAgKiAtIHByb3BlcnR5OiB0aGUgdGFyZ2V0IHByb3BlcnR5IG5hbWVcbiAgICAgKi9cbiAgICB1c2VUd29XYXkoZm4pIHtcbiAgICAgICAgdGhpcy5mbnMucHVzaChmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRyYW5zZm9ybShub2RlLCBhdHRyU3ludGF4KSB7XG4gICAgICAgIGlmIChhdHRyU3ludGF4LmNvbW1hbmQgPT09ICdiaW5kJyAmJlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgLy8gbm90ZTogZXZlbiB0aG91Z2ggdGFyZ2V0IGNvdWxkIHBvc3NpYmx5IGJlIG1hcHBlZCB0byBhIGRpZmZlcmVudCBuYW1lXG4gICAgICAgICAgICAvLyB0aGUgZmluYWwgcHJvcGVydHkgbmFtZSBzaG91bGRuJ3QgYWZmZWN0IHRoZSB0d28gd2F5IHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGJvdGggc2hvdWxkIHdvcmsgd2l0aCBvcmlnaW5hbCBzb3VyY2UgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIHNob3VsZERlZmF1bHRUb1R3b1dheShub2RlLCBhdHRyU3ludGF4LnRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmZucy5sZW5ndGggPiAwICYmIHRoaXMuZm5zLnNvbWUoZm4gPT4gZm4obm9kZSwgYXR0clN5bnRheC50YXJnZXQpKSkpIHtcbiAgICAgICAgICAgIGF0dHJTeW50YXguY29tbWFuZCA9ICd0d28td2F5JztcbiAgICAgICAgfVxuICAgICAgICBhdHRyU3ludGF4LnRhcmdldCA9IHRoaXMubWFwKG5vZGUudGFnTmFtZSwgYXR0clN5bnRheC50YXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0b2RvOiB0aGlzIHNob3VsZCBiZSBpbiB0aGUgZm9ybSBvZiBhIGxvb2t1cC4gdGhlIGZvbGxvd2luZyBpcyBub3QgZXh0ZW5zaWJsZVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbWFwKHRhZ05hbWUsIGF0dHIpIHtcbiAgICAgICAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdMQUJFTCc6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2h0bWxGb3InO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnSU1HJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndXNlbWFwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndXNlTWFwJztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0lOUFVUJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4bGVuZ3RoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWF4TGVuZ3RoJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlubGVuZ3RoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWluTGVuZ3RoJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9ybWFjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zvcm1BY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3JtZW5jdHlwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zvcm1FbmNUeXBlJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9ybW1ldGhvZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zvcm1NZXRob2QnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3Jtbm92YWxpZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zvcm1Ob1ZhbGlkYXRlJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9ybXRhcmdldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zvcm1UYXJnZXQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnB1dG1vZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdpbnB1dE1vZGUnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXhsZW5ndGgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtYXhMZW5ndGgnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVEQnOlxuICAgICAgICAgICAgY2FzZSAnVEgnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyb3dzcGFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncm93U3Bhbic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbHNwYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xTcGFuJztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FjY2Vzc2tleSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FjY2Vzc0tleSc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnRlZGl0YWJsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbnRlbnRFZGl0YWJsZSc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RhYmluZGV4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndGFiSW5kZXgnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Y29udGVudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHRDb250ZW50JztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5uZXJodG1sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaW5uZXJIVE1MJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2Nyb2xsdG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnc2Nyb2xsVG9wJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2Nyb2xsbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3Njcm9sbExlZnQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWFkb25seSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JlYWRPbmx5JztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3VsZERlZmF1bHRUb1R3b1dheShlbGVtZW50LCBhdHRyKSB7XG4gICAgc3dpdGNoIChlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ciA9PT0gJ2NoZWNrZWQnO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyID09PSAndmFsdWUnIHx8IGF0dHIgPT09ICdmaWxlcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcbiAgICAgICAgICAgIHJldHVybiBhdHRyID09PSAndmFsdWUnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dGNvbnRlbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2lubmVyaHRtbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Nyb2xsdG9wJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY3JvbGxsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHJpYnV0ZS1zeW50YXgtdHJhbnNmb3JtZXIuanMubWFwIiwiaW1wb3J0IHsgREksIFJlZ2lzdHJhdGlvbiwgSW5zdGFuY2VQcm92aWRlciwgb25SZXNvbHZlIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJyb3dzZXJQbGF0Zm9ybSB9IGZyb20gJ0BhdXJlbGlhL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgQXBwUm9vdCwgSUFwcFJvb3QgfSBmcm9tICcuL2FwcC1yb290LmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuZXhwb3J0IGNvbnN0IElBdXJlbGlhID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJQXVyZWxpYScpO1xuZXhwb3J0IGNsYXNzIEF1cmVsaWEge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciA9IERJLmNyZWF0ZUNvbnRhaW5lcigpKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTdGFydGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1N0b3BwaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5zdGFydFByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuc3RvcFByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjb250YWluZXIuaGFzKElBdXJlbGlhLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpbnN0YW5jZSBvZiBBdXJlbGlhIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIHRoZSBjb250YWluZXIgb3IgYW4gYW5jZXN0b3Igb2YgaXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShJQXVyZWxpYSwgdGhpcykpO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihJQXBwUm9vdCwgdGhpcy5yb290UHJvdmlkZXIgPSBuZXcgSW5zdGFuY2VQcm92aWRlcignSUFwcFJvb3QnKSk7XG4gICAgfVxuICAgIGdldCBpc1J1bm5pbmcoKSB7IHJldHVybiB0aGlzLl9pc1J1bm5pbmc7IH1cbiAgICBnZXQgaXNTdGFydGluZygpIHsgcmV0dXJuIHRoaXMuX2lzU3RhcnRpbmc7IH1cbiAgICBnZXQgaXNTdG9wcGluZygpIHsgcmV0dXJuIHRoaXMuX2lzU3RvcHBpbmc7IH1cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0ID09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcm9vdCBpcyBub3QgZGVmaW5lZGApOyAvLyBUT0RPOiBjcmVhdGUgZXJyb3IgY29kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICB9XG4gICAgcmVnaXN0ZXIoLi4ucGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlZ2lzdGVyKC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhcHAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IG5ldyBBcHBSb290KGNvbmZpZywgdGhpcy5pbml0UGxhdGZvcm0oY29uZmlnLmhvc3QpLCB0aGlzLmNvbnRhaW5lciwgdGhpcy5yb290UHJvdmlkZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVuaGFuY2UoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IG5ldyBBcHBSb290KGNvbmZpZywgdGhpcy5pbml0UGxhdGZvcm0oY29uZmlnLmhvc3QpLCB0aGlzLmNvbnRhaW5lciwgdGhpcy5yb290UHJvdmlkZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvcklkbGUoKSB7XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5yb290LnBsYXRmb3JtO1xuICAgICAgICBhd2FpdCBwbGF0Zm9ybS5kb21Xcml0ZVF1ZXVlLnlpZWxkKCk7XG4gICAgICAgIGF3YWl0IHBsYXRmb3JtLmRvbVJlYWRRdWV1ZS55aWVsZCgpO1xuICAgICAgICBhd2FpdCBwbGF0Zm9ybS5tYWNyb1Rhc2tRdWV1ZS55aWVsZCgpO1xuICAgIH1cbiAgICBpbml0UGxhdGZvcm0oaG9zdCkge1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lci5oYXMoSVBsYXRmb3JtLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGlmIChob3N0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIHRoZSBwbGF0Zm9ybSBvYmplY3QuIFRoZSBob3N0IGVsZW1lbnQncyBvd25lckRvY3VtZW50IGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0Vmlld2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IG5ldyBCcm93c2VyUGxhdGZvcm0oaG9zdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShJUGxhdGZvcm0sIHApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgPSB0aGlzLmNvbnRhaW5lci5nZXQoSVBsYXRmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgc3RhcnQocm9vdCA9IHRoaXMubmV4dCkge1xuICAgICAgICBpZiAocm9vdCA9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gY29tcG9zaXRpb24gcm9vdGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0UHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFByb21pc2UgPSBvblJlc29sdmUodGhpcy5zdG9wKCksICgpID0+IHtcbiAgICAgICAgICAgIFJlZmxlY3Quc2V0KHJvb3QuaG9zdCwgJyRhdXJlbGlhJywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJvb3RQcm92aWRlci5wcmVwYXJlKHRoaXMuX3Jvb3QgPSByb290KTtcbiAgICAgICAgICAgIHRoaXMuX2lzU3RhcnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZShyb290LmFjdGl2YXRlKCksICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocm9vdCwgJ2F1LXN0YXJ0ZWQnLCByb290Lmhvc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKGRpc3Bvc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5zdG9wUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1J1bm5pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290O1xuICAgICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1N0b3BwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BQcm9taXNlID0gb25SZXNvbHZlKHJvb3QuZGVhY3RpdmF0ZSgpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShyb290Lmhvc3QsICckYXVyZWxpYScpO1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdFByb3ZpZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1N0b3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHJvb3QsICdhdS1zdG9wcGVkJywgcm9vdC5ob3N0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1J1bm5pbmcgfHwgdGhpcy5faXNTdG9wcGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYXVyZWxpYSBpbnN0YW5jZSBtdXN0IGJlIGZ1bGx5IHN0b3BwZWQgYmVmb3JlIGl0IGNhbiBiZSBkaXNwb3NlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZGlzcGF0Y2hFdmVudChyb290LCBuYW1lLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgZXYgPSBuZXcgcm9vdC5wbGF0Zm9ybS53aW5kb3cuQ3VzdG9tRXZlbnQobmFtZSwgeyBkZXRhaWw6IHRoaXMsIGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSk7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXJlbGlhLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IGtlYmFiQ2FzZSwgTWV0YWRhdGEsIFByb3RvY29sLCBmaXJzdERlZmluZWQsIGdldFByb3RvdHlwZUNoYWluLCBub29wLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBCaW5kaW5nTW9kZSwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmV4cG9ydCBmdW5jdGlvbiBiaW5kYWJsZShjb25maWdPclRhcmdldCwgcHJvcCkge1xuICAgIGxldCBjb25maWc7XG4gICAgZnVuY3Rpb24gZGVjb3JhdG9yKCR0YXJnZXQsICRwcm9wKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gTm9uIGludm9jYXRpb246XG4gICAgICAgICAgICAvLyAtIEBiaW5kYWJsZVxuICAgICAgICAgICAgLy8gSW52b2NhdGlvbiB3aXRoIG9yIHcvbyBvcHRzOlxuICAgICAgICAgICAgLy8gLSBAYmluZGFibGUoKVxuICAgICAgICAgICAgLy8gLSBAYmluZGFibGUoey4uLm9wdHN9KVxuICAgICAgICAgICAgY29uZmlnLnByb3BlcnR5ID0gJHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEJpbmRhYmxlLm5hbWUsIEJpbmRhYmxlRGVmaW5pdGlvbi5jcmVhdGUoJHByb3AsIGNvbmZpZyksICR0YXJnZXQuY29uc3RydWN0b3IsICRwcm9wKTtcbiAgICAgICAgUHJvdG9jb2wuYW5ub3RhdGlvbi5hcHBlbmRUbygkdGFyZ2V0LmNvbnN0cnVjdG9yLCBCaW5kYWJsZS5rZXlGcm9tKCRwcm9wKSk7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBOb24gaW52b2NhdGlvbjpcbiAgICAgICAgLy8gLSBAYmluZGFibGVcbiAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIGRlY29yYXRvcihjb25maWdPclRhcmdldCwgcHJvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZ09yVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBDbGFzc0RlY29yYXRvclxuICAgICAgICAvLyAtIEBiaW5kYWJsZSgnYmFyJylcbiAgICAgICAgLy8gRGlyZWN0IGNhbGw6XG4gICAgICAgIC8vIC0gQGJpbmRhYmxlKCdiYXInKShGb28pXG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgIH1cbiAgICAvLyBJbnZvY2F0aW9uIHdpdGggb3Igdy9vIG9wdHM6XG4gICAgLy8gLSBAYmluZGFibGUoKVxuICAgIC8vIC0gQGJpbmRhYmxlKHsuLi5vcHRzfSlcbiAgICBjb25maWcgPSBjb25maWdPclRhcmdldCA9PT0gdm9pZCAwID8ge30gOiBjb25maWdPclRhcmdldDtcbiAgICByZXR1cm4gZGVjb3JhdG9yO1xufVxuZnVuY3Rpb24gaXNCaW5kYWJsZUFubm90YXRpb24oa2V5KSB7XG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKEJpbmRhYmxlLm5hbWUpO1xufVxuZXhwb3J0IGNvbnN0IEJpbmRhYmxlID0ge1xuICAgIG5hbWU6IFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKCdiaW5kYWJsZScpLFxuICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7QmluZGFibGUubmFtZX06JHtuYW1lfWA7XG4gICAgfSxcbiAgICBmcm9tKC4uLmJpbmRhYmxlTGlzdHMpIHtcbiAgICAgICAgY29uc3QgYmluZGFibGVzID0ge307XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgICAgICBmdW5jdGlvbiBhZGROYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIGJpbmRhYmxlc1tuYW1lXSA9IEJpbmRhYmxlRGVmaW5pdGlvbi5jcmVhdGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkRGVzY3JpcHRpb24obmFtZSwgZGVmKSB7XG4gICAgICAgICAgICBiaW5kYWJsZXNbbmFtZV0gPSBkZWYgaW5zdGFuY2VvZiBCaW5kYWJsZURlZmluaXRpb24gPyBkZWYgOiBCaW5kYWJsZURlZmluaXRpb24uY3JlYXRlKG5hbWUsIGRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkTGlzdChtYXliZUxpc3QpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1heWJlTGlzdCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZUxpc3QuZm9yRWFjaChhZGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1heWJlTGlzdCBpbnN0YW5jZW9mIEJpbmRhYmxlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIGJpbmRhYmxlc1ttYXliZUxpc3QucHJvcGVydHldID0gbWF5YmVMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF5YmVMaXN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtYXliZUxpc3QpLmZvckVhY2gobmFtZSA9PiBhZGREZXNjcmlwdGlvbihuYW1lLCBtYXliZUxpc3RbbmFtZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiaW5kYWJsZUxpc3RzLmZvckVhY2goYWRkTGlzdCk7XG4gICAgICAgIHJldHVybiBiaW5kYWJsZXM7XG4gICAgfSxcbiAgICBmb3IoVHlwZSkge1xuICAgICAgICBsZXQgZGVmO1xuICAgICAgICBjb25zdCBidWlsZGVyID0ge1xuICAgICAgICAgICAgYWRkKGNvbmZpZ09yUHJvcCkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wO1xuICAgICAgICAgICAgICAgIGxldCBjb25maWc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWdPclByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdPclByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IHsgcHJvcGVydHk6IHByb3AgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdPclByb3AucHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZ09yUHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmID0gQmluZGFibGVEZWZpbml0aW9uLmNyZWF0ZShwcm9wLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICghTWV0YWRhdGEuaGFzT3duKEJpbmRhYmxlLm5hbWUsIFR5cGUsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIFByb3RvY29sLmFubm90YXRpb24uYXBwZW5kVG8oVHlwZSwgQmluZGFibGUua2V5RnJvbShwcm9wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShCaW5kYWJsZS5uYW1lLCBkZWYsIFR5cGUsIHByb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vZGUobW9kZSkge1xuICAgICAgICAgICAgICAgIGRlZi5tb2RlID0gbW9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGRlZi5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBkZWYuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaW1hcnkoKSB7XG4gICAgICAgICAgICAgICAgZGVmLnByaW1hcnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldChzZXRJbnRlcnByZXRlcikge1xuICAgICAgICAgICAgICAgIGRlZi5zZXQgPSBzZXRJbnRlcnByZXRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBnZXRBbGwoVHlwZSkge1xuICAgICAgICBjb25zdCBwcm9wU3RhcnQgPSBCaW5kYWJsZS5uYW1lLmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGRlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlQ2hhaW4gPSBnZXRQcm90b3R5cGVDaGFpbihUeXBlKTtcbiAgICAgICAgbGV0IGlQcm90byA9IHByb3RvdHlwZUNoYWluLmxlbmd0aDtcbiAgICAgICAgbGV0IGlEZWZzID0gMDtcbiAgICAgICAgbGV0IGtleXM7XG4gICAgICAgIGxldCBrZXlzTGVuO1xuICAgICAgICBsZXQgQ2xhc3M7XG4gICAgICAgIHdoaWxlICgtLWlQcm90byA+PSAwKSB7XG4gICAgICAgICAgICBDbGFzcyA9IHByb3RvdHlwZUNoYWluW2lQcm90b107XG4gICAgICAgICAgICBrZXlzID0gUHJvdG9jb2wuYW5ub3RhdGlvbi5nZXRLZXlzKENsYXNzKS5maWx0ZXIoaXNCaW5kYWJsZUFubm90YXRpb24pO1xuICAgICAgICAgICAga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWZzW2lEZWZzKytdID0gTWV0YWRhdGEuZ2V0T3duKEJpbmRhYmxlLm5hbWUsIENsYXNzLCBrZXlzW2ldLnNsaWNlKHByb3BTdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZzO1xuICAgIH0sXG59O1xuZXhwb3J0IGNsYXNzIEJpbmRhYmxlRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXR0cmlidXRlLCBjYWxsYmFjaywgbW9kZSwgcHJpbWFyeSwgcHJvcGVydHksIHNldCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHByb3AsIGRlZiA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGFibGVEZWZpbml0aW9uKGZpcnN0RGVmaW5lZChkZWYuYXR0cmlidXRlLCBrZWJhYkNhc2UocHJvcCkpLCBmaXJzdERlZmluZWQoZGVmLmNhbGxiYWNrLCBgJHtwcm9wfUNoYW5nZWRgKSwgZmlyc3REZWZpbmVkKGRlZi5tb2RlLCBCaW5kaW5nTW9kZS50b1ZpZXcpLCBmaXJzdERlZmluZWQoZGVmLnByaW1hcnksIGZhbHNlKSwgZmlyc3REZWZpbmVkKGRlZi5wcm9wZXJ0eSwgcHJvcCksIGZpcnN0RGVmaW5lZChkZWYuc2V0LCBub29wKSk7XG4gICAgfVxufVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLHNwYWNlZC1jb21tZW50ICovXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc2VydmVzIHR3byBwdXJwb3NlczpcbiAqIC0gQSBwbGF5Z3JvdW5kIGZvciBjb250cmlidXRvcnMgdG8gdHJ5IHRoZWlyIGNoYW5nZXMgdG8gdGhlIEFQSXMuXG4gKiAtIENhdXNlIHRoZSBBUEkgc3VyZmFjZSB0byBiZSBwcm9wZXJseSB0eXBlLWNoZWNrZWQgYW5kIHByb3RlY3RlZCBhZ2FpbnN0IGFjY2lkZW50YWwgdHlwZSByZWdyZXNzaW9ucy5cbiAqXG4gKiBJdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBieSBkZWFkIGNvZGUgZWxpbWluYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFwaVR5cGVDaGVjaygpIHtcbiAgICBsZXQgRm9vID0gXG4gICAgLy8gPiBleHBlY3RlZCBlcnJvciAtIGNsYXNzIGRlY29yYXRvciBvbmx5IGFjY2VwdHMgYSBzdHJpbmdcbiAgICAvL0BiaW5kYWJsZSh7fSlcbiAgICBjbGFzcyBGb28ge1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGJpbmRhYmxlLFxuICAgICAgICBiaW5kYWJsZSgpLFxuICAgICAgICBiaW5kYWJsZSh7fSlcbiAgICAgICAgLy8gPiBleHBlY3RlZCBlcnJvciAtICdwcm9wZXJ0eScgZG9lcyBub3QgZXhpc3Qgb24gZGVjb3JhdG9yIGlucHV0IG9iamVjdFxuICAgICAgICAvL0BiaW5kYWJsZSh7IHByb3BlcnR5OiAncHJvcCcgfSlcbiAgICAgICAgLFxuICAgICAgICBiaW5kYWJsZSh7IG1vZGU6IEJpbmRpbmdNb2RlLnR3b1dheSB9KSxcbiAgICAgICAgYmluZGFibGUoeyBjYWxsYmFjazogJ3Byb3BDaGFuZ2VkJyB9KSxcbiAgICAgICAgYmluZGFibGUoeyBhdHRyaWJ1dGU6ICdwcm9wJyB9KSxcbiAgICAgICAgYmluZGFibGUoeyBwcmltYXJ5OiB0cnVlIH0pLFxuICAgICAgICBiaW5kYWJsZSh7IHNldDogdmFsdWUgPT4gU3RyaW5nKHZhbHVlKSB9KSxcbiAgICAgICAgYmluZGFibGUoeyBzZXQ6IHZhbHVlID0+IE51bWJlcih2YWx1ZSkgfSksXG4gICAgICAgIGJpbmRhYmxlKHtcbiAgICAgICAgICAgIG1vZGU6IEJpbmRpbmdNb2RlLnR3b1dheSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAncHJvcENoYW5nZWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAncHJvcCcsXG4gICAgICAgICAgICBwcmltYXJ5OiB0cnVlLFxuICAgICAgICAgICAgc2V0OiB2YWx1ZSA9PiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH0pXG4gICAgXSwgRm9vLnByb3RvdHlwZSwgXCJwcm9wXCIsIHZvaWQgMCk7XG4gICAgRm9vID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGJpbmRhYmxlKCdwcm9wJylcbiAgICAgICAgLy8gPiBleHBlY3RlZCBlcnJvciAtIGNsYXNzIGRlY29yYXRvciBvbmx5IGFjY2VwdHMgYSBzdHJpbmdcbiAgICAgICAgLy9AYmluZGFibGUoe30pXG4gICAgXSwgRm9vKTtcbiAgICBCaW5kYWJsZS5mb3IoRm9vKVxuICAgICAgICAvLyA+IGV4cGVjdGVkIGVycm9yIC0gdGhlcmUgaXMgbm8gYWRkKCkgZnVuY3Rpb24gd2l0aCBvbmx5IG9wdGlvbmFsIHBhcmFtcyBvbiB0aGUgZmx1ZW50IGFwaVxuICAgICAgICAvLy5hZGQoKVxuICAgICAgICAvLyA+IGV4cGVjdGVkIGVycm9yIC0gJ3Byb3BlcnR5JyBpcyBhIHJlcXVpcmVkIHByb3BlcnR5IG9uIHRoZSBmbHVlbnQgYXBpXG4gICAgICAgIC8vLmFkZCh7fSlcbiAgICAgICAgLmFkZCh7IHByb3BlcnR5OiAncHJvcCcgfSlcbiAgICAgICAgLmFkZCh7IHByb3BlcnR5OiAncHJvcCcsIG1vZGU6IEJpbmRpbmdNb2RlLnR3b1dheSB9KVxuICAgICAgICAuYWRkKHsgcHJvcGVydHk6ICdwcm9wJywgY2FsbGJhY2s6ICdwcm9wQ2hhbmdlZCcgfSlcbiAgICAgICAgLmFkZCh7IHByb3BlcnR5OiAncHJvcCcsIGF0dHJpYnV0ZTogJ3Byb3AnIH0pXG4gICAgICAgIC5hZGQoeyBwcm9wZXJ0eTogJ3Byb3AnLCBwcmltYXJ5OiB0cnVlIH0pXG4gICAgICAgIC5hZGQoeyBwcm9wZXJ0eTogJ3Byb3AnLCBtb2RlOiBCaW5kaW5nTW9kZS50d29XYXksIGNhbGxiYWNrOiAncHJvcENoYW5nZWQnLCBhdHRyaWJ1dGU6ICdwcm9wJywgcHJpbWFyeTogdHJ1ZSB9KVxuICAgICAgICAuYWRkKCdwcm9wJylcbiAgICAgICAgLy8gPiBleHBlY3RlZCBlcnJvciAtIHRoZSBhZGQoKSBtZXRob2QgdGhhdCBhY2NlcHRzIGFuIG9iamVjdCBsaXRlcmFsIGRvZXMgbm90IHJldHVybiBhIGZsdWVudCBhcGlcbiAgICAgICAgLy8uYWRkKHsgcHJvcGVydHk6ICdwcm9wJyB9KS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSlcbiAgICAgICAgLy8uYWRkKHsgcHJvcGVydHk6ICdwcm9wJyB9KS5jYWxsYmFjaygncHJvcENoYW5nZWQnKVxuICAgICAgICAvLy5hZGQoeyBwcm9wZXJ0eTogJ3Byb3AnIH0pLmF0dHJpYnV0ZSgncHJvcCcpXG4gICAgICAgIC8vLmFkZCh7IHByb3BlcnR5OiAncHJvcCcgfSkucHJpbWFyeSgpXG4gICAgICAgIC8vID4gZXhwZWN0ZWQgZXJyb3IgLSBmbHVlbnQgYXBpIG1ldGhvZHMgY2FuIG9ubHkgYmUgaW52b2tlZCBvbmNlIHBlciBiaW5kYWJsZVxuICAgICAgICAvLy5hZGQoJ3Byb3AnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSkubW9kZShCaW5kaW5nTW9kZS50d29XYXkpXG4gICAgICAgIC8vLmFkZCgncHJvcCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KS5jYWxsYmFjaygncHJvcENoYW5nZWQnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSlcbiAgICAgICAgLy8uYWRkKCdwcm9wJykubW9kZShCaW5kaW5nTW9kZS50d29XYXkpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpIC8vIGV0Y1xuICAgICAgICAvLyA+IGV4cGVjdGVkIGVycm9yIC0gd3JvbmcgaW52b2NhdGlvbiBvcmRlclxuICAgICAgICAvLy5hZGQoJ3Byb3AnKS5jYWxsYmFjaygncHJvcENoYW5nZWQnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSlcbiAgICAgICAgLy8uYWRkKCdwcm9wJykucHJpbWFyeSgpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KSAgLy8gZXRjXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSlcbiAgICAgICAgLmFkZCgncHJvcCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KS5jYWxsYmFjaygncHJvcENoYW5nZWQnKVxuICAgICAgICAuYWRkKCdwcm9wJykubW9kZShCaW5kaW5nTW9kZS50d29XYXkpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpLmF0dHJpYnV0ZSgncHJvcCcpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSkuY2FsbGJhY2soJ3Byb3BDaGFuZ2VkJykuYXR0cmlidXRlKCdwcm9wJykucHJpbWFyeSgpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSkuc2V0KCh2YWx1ZSkgPT4gTnVtYmVyKHZhbHVlKSlcbiAgICAgICAgLmFkZCgncHJvcCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KS5jYWxsYmFjaygncHJvcENoYW5nZWQnKS5zZXQodmFsdWUgPT4gTnVtYmVyKHZhbHVlKSlcbiAgICAgICAgLmFkZCgncHJvcCcpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5jYWxsYmFjaygncHJvcENoYW5nZWQnKS5hdHRyaWJ1dGUoJ3Byb3AnKVxuICAgICAgICAuYWRkKCdwcm9wJykuY2FsbGJhY2soJ3Byb3BDaGFuZ2VkJykuYXR0cmlidXRlKCdwcm9wJykucHJpbWFyeSgpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5hdHRyaWJ1dGUoJ3Byb3AnKVxuICAgICAgICAuYWRkKCdwcm9wJykuYXR0cmlidXRlKCdwcm9wJykucHJpbWFyeSgpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5wcmltYXJ5KCk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyxzcGFjZWQtY29tbWVudCAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGFibGUuanMubWFwIiwiaW1wb3J0IHsgYmluZGluZ0JlaGF2aW9yLCBCaW5kaW5nTW9kZSB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuZXhwb3J0IGNsYXNzIEJpbmRpbmdNb2RlQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1vZGUpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE1vZGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxNb2Rlcy5zZXQoYmluZGluZywgYmluZGluZy5tb2RlKTtcbiAgICAgICAgYmluZGluZy5tb2RlID0gdGhpcy5tb2RlO1xuICAgIH1cbiAgICB1bmJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgYmluZGluZy5tb2RlID0gdGhpcy5vcmlnaW5hbE1vZGVzLmdldChiaW5kaW5nKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE1vZGVzLmRlbGV0ZShiaW5kaW5nKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT25lVGltZUJpbmRpbmdCZWhhdmlvciBleHRlbmRzIEJpbmRpbmdNb2RlQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihCaW5kaW5nTW9kZS5vbmVUaW1lKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVG9WaWV3QmluZGluZ0JlaGF2aW9yIGV4dGVuZHMgQmluZGluZ01vZGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEJpbmRpbmdNb2RlLnRvVmlldyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZyb21WaWV3QmluZGluZ0JlaGF2aW9yIGV4dGVuZHMgQmluZGluZ01vZGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEJpbmRpbmdNb2RlLmZyb21WaWV3KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHdvV2F5QmluZGluZ0JlaGF2aW9yIGV4dGVuZHMgQmluZGluZ01vZGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEJpbmRpbmdNb2RlLnR3b1dheSk7XG4gICAgfVxufVxuYmluZGluZ0JlaGF2aW9yKCdvbmVUaW1lJykoT25lVGltZUJpbmRpbmdCZWhhdmlvcik7XG5iaW5kaW5nQmVoYXZpb3IoJ3RvVmlldycpKFRvVmlld0JpbmRpbmdCZWhhdmlvcik7XG5iaW5kaW5nQmVoYXZpb3IoJ2Zyb21WaWV3JykoRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3IpO1xuYmluZGluZ0JlaGF2aW9yKCd0d29XYXknKShUd29XYXlCaW5kaW5nQmVoYXZpb3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGluZy1tb2RlLmpzLm1hcCIsImltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBiaW5kaW5nQmVoYXZpb3IsIEJpbmRpbmdJbnRlcmNlcHRvciB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuZXhwb3J0IGNsYXNzIERlYm91bmNlQmluZGluZ0JlaGF2aW9yIGV4dGVuZHMgQmluZGluZ0ludGVyY2VwdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nLCBleHByKSB7XG4gICAgICAgIHN1cGVyKGJpbmRpbmcsIGV4cHIpO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IGRlbGF5OiAwIH07XG4gICAgICAgIHRoaXMuZmlyc3RBcmcgPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2tRdWV1ZSA9IGJpbmRpbmcubG9jYXRvci5nZXQoSVBsYXRmb3JtKS5tYWNyb1Rhc2tRdWV1ZTtcbiAgICAgICAgaWYgKGV4cHIuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0QXJnID0gZXhwci5hcmdzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxTb3VyY2UoYXJncykge1xuICAgICAgICB0aGlzLnF1ZXVlVGFzaygoKSA9PiB0aGlzLmJpbmRpbmcuY2FsbFNvdXJjZShhcmdzKSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVRhc2soKCkgPT4gdGhpcy5iaW5kaW5nLmhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpKTtcbiAgICB9XG4gICAgcXVldWVUYXNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGFzay5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLnRhc2tRdWV1ZS5xdWV1ZVRhc2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9LCB0aGlzLm9wdHMpO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5maXJzdEFyZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGhpcy5maXJzdEFyZy5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCBudWxsKSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZGluZy4kYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgdGhpcy50YXNrPy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5iaW5kaW5nLiR1bmJpbmQoZmxhZ3MpO1xuICAgIH1cbn1cbmJpbmRpbmdCZWhhdmlvcignZGVib3VuY2UnKShEZWJvdW5jZUJpbmRpbmdCZWhhdmlvcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGJpbmRpbmdCZWhhdmlvciwgSVNpZ25hbGVyIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5sZXQgU2lnbmFsQmluZGluZ0JlaGF2aW9yID0gY2xhc3MgU2lnbmFsQmluZGluZ0JlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaWduYWxlcikge1xuICAgICAgICB0aGlzLnNpZ25hbGVyID0gc2lnbmFsZXI7XG4gICAgICAgIHRoaXMubG9va3VwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCBiaW5kaW5nLCAuLi5uYW1lcykge1xuICAgICAgICBpZiAoISgnaGFuZGxlQ2hhbmdlJyBpbiBiaW5kaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2lnbmFsIGJlaGF2aW9yIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBiaW5kaW5ncyB0aGF0IGhhdmUgYSAnaGFuZGxlQ2hhbmdlJyBtZXRob2RgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0IGxlYXN0IG9uZSBzaWduYWwgbmFtZSBtdXN0IGJlIHBhc3NlZCB0byB0aGUgc2lnbmFsIGJlaGF2aW9yLCBlLmcuIFxcYGV4cHIgJiBzaWduYWw6J215LXNpZ25hbCdcXGBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvb2t1cC5zZXQoYmluZGluZywgbmFtZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsZXIuYWRkU2lnbmFsTGlzdGVuZXIobmFtZSwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5sb29rdXAuZ2V0KGJpbmRpbmcpO1xuICAgICAgICB0aGlzLmxvb2t1cC5kZWxldGUoYmluZGluZyk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgdGhpcy5zaWduYWxlci5yZW1vdmVTaWduYWxMaXN0ZW5lcihuYW1lLCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5TaWduYWxCaW5kaW5nQmVoYXZpb3IgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElTaWduYWxlcilcbl0sIFNpZ25hbEJpbmRpbmdCZWhhdmlvcik7XG5leHBvcnQgeyBTaWduYWxCaW5kaW5nQmVoYXZpb3IgfTtcbmJpbmRpbmdCZWhhdmlvcignc2lnbmFsJykoU2lnbmFsQmluZGluZ0JlaGF2aW9yKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hbHMuanMubWFwIiwiaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IGJpbmRpbmdCZWhhdmlvciwgQmluZGluZ0ludGVyY2VwdG9yIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5leHBvcnQgY2xhc3MgVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3IgZXh0ZW5kcyBCaW5kaW5nSW50ZXJjZXB0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGJpbmRpbmcsIGV4cHIpIHtcbiAgICAgICAgc3VwZXIoYmluZGluZywgZXhwcik7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgZGVsYXk6IDAgfTtcbiAgICAgICAgdGhpcy5maXJzdEFyZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENhbGwgPSAwO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gYmluZGluZy5sb2NhdG9yLmdldChJUGxhdGZvcm0pO1xuICAgICAgICB0aGlzLnRhc2tRdWV1ZSA9IHRoaXMucGxhdGZvcm0ubWFjcm9UYXNrUXVldWU7XG4gICAgICAgIGlmIChleHByLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdEFyZyA9IGV4cHIuYXJnc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsU291cmNlKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVRhc2soKCkgPT4gdGhpcy5iaW5kaW5nLmNhbGxTb3VyY2UoYXJncykpO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMucXVldWVUYXNrKCgpID0+IHRoaXMuYmluZGluZy5oYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSk7XG4gICAgfVxuICAgIHF1ZXVlVGFzayhjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgICAgIGNvbnN0IG5leHREZWxheSA9IHRoaXMubGFzdENhbGwgKyBvcHRzLmRlbGF5IC0gcGxhdGZvcm0ucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgaWYgKG5leHREZWxheSA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2suY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRzLmRlbGF5ID0gbmV4dERlbGF5O1xuICAgICAgICAgICAgdGhpcy50YXNrID0gdGhpcy50YXNrUXVldWUucXVldWVUYXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDYWxsID0gcGxhdGZvcm0ucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENhbGwgPSBwbGF0Zm9ybS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5maXJzdEFyZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGhpcy5maXJzdEFyZy5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCBudWxsKSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZGluZy4kYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgdGhpcy50YXNrPy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgc3VwZXIuJHVuYmluZChmbGFncyk7XG4gICAgfVxufVxuYmluZGluZ0JlaGF2aW9yKCd0aHJvdHRsZScpKFRocm90dGxlQmluZGluZ0JlaGF2aW9yKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlLmpzLm1hcCIsImltcG9ydCB7IEJpbmRpbmdNb2RlLCBjb25uZWN0YWJsZSwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IEF0dHJpYnV0ZU9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24vZWxlbWVudC1hdHRyaWJ1dGUtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi4vcGxhdGZvcm0uanMnO1xuLy8gQmluZGluZ01vZGUgaXMgbm90IGEgY29uc3QgZW51bSAoYW5kIHRoZXJlZm9yZSBub3QgaW5saW5lZCksIHNvIGFzc2lnbmluZyB0aGVtIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBhIG1lbWJlciBhY2Nlc3NvciBpcyBhIG1pbm9yIHBlcmYgdHdlYWtcbmNvbnN0IHsgb25lVGltZSwgdG9WaWV3LCBmcm9tVmlldyB9ID0gQmluZGluZ01vZGU7XG4vLyBwcmUtY29tYmluaW5nIGZsYWdzIGZvciBiaXR3aXNlIGNoZWNrcyBpcyBhIG1pbm9yIHBlcmYgdHdlYWtcbmNvbnN0IHRvVmlld09yT25lVGltZSA9IHRvVmlldyB8IG9uZVRpbWU7XG5jb25zdCB0YXNrT3B0aW9ucyA9IHtcbiAgICByZXVzYWJsZTogZmFsc2UsXG4gICAgcHJlZW1wdDogdHJ1ZSxcbn07XG4vKipcbiAqIEF0dHJpYnV0ZSBiaW5kaW5nLiBIYW5kbGUgYXR0cmlidXRlIGJpbmRpbmcgYmV0d2VuIHZpZXcvdmlldyBtb2RlbC4gVW5kZXJzdGFuZCBIdG1sIHNwZWNpYWwgYXR0cmlidXRlc1xuICovXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlQmluZGluZyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCBcbiAgICAvLyBzb21lIGF0dHJpYnV0ZXMgbWF5IGhhdmUgaW5uZXIgc3RydWN0dXJlXG4gICAgLy8gc3VjaCBhcyBjbGFzcyAtPiBjb2xsZWN0aW9uIG9mIGNsYXNzIG5hbWVzXG4gICAgLy8gc3VjaCBhcyBzdHlsZSAtPiBjb2xsZWN0aW9uIG9mIHN0eWxlIHJ1bGVzXG4gICAgLy9cbiAgICAvLyBmb3Igbm9ybWFsIGF0dHJpYnV0ZXMsIHRhcmdldEF0dHJpYnV0ZSBhbmQgdGFyZ2V0UHJvcGVydHkgYXJlIHRoZSBzYW1lIGFuZCBjYW4gYmUgaWdub3JlXG4gICAgdGFyZ2V0QXR0cmlidXRlLCB0YXJnZXRQcm9wZXJ0eSwgbW9kZSwgb2JzZXJ2ZXJMb2NhdG9yLCBsb2NhdG9yKSB7XG4gICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbiA9IHNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudGFyZ2V0QXR0cmlidXRlID0gdGFyZ2V0QXR0cmlidXRlO1xuICAgICAgICB0aGlzLnRhcmdldFByb3BlcnR5ID0gdGFyZ2V0UHJvcGVydHk7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50RmxhZ3MgPSAwIC8qIG5vbmUgKi87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBjb25uZWN0YWJsZS5hc3NpZ25JZFRvKHRoaXMpO1xuICAgICAgICB0aGlzLiRwbGF0Zm9ybSA9IGxvY2F0b3IuZ2V0KElQbGF0Zm9ybSk7XG4gICAgfVxuICAgIHVwZGF0ZVRhcmdldCh2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgZmxhZ3MgfD0gdGhpcy5wZXJzaXN0ZW50RmxhZ3M7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIuc2V0VmFsdWUodmFsdWUsIGZsYWdzIHwgOCAvKiB1cGRhdGVUYXJnZXQgKi8sIHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgdXBkYXRlU291cmNlKHZhbHVlLCBmbGFncykge1xuICAgICAgICBmbGFncyB8PSB0aGlzLnBlcnNpc3RlbnRGbGFncztcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLmFzc2lnbihmbGFncyB8IDE2IC8qIHVwZGF0ZVNvdXJjZSAqLywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgX3ByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3MgfD0gdGhpcy5wZXJzaXN0ZW50RmxhZ3M7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yID0gdGhpcy5pbnRlcmNlcHRvcjtcbiAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgY29uc3QgJHNjb3BlID0gdGhpcy4kc2NvcGU7XG4gICAgICAgIGNvbnN0IGxvY2F0b3IgPSB0aGlzLmxvY2F0b3I7XG4gICAgICAgIGlmIChtb2RlID09PSBCaW5kaW5nTW9kZS5mcm9tVmlldykge1xuICAgICAgICAgICAgZmxhZ3MgJj0gfjggLyogdXBkYXRlVGFyZ2V0ICovO1xuICAgICAgICAgICAgZmxhZ3MgfD0gMTYgLyogdXBkYXRlU291cmNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDggLyogdXBkYXRlVGFyZ2V0ICovKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRPYnNlcnZlciA9IHRoaXMudGFyZ2V0T2JzZXJ2ZXI7XG4gICAgICAgICAgICAvLyBBbHBoYTogZHVyaW5nIGJpbmQgYSBzaW1wbGUgc3RyYXRlZ3kgZm9yIGJpbmQgaXMgYWx3YXlzIGZsdXNoIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAvLyB0b2RvOlxuICAgICAgICAgICAgLy8gICgxKS4gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBzaG91bGQgYmUgdGhlIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyAgKDIpLiBpZiBub3QsIHRoZW4gZml4IHRlc3RzIHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMvcGxhdGZvcm0gdG8gcHJvcGVybHkgeWllbGQgYWxsIHdpdGggYXVyZWxpYS5zdGFydCgpXG4gICAgICAgICAgICBjb25zdCBzaG91bGRRdWV1ZUZsdXNoID0gKGZsYWdzICYgMzIgLyogZnJvbUJpbmQgKi8pID09PSAwICYmICh0YXJnZXRPYnNlcnZlci50eXBlICYgNCAvKiBMYXlvdXQgKi8pID4gMDtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLiRraW5kICE9PSAxMDA4MiAvKiBBY2Nlc3NTY29wZSAqLyB8fCB0aGlzLm9icy5jb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRDb25uZWN0ID0gKG1vZGUgJiBvbmVUaW1lKSA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9icy52ZXJzaW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIGxvY2F0b3IsIGludGVyY2VwdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9icy5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRRdWV1ZUZsdXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFzaz8uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFzayA9IHRoaXMuJHBsYXRmb3JtLmRvbVdyaXRlUXVldWUucXVldWVUYXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRvci51cGRhdGVUYXJnZXQobmV3VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGFza09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJjZXB0b3IudXBkYXRlVGFyZ2V0KG5ld1ZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDE2IC8qIHVwZGF0ZVNvdXJjZSAqLykge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBzb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCAkc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgbG9jYXRvciwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRvci51cGRhdGVTb3VyY2UobmV3VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaGFuZGxlQ2hhbmdlIGNvbnRleHQgaW4gQXR0cmlidXRlQmluZGluZycpO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgcHJvamVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzIHwgMzIgLyogZnJvbUJpbmQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIGZsYWdzIHdoaWNoIHdlIGNhbiBvbmx5IHJlY2VpdmUgZHVyaW5nICRiaW5kIGFuZCBuZWVkIHRvIHBhc3Mgb25cbiAgICAgICAgLy8gdG8gdGhlIEFTVCBkdXJpbmcgZXZhbHVhdGUvY29ubmVjdC9hc3NpZ25cbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50RmxhZ3MgPSBmbGFncyAmIDE1MzY3IC8qIHBlcnNpc3RlbnRCaW5kaW5nRmxhZ3MgKi87XG4gICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IGhvc3RTY29wZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICAgICAgbGV0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLmhhc0JpbmQpIHtcbiAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24uYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgaWYgKCF0YXJnZXRPYnNlcnZlcikge1xuICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLnRhcmdldE9ic2VydmVyID0gbmV3IEF0dHJpYnV0ZU9ic2VydmVyKHRoaXMuJHBsYXRmb3JtLCB0aGlzLm9ic2VydmVyTG9jYXRvciwgdGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHksIHRoaXMudGFyZ2V0QXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgYmluZCwgYmluZGluZyBiZWhhdmlvciBtaWdodCBoYXZlIGNoYW5nZWQgc291cmNlRXhwcmVzc2lvblxuICAgICAgICBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBjb25zdCAkbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3IgPSB0aGlzLmludGVyY2VwdG9yO1xuICAgICAgICBpZiAoJG1vZGUgJiB0b1ZpZXdPck9uZVRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSAoJG1vZGUgJiB0b1ZpZXcpID4gMDtcbiAgICAgICAgICAgIGludGVyY2VwdG9yLnVwZGF0ZVRhcmdldCh0aGlzLnZhbHVlID0gc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCBzaG91bGRDb25uZWN0ID8gaW50ZXJjZXB0b3IgOiBudWxsKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkbW9kZSAmIGZyb21WaWV3KSB7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlclt0aGlzLmlkXSB8PSAxNiAvKiB1cGRhdGVTb3VyY2UgKi87XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlci5zdWJzY3JpYmUoaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciBwZXJzaXN0ZW50IGZsYWdzXG4gICAgICAgIHRoaXMucGVyc2lzdGVudEZsYWdzID0gMCAvKiBub25lICovO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFeHByZXNzaW9uLmhhc1VuYmluZCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLnVuYmluZChmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGVcbiAgICAgICAgICAgID0gdGhpcy4kaG9zdFNjb3BlXG4gICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgICAgICBjb25zdCB0YXJnZXRPYnNlcnZlciA9IHRoaXMudGFyZ2V0T2JzZXJ2ZXI7XG4gICAgICAgIGlmICh0YXJnZXRPYnNlcnZlci51bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlclt0aGlzLmlkXSAmPSB+MTYgLyogdXBkYXRlU291cmNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFzaz8uY2FuY2VsKCk7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMub2JzLmNsZWFyKHRydWUpO1xuICAgICAgICAvLyByZW1vdmUgaXNCb3VuZCBhbmQgaXNVbmJpbmRpbmcgZmxhZ3NcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxufVxuY29ubmVjdGFibGUoQXR0cmlidXRlQmluZGluZyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGUuanMubWFwIiwiZXhwb3J0IGNsYXNzIENhbGxCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VFeHByZXNzaW9uLCB0YXJnZXQsIHRhcmdldFByb3BlcnR5LCBvYnNlcnZlckxvY2F0b3IsIGxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uID0gc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvciA9IHRoaXM7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyID0gb2JzZXJ2ZXJMb2NhdG9yLmdldE9ic2VydmVyKHRhcmdldCwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICBjYWxsU291cmNlKGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVDb250ZXh0ID0gdGhpcy4kc2NvcGUub3ZlcnJpZGVDb250ZXh0O1xuICAgICAgICAvLyByZWFsbHkgbmVlZCB0byBkZWxldGUgdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgIC8vIGFuZCB0aGUgZm9yLi5pbiBsb29wIGJlbG93XG4gICAgICAgIC8vIGNvbnZlbmllbmNlIGluIHRoZSB0ZW1wbGF0ZSB3b24ndCBvdXR3ZWlnaHQgdGhlIGRyYXcgYmFjayBvZiBzdWNoIGNvbmZ1c2luZyBmZWF0dXJlXG4gICAgICAgIC8vIE9SLCBhdCB0aGUgdmVyeSBsZWFzdCwgdXNlIGdldHRlci9zZXR0ZXIgZm9yIGVhY2ggcHJvcGVydHkgaW4gYXJncyB0byBnZXQvc2V0IG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICAvLyAtLS1cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvdmVycmlkZUNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoMTI4IC8qIG11c3RFdmFsdWF0ZSAqLywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCBudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGFyZ3MpIHtcbiAgICAgICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkob3ZlcnJpZGVDb250ZXh0LCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzIHwgMzIgLyogZnJvbUJpbmQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IGhvc3RTY29wZTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlRXhwcmVzc2lvbi5oYXNCaW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24uYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zZXRWYWx1ZSgoJGFyZ3MpID0+IHRoaXMuaW50ZXJjZXB0b3IuY2FsbFNvdXJjZSgkYXJncyksIGZsYWdzLCB0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRQcm9wZXJ0eSk7XG4gICAgICAgIC8vIGFkZCBpc0JvdW5kIGZsYWcgYW5kIHJlbW92ZSBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICAkdW5iaW5kKGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlRXhwcmVzc2lvbi5oYXNVbmJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbi51bmJpbmQoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyLnNldFZhbHVlKG51bGwsIGZsYWdzLCB0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRQcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBvYnNlcnZlUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLWJpbmRpbmcuanMubWFwIiwiaW1wb3J0IHsgQmluZGluZ01vZGUsIGNvbm5lY3RhYmxlLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuY29uc3QgeyB0b1ZpZXcgfSA9IEJpbmRpbmdNb2RlO1xuY29uc3QgcXVldWVUYXNrT3B0aW9ucyA9IHtcbiAgICByZXVzYWJsZTogZmFsc2UsXG4gICAgcHJlZW1wdDogdHJ1ZSxcbn07XG4vLyBhIHBzZXVkbyBiaW5kaW5nIHRvIG1hbmFnZSBtdWx0aXBsZSBJbnRlcnBvbGF0aW9uQmluZGluZyBzXG4vLyA9PT09PT09PVxuLy8gTm90ZTogdGhlIGNoaWxkIGV4cHJlc3Npb25zIG9mIGFuIEludGVycG9sYXRpb24gZXhwcmVzc2lvbiBhcmUgZnVsbCBBdXJlbGlhIGV4cHJlc3Npb25zLCBtZWFuaW5nIHRoZXkgbWF5IGluY2x1ZGVcbi8vIHZhbHVlIGNvbnZlcnRlcnMgYW5kIGJpbmRpbmcgYmVoYXZpb3JzLlxuLy8gRWFjaCBleHByZXNzaW9uIHJlcHJlc2VudHMgb25lICR7aW50ZXJwb2xhdGlvbn0sIGFuZCBmb3IgZWFjaCB3ZSBjcmVhdGUgYSBjaGlsZCBUZXh0QmluZGluZyB1bmxlc3MgdGhlcmUgaXMgb25seSBvbmUsXG4vLyBpbiB3aGljaCBjYXNlIHRoZSByZW5kZXJlciB3aWxsIGNyZWF0ZSB0aGUgVGV4dEJpbmRpbmcgZGlyZWN0bHlcbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uQmluZGluZyB7XG4gICAgY29uc3RydWN0b3Iob2JzZXJ2ZXJMb2NhdG9yLCBpbnRlcnBvbGF0aW9uLCB0YXJnZXQsIHRhcmdldFByb3BlcnR5LCBtb2RlLCBsb2NhdG9yLCB0YXNrUXVldWUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnRhcmdldFByb3BlcnR5ID0gdGFyZ2V0UHJvcGVydHk7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMudGFza1F1ZXVlID0gdGFza1F1ZXVlO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyID0gb2JzZXJ2ZXJMb2NhdG9yLmdldEFjY2Vzc29yKHRhcmdldCwgdGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IGludGVycG9sYXRpb24uZXhwcmVzc2lvbnM7XG4gICAgICAgIGNvbnN0IHBhcnRCaW5kaW5ncyA9IHRoaXMucGFydEJpbmRpbmdzID0gQXJyYXkoZXhwcmVzc2lvbnMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZXhwcmVzc2lvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgcGFydEJpbmRpbmdzW2ldID0gbmV3IENvbnRlbnRCaW5kaW5nKGV4cHJlc3Npb25zW2ldLCB0YXJnZXQsIHRhcmdldFByb3BlcnR5LCBsb2NhdG9yLCBvYnNlcnZlckxvY2F0b3IsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVRhcmdldCh2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgcGFydEJpbmRpbmdzID0gdGhpcy5wYXJ0QmluZGluZ3M7XG4gICAgICAgIGNvbnN0IHN0YXRpY1BhcnRzID0gdGhpcy5pbnRlcnBvbGF0aW9uLnBhcnRzO1xuICAgICAgICBjb25zdCBpaSA9IHBhcnRCaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgaWYgKGlpID09PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdGF0aWNQYXJ0c1swXSArIHBhcnRCaW5kaW5nc1swXS52YWx1ZSArIHN0YXRpY1BhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3RhdGljUGFydHNbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaWkgPiBpOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gcGFydEJpbmRpbmdzW2ldLnZhbHVlICsgc3RhdGljUGFydHNbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgLy8gQWxwaGE6IGR1cmluZyBiaW5kIGEgc2ltcGxlIHN0cmF0ZWd5IGZvciBiaW5kIGlzIGFsd2F5cyBmbHVzaCBpbW1lZGlhdGVseVxuICAgICAgICAvLyB0b2RvOlxuICAgICAgICAvLyAgKDEpLiBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHNob3VsZCBiZSB0aGUgYmVoYXZpb3JcbiAgICAgICAgLy8gICgyKS4gaWYgbm90LCB0aGVuIGZpeCB0ZXN0cyB0byByZWZsZWN0IHRoZSBjaGFuZ2VzL3BsYXRmb3JtIHRvIHByb3Blcmx5IHlpZWxkIGFsbCB3aXRoIGF1cmVsaWEuc3RhcnQoKS53YWl0KClcbiAgICAgICAgY29uc3Qgc2hvdWxkUXVldWVGbHVzaCA9IChmbGFncyAmIDMyIC8qIGZyb21CaW5kICovKSA9PT0gMCAmJiAodGFyZ2V0T2JzZXJ2ZXIudHlwZSAmIDQgLyogTGF5b3V0ICovKSA+IDA7XG4gICAgICAgIGlmIChzaG91bGRRdWV1ZUZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2s/LmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy50YXNrID0gdGhpcy50YXNrUXVldWUucXVldWVUYXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRhcmdldE9ic2VydmVyLnNldFZhbHVlKHJlc3VsdCwgZmxhZ3MsIHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgICAgIH0sIHF1ZXVlVGFza09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIuc2V0VmFsdWUocmVzdWx0LCBmbGFncywgdGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdG9yLiR1bmJpbmQoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgIGNvbnN0IHBhcnRCaW5kaW5ncyA9IHRoaXMucGFydEJpbmRpbmdzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJ0QmluZGluZ3MubGVuZ3RoOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAgICAgcGFydEJpbmRpbmdzW2ldLiRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldCh2b2lkIDAsIGZsYWdzKTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRzY29wZSA9IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcGFydEJpbmRpbmdzID0gdGhpcy5wYXJ0QmluZGluZ3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRCaW5kaW5ncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBwYXJ0QmluZGluZ3NbaV0uaW50ZXJjZXB0b3IuJHVuYmluZChmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXNrPy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGVudEJpbmRpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZUV4cHJlc3Npb24sIHRhcmdldCwgdGFyZ2V0UHJvcGVydHksIGxvY2F0b3IsIG9ic2VydmVyTG9jYXRvciwgb3duZXIpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uID0gc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvciA9IHRoaXM7XG4gICAgICAgIC8vIGF0IHJ1bnRpbWUsIG1vZGUgbWF5IGJlIG92ZXJyaWRlbiBieSBiaW5kaW5nIGJlaGF2aW9yXG4gICAgICAgIC8vIGJ1dCBpdCB3b3VsZG4ndCBtYXR0ZXIgaGVyZSwganVzdCBzdGFydCB3aXRoIHNvbWV0aGluZyBmb3IgbGF0ZXIgY2hlY2tcbiAgICAgICAgdGhpcy5tb2RlID0gQmluZGluZ01vZGUudG9WaWV3O1xuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGNvbnN0IG9ic1JlY29yZCA9IHRoaXMub2JzO1xuICAgICAgICBjb25zdCBjYW5PcHRpbWl6ZSA9IHNvdXJjZUV4cHJlc3Npb24uJGtpbmQgPT09IDEwMDgyIC8qIEFjY2Vzc1Njb3BlICovICYmIG9ic1JlY29yZC5jb3VudCA9PT0gMTtcbiAgICAgICAgaWYgKCFjYW5PcHRpbWl6ZSkge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9ICh0aGlzLm1vZGUgJiB0b1ZpZXcpID4gMDtcbiAgICAgICAgICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JzUmVjb3JkLnZlcnNpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCBzaG91bGRDb25uZWN0ID8gdGhpcy5pbnRlcmNlcHRvciA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBvYnNSZWNvcmQuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUNvbGxlY3Rpb24obmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vd25lci51cGRhdGVUYXJnZXQobmV3VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncykge1xuICAgICAgICB0aGlzLm93bmVyLnVwZGF0ZVRhcmdldCh2b2lkIDAsIGZsYWdzKTtcbiAgICB9XG4gICAgJGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3IuJHVuYmluZChmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gaG9zdFNjb3BlO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFeHByZXNzaW9uLmhhc0JpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ID0gdGhpcy52YWx1ZSA9IHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCAodGhpcy5tb2RlICYgdG9WaWV3KSA+IDAgPyB0aGlzLmludGVyY2VwdG9yIDogbnVsbCk7XG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUNvbGxlY3Rpb24odik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFeHByZXNzaW9uLmhhc1VuYmluZCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLnVuYmluZChmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMub2JzLmNsZWFyKHRydWUpO1xuICAgIH1cbn1cbmNvbm5lY3RhYmxlKENvbnRlbnRCaW5kaW5nKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycG9sYXRpb24tYmluZGluZy5qcy5tYXAiLCJpbXBvcnQgeyBjb25uZWN0YWJsZSB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuZXhwb3J0IGNsYXNzIExldEJpbmRpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZUV4cHJlc3Npb24sIHRhcmdldFByb3BlcnR5LCBvYnNlcnZlckxvY2F0b3IsIGxvY2F0b3IsIHRvQmluZGluZ0NvbnRleHQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldFByb3BlcnR5ID0gdGFyZ2V0UHJvcGVydHk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLnRvQmluZGluZ0NvbnRleHQgPSB0b0JpbmRpbmdDb250ZXh0O1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIGNvbm5lY3RhYmxlLmFzc2lnbklkVG8odGhpcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShfbmV3VmFsdWUsIF9wcmV2aW91c1ZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDggLyogdXBkYXRlVGFyZ2V0ICovKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFByb3BlcnR5ID0gdGhpcy50YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0YXJnZXRbdGFyZ2V0UHJvcGVydHldO1xuICAgICAgICAgICAgdGhpcy5vYnMudmVyc2lvbisrO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMubG9jYXRvciwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgICAgICB0aGlzLm9icy5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0UHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGhhbmRsZUNoYW5nZSBjb250ZXh0IGluIExldEJpbmRpbmcnKTtcbiAgICB9XG4gICAgJGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3IuJHVuYmluZChmbGFncyB8IDMyIC8qIGZyb21CaW5kICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBob3N0U2NvcGU7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gKHRoaXMudG9CaW5kaW5nQ29udGV4dCA/IChob3N0U2NvcGUgPz8gc2NvcGUpLmJpbmRpbmdDb250ZXh0IDogKGhvc3RTY29wZSA/PyBzY29wZSkub3ZlcnJpZGVDb250ZXh0KTtcbiAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uaGFzQmluZCkge1xuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb3VyY2VFeHByZXNzaW9uIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIGR1cmluZyBiaW5kXG4gICAgICAgIHRoaXMudGFyZ2V0W3RoaXMudGFyZ2V0UHJvcGVydHldXG4gICAgICAgICAgICA9IHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncyB8IDMyIC8qIGZyb21CaW5kICovLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICAvLyBhZGQgaXNCb3VuZCBmbGFnIGFuZCByZW1vdmUgaXNCaW5kaW5nIGZsYWdcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLmhhc1VuYmluZCkge1xuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi51bmJpbmQoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9icy5jbGVhcih0cnVlKTtcbiAgICAgICAgLy8gcmVtb3ZlIGlzQm91bmQgYW5kIGlzVW5iaW5kaW5nIGZsYWdzXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgIH1cbn1cbmNvbm5lY3RhYmxlKExldEJpbmRpbmcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV0LWJpbmRpbmcuanMubWFwIiwiaW1wb3J0IHsgRGVsZWdhdGlvblN0cmF0ZWd5LCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgSUV2ZW50VGFyZ2V0IH0gZnJvbSAnLi4vZG9tLmpzJztcbmNvbnN0IG9wdGlvbnMgPSB7XG4gICAgW0RlbGVnYXRpb25TdHJhdGVneS5jYXB0dXJpbmddOiB7IGNhcHR1cmU6IHRydWUgfSxcbiAgICBbRGVsZWdhdGlvblN0cmF0ZWd5LmJ1YmJsaW5nXTogeyBjYXB0dXJlOiBmYWxzZSB9LFxufTtcbi8qKlxuICogTGlzdGVuZXIgYmluZGluZy4gSGFuZGxlIGV2ZW50IGJpbmRpbmcgYmV0d2VlbiB2aWV3IGFuZCB2aWV3IG1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBMaXN0ZW5lciB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm0sIHRhcmdldEV2ZW50LCBkZWxlZ2F0aW9uU3RyYXRlZ3ksIHNvdXJjZUV4cHJlc3Npb24sIHRhcmdldCwgcHJldmVudERlZmF1bHQsIGV2ZW50RGVsZWdhdG9yLCBsb2NhdG9yKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy50YXJnZXRFdmVudCA9IHRhcmdldEV2ZW50O1xuICAgICAgICB0aGlzLmRlbGVnYXRpb25TdHJhdGVneSA9IGRlbGVnYXRpb25TdHJhdGVneTtcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uID0gc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgdGhpcy5ldmVudERlbGVnYXRvciA9IGV2ZW50RGVsZWdhdG9yO1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgfVxuICAgIGNhbGxTb3VyY2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVDb250ZXh0ID0gdGhpcy4kc2NvcGUub3ZlcnJpZGVDb250ZXh0O1xuICAgICAgICBvdmVycmlkZUNvbnRleHQuJGV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZSgxMjggLyogbXVzdEV2YWx1YXRlICovLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIG51bGwpO1xuICAgICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KG92ZXJyaWRlQ29udGV4dCwgJyRldmVudCcpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlICYmIHRoaXMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvci5jYWxsU291cmNlKGV2ZW50KTtcbiAgICB9XG4gICAgJGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3IuJHVuYmluZChmbGFncyB8IDMyIC8qIGZyb21CaW5kICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBob3N0U2NvcGU7XG4gICAgICAgIGNvbnN0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLmhhc0JpbmQpIHtcbiAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24uYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGlvblN0cmF0ZWd5ID09PSBEZWxlZ2F0aW9uU3RyYXRlZ3kubm9uZSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnRhcmdldEV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gdGhpcy5sb2NhdG9yLmdldChJRXZlbnRUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gdGhpcy5ldmVudERlbGVnYXRvci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VGFyZ2V0LCB0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRFdmVudCwgdGhpcywgb3B0aW9uc1t0aGlzLmRlbGVnYXRpb25TdHJhdGVneV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBpc0JvdW5kIGZsYWcgYW5kIHJlbW92ZSBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICAkdW5iaW5kKGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uaGFzVW5iaW5kKSB7XG4gICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLnVuYmluZChmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0aW9uU3RyYXRlZ3kgPT09IERlbGVnYXRpb25TdHJhdGVneS5ub25lKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMudGFyZ2V0RXZlbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGlzQm91bmQgYW5kIGlzVW5iaW5kaW5nIGZsYWdzXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBvYnNlcnZlUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0ZW5lci5qcy5tYXAiLCJpbXBvcnQgeyBCaW5kaW5nTW9kZSwgY29ubmVjdGFibGUgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbi8vIEJpbmRpbmdNb2RlIGlzIG5vdCBhIGNvbnN0IGVudW0gKGFuZCB0aGVyZWZvcmUgbm90IGlubGluZWQpLCBzbyBhc3NpZ25pbmcgdGhlbSB0byBhIHZhcmlhYmxlIHRvIHNhdmUgYSBtZW1iZXIgYWNjZXNzb3IgaXMgYSBtaW5vciBwZXJmIHR3ZWFrXG5jb25zdCB7IG9uZVRpbWUsIHRvVmlldywgZnJvbVZpZXcgfSA9IEJpbmRpbmdNb2RlO1xuLy8gcHJlLWNvbWJpbmluZyBmbGFncyBmb3IgYml0d2lzZSBjaGVja3MgaXMgYSBtaW5vciBwZXJmIHR3ZWFrXG5jb25zdCB0b1ZpZXdPck9uZVRpbWUgPSB0b1ZpZXcgfCBvbmVUaW1lO1xuY29uc3QgdXBkYXRlVGFza09wdHMgPSB7XG4gICAgcmV1c2FibGU6IGZhbHNlLFxuICAgIHByZWVtcHQ6IHRydWUsXG59O1xuZXhwb3J0IGNsYXNzIFByb3BlcnR5QmluZGluZyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCB0YXJnZXRQcm9wZXJ0eSwgbW9kZSwgb2JzZXJ2ZXJMb2NhdG9yLCBsb2NhdG9yLCB0YXNrUXVldWUpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uID0gc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMudGFza1F1ZXVlID0gdGFza1F1ZXVlO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbnRGbGFncyA9IDAgLyogbm9uZSAqLztcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgY29ubmVjdGFibGUuYXNzaWduSWRUbyh0aGlzKTtcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0KHZhbHVlLCBmbGFncykge1xuICAgICAgICBmbGFncyB8PSB0aGlzLnBlcnNpc3RlbnRGbGFncztcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zZXRWYWx1ZSh2YWx1ZSwgZmxhZ3MsIHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgdXBkYXRlU291cmNlKHZhbHVlLCBmbGFncykge1xuICAgICAgICBmbGFncyB8PSB0aGlzLnBlcnNpc3RlbnRGbGFncztcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLmFzc2lnbihmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgX3ByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3MgfD0gdGhpcy5wZXJzaXN0ZW50RmxhZ3M7XG4gICAgICAgIGNvbnN0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3IgPSB0aGlzLmludGVyY2VwdG9yO1xuICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBjb25zdCAkc2NvcGUgPSB0aGlzLiRzY29wZTtcbiAgICAgICAgY29uc3QgbG9jYXRvciA9IHRoaXMubG9jYXRvcjtcbiAgICAgICAgaWYgKChmbGFncyAmIDggLyogdXBkYXRlVGFyZ2V0ICovKSA+IDApIHtcbiAgICAgICAgICAgIC8vIEFscGhhOiBkdXJpbmcgYmluZCBhIHNpbXBsZSBzdHJhdGVneSBmb3IgYmluZCBpcyBhbHdheXMgZmx1c2ggaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIHRvZG86XG4gICAgICAgICAgICAvLyAgKDEpLiBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHNob3VsZCBiZSB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vICAoMikuIGlmIG5vdCwgdGhlbiBmaXggdGVzdHMgdG8gcmVmbGVjdCB0aGUgY2hhbmdlcy9wbGF0Zm9ybSB0byBwcm9wZXJseSB5aWVsZCBhbGwgd2l0aCBhdXJlbGlhLnN0YXJ0KClcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFF1ZXVlRmx1c2ggPSAoZmxhZ3MgJiAzMiAvKiBmcm9tQmluZCAqLykgPT09IDAgJiYgKHRhcmdldE9ic2VydmVyLnR5cGUgJiA0IC8qIExheW91dCAqLykgPiAwO1xuICAgICAgICAgICAgY29uc3Qgb2JzUmVjb3JkID0gdGhpcy5vYnM7XG4gICAgICAgICAgICAvLyBpZiB0aGUgb25seSBvYnNlcnZhYmxlIGlzIGFuIEFjY2Vzc1Njb3BlIHRoZW4gd2UgY2FuIGFzc3VtZSB0aGUgcGFzc2VkLWluIG5ld1ZhbHVlIGlzIHRoZSBjb3JyZWN0IGFuZCBsYXRlc3QgdmFsdWVcbiAgICAgICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLiRraW5kICE9PSAxMDA4MiAvKiBBY2Nlc3NTY29wZSAqLyB8fCBvYnNSZWNvcmQuY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbzogaW4gVkMgZXhwcmVzc2lvbnMsIGZyb20gdmlldyBhbHNvIHJlcXVpcmVzIGNvbm5lY3RcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRDb25uZWN0ID0gdGhpcy5tb2RlID4gb25lVGltZTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNSZWNvcmQudmVyc2lvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsICRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCBsb2NhdG9yLCBpbnRlcmNlcHRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzUmVjb3JkLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkUXVldWVGbHVzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFzaz8uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50YXNrID0gdGhpcy50YXNrUXVldWUucXVldWVUYXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJjZXB0b3IudXBkYXRlVGFyZ2V0KG5ld1ZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgdXBkYXRlVGFza09wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0b3IudXBkYXRlVGFyZ2V0KG5ld1ZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmbGFncyAmIDE2IC8qIHVwZGF0ZVNvdXJjZSAqLykgPiAwKSB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsICRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCBsb2NhdG9yLCBudWxsKSkge1xuICAgICAgICAgICAgICAgIGludGVyY2VwdG9yLnVwZGF0ZVNvdXJjZShuZXdWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBoYW5kbGVDaGFuZ2UgY29udGV4dCBpbiBQcm9wZXJ0eUJpbmRpbmcnKTtcbiAgICB9XG4gICAgJGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3IuJHVuYmluZChmbGFncyB8IDMyIC8qIGZyb21CaW5kICovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3JjZSBwcm9wZXJ0eSBiaW5kaW5nIHRvIGFsd2F5cyBiZSBzdHJpY3RcbiAgICAgICAgZmxhZ3MgfD0gNCAvKiBpc1N0cmljdEJpbmRpbmdTdHJhdGVneSAqLztcbiAgICAgICAgLy8gU3RvcmUgZmxhZ3Mgd2hpY2ggd2UgY2FuIG9ubHkgcmVjZWl2ZSBkdXJpbmcgJGJpbmQgYW5kIG5lZWQgdG8gcGFzcyBvblxuICAgICAgICAvLyB0byB0aGUgQVNUIGR1cmluZyBldmFsdWF0ZS9jb25uZWN0L2Fzc2lnblxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRGbGFncyA9IGZsYWdzICYgMTUzNjcgLyogcGVyc2lzdGVudEJpbmRpbmdGbGFncyAqLztcbiAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gaG9zdFNjb3BlO1xuICAgICAgICBsZXQgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uaGFzQmluZCkge1xuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgICAgbGV0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgaWYgKCF0YXJnZXRPYnNlcnZlcikge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXJMb2NhdG9yID0gdGhpcy5vYnNlcnZlckxvY2F0b3I7XG4gICAgICAgICAgICBpZiAoJG1vZGUgJiBmcm9tVmlldykge1xuICAgICAgICAgICAgICAgIHRhcmdldE9ic2VydmVyID0gb2JzZXJ2ZXJMb2NhdG9yLmdldE9ic2VydmVyKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE9ic2VydmVyID0gb2JzZXJ2ZXJMb2NhdG9yLmdldEFjY2Vzc29yKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIgPSB0YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgYmluZCwgYmluZGluZyBiZWhhdmlvciBtaWdodCBoYXZlIGNoYW5nZWQgc291cmNlRXhwcmVzc2lvblxuICAgICAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IHRoaXMuaW50ZXJjZXB0b3I7XG4gICAgICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSAoJG1vZGUgJiB0b1ZpZXcpID4gMDtcbiAgICAgICAgaWYgKCRtb2RlICYgdG9WaWV3T3JPbmVUaW1lKSB7XG4gICAgICAgICAgICBpbnRlcmNlcHRvci51cGRhdGVUYXJnZXQoc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCBzaG91bGRDb25uZWN0ID8gaW50ZXJjZXB0b3IgOiBudWxsKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkbW9kZSAmIGZyb21WaWV3KSB7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlci5zdWJzY3JpYmUoaW50ZXJjZXB0b3IpO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0b3IudXBkYXRlU291cmNlKHRhcmdldE9ic2VydmVyLmdldFZhbHVlKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KSwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXJbdGhpcy5pZF0gfD0gMTYgLyogdXBkYXRlU291cmNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRGbGFncyA9IDAgLyogbm9uZSAqLztcbiAgICAgICAgaWYgKHRoaXMuc291cmNlRXhwcmVzc2lvbi5oYXNVbmJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbi51bmJpbmQoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICBjb25zdCB0YXJnZXRPYnNlcnZlciA9IHRoaXMudGFyZ2V0T2JzZXJ2ZXI7XG4gICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLnRhc2s7XG4gICAgICAgIGlmICh0YXJnZXRPYnNlcnZlci51bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlclt0aGlzLmlkXSAmPSB+MTYgLyogdXBkYXRlU291cmNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRhc2suY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzLmNsZWFyKHRydWUpO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICB9XG59XG5jb25uZWN0YWJsZShQcm9wZXJ0eUJpbmRpbmcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHktYmluZGluZy5qcy5tYXAiLCJleHBvcnQgY2xhc3MgUmVmQmluZGluZyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCBsb2NhdG9yKSB7XG4gICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbiA9IHNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzIHwgMzIgLyogZnJvbUJpbmQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IGhvc3RTY29wZTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlRXhwcmVzc2lvbi5oYXNCaW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24uYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLmFzc2lnbihmbGFncyB8IDE2IC8qIHVwZGF0ZVNvdXJjZSAqLywgdGhpcy4kc2NvcGUsIGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCB0aGlzLnRhcmdldCk7XG4gICAgICAgIC8vIGFkZCBpc0JvdW5kIGZsYWcgYW5kIHJlbW92ZSBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICAkdW5iaW5kKGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIG51bGwpID09PSB0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi5hc3NpZ24oZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMubG9jYXRvciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc291cmNlIGV4cHJlc3Npb24gbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkIGR1cnJpbmcgYXNzaWduLCB2aWEgYSBCQlxuICAgICAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBpZiAoc291cmNlRXhwcmVzc2lvbi5oYXNVbmJpbmQpIHtcbiAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24udW5iaW5kKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzY29wZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIG9ic2VydmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZi1iaW5kaW5nLmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVybiwgQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuLCBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuLCBSZWZBdHRyaWJ1dGVQYXR0ZXJuLCB9IGZyb20gJy4vcmVzb3VyY2VzL2F0dHJpYnV0ZS1wYXR0ZXJuLmpzJztcbmltcG9ydCB7IENhbGxCaW5kaW5nQ29tbWFuZCwgRGVmYXVsdEJpbmRpbmdDb21tYW5kLCBGb3JCaW5kaW5nQ29tbWFuZCwgRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCwgT25lVGltZUJpbmRpbmdDb21tYW5kLCBUb1ZpZXdCaW5kaW5nQ29tbWFuZCwgVHdvV2F5QmluZGluZ0NvbW1hbmQsIEF0dHJCaW5kaW5nQ29tbWFuZCwgQ2FwdHVyZUJpbmRpbmdDb21tYW5kLCBDbGFzc0JpbmRpbmdDb21tYW5kLCBEZWxlZ2F0ZUJpbmRpbmdDb21tYW5kLCBSZWZCaW5kaW5nQ29tbWFuZCwgU3R5bGVCaW5kaW5nQ29tbWFuZCwgVHJpZ2dlckJpbmRpbmdDb21tYW5kLCB9IGZyb20gJy4vcmVzb3VyY2VzL2JpbmRpbmctY29tbWFuZC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUNvbXBpbGVyIH0gZnJvbSAnLi90ZW1wbGF0ZS1jb21waWxlci5qcyc7XG5pbXBvcnQgeyBDYWxsQmluZGluZ1JlbmRlcmVyLCBDdXN0b21BdHRyaWJ1dGVSZW5kZXJlciwgQ3VzdG9tRWxlbWVudFJlbmRlcmVyLCBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyLCBJdGVyYXRvckJpbmRpbmdSZW5kZXJlciwgTGV0RWxlbWVudFJlbmRlcmVyLCBQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciwgUmVmQmluZGluZ1JlbmRlcmVyLCBTZXRQcm9wZXJ0eVJlbmRlcmVyLCBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlciwgQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyLCBMaXN0ZW5lckJpbmRpbmdSZW5kZXJlciwgU2V0QXR0cmlidXRlUmVuZGVyZXIsIFN0eWxlUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIsIFRleHRCaW5kaW5nUmVuZGVyZXIsIFNldENsYXNzQXR0cmlidXRlUmVuZGVyZXIsIFNldFN0eWxlQXR0cmlidXRlUmVuZGVyZXIsIH0gZnJvbSAnLi9yZW5kZXJlci5qcyc7XG5pbXBvcnQgeyBGcm9tVmlld0JpbmRpbmdCZWhhdmlvciwgT25lVGltZUJpbmRpbmdCZWhhdmlvciwgVG9WaWV3QmluZGluZ0JlaGF2aW9yLCBUd29XYXlCaW5kaW5nQmVoYXZpb3IsIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9ycy9iaW5kaW5nLW1vZGUuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VCaW5kaW5nQmVoYXZpb3IgfSBmcm9tICcuL2JpbmRpbmctYmVoYXZpb3JzL2RlYm91bmNlLmpzJztcbmltcG9ydCB7IFNpZ25hbEJpbmRpbmdCZWhhdmlvciB9IGZyb20gJy4vYmluZGluZy1iZWhhdmlvcnMvc2lnbmFscy5qcyc7XG5pbXBvcnQgeyBUaHJvdHRsZUJpbmRpbmdCZWhhdmlvciB9IGZyb20gJy4vYmluZGluZy1iZWhhdmlvcnMvdGhyb3R0bGUuanMnO1xuaW1wb3J0IHsgU1ZHQW5hbHl6ZXIgfSBmcm9tICcuL29ic2VydmF0aW9uL3N2Zy1hbmFseXplci5qcyc7XG5pbXBvcnQgeyBBdHRyQmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1iZWhhdmlvcnMvYXR0ci5qcyc7XG5pbXBvcnQgeyBTZWxmQmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1iZWhhdmlvcnMvc2VsZi5qcyc7XG5pbXBvcnQgeyBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1iZWhhdmlvcnMvdXBkYXRlLXRyaWdnZXIuanMnO1xuaW1wb3J0IHsgQmx1ciB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGVzL2JsdXIuanMnO1xuaW1wb3J0IHsgRm9jdXMgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlcy9mb2N1cy5qcyc7XG5pbXBvcnQgeyBTaG93IH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZXMvc2hvdy5qcyc7XG5pbXBvcnQgeyBQb3J0YWwgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9wb3J0YWwuanMnO1xuaW1wb3J0IHsgRnJlcXVlbnRNdXRhdGlvbnMsIE9ic2VydmVTaGFsbG93IH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvZmxhZ3MuanMnO1xuaW1wb3J0IHsgRWxzZSwgSWYgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9pZi5qcyc7XG5pbXBvcnQgeyBSZXBlYXQgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9yZXBlYXQuanMnO1xuaW1wb3J0IHsgV2l0aCB9IGZyb20gJy4vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3dpdGguanMnO1xuaW1wb3J0IHsgU3dpdGNoLCBDYXNlLCBEZWZhdWx0Q2FzZSB9IGZyb20gJy4vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3N3aXRjaC5qcyc7XG5pbXBvcnQgeyBDb21wb3NlIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnRzL2NvbXBvc2UuanMnO1xuaW1wb3J0IHsgQXVTbG90IH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnRzL2F1LXNsb3QuanMnO1xuaW1wb3J0IHsgU2FuaXRpemVWYWx1ZUNvbnZlcnRlciB9IGZyb20gJy4vcmVzb3VyY2VzL3ZhbHVlLWNvbnZlcnRlcnMvc2FuaXRpemUuanMnO1xuaW1wb3J0IHsgVmlld1ZhbHVlQ29udmVydGVyIH0gZnJvbSAnLi9yZXNvdXJjZXMvdmFsdWUtY29udmVydGVycy92aWV3LmpzJztcbmltcG9ydCB7IE5vZGVPYnNlcnZlckxvY2F0b3IgfSBmcm9tICcuL29ic2VydmF0aW9uL29ic2VydmVyLWxvY2F0b3IuanMnO1xuZXhwb3J0IGNvbnN0IERlYm91bmNlQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gRGVib3VuY2VCaW5kaW5nQmVoYXZpb3I7XG5leHBvcnQgY29uc3QgT25lVGltZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbiA9IE9uZVRpbWVCaW5kaW5nQmVoYXZpb3I7XG5leHBvcnQgY29uc3QgVG9WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gVG9WaWV3QmluZGluZ0JlaGF2aW9yO1xuZXhwb3J0IGNvbnN0IEZyb21WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3I7XG5leHBvcnQgY29uc3QgU2lnbmFsQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gU2lnbmFsQmluZGluZ0JlaGF2aW9yO1xuZXhwb3J0IGNvbnN0IFRocm90dGxlQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3I7XG5leHBvcnQgY29uc3QgVHdvV2F5QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gVHdvV2F5QmluZGluZ0JlaGF2aW9yO1xuZXhwb3J0IGNvbnN0IElUZW1wbGF0ZUNvbXBpbGVyUmVnaXN0cmF0aW9uID0gVGVtcGxhdGVDb21waWxlcjtcbmV4cG9ydCBjb25zdCBJTm9kZU9ic2VydmVyTG9jYXRvclJlZ2lzdHJhdGlvbiA9IE5vZGVPYnNlcnZlckxvY2F0b3I7XG4vKipcbiAqIERlZmF1bHQgSFRNTC1zcGVjaWZpYyAoYnV0IGVudmlyb25tZW50LWFnbm9zdGljKSBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlczpcbiAqIC0gYElUZW1wbGF0ZUNvbXBpbGVyYFxuICogLSBgSVRhcmdldEFjY2Vzc29yTG9jYXRvcmBcbiAqIC0gYElUYXJnZXRPYnNlcnZlckxvY2F0b3JgXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0Q29tcG9uZW50cyA9IFtcbiAgICBJVGVtcGxhdGVDb21waWxlclJlZ2lzdHJhdGlvbixcbiAgICBJTm9kZU9ic2VydmVyTG9jYXRvclJlZ2lzdHJhdGlvbixcbl07XG5leHBvcnQgY29uc3QgU1ZHQW5hbHl6ZXJSZWdpc3RyYXRpb24gPSBTVkdBbmFseXplcjtcbmV4cG9ydCBjb25zdCBBdFByZWZpeGVkVHJpZ2dlckF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24gPSBBdFByZWZpeGVkVHJpZ2dlckF0dHJpYnV0ZVBhdHRlcm47XG5leHBvcnQgY29uc3QgQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uID0gQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuO1xuZXhwb3J0IGNvbnN0IFJlZkF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24gPSBSZWZBdHRyaWJ1dGVQYXR0ZXJuO1xuZXhwb3J0IGNvbnN0IERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24gPSBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuO1xuLyoqXG4gKiBEZWZhdWx0IGJpbmRpbmcgc3ludGF4IGZvciB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZSBuYW1lIHBhdHRlcm5zOlxuICogLSBgcmVmYFxuICogLSBgdGFyZ2V0LmNvbW1hbmRgIChkb3Qtc2VwYXJhdGVkKVxuICovXG5leHBvcnQgY29uc3QgRGVmYXVsdEJpbmRpbmdTeW50YXggPSBbXG4gICAgUmVmQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvbixcbiAgICBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uXG5dO1xuLyoqXG4gKiBCaW5kaW5nIHN5bnRheCBmb3Igc2hvcnQtaGFuZCBhdHRyaWJ1dGUgbmFtZSBwYXR0ZXJuczpcbiAqIC0gYEB0YXJnZXRgIChzaG9ydC1oYW5kIGZvciBgdGFyZ2V0LnRyaWdnZXJgKVxuICogLSBgOnRhcmdldGAgKHNob3J0LWhhbmQgZm9yIGB0YXJnZXQuYmluZGApXG4gKi9cbmV4cG9ydCBjb25zdCBTaG9ydEhhbmRCaW5kaW5nU3ludGF4ID0gW1xuICAgIEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvbixcbiAgICBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb25cbl07XG5leHBvcnQgY29uc3QgQ2FsbEJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gQ2FsbEJpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IERlZmF1bHRCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IERlZmF1bHRCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBGb3JCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IEZvckJpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IEZyb21WaWV3QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBGcm9tVmlld0JpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IE9uZVRpbWVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IE9uZVRpbWVCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBUb1ZpZXdCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IFRvVmlld0JpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IFR3b1dheUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gVHdvV2F5QmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgUmVmQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBSZWZCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBUcmlnZ2VyQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBUcmlnZ2VyQmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgRGVsZWdhdGVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IERlbGVnYXRlQmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgQ2FwdHVyZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gQ2FwdHVyZUJpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IEF0dHJCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IEF0dHJCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBDbGFzc0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gQ2xhc3NCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBTdHlsZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gU3R5bGVCaW5kaW5nQ29tbWFuZDtcbi8qKlxuICogRGVmYXVsdCBIVE1MLXNwZWNpZmljIChidXQgZW52aXJvbm1lbnQtYWdub3N0aWMpIGJpbmRpbmcgY29tbWFuZHM6XG4gKiAtIFByb3BlcnR5IG9ic2VydmF0aW9uOiBgLmJpbmRgLCBgLm9uZS10aW1lYCwgYC5mcm9tLXZpZXdgLCBgLnRvLXZpZXdgLCBgLnR3by13YXlgXG4gKiAtIEZ1bmN0aW9uIGNhbGw6IGAuY2FsbGBcbiAqIC0gQ29sbGVjdGlvbiBvYnNlcnZhdGlvbjogYC5mb3JgXG4gKiAtIEV2ZW50IGxpc3RlbmVyczogYC50cmlnZ2VyYCwgYC5kZWxlZ2F0ZWAsIGAuY2FwdHVyZWBcbiAqL1xuZXhwb3J0IGNvbnN0IERlZmF1bHRCaW5kaW5nTGFuZ3VhZ2UgPSBbXG4gICAgRGVmYXVsdEJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIE9uZVRpbWVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBGcm9tVmlld0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIFRvVmlld0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIFR3b1dheUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIENhbGxCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBGb3JCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBSZWZCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBUcmlnZ2VyQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4gICAgRGVsZWdhdGVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBDYXB0dXJlQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4gICAgQ2xhc3NCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBTdHlsZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIEF0dHJCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbl07XG5leHBvcnQgY29uc3QgU2FuaXRpemVWYWx1ZUNvbnZlcnRlclJlZ2lzdHJhdGlvbiA9IFNhbml0aXplVmFsdWVDb252ZXJ0ZXI7XG5leHBvcnQgY29uc3QgVmlld1ZhbHVlQ29udmVydGVyUmVnaXN0cmF0aW9uID0gVmlld1ZhbHVlQ29udmVydGVyO1xuZXhwb3J0IGNvbnN0IEZyZXF1ZW50TXV0YXRpb25zUmVnaXN0cmF0aW9uID0gRnJlcXVlbnRNdXRhdGlvbnM7XG5leHBvcnQgY29uc3QgT2JzZXJ2ZVNoYWxsb3dSZWdpc3RyYXRpb24gPSBPYnNlcnZlU2hhbGxvdztcbmV4cG9ydCBjb25zdCBJZlJlZ2lzdHJhdGlvbiA9IElmO1xuZXhwb3J0IGNvbnN0IEVsc2VSZWdpc3RyYXRpb24gPSBFbHNlO1xuZXhwb3J0IGNvbnN0IFJlcGVhdFJlZ2lzdHJhdGlvbiA9IFJlcGVhdDtcbmV4cG9ydCBjb25zdCBXaXRoUmVnaXN0cmF0aW9uID0gV2l0aDtcbmV4cG9ydCBjb25zdCBTd2l0Y2hSZWdpc3RyYXRpb24gPSBTd2l0Y2g7XG5leHBvcnQgY29uc3QgQ2FzZVJlZ2lzdHJhdGlvbiA9IENhc2U7XG5leHBvcnQgY29uc3QgRGVmYXVsdENhc2VSZWdpc3RyYXRpb24gPSBEZWZhdWx0Q2FzZTtcbmV4cG9ydCBjb25zdCBBdHRyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gQXR0ckJpbmRpbmdCZWhhdmlvcjtcbmV4cG9ydCBjb25zdCBTZWxmQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gU2VsZkJpbmRpbmdCZWhhdmlvcjtcbmV4cG9ydCBjb25zdCBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvcjtcbmV4cG9ydCBjb25zdCBDb21wb3NlUmVnaXN0cmF0aW9uID0gQ29tcG9zZTtcbmV4cG9ydCBjb25zdCBQb3J0YWxSZWdpc3RyYXRpb24gPSBQb3J0YWw7XG5leHBvcnQgY29uc3QgRm9jdXNSZWdpc3RyYXRpb24gPSBGb2N1cztcbmV4cG9ydCBjb25zdCBCbHVyUmVnaXN0cmF0aW9uID0gQmx1cjtcbmV4cG9ydCBjb25zdCBTaG93UmVnaXN0cmF0aW9uID0gU2hvdztcbi8qKlxuICogRGVmYXVsdCBIVE1MLXNwZWNpZmljIChidXQgZW52aXJvbm1lbnQtYWdub3N0aWMpIHJlc291cmNlczpcbiAqIC0gQmluZGluZyBCZWhhdmlvcnM6IGBvbmVUaW1lYCwgYHRvVmlld2AsIGBmcm9tVmlld2AsIGB0d29XYXlgLCBgc2lnbmFsYCwgYGRlYm91bmNlYCwgYHRocm90dGxlYCwgYGF0dHJgLCBgc2VsZmAsIGB1cGRhdGVUcmlnZ2VyYFxuICogLSBDdXN0b20gRWxlbWVudHM6IGBhdS1jb21wb3NlYCwgYGF1LXNsb3RgXG4gKiAtIEN1c3RvbSBBdHRyaWJ1dGVzOiBgYmx1cmAsIGBmb2N1c2AsIGBwb3J0YWxgXG4gKiAtIFRlbXBsYXRlIGNvbnRyb2xsZXJzOiBgaWZgL2BlbHNlYCwgYHJlcGVhdGAsIGB3aXRoYFxuICogLSBWYWx1ZSBDb252ZXJ0ZXJzOiBgc2FuaXRpemVgXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0UmVzb3VyY2VzID0gW1xuICAgIERlYm91bmNlQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuICAgIE9uZVRpbWVCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4gICAgVG9WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuICAgIEZyb21WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuICAgIFNpZ25hbEJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbiAgICBUaHJvdHRsZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbiAgICBUd29XYXlCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4gICAgU2FuaXRpemVWYWx1ZUNvbnZlcnRlclJlZ2lzdHJhdGlvbixcbiAgICBWaWV3VmFsdWVDb252ZXJ0ZXJSZWdpc3RyYXRpb24sXG4gICAgRnJlcXVlbnRNdXRhdGlvbnNSZWdpc3RyYXRpb24sXG4gICAgT2JzZXJ2ZVNoYWxsb3dSZWdpc3RyYXRpb24sXG4gICAgSWZSZWdpc3RyYXRpb24sXG4gICAgRWxzZVJlZ2lzdHJhdGlvbixcbiAgICBSZXBlYXRSZWdpc3RyYXRpb24sXG4gICAgV2l0aFJlZ2lzdHJhdGlvbixcbiAgICBTd2l0Y2hSZWdpc3RyYXRpb24sXG4gICAgQ2FzZVJlZ2lzdHJhdGlvbixcbiAgICBEZWZhdWx0Q2FzZVJlZ2lzdHJhdGlvbixcbiAgICBBdHRyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuICAgIFNlbGZCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4gICAgVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbiAgICBDb21wb3NlUmVnaXN0cmF0aW9uLFxuICAgIFBvcnRhbFJlZ2lzdHJhdGlvbixcbiAgICBGb2N1c1JlZ2lzdHJhdGlvbixcbiAgICBCbHVyUmVnaXN0cmF0aW9uLFxuICAgIFNob3dSZWdpc3RyYXRpb24sXG4gICAgQXVTbG90LFxuXTtcbmV4cG9ydCBjb25zdCBDYWxsQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gQ2FsbEJpbmRpbmdSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBDdXN0b21BdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IEN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnRSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IEN1c3RvbUVsZW1lbnRSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gSW50ZXJwb2xhdGlvbkJpbmRpbmdSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBJdGVyYXRvckJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IExldEVsZW1lbnRSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IExldEVsZW1lbnRSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IFByb3BlcnR5QmluZGluZ1JlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IFJlZkJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IFJlZkJpbmRpbmdSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBTZXRQcm9wZXJ0eVJlbmRlcmVyUmVnaXN0cmF0aW9uID0gU2V0UHJvcGVydHlSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IFRlbXBsYXRlQ29udHJvbGxlclJlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IExpc3RlbmVyQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IFNldEF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uID0gU2V0QXR0cmlidXRlUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IFNldENsYXNzQXR0cmlidXRlUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgU2V0U3R5bGVBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IFNldFN0eWxlQXR0cmlidXRlUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IFN0eWxlUHJvcGVydHlCaW5kaW5nUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgVGV4dEJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiA9IFRleHRCaW5kaW5nUmVuZGVyZXI7XG4vKipcbiAqIERlZmF1bHQgcmVuZGVyZXJzIGZvcjpcbiAqIC0gUHJvcGVydHlCaW5kaW5nOiBgYmluZGAsIGBvbmUtdGltZWAsIGB0by12aWV3YCwgYGZyb20tdmlld2AsIGB0d28td2F5YFxuICogLSBJdGVyYXRvckJpbmRpbmc6IGBmb3JgXG4gKiAtIENhbGxCaW5kaW5nOiBgY2FsbGBcbiAqIC0gUmVmQmluZGluZzogYHJlZmBcbiAqIC0gSW50ZXJwb2xhdGlvbkJpbmRpbmc6IGAke31gXG4gKiAtIFNldFByb3BlcnR5XG4gKiAtIGBjdXN0b21FbGVtZW50YCBoeWRyYXRpb25cbiAqIC0gYGN1c3RvbUF0dHJpYnV0ZWAgaHlkcmF0aW9uXG4gKiAtIGB0ZW1wbGF0ZUNvbnRyb2xsZXJgIGh5ZHJhdGlvblxuICogLSBgbGV0YCBlbGVtZW50IGh5ZHJhdGlvblxuICogLSBMaXN0ZW5lciBCaW5kaW5nczogYHRyaWdnZXJgLCBgY2FwdHVyZWAsIGBkZWxlZ2F0ZWBcbiAqIC0gU2V0QXR0cmlidXRlXG4gKiAtIFN0eWxlUHJvcGVydHk6IGBzdHlsZWAsIGBjc3NgXG4gKiAtIFRleHRCaW5kaW5nOiBgJHt9YFxuICovXG5leHBvcnQgY29uc3QgRGVmYXVsdFJlbmRlcmVycyA9IFtcbiAgICBQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBJdGVyYXRvckJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBDYWxsQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIFJlZkJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIFNldFByb3BlcnR5UmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgQ3VzdG9tRWxlbWVudFJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIEN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIFRlbXBsYXRlQ29udHJvbGxlclJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIExldEVsZW1lbnRSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBMaXN0ZW5lckJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgU2V0QXR0cmlidXRlUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIFN0eWxlUHJvcGVydHlCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgVGV4dEJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbl07XG4vKipcbiAqIEEgREkgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyBodG1sLXNwZWNpZmljIChidXQgZW52aXJvbm1lbnQtYWdub3N0aWMpIHJlZ2lzdHJhdGlvbnM6XG4gKiAtIGBSdW50aW1lQ29uZmlndXJhdGlvbmAgZnJvbSBgQGF1cmVsaWEvcnVudGltZWBcbiAqIC0gYERlZmF1bHRDb21wb25lbnRzYFxuICogLSBgRGVmYXVsdFJlc291cmNlc2BcbiAqIC0gYERlZmF1bHRSZW5kZXJlcnNgXG4gKi9cbmV4cG9ydCBjb25zdCBTdGFuZGFyZENvbmZpZ3VyYXRpb24gPSB7XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhpcyBjb25maWd1cmF0aW9uIHRvIHRoZSBwcm92aWRlZCBjb250YWluZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIucmVnaXN0ZXIoLi4uRGVmYXVsdENvbXBvbmVudHMsIC4uLkRlZmF1bHRSZXNvdXJjZXMsIC4uLkRlZmF1bHRCaW5kaW5nU3ludGF4LCAuLi5EZWZhdWx0QmluZGluZ0xhbmd1YWdlLCAuLi5EZWZhdWx0UmVuZGVyZXJzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb250YWluZXIgd2l0aCB0aGlzIGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBpdC5cbiAgICAgKi9cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyKERJLmNyZWF0ZUNvbnRhaW5lcigpKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlndXJhdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBIeWRyYXRlRWxlbWVudEluc3RydWN0aW9uLCBpc0luc3RydWN0aW9uLCBTZXRBdHRyaWJ1dGVJbnN0cnVjdGlvbiwgfSBmcm9tICcuL3JlbmRlcmVyLmpzJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQsIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgZ2V0UmVuZGVyQ29udGV4dCB9IGZyb20gJy4vdGVtcGxhdGluZy9yZW5kZXItY29udGV4dC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwLCB0YWdPclR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIGlmICh0eXBlb2YgdGFnT3JUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudEZvclRhZyhwLCB0YWdPclR5cGUsIHByb3BzLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKEN1c3RvbUVsZW1lbnQuaXNUeXBlKHRhZ09yVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnRGb3JUeXBlKHAsIHRhZ09yVHlwZSwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YWdPclR5cGUuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZW5kZXJQbGFuLiBUb2RvOiBkZXNjcmliZSBnb2FsIG9mIHRoaXMgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFJlbmRlclBsYW4ge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGluc3RydWN0aW9ucywgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5sYXp5RGVmaW5pdGlvbiA9IHZvaWQgMDtcbiAgICB9XG4gICAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmxhenlEZWZpbml0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMubGF6eURlZmluaXRpb24gPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IEN1c3RvbUVsZW1lbnQuZ2VuZXJhdGVOYW1lKCksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMubm9kZSxcbiAgICAgICAgICAgICAgICBuZWVkc0NvbXBpbGU6IHR5cGVvZiB0aGlzLm5vZGUgPT09ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiB0aGlzLmRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhenlEZWZpbml0aW9uO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KHBhcmVudENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gZ2V0UmVuZGVyQ29udGV4dCh0aGlzLmRlZmluaXRpb24sIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuICAgIGNyZWF0ZVZpZXcocGFyZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZpZXdGYWN0b3J5KHBhcmVudENvbnRhaW5lcikuY3JlYXRlKCk7XG4gICAgfVxuICAgIGdldFZpZXdGYWN0b3J5KHBhcmVudENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZXh0KHBhcmVudENvbnRhaW5lcikuZ2V0Vmlld0ZhY3RvcnkoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG1lcmdlSW50byhwYXJlbnQsIGluc3RydWN0aW9ucywgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCguLi50aGlzLmluc3RydWN0aW9ucyk7XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKC4uLnRoaXMuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50Rm9yVGFnKHAsIHRhZ05hbWUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGFsbEluc3RydWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBwLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgbGV0IGhhc0luc3RydWN0aW9ucyA9IGZhbHNlO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wcylcbiAgICAgICAgICAgIC5mb3JFYWNoKHRvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbdG9dO1xuICAgICAgICAgICAgaWYgKGlzSW5zdHJ1Y3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaGFzSW5zdHJ1Y3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSh0bywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGhhc0luc3RydWN0aW9ucykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9ICdhdSc7XG4gICAgICAgIGFsbEluc3RydWN0aW9ucy5wdXNoKGluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBhZGRDaGlsZHJlbihwLCBlbGVtZW50LCBjaGlsZHJlbiwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlbmRlclBsYW4oZWxlbWVudCwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEZvclR5cGUocCwgVHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IEN1c3RvbUVsZW1lbnQuZ2V0RGVmaW5pdGlvbihUeXBlKTtcbiAgICBjb25zdCB0YWdOYW1lID0gZGVmaW5pdGlvbi5uYW1lO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGFsbEluc3RydWN0aW9ucyA9IFtpbnN0cnVjdGlvbnNdO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIGNvbnN0IGNoaWxkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgY29uc3QgYmluZGFibGVzID0gZGVmaW5pdGlvbi5iaW5kYWJsZXM7XG4gICAgY29uc3QgZWxlbWVudCA9IHAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9ICdhdSc7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMuaW5jbHVkZXMoVHlwZSkpIHtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goVHlwZSk7XG4gICAgfVxuICAgIGluc3RydWN0aW9ucy5wdXNoKG5ldyBIeWRyYXRlRWxlbWVudEluc3RydWN0aW9uKHRhZ05hbWUsIHZvaWQgMCwgY2hpbGRJbnN0cnVjdGlvbnMsIG51bGwpKTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpXG4gICAgICAgICAgICAuZm9yRWFjaCh0byA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3RvXTtcbiAgICAgICAgICAgIGlmIChpc0luc3RydWN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb25zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluZGFibGUgPSBiaW5kYWJsZXNbdG9dO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kYWJsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZVwiIC8qIHNldFByb3BlcnR5ICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFNldEF0dHJpYnV0ZUluc3RydWN0aW9uKHZhbHVlLCB0bykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBhZGRDaGlsZHJlbihwLCBlbGVtZW50LCBjaGlsZHJlbiwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlbmRlclBsYW4oZWxlbWVudCwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocCwgcGFyZW50LCBjaGlsZHJlbiwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgcC5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ21lcmdlSW50bycgaW4gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lcmdlSW50byhwYXJlbnQsIGFsbEluc3RydWN0aW9ucywgZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtZWxlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyBESSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJQXBwUm9vdCB9IGZyb20gJy4vYXBwLXJvb3QuanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuZXhwb3J0IGNvbnN0IElOb2RlID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJTm9kZScpO1xuZXhwb3J0IGNvbnN0IElFdmVudFRhcmdldCA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUV2ZW50VGFyZ2V0JywgeCA9PiB4LmNhY2hlZENhbGxiYWNrKGhhbmRsZXIgPT4ge1xuICAgIGlmIChoYW5kbGVyLmhhcyhJQXBwUm9vdCwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0KElBcHBSb290KS5ob3N0O1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5nZXQoSVBsYXRmb3JtKS5kb2N1bWVudDtcbn0pKTtcbmV4cG9ydCBjb25zdCBJUmVuZGVyTG9jYXRpb24gPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lSZW5kZXJMb2NhdGlvbicpO1xuZXhwb3J0IHZhciBOb2RlVHlwZTtcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkVsZW1lbnRcIl0gPSAxXSA9IFwiRWxlbWVudFwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiQXR0clwiXSA9IDJdID0gXCJBdHRyXCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJUZXh0XCJdID0gM10gPSBcIlRleHRcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNEQVRBU2VjdGlvblwiXSA9IDRdID0gXCJDREFUQVNlY3Rpb25cIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkVudGl0eVJlZmVyZW5jZVwiXSA9IDVdID0gXCJFbnRpdHlSZWZlcmVuY2VcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkVudGl0eVwiXSA9IDZdID0gXCJFbnRpdHlcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIlByb2Nlc3NpbmdJbnN0cnVjdGlvblwiXSA9IDddID0gXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNvbW1lbnRcIl0gPSA4XSA9IFwiQ29tbWVudFwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRcIl0gPSA5XSA9IFwiRG9jdW1lbnRcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkRvY3VtZW50VHlwZVwiXSA9IDEwXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJEb2N1bWVudEZyYWdtZW50XCJdID0gMTFdID0gXCJEb2N1bWVudEZyYWdtZW50XCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJOb3RhdGlvblwiXSA9IDEyXSA9IFwiTm90YXRpb25cIjtcbn0pKE5vZGVUeXBlIHx8IChOb2RlVHlwZSA9IHt9KSk7XG5jb25zdCBlZmZlY3RpdmVQYXJlbnROb2RlT3ZlcnJpZGVzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIHBhcmVudE5vZGUgYWNjb3JkaW5nIHRvIEF1cmVsaWEncyBjb21wb25lbnQgaGllcmFyY2h5LlxuICpcbiAqIFVzZWQgYnkgQXVyZWxpYSB0byBmaW5kIHRoZSBjbG9zZXN0IHBhcmVudCBjb250cm9sbGVyIHJlbGF0aXZlIHRvIGEgbm9kZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyAzIGFkZGl0aW9uYWwgc2NlbmFyaW9zIHRoYXQgYG5vZGUucGFyZW50Tm9kZWAgZG9lcyBub3Qgc3VwcG9ydDpcbiAqIC0gQ29udGFpbmVybGVzcyBlbGVtZW50cy4gVGhlIHBhcmVudE5vZGUgaW4gdGhpcyBjYXNlIGlzIGEgY29tbWVudCBwcmVjZW5kaW5nIHRoZSBlbGVtZW50IHVuZGVyIHNwZWNpZmljIGNvbmRpdGlvbnMsIHJhdGhlciB0aGFuIGEgbm9kZSB3cmFwcGluZyB0aGUgZWxlbWVudC5cbiAqIC0gU2hhZG93RE9NLiBJZiBhIGBTaGFkb3dSb290YCBpcyBlbmNvdW50ZXJlZCwgdGhpcyBtZXRob2QgcmV0cmlldmVzIHRoZSBhc3NvY2lhdGVkIGNvbnRyb2xsZXIgdmlhIHRoZSBtZXRhZGF0YSBhcGkgdG8gbG9jYXRlIHRoZSBvcmlnaW5hbCBob3N0LlxuICogLSBQb3J0YWxzLiBJZiB0aGUgcHJvdmlkZWQgbm9kZSB3YXMgbW92ZWQgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gaW4gdGhlIERPTSBieSBhIGBwb3J0YWxgIGF0dHJpYnV0ZSwgdGhlbiB0aGUgb3JpZ2luYWwgcGFyZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gKiBAcmV0dXJucyBFaXRoZXIgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUsIHRoZSBjbG9zZXN0IGBJUmVuZGVyTG9jYXRpb25gIChjb21tZW50IG5vZGUgdGhhdCBpcyB0aGUgY29udGFpbmVybGVzcyBob3N0KSwgb3JpZ2luYWwgcG9ydGFsIGhvc3QsIG9yIGBudWxsYCBpZiB0aGlzIGlzIGVpdGhlciB0aGUgYWJzb2x1dGUgZG9jdW1lbnQgcm9vdCBvciBhIGRpc2Nvbm5lY3RlZCBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWZmZWN0aXZlUGFyZW50Tm9kZShub2RlKSB7XG4gICAgLy8gVE9ETzogdGhpcyBtZXRob2QgbmVlZHMgbW9yZSB0ZXN0cyFcbiAgICAvLyBGaXJzdCBsb29rIGZvciBhbnkgb3ZlcnJpZGVzXG4gICAgaWYgKGVmZmVjdGl2ZVBhcmVudE5vZGVPdmVycmlkZXMuaGFzKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBlZmZlY3RpdmVQYXJlbnROb2RlT3ZlcnJpZGVzLmdldChub2RlKTtcbiAgICB9XG4gICAgLy8gVGhlbiB0cnkgdG8gZ2V0IHRoZSBuZWFyZXN0IGF1LXN0YXJ0IHJlbmRlciBsb2NhdGlvbiwgd2hpY2ggd291bGQgYmUgdGhlIGNvbnRhaW5lcmxlc3MgcGFyZW50LFxuICAgIC8vIGFnYWluIGxvb2tpbmcgZm9yIGFueSBvdmVycmlkZXMgYWxvbmcgdGhlIHdheS5cbiAgICAvLyBvdGhlcndpc2UgcmV0dXJuIHRoZSBub3JtYWwgcGFyZW50IG5vZGVcbiAgICBsZXQgY29udGFpbmVybGVzc09mZnNldCA9IDA7XG4gICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnQgKi8pIHtcbiAgICAgICAgICAgIHN3aXRjaCAobmV4dC50ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F1LXN0YXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2VlIGFuIGF1LXN0YXJ0IGJlZm9yZSB3ZSBzZWUgYXUtZW5kLCBpdCB3aWxsIHByZWNlZGUgdGhlIGhvc3Qgb2YgYSBzaWJsaW5nIGNvbnRhaW5lcmxlc3MgZWxlbWVudCByYXRoZXIgdGhhbiBhIHBhcmVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gU28gd2UgdXNlIHRoZSBvZmZzZXQgdG8gaWdub3JlIHRoZSBuZXh0IGF1LWVuZFxuICAgICAgICAgICAgICAgICAgICArK2NvbnRhaW5lcmxlc3NPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F1LWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXJsZXNzT2Zmc2V0LS0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGlmIChub2RlLnBhcmVudE5vZGUgPT09IG51bGwgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLykge1xuICAgICAgICAvLyBDb3VsZCBiZSBhIHNoYWRvdyByb290OyBzZWUgaWYgdGhlcmUncyBhIGNvbnRyb2xsZXIgYW5kIGlmIHNvLCBnZXQgdGhlIG9yaWdpbmFsIGhvc3QgdmlhIHRoZSBwcm9qZWN0b3JcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IEN1c3RvbUVsZW1lbnQuZm9yKG5vZGUpO1xuICAgICAgICBpZiAoY29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAvLyBOb3QgYSBzaGFkb3cgcm9vdCAob3IgYXQgbGVhc3QsIG5vdCBvbmUgY3JlYXRlZCBieSBBdXJlbGlhKVxuICAgICAgICAgICAgLy8gTm90aGluZyBtb3JlIHdlIGNhbiB0cnksIGp1c3QgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLm1vdW50VGFyZ2V0ID09PSAyIC8qIHNoYWRvd1Jvb3QgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFZmZlY3RpdmVQYXJlbnROb2RlKGNvbnRyb2xsZXIuaG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFZmZlY3RpdmVQYXJlbnROb2RlKGNoaWxkTm9kZU9yTm9kZVNlcXVlbmNlLCBwYXJlbnROb2RlKSB7XG4gICAgaWYgKGNoaWxkTm9kZU9yTm9kZVNlcXVlbmNlLnBsYXRmb3JtICE9PSB2b2lkIDAgJiYgIShjaGlsZE5vZGVPck5vZGVTZXF1ZW5jZSBpbnN0YW5jZW9mIGNoaWxkTm9kZU9yTm9kZVNlcXVlbmNlLnBsYXRmb3JtLk5vZGUpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGROb2RlT3JOb2RlU2VxdWVuY2UuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbm9kZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgZWZmZWN0aXZlUGFyZW50Tm9kZU92ZXJyaWRlcy5zZXQobm9kZXNbaV0sIHBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZmZlY3RpdmVQYXJlbnROb2RlT3ZlcnJpZGVzLnNldChjaGlsZE5vZGVPck5vZGVTZXF1ZW5jZSwgcGFyZW50Tm9kZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1JlbmRlckxvY2F0aW9uKG5vZGUpIHtcbiAgICBpZiAoaXNSZW5kZXJMb2NhdGlvbihub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZTsgLy8gaXQncyBhbHJlYWR5IGEgSVJlbmRlckxvY2F0aW9uIChjb252ZXJ0ZWQgYnkgRnJhZ21lbnROb2RlU2VxdWVuY2UpXG4gICAgfVxuICAgIGNvbnN0IGxvY2F0aW9uRW5kID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ2F1LWVuZCcpO1xuICAgIGNvbnN0IGxvY2F0aW9uU3RhcnQgPSBub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnYXUtc3RhcnQnKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobG9jYXRpb25FbmQsIG5vZGUpO1xuICAgICAgICBsb2NhdGlvbkVuZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsb2NhdGlvblN0YXJ0LCBsb2NhdGlvbkVuZCk7XG4gICAgfVxuICAgIGxvY2F0aW9uRW5kLiRzdGFydCA9IGxvY2F0aW9uU3RhcnQ7XG4gICAgcmV0dXJuIGxvY2F0aW9uRW5kO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVuZGVyTG9jYXRpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLnRleHRDb250ZW50ID09PSAnYXUtZW5kJztcbn1cbmV4cG9ydCBjbGFzcyBGcmFnbWVudE5vZGVTZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm0sIGZyYWdtZW50KSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTGlua2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5yZWZOb2RlID0gdm9pZCAwO1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlTGlzdCA9IGZyYWdtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hdScpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBpaSA9IHRhcmdldE5vZGVMaXN0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyA9IEFycmF5KGlpKTtcbiAgICAgICAgd2hpbGUgKGkgPCBpaSkge1xuICAgICAgICAgICAgLy8gZWFnZXJseSBjb252ZXJ0IGFsbCBtYXJrZXJzIHRvIFJlbmRlckxvY2F0aW9ucyAob3RoZXJ3aXNlIHRoZSByZW5kZXJlclxuICAgICAgICAgICAgLy8gd2lsbCBkbyBpdCBhbnl3YXkpIGFuZCBzdG9yZSB0aGVtIGluIHRoZSB0YXJnZXQgbGlzdCAoc2luY2UgdGhlIGNvbW1lbnRzXG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBxdWVyaWVkKVxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0Tm9kZUxpc3RbaV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnQVUtTScpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoZSByZW5kZXJlciB3aWxsIHN0aWxsIGNhbGwgdGhpcyBtZXRob2QsIGJ1dCBpdCB3aWxsIGp1c3QgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxvY2F0aW9uIGlmIGl0IHNlZXMgaXQncyBhbHJlYWR5IGEgbG9jYXRpb25cbiAgICAgICAgICAgICAgICB0YXJnZXRzW2ldID0gY29udmVydFRvUmVuZGVyTG9jYXRpb24odGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFsc28gc3RvcmUgbm9uLW1hcmtlcnMgZm9yIGNvbnNpc3RlbnQgb3JkZXJpbmdcbiAgICAgICAgICAgICAgICB0YXJnZXRzW2ldID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZUxpc3QgPSBmcmFnbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgaWkgPSBjaGlsZE5vZGVMaXN0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcyA9IEFycmF5KGlpKTtcbiAgICAgICAgd2hpbGUgKGkgPCBpaSkge1xuICAgICAgICAgICAgY2hpbGROb2Rlc1tpXSA9IGNoaWxkTm9kZUxpc3RbaV07XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBmcmFnbWVudC5sYXN0Q2hpbGQ7XG4gICAgfVxuICAgIGZpbmRUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzO1xuICAgIH1cbiAgICBpbnNlcnRCZWZvcmUocmVmTm9kZSkge1xuICAgICAgICBpZiAodGhpcy5pc0xpbmtlZCAmJiAhIXRoaXMucmVmTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUb0xpbmtlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcmVmTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjdXJyZW50LCByZWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlZk5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5mcmFnbWVudCwgcmVmTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kVG8ocGFyZW50LCBlbmhhbmNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMubGFzdENoaWxkO1xuICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGN1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFlbmhhbmNlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUb0xpbmtlZCgpIHtcbiAgICAgICAgY29uc3QgcmVmTm9kZSA9IHRoaXMucmVmTm9kZTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gcmVmTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5maXJzdENoaWxkO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGN1cnJlbnQsIHJlZk5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmZyYWdtZW50LCByZWZOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmxpbmsoKSB7XG4gICAgICAgIHRoaXMuaXNMaW5rZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnJlZk5vZGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxpbmsobmV4dCkge1xuICAgICAgICB0aGlzLmlzTGlua2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzUmVuZGVyTG9jYXRpb24obmV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVmTm9kZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5vYnRhaW5SZWZOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2J0YWluUmVmTm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlZk5vZGUgPSB0aGlzLm5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJV2luZG93ID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJV2luZG93JywgeCA9PiB4LmNhbGxiYWNrKGhhbmRsZXIgPT4gaGFuZGxlci5nZXQoSVBsYXRmb3JtKS53aW5kb3cpKTtcbmV4cG9ydCBjb25zdCBJTG9jYXRpb24gPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lMb2NhdGlvbicsIHggPT4geC5jYWxsYmFjayhoYW5kbGVyID0+IGhhbmRsZXIuZ2V0KElXaW5kb3cpLmxvY2F0aW9uKSk7XG5leHBvcnQgY29uc3QgSUhpc3RvcnkgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lIaXN0b3J5JywgeCA9PiB4LmNhbGxiYWNrKGhhbmRsZXIgPT4gaGFuZGxlci5nZXQoSVdpbmRvdykuaGlzdG9yeSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLmpzLm1hcCIsImV4cG9ydCB7IFBsYXRmb3JtLCBUYXNrUXVldWUsIFRhc2ssIFRhc2tBYm9ydEVycm9yLCBUYXNrUXVldWVQcmlvcml0eSwgVGFza1N0YXR1cywgfSBmcm9tICdAYXVyZWxpYS9wbGF0Zm9ybSc7XG5leHBvcnQgeyBCcm93c2VyUGxhdGZvcm0sIH0gZnJvbSAnQGF1cmVsaWEvcGxhdGZvcm0tYnJvd3Nlcic7XG5leHBvcnQgeyBiaW5kYWJsZSwgQmluZGFibGUsIEJpbmRhYmxlRGVmaW5pdGlvbiwgfSBmcm9tICcuL2JpbmRhYmxlLmpzJztcbmV4cG9ydCB7IEJpbmRhYmxlT2JzZXJ2ZXIsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9iaW5kYWJsZS1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBEZWJvdW5jZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbiwgT25lVGltZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbiwgVG9WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBGcm9tVmlld0JpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbiwgU2lnbmFsQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBUaHJvdHRsZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbiwgVHdvV2F5QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCB9IGZyb20gJy4vY29uZmlndXJhdGlvbi5qcyc7XG5leHBvcnQgeyBCaW5kaW5nTW9kZUJlaGF2aW9yLCBPbmVUaW1lQmluZGluZ0JlaGF2aW9yLCBUb1ZpZXdCaW5kaW5nQmVoYXZpb3IsIEZyb21WaWV3QmluZGluZ0JlaGF2aW9yLCBUd29XYXlCaW5kaW5nQmVoYXZpb3IsIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9ycy9iaW5kaW5nLW1vZGUuanMnO1xuZXhwb3J0IHsgRGVib3VuY2VCaW5kaW5nQmVoYXZpb3IsIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9ycy9kZWJvdW5jZS5qcyc7XG5leHBvcnQgeyBTaWduYWxCaW5kaW5nQmVoYXZpb3IsIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9ycy9zaWduYWxzLmpzJztcbmV4cG9ydCB7IFRocm90dGxlQmluZGluZ0JlaGF2aW9yLCB9IGZyb20gJy4vYmluZGluZy1iZWhhdmlvcnMvdGhyb3R0bGUuanMnO1xuZXhwb3J0IHsgYWxpYXMsIHJlZ2lzdGVyQWxpYXNlcywgQ2FsbEZ1bmN0aW9uRXhwcmVzc2lvbiwgQ3VzdG9tRXhwcmVzc2lvbiwgQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbiwgVmFsdWVDb252ZXJ0ZXJFeHByZXNzaW9uLCBBc3NpZ25FeHByZXNzaW9uLCBDb25kaXRpb25hbEV4cHJlc3Npb24sIEFjY2Vzc1RoaXNFeHByZXNzaW9uLCBBY2Nlc3NTY29wZUV4cHJlc3Npb24sIEFjY2Vzc01lbWJlckV4cHJlc3Npb24sIEFjY2Vzc0tleWVkRXhwcmVzc2lvbiwgQ2FsbFNjb3BlRXhwcmVzc2lvbiwgQ2FsbE1lbWJlckV4cHJlc3Npb24sIEJpbmFyeUV4cHJlc3Npb24sIFVuYXJ5RXhwcmVzc2lvbiwgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24sIEh0bWxMaXRlcmFsRXhwcmVzc2lvbiwgQXJyYXlMaXRlcmFsRXhwcmVzc2lvbiwgT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24sIFRlbXBsYXRlRXhwcmVzc2lvbiwgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLCBBcnJheUJpbmRpbmdQYXR0ZXJuLCBPYmplY3RCaW5kaW5nUGF0dGVybiwgQmluZGluZ0lkZW50aWZpZXIsIEZvck9mU3RhdGVtZW50LCBJbnRlcnBvbGF0aW9uLCBjb25uZWN0YWJsZSwgQmluZGluZ01lZGlhdG9yLCBJRXhwcmVzc2lvblBhcnNlciwgQmluZGluZ1R5cGUsIHBhcnNlRXhwcmVzc2lvbiwgQ2hhciwgQWNjZXNzLCBQcmVjZWRlbmNlLCBwYXJzZSwgUGFyc2VyU3RhdGUsIEFycmF5T2JzZXJ2ZXIsIEFycmF5SW5kZXhPYnNlcnZlciwgZW5hYmxlQXJyYXlPYnNlcnZhdGlvbiwgZGlzYWJsZUFycmF5T2JzZXJ2YXRpb24sIGFwcGx5TXV0YXRpb25zVG9JbmRpY2VzLCBzeW5jaHJvbml6ZUluZGljZXMsIE1hcE9ic2VydmVyLCBlbmFibGVNYXBPYnNlcnZhdGlvbiwgZGlzYWJsZU1hcE9ic2VydmF0aW9uLCBTZXRPYnNlcnZlciwgZW5hYmxlU2V0T2JzZXJ2YXRpb24sIGRpc2FibGVTZXRPYnNlcnZhdGlvbiwgQmluZGluZ0NvbnRleHQsIFNjb3BlLCBPdmVycmlkZUNvbnRleHQsIENvbGxlY3Rpb25MZW5ndGhPYnNlcnZlciwgQ29sbGVjdGlvblNpemVPYnNlcnZlciwgSURpcnR5Q2hlY2tlciwgRGlydHlDaGVja1Byb3BlcnR5LCBEaXJ0eUNoZWNrU2V0dGluZ3MsIENvbXB1dGVkT2JzZXJ2ZXIsIG9ic2VydmFibGUsIElPYnNlcnZlckxvY2F0b3IsIElOb2RlT2JzZXJ2ZXJMb2NhdG9yLCBnZXRDb2xsZWN0aW9uT2JzZXJ2ZXIsIE9ic2VydmVyTG9jYXRvciwgUHJpbWl0aXZlT2JzZXJ2ZXIsIFByb3BlcnR5QWNjZXNzb3IsIFNldHRlck9ic2VydmVyLCBJU2lnbmFsZXIsIHN1YnNjcmliZXJDb2xsZWN0aW9uLCBiaW5kaW5nQmVoYXZpb3IsIEJpbmRpbmdCZWhhdmlvciwgQmluZGluZ0JlaGF2aW9yRGVmaW5pdGlvbiwgQmluZGluZ0ludGVyY2VwdG9yLCBCaW5kaW5nQmVoYXZpb3JGYWN0b3J5LCBCaW5kaW5nQmVoYXZpb3JTdHJhdGVneSwgVmFsdWVDb252ZXJ0ZXIsIFZhbHVlQ29udmVydGVyRGVmaW5pdGlvbiwgdmFsdWVDb252ZXJ0ZXIsIEJpbmRpbmdNb2RlLCBFeHByZXNzaW9uS2luZCwgTGlmZWN5Y2xlRmxhZ3MsIEFjY2Vzc29yVHlwZSwgQ29sbGVjdGlvbktpbmQsIERlbGVnYXRpb25TdHJhdGVneSwgaXNJbmRleE1hcCwgY29weUluZGV4TWFwLCBjbG9uZUluZGV4TWFwLCBjcmVhdGVJbmRleE1hcCwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmV4cG9ydCB7IEF1cmVsaWEsIElBdXJlbGlhLCB9IGZyb20gJy4vYXVyZWxpYS5qcyc7XG5leHBvcnQgeyBBcHBSb290LCBJQXBwUm9vdCwgfSBmcm9tICcuL2FwcC1yb290LmpzJztcbmV4cG9ydCB7IEFwcFRhc2ssIElBcHBUYXNrLCB9IGZyb20gJy4vYXBwLXRhc2suanMnO1xuZXhwb3J0IHsgQXR0clN5bnRheCwgSUF0dHJpYnV0ZVBhcnNlciwgYXR0cmlidXRlUGF0dGVybiwgSUF0dHJpYnV0ZVBhdHRlcm4sIEF0dHJpYnV0ZVBhdHRlcm4sIEludGVycHJldGF0aW9uLCBJU3ludGF4SW50ZXJwcmV0ZXIsIEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVybiwgQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuLCBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuLCBSZWZBdHRyaWJ1dGVQYXR0ZXJuLCB9IGZyb20gJy4vcmVzb3VyY2VzL2F0dHJpYnV0ZS1wYXR0ZXJuLmpzJztcbmV4cG9ydCB7IGJpbmRpbmdDb21tYW5kLCBCaW5kaW5nQ29tbWFuZCwgQmluZGluZ0NvbW1hbmREZWZpbml0aW9uLCBnZXRUYXJnZXQsIENhbGxCaW5kaW5nQ29tbWFuZCwgRGVmYXVsdEJpbmRpbmdDb21tYW5kLCBGb3JCaW5kaW5nQ29tbWFuZCwgRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCwgT25lVGltZUJpbmRpbmdDb21tYW5kLCBUb1ZpZXdCaW5kaW5nQ29tbWFuZCwgVHdvV2F5QmluZGluZ0NvbW1hbmQsIFRyaWdnZXJCaW5kaW5nQ29tbWFuZCwgRGVsZWdhdGVCaW5kaW5nQ29tbWFuZCwgQ2FwdHVyZUJpbmRpbmdDb21tYW5kLCBBdHRyQmluZGluZ0NvbW1hbmQsIENsYXNzQmluZGluZ0NvbW1hbmQsIFN0eWxlQmluZGluZ0NvbW1hbmQsIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1jb21tYW5kLmpzJztcbmV4cG9ydCB7IElBdHRyU3ludGF4VHJhbnNmb3JtZXIsIH0gZnJvbSAnLi9hdHRyaWJ1dGUtc3ludGF4LXRyYW5zZm9ybWVyLmpzJztcbmV4cG9ydCB7IExpc3RlbmVyLCB9IGZyb20gJy4vYmluZGluZy9saXN0ZW5lci5qcyc7XG5leHBvcnQgeyBBdHRyaWJ1dGVCaW5kaW5nLCB9IGZyb20gJy4vYmluZGluZy9hdHRyaWJ1dGUuanMnO1xuZXhwb3J0IHsgQ2FsbEJpbmRpbmcsIH0gZnJvbSAnLi9iaW5kaW5nL2NhbGwtYmluZGluZy5qcyc7XG5leHBvcnQgeyBJbnRlcnBvbGF0aW9uQmluZGluZywgfSBmcm9tICcuL2JpbmRpbmcvaW50ZXJwb2xhdGlvbi1iaW5kaW5nLmpzJztcbmV4cG9ydCB7IExldEJpbmRpbmcsIH0gZnJvbSAnLi9iaW5kaW5nL2xldC1iaW5kaW5nLmpzJztcbmV4cG9ydCB7IFByb3BlcnR5QmluZGluZywgfSBmcm9tICcuL2JpbmRpbmcvcHJvcGVydHktYmluZGluZy5qcyc7XG5leHBvcnQgeyBSZWZCaW5kaW5nLCB9IGZyb20gJy4vYmluZGluZy9yZWYtYmluZGluZy5qcyc7XG5leHBvcnQgeyBJUmVuZGVyZXIsIElUZW1wbGF0ZUNvbXBpbGVyLCByZW5kZXJlciwgQ2FsbEJpbmRpbmdJbnN0cnVjdGlvbiwgSHlkcmF0ZUF0dHJpYnV0ZUluc3RydWN0aW9uLCBIeWRyYXRlRWxlbWVudEluc3RydWN0aW9uLCBIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyLCBJbnRlcnBvbGF0aW9uSW5zdHJ1Y3Rpb24sIEl0ZXJhdG9yQmluZGluZ0luc3RydWN0aW9uLCBMZXRCaW5kaW5nSW5zdHJ1Y3Rpb24sIEh5ZHJhdGVMZXRFbGVtZW50SW5zdHJ1Y3Rpb24sIFJlZkJpbmRpbmdJbnN0cnVjdGlvbiwgU2V0UHJvcGVydHlJbnN0cnVjdGlvbiwgQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uLCBMaXN0ZW5lckJpbmRpbmdJbnN0cnVjdGlvbiwgUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24sIFNldEF0dHJpYnV0ZUluc3RydWN0aW9uLCBTZXRDbGFzc0F0dHJpYnV0ZUluc3RydWN0aW9uLCBTZXRTdHlsZUF0dHJpYnV0ZUluc3RydWN0aW9uLCBTdHlsZVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uLCBUZXh0QmluZGluZ0luc3RydWN0aW9uLCBpc0luc3RydWN0aW9uLCBJSW5zdHJ1Y3Rpb24sIEluc3RydWN0aW9uVHlwZSwgfSBmcm9tICcuL3JlbmRlcmVyLmpzJztcbmV4cG9ydCB7IEF0dHJpYnV0ZU5TQWNjZXNzb3IsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9hdHRyaWJ1dGUtbnMtYWNjZXNzb3IuanMnO1xuZXhwb3J0IHsgQ2hlY2tlZE9ic2VydmVyLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vY2hlY2tlZC1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBDbGFzc0F0dHJpYnV0ZUFjY2Vzc29yLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vY2xhc3MtYXR0cmlidXRlLWFjY2Vzc29yLmpzJztcbmV4cG9ydCB7IERhdGFBdHRyaWJ1dGVBY2Nlc3NvciwgfSBmcm9tICcuL29ic2VydmF0aW9uL2RhdGEtYXR0cmlidXRlLWFjY2Vzc29yLmpzJztcbmV4cG9ydCB7IElFdmVudERlbGVnYXRvciwgRXZlbnRTdWJzY3JpYmVyLCBFdmVudERlbGVnYXRvciwgfSBmcm9tICcuL29ic2VydmF0aW9uL2V2ZW50LWRlbGVnYXRvci5qcyc7XG5leHBvcnQgeyBOb2RlT2JzZXJ2ZXJDb25maWcsIE5vZGVPYnNlcnZlckxvY2F0b3IsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9vYnNlcnZlci1sb2NhdG9yLmpzJztcbmV4cG9ydCB7IFNlbGVjdFZhbHVlT2JzZXJ2ZXIgfSBmcm9tICcuL29ic2VydmF0aW9uL3NlbGVjdC12YWx1ZS1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBTdHlsZUF0dHJpYnV0ZUFjY2Vzc29yIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9zdHlsZS1hdHRyaWJ1dGUtYWNjZXNzb3IuanMnO1xuZXhwb3J0IHsgSVNWR0FuYWx5emVyLCBTVkdBbmFseXplciwgTm9vcFNWR0FuYWx5emVyLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vc3ZnLWFuYWx5emVyLmpzJztcbmV4cG9ydCB7IFZhbHVlQXR0cmlidXRlT2JzZXJ2ZXIsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi92YWx1ZS1hdHRyaWJ1dGUtb2JzZXJ2ZXIuanMnO1xuZXhwb3J0IHsgQXR0ckJpbmRpbmdCZWhhdmlvciwgfSBmcm9tICcuL3Jlc291cmNlcy9iaW5kaW5nLWJlaGF2aW9ycy9hdHRyLmpzJztcbmV4cG9ydCB7IFNlbGZCaW5kaW5nQmVoYXZpb3IsIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1iZWhhdmlvcnMvc2VsZi5qcyc7XG5leHBvcnQgeyBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yLCB9IGZyb20gJy4vcmVzb3VyY2VzL2JpbmRpbmctYmVoYXZpb3JzL3VwZGF0ZS10cmlnZ2VyLmpzJztcbmV4cG9ydCB7IGN1c3RvbUF0dHJpYnV0ZSwgQ3VzdG9tQXR0cmlidXRlLCBDdXN0b21BdHRyaWJ1dGVEZWZpbml0aW9uLCB0ZW1wbGF0ZUNvbnRyb2xsZXIsIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5leHBvcnQgeyBGcmVxdWVudE11dGF0aW9ucywgT2JzZXJ2ZVNoYWxsb3csIH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvZmxhZ3MuanMnO1xuZXhwb3J0IHsgSWYsIEVsc2UsIH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvaWYuanMnO1xuZXhwb3J0IHsgUmVwZWF0IH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvcmVwZWF0LmpzJztcbmV4cG9ydCB7IFdpdGggfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy93aXRoLmpzJztcbmV4cG9ydCB7IFN3aXRjaCwgQ2FzZSwgRGVmYXVsdENhc2UsIH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvc3dpdGNoLmpzJztcbmV4cG9ydCB7IEJsdXIsIEJsdXJNYW5hZ2VyLCB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGVzL2JsdXIuanMnO1xuZXhwb3J0IHsgRm9jdXMsIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZXMvZm9jdXMuanMnO1xuZXhwb3J0IHsgUG9ydGFsLCB9IGZyb20gJy4vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3BvcnRhbC5qcyc7XG5leHBvcnQgeyBBdVNsb3QsIElQcm9qZWN0aW9ucywgU2xvdEluZm8sIEF1U2xvdENvbnRlbnRUeXBlLCBSZWdpc3RlcmVkUHJvamVjdGlvbnMsIElQcm9qZWN0aW9uUHJvdmlkZXIsIFByb2plY3Rpb25Db250ZXh0LCB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9hdS1zbG90LmpzJztcbmV4cG9ydCB7IGNvbnRhaW5lcmxlc3MsIGN1c3RvbUVsZW1lbnQsIEN1c3RvbUVsZW1lbnQsIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLCB1c2VTaGFkb3dET00sIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuZXhwb3J0IHsgQ29tcG9zZSwgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudHMvY29tcG9zZS5qcyc7XG5leHBvcnQgeyBJU2FuaXRpemVyLCBTYW5pdGl6ZVZhbHVlQ29udmVydGVyLCB9IGZyb20gJy4vcmVzb3VyY2VzL3ZhbHVlLWNvbnZlcnRlcnMvc2FuaXRpemUuanMnO1xuZXhwb3J0IHsgVmlld1ZhbHVlQ29udmVydGVyLCB9IGZyb20gJy4vcmVzb3VyY2VzL3ZhbHVlLWNvbnZlcnRlcnMvdmlldy5qcyc7XG5leHBvcnQgeyBJVGVtcGxhdGVDb21waWxlclJlZ2lzdHJhdGlvbiwgSU5vZGVPYnNlcnZlckxvY2F0b3JSZWdpc3RyYXRpb24sIERlZmF1bHRDb21wb25lbnRzLCBSZWZBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLCBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLCBEZWZhdWx0QmluZGluZ1N5bnRheCwgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLCBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24sIFNob3J0SGFuZEJpbmRpbmdTeW50YXgsIFNWR0FuYWx5emVyUmVnaXN0cmF0aW9uLCBDYWxsQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIERlZmF1bHRCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgRm9yQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIFJlZkJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBGcm9tVmlld0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBPbmVUaW1lQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIFRvVmlld0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBUd29XYXlCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgVHJpZ2dlckJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBEZWxlZ2F0ZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBDYXB0dXJlQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIEF0dHJCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgQ2xhc3NCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgU3R5bGVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgRGVmYXVsdEJpbmRpbmdMYW5ndWFnZSwgVmlld1ZhbHVlQ29udmVydGVyUmVnaXN0cmF0aW9uLCBTYW5pdGl6ZVZhbHVlQ29udmVydGVyUmVnaXN0cmF0aW9uLCBJZlJlZ2lzdHJhdGlvbiwgRWxzZVJlZ2lzdHJhdGlvbiwgUmVwZWF0UmVnaXN0cmF0aW9uLCBXaXRoUmVnaXN0cmF0aW9uLCBBdHRyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBTZWxmQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBDb21wb3NlUmVnaXN0cmF0aW9uLCBEZWZhdWx0UmVzb3VyY2VzLCBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sIExpc3RlbmVyQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBTZXRBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbiwgU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbiwgU2V0U3R5bGVBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbiwgU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiwgVGV4dEJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiwgUmVmQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBDYWxsQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBDdXN0b21BdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbiwgQ3VzdG9tRWxlbWVudFJlbmRlcmVyUmVnaXN0cmF0aW9uLCBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBJdGVyYXRvckJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiwgTGV0RWxlbWVudFJlbmRlcmVyUmVnaXN0cmF0aW9uLCBQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiwgU2V0UHJvcGVydHlSZW5kZXJlclJlZ2lzdHJhdGlvbiwgVGVtcGxhdGVDb250cm9sbGVyUmVuZGVyZXJSZWdpc3RyYXRpb24sIERlZmF1bHRSZW5kZXJlcnMsIFN0YW5kYXJkQ29uZmlndXJhdGlvbiB9IGZyb20gJy4vY29uZmlndXJhdGlvbi5qcyc7XG5leHBvcnQgeyBUZW1wbGF0ZUJpbmRlciwgfSBmcm9tICcuL3RlbXBsYXRlLWJpbmRlci5qcyc7XG5leHBvcnQgeyBJVGVtcGxhdGVFbGVtZW50RmFjdG9yeSB9IGZyb20gJy4vdGVtcGxhdGUtZWxlbWVudC1mYWN0b3J5LmpzJztcbmV4cG9ydCB7IENoaWxkcmVuRGVmaW5pdGlvbiwgQ2hpbGRyZW4sIGNoaWxkcmVuLCBDaGlsZHJlbk9ic2VydmVyLCB9IGZyb20gJy4vdGVtcGxhdGluZy9jaGlsZHJlbi5qcyc7XG4vLyBUaGVzZSBleHBvcnRzIGFyZSB0ZW1wb3JhcnkgdW50aWwgd2UgaGF2ZSBhIHByb3BlciB3YXkgdG8gdW5pdCB0ZXN0IHRoZW1cbmV4cG9ydCB7IENvbnRyb2xsZXIsIGlzQ3VzdG9tRWxlbWVudENvbnRyb2xsZXIsIGlzQ3VzdG9tRWxlbWVudFZpZXdNb2RlbCwgVmlld01vZGVsS2luZCwgSUNvbnRyb2xsZXIsIH0gZnJvbSAnLi90ZW1wbGF0aW5nL2NvbnRyb2xsZXIuanMnO1xuZXhwb3J0IHsgZ2V0UmVuZGVyQ29udGV4dCwgaXNSZW5kZXJDb250ZXh0LCB9IGZyb20gJy4vdGVtcGxhdGluZy9yZW5kZXItY29udGV4dC5qcyc7XG5leHBvcnQgeyBWaWV3RmFjdG9yeSwgSVZpZXdGYWN0b3J5LCBJVmlld0xvY2F0b3IsIFZpZXdMb2NhdG9yLCB2aWV3LCBWaWV3cywgfSBmcm9tICcuL3RlbXBsYXRpbmcvdmlldy5qcyc7XG5leHBvcnQgeyBjcmVhdGVFbGVtZW50LCBSZW5kZXJQbGFuIH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudC5qcyc7XG5leHBvcnQgeyBJTm9kZSwgSUV2ZW50VGFyZ2V0LCBJUmVuZGVyTG9jYXRpb24sIE5vZGVUeXBlLCBGcmFnbWVudE5vZGVTZXF1ZW5jZSwgSUhpc3RvcnksIElXaW5kb3csIElMb2NhdGlvbiwgZ2V0RWZmZWN0aXZlUGFyZW50Tm9kZSwgc2V0RWZmZWN0aXZlUGFyZW50Tm9kZSwgY29udmVydFRvUmVuZGVyTG9jYXRpb24sIGlzUmVuZGVyTG9jYXRpb24sIH0gZnJvbSAnLi9kb20uanMnO1xuZXhwb3J0IHsgSVBsYXRmb3JtLCB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuZXhwb3J0IHsgQmluZGFibGVJbmZvLCBFbGVtZW50SW5mbywgQXR0ckluZm8sIEJpbmRpbmdTeW1ib2wsIEN1c3RvbUF0dHJpYnV0ZVN5bWJvbCwgQ3VzdG9tRWxlbWVudFN5bWJvbCwgTGV0RWxlbWVudFN5bWJvbCwgUGxhaW5BdHRyaWJ1dGVTeW1ib2wsIFBsYWluRWxlbWVudFN5bWJvbCwgU3ltYm9sRmxhZ3MsIFRlbXBsYXRlQ29udHJvbGxlclN5bWJvbCwgVGV4dFN5bWJvbCwgUHJvamVjdGlvblN5bWJvbCwgfSBmcm9tICcuL3NlbWFudGljLW1vZGVsLmpzJztcbmV4cG9ydCB7IENTU01vZHVsZXNQcm9jZXNzb3JSZWdpc3RyeSwgY3NzTW9kdWxlcywgU2hhZG93RE9NUmVnaXN0cnksIElTaGFkb3dET01TdHlsZUZhY3RvcnksIHNoYWRvd0NTUywgU3R5bGVDb25maWd1cmF0aW9uLCBBZG9wdGVkU3R5bGVTaGVldHNTdHlsZXMsIFN0eWxlRWxlbWVudFN0eWxlcywgSVNoYWRvd0RPTVN0eWxlcywgSVNoYWRvd0RPTUdsb2JhbFN0eWxlcywgfSBmcm9tICcuL3RlbXBsYXRpbmcvc3R5bGVzLmpzJztcbmV4cG9ydCB7IFdhdGNoLCB3YXRjaCwgfSBmcm9tICcuL3dhdGNoLmpzJztcbmV4cG9ydCB7IENvbXB1dGVkV2F0Y2hlciwgRXhwcmVzc2lvbldhdGNoZXIsIH0gZnJvbSAnLi90ZW1wbGF0aW5nL3dhdGNoZXJzLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImNvbnN0IG5zTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuICogQXR0cmlidXRlIGFjY2Vzc29yIGluIGEgWE1MIGRvY3VtZW50L2VsZW1lbnQgdGhhdCBjYW4gYmUgYWNjZXNzZWQgdmlhIGEgbmFtZXNwYWNlLlxuICogV3JhcHMgW2BnZXRBdHRyaWJ1dGVOU2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEF0dHJpYnV0ZU5TKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZU5TQWNjZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWVzcGFjZSkge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgICAvLyBPYnNlcnZlclR5cGUuTGF5b3V0IGlzIG5vdCBhbHdheXMgdHJ1ZSwgaXQgZGVwZW5kcyBvbiB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gYnV0IGZvciBzaW1wbGljaXR5LCBhbHdheXMgdHJlYXQgYXMgc3VjaFxuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCA0IC8qIExheW91dCAqLztcbiAgICB9XG4gICAgc3RhdGljIGZvck5zKG5zKSB7XG4gICAgICAgIHJldHVybiBuc01hcFtuc10gPz8gKG5zTWFwW25zXSA9IG5ldyBBdHRyaWJ1dGVOU0FjY2Vzc29yKG5zKSk7XG4gICAgfVxuICAgIGdldFZhbHVlKG9iaiwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG9iai5nZXRBdHRyaWJ1dGVOUyh0aGlzLm5hbWVzcGFjZSwgcHJvcGVydHlLZXkpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MsIG9iaiwga2V5KSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9iai5yZW1vdmVBdHRyaWJ1dGVOUyh0aGlzLm5hbWVzcGFjZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGVOUyh0aGlzLm5hbWVzcGFjZSwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGUtbnMtYWNjZXNzb3IuanMubWFwIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuZXhwb3J0IGNsYXNzIEJpbmRhYmxlT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgcHJvcGVydHlLZXksIGNiTmFtZSwgc2V0LCAkY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy4kY29udHJvbGxlciA9ICRjb250cm9sbGVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgY29uc3QgY2IgPSBvYmpbY2JOYW1lXTtcbiAgICAgICAgY29uc3QgY2JBbGwgPSBvYmoucHJvcGVydHlDaGFuZ2VkO1xuICAgICAgICBjb25zdCBoYXNDYiA9IHRoaXMuaGFzQ2IgPSB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIGNvbnN0IGhhc0NiQWxsID0gdGhpcy5oYXNDYkFsbCA9IHR5cGVvZiBjYkFsbCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgY29uc3QgaGFzU2V0dGVyID0gdGhpcy5oYXNTZXR0ZXIgPSBzZXQgIT09IG5vb3A7XG4gICAgICAgIHRoaXMuY2IgPSBoYXNDYiA/IGNiIDogbm9vcDtcbiAgICAgICAgdGhpcy5jYkFsbCA9IHRoaXMuaGFzQ2JBbGwgPyBjYkFsbCA6IG5vb3A7XG4gICAgICAgIC8vIHdoZW4gdXNlciBkZWNsYXJlIEBiaW5kYWJsZSh7IHNldCB9KVxuICAgICAgICAvLyBpdCdzIGV4cGVjdGVkIHRvIHdvcmsgZnJvbSB0aGUgc3RhcnQsXG4gICAgICAgIC8vIHJlZ2FyZGxlc3Mgd2hlcmUgdGhlIGFzc2lnbm1lbnQgY29tZXMgZnJvbTogZWl0aGVyIGRpcmVjdCB2aWV3IG1vZGVsIGFzc2lnbm1lbnQgb3IgZnJvbSBiaW5kaW5nIGR1cmluZyByZW5kZXJcbiAgICAgICAgLy8gc28gaWYgZWl0aGVyIGdldHRlci9zZXR0ZXIgY29uZmlnIGlzIHByZXNlbnQsIGFsdGVyIHRoZSBhY2Nlc3NvciBzdHJhaWdodCBhd2FpdFxuICAgICAgICBpZiAodGhpcy5jYiA9PT0gdm9pZCAwICYmICFoYXNDYkFsbCAmJiAhaGFzU2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gb2JqW3Byb3BlcnR5S2V5XTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaGFzU2V0dGVyICYmIHZhbCAhPT0gdm9pZCAwID8gc2V0KHZhbCkgOiB2YWw7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdldHRlclNldHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gMSAvKiBPYnNlcnZlciAqLzsgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAodGhpcy5oYXNTZXR0ZXIpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5zZXQobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmluZykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzKG5ld1ZhbHVlLCBjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIC8vIHRvZG86IGNvbnRyb2xsZXIgKGlmIGFueSkgc3RhdGUgc2hvdWxkIGRldGVybWluZSB0aGUgaW52b2NhdGlvbiBpbnN0ZWFkXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMzIgLyogZnJvbUJpbmQgKi8pID09PSAwIHx8IChmbGFncyAmIDE2IC8qIHVwZGF0ZVNvdXJjZSAqLykgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ2IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMub2JqLCBuZXdWYWx1ZSwgY3VycmVudFZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0NiQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2JBbGwuY2FsbCh0aGlzLm9iaiwgdGhpcy5wcm9wZXJ0eUtleSwgbmV3VmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkobmV3VmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VlIFNldHRlck9ic2VydmVyLnNldFZhbHVlIGZvciBleHBsYW5hdGlvblxuICAgICAgICAgICAgdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAoIXRoaXMub2JzZXJ2aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMuaGFzU2V0dGVyXG4gICAgICAgICAgICAgICAgPyB0aGlzLnNldChjdXJyZW50VmFsdWUpXG4gICAgICAgICAgICAgICAgOiBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdldHRlclNldHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcik7XG4gICAgfVxuICAgIGNyZWF0ZUdldHRlclNldHRlcigpIHtcbiAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9iaiwgdGhpcy5wcm9wZXJ0eUtleSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCAvKiBCaW5kYWJsZSBPYnNlcnZlciAqLykgPT4gdGhpcy5jdXJyZW50VmFsdWUsXG4gICAgICAgICAgICBzZXQ6ICgvKiBCaW5kYWJsZSBPYnNlcnZlciAqLyB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUsIDAgLyogbm9uZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbnN1YnNjcmliZXJDb2xsZWN0aW9uKEJpbmRhYmxlT2JzZXJ2ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGFibGUtb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24sIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBnZXRDb2xsZWN0aW9uT2JzZXJ2ZXIgfSBmcm9tICcuL29ic2VydmVyLWxvY2F0b3IuanMnO1xuZnVuY3Rpb24gZGVmYXVsdE1hdGNoZXIoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xufVxuZXhwb3J0IGNsYXNzIENoZWNrZWRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob2JqLCBcbiAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHQtbGluZVxuICAgIF9rZXksIGhhbmRsZXIsIG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBOb2RlICovIHwgMSAvKiBPYnNlcnZlciAqLyB8IDQgLyogTGF5b3V0ICovO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25PYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnN1YnMubm90aWZ5KG5ld1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZsYWdzKTtcbiAgICB9XG4gICAgaGFuZGxlQ29sbGVjdGlvbkNoYW5nZShpbmRleE1hcCwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZUVsZW1lbnQoKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplRWxlbWVudCgpO1xuICAgIH1cbiAgICBzeW5jaHJvbml6ZUVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqO1xuICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnbW9kZWwnKSA/IG9iai5tb2RlbCA6IG9iai52YWx1ZTtcbiAgICAgICAgY29uc3QgaXNSYWRpbyA9IG9iai50eXBlID09PSAncmFkaW8nO1xuICAgICAgICBjb25zdCBtYXRjaGVyID0gb2JqLm1hdGNoZXIgIT09IHZvaWQgMCA/IG9iai5tYXRjaGVyIDogZGVmYXVsdE1hdGNoZXI7XG4gICAgICAgIGlmIChpc1JhZGlvKSB7XG4gICAgICAgICAgICBvYmouY2hlY2tlZCA9ICEhbWF0Y2hlcihjdXJyZW50VmFsdWUsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvYmouY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gY3VycmVudFZhbHVlLmZpbmRJbmRleChpdGVtID0+ICEhbWF0Y2hlcihpdGVtLCBlbGVtZW50VmFsdWUpKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKHYsIGVsZW1lbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSBwYWlyWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCAkaXNDaGVja2VkID0gcGFpclsxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBwb3RlbnRpYWwgY29tcGxhaW4sIHdoZW4gb25seSBgdHJ1ZWAgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCdzIGNvbnNpc3RlbnQgd2l0aCBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihleGlzdGluZ0l0ZW0sIGVsZW1lbnRWYWx1ZSkgJiYgJGlzQ2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmouY2hlY2tlZCA9IGhhc01hdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KCkge1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqO1xuICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnbW9kZWwnKSA/IG9iai5tb2RlbCA6IG9iai52YWx1ZTtcbiAgICAgICAgY29uc3QgaXNDaGVja2VkID0gb2JqLmNoZWNrZWQ7XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSBvYmoubWF0Y2hlciAhPT0gdm9pZCAwID8gb2JqLm1hdGNoZXIgOiBkZWZhdWx0TWF0Y2hlcjtcbiAgICAgICAgaWYgKG9iai50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBBcnJheSBiaW5kaW5nIHN0ZXBzIG9uIGEgY2hhbmdlIGV2ZW50OlxuICAgICAgICAgICAgICAgIC8vIDEuIGZpbmQgY29ycmVzcG9uZGluZyBpdGVtIElOREVYIGluIHRoZSBTZXQgYmFzZWQgb24gY3VycmVudCBtb2RlbC92YWx1ZSBhbmQgbWF0Y2hlclxuICAgICAgICAgICAgICAgIC8vIDIuIGlzIHRoZSBjaGVja2JveCBjaGVja2VkP1xuICAgICAgICAgICAgICAgIC8vICAgIDIuMS4gWWVzOiBpcyB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBBcnJheSAoaW5kZXggPT09IC0xKT9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgMi4xLjEgTm86IHB1c2ggdGhlIGN1cnJlbnQgbW9kZWwvdmFsdWUgdG8gdGhlIEFycmF5XG4gICAgICAgICAgICAgICAgLy8gICAgMi4yLiBObzogaXMgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgQXJyYXkgKGluZGV4ICE9PSAtMSk/XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIDIuMi4xOiBZZXM6IHJlbW92ZSB0aGUgY29ycmVzcG9uZGluZyBpdGVtXG4gICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudFZhbHVlLmZpbmRJbmRleChpdGVtID0+ICEhbWF0Y2hlcihpdGVtLCBlbGVtZW50VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2hlY2tib3ggaXMgY2hlY2tkZSwgYW5kIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgdmFsdWUgaW4gdGhlIGV4aXN0aW5nIGFycmF5XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjaGVja2JveCBtb2RlbC92YWx1ZSB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGVja2VkICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUucHVzaChlbGVtZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNDaGVja2VkICYmIGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2hlY2tib3ggaXMgbm90IGNoZWNrZWQsIGFuZCBmb3VuZCBhIG1hdGNoaW5nIGl0ZW0gaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VkIG9uIHRoZSBjaGVja2JveCBtb2RlbC92YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGV4aXN0aW5nIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gZXhpc3RpbmcgY3VycmVudFZhbHVlIGlzIGFuIGFycmF5LFxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBpbnZva2UgY2FsbGJhY2sgYXMgb25seSB0aGUgYXJyYXkgb2JqIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGJpbmRpbmcgc3RlcHMgb24gYSBjaGFuZ2UgZXZlbnQ6XG4gICAgICAgICAgICAgICAgLy8gMS4gZmluZCBjb3JyZXNwb25kaW5nIGl0ZW0gaW4gdGhlIFNldCBiYXNlZCBvbiBjdXJyZW50IG1vZGVsL3ZhbHVlIGFuZCBtYXRjaGVyXG4gICAgICAgICAgICAgICAgLy8gMi4gaXMgdGhlIGNoZWNrYm94IGNoZWNrZWQ/XG4gICAgICAgICAgICAgICAgLy8gICAgMi4xLiBZZXM6IGlzIHRoZSBjb3JyZXNwb25kaW5nIGl0ZW0gaW4gdGhlIFNldD9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgMi4xLjEgTm86IGFkZCB0aGUgY3VycmVudCBtb2RlbC92YWx1ZSB0byB0aGUgU2V0XG4gICAgICAgICAgICAgICAgLy8gICAgMi4yLiBObzogaXMgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgU2V0P1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAyLjIuMTogWWVzOiByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbVxuICAgICAgICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAgICAvLyAxLiBmaW5kIGNvcnJlc3BvbmRpbmcgaXRlbVxuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2V0ID0ge307XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nSXRlbSA9IHVuc2V0O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKHZhbHVlLCBlbGVtZW50VmFsdWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0l0ZW0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDIuMS4gQ2hlY2tib3ggaXMgY2hlY2tlZCwgaXMgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgU2V0P1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaWYgY2hlY2tib3ggaXMgY2hlY2tlZCBhbmQgdGhlcmUncyBubyB2YWx1ZSBpbiB0aGUgZXhpc3RpbmcgU2V0XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjaGVja2JveCBtb2RlbC92YWx1ZSB0byB0aGUgU2V0XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tlZCAmJiBleGlzdGluZ0l0ZW0gPT09IHVuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDIuMS4xLiBhZGQgdGhlIGN1cnJlbnQgbW9kZWwvdmFsdWUgdG8gdGhlIFNldFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuYWRkKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0NoZWNrZWQgJiYgZXhpc3RpbmdJdGVtICE9PSB1bnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAyLjIuMSBDaGVja2JveCBpcyB1bmNoZWNrZWQsIGNvcnJlc3BvbmRpbmcgaXMgaW4gdGhlIFNldFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjaGVja2JveCBpcyBub3QgY2hlY2tlZCwgYW5kIGZvdW5kIGEgbWF0Y2hpbmcgaXRlbSBpbiB0aGUgU2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VkIG9uIHRoZSBjaGVja2JveCBtb2RlbC92YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGV4aXN0aW5nIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLmRlbGV0ZShleGlzdGluZ0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3aGVuIGV4aXN0aW5nIHZhbHVlIGlzIGEgU2V0LFxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBpbnZva2UgY2FsbGJhY2sgYXMgb25seSB0aGUgU2V0IGhhcyBiZWVuIG11dGF0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAvLyBNYXAgYmluZGluZyBzdGVwcyBvbiBhIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgIC8vIDEuIGZpbmQgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBNYXAgYmFzZWQgb24gY3VycmVudCBtb2RlbC92YWx1ZSBhbmQgbWF0Y2hlclxuICAgICAgICAgICAgICAgIC8vIDIuIFNldCB0aGUgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgTWFwIGJhc2VkIG9uIGNoZWNrZWQgc3RhdGUgb2YgdGhlIGNoZWNrYm94XG4gICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgIC8vIDEuIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbVxuICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ0l0ZW07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJySXRlbSA9IHBhaXJbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGN1cnJJdGVtLCBlbGVtZW50VmFsdWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0l0ZW0gPSBjdXJySXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDIuIHNldCB0aGUgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgLy8gaWYgY2hlY2tib3ggaXMgY2hlY2tlZCBhbmQgdGhlcmUncyBubyB2YWx1ZSBpbiB0aGUgZXhpc3RpbmcgTWFwXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjaGVja2JveCBtb2RlbC92YWx1ZSB0byB0aGUgTWFwIGFzIGtleSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgdmFsdWUgd2lsbCBiZSBjaGVja2VkIHN0YXRlIG9mIHRoZSBjaGVja2JveFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5zZXQoZXhpc3RpbmdJdGVtLCBpc0NoZWNrZWQpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gZXhpc3RpbmcgdmFsdWUgaXMgYSBNYXAsXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGludm9rZSBjYWxsYmFjayBhcyBvbmx5IHRoZSBNYXAgaGFzIGJlZW4gbXV0YXRlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlzQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGVsZW1lbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYSByYWRpbyBhbmQgaXQgaGFzIGJlZW4gdW5jaGVja2VkXG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nLCBhcyB0aGUgcmFkaW8gdGhhdCB3YXMgY2hlY2tlZCB3aWxsIGZpcmUgY2hhbmdlIGV2ZW50IGFuZCBpdCB3aWxsIGJlIGhhbmRsZSB0aGVyZVxuICAgICAgICAgICAgLy8gYSByYWRpbyBjYW5ub3QgYmUgdW5jaGVja2VkIGJ5IHVzZXJcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICB0aGlzLnN1YnMubm90aWZ5KHRoaXMudmFsdWUsIHRoaXMub2xkVmFsdWUsIDAgLyogbm9uZSAqLyk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuc3Vic2NyaWJlKHRoaXMub2JqLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbk9ic2VydmVyPy51bnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uT2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudmFsdWVPYnNlcnZlcj8udW5zdWJzY3JpYmUodGhpcyk7XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZlKCkge1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLm9iajtcbiAgICAgICAgKHRoaXMudmFsdWVPYnNlcnZlciA/PyAodGhpcy52YWx1ZU9ic2VydmVyID0gb2JqLiRvYnNlcnZlcnM/Lm1vZGVsID8/IG9iai4kb2JzZXJ2ZXJzPy52YWx1ZSkpPy5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbk9ic2VydmVyPy51bnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uT2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgKHRoaXMuY29sbGVjdGlvbk9ic2VydmVyID0gZ2V0Q29sbGVjdGlvbk9ic2VydmVyKHRoaXMudmFsdWUsIHRoaXMub2JzZXJ2ZXJMb2NhdG9yKSk/LnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnN1YnNjcmliZXJDb2xsZWN0aW9uKENoZWNrZWRPYnNlcnZlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja2VkLW9ic2VydmVyLmpzLm1hcCIsImltcG9ydCB7IGVtcHR5QXJyYXkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IGNsYXNzIENsYXNzQXR0cmlidXRlQWNjZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9iaikge1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLmRvTm90Q2FjaGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWVJbmRleCA9IHt9O1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCA0IC8qIExheW91dCAqLztcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIC8vIGlzIGl0IHNhZmUgdG8gYXNzdW1lIHRoZSBvYnNlcnZlciBoYXMgdGhlIGxhdGVzdCB2YWx1ZT9cbiAgICAgICAgLy8gdG9kbzogYWJpbGl0eSB0byB0dXJuIG9uL29mZiBjYWNoZSBiYXNlZCBvbiB0eXBlXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IG5ld1ZhbHVlICE9PSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICBpZiAoKGZsYWdzICYgNDA5NiAvKiBub0ZsdXNoICovKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaENoYW5nZXMoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoQ2hhbmdlcyhmbGFncykge1xuICAgICAgICBpZiAodGhpcy5oYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmFtZUluZGV4ID0gdGhpcy5uYW1lSW5kZXg7XG4gICAgICAgICAgICBsZXQgdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzVG9BZGQgPSBnZXRDbGFzc2VzVG9BZGQoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIC8vIEdldCBzdHJpbmdzIHNwbGl0IG9uIGEgc3BhY2Ugbm90IGluY2x1ZGluZyBlbXB0aWVzXG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsYXNzZXNBbmRVcGRhdGVJbmRleChjbGFzc2VzVG9BZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uICs9IDE7XG4gICAgICAgICAgICAvLyBGaXJzdCBjYWxsIHRvIHNldFZhbHVlPyAgV2UncmUgZG9uZS5cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNsYXNzZXMgZnJvbSBwcmV2aW91cyB2ZXJzaW9uLlxuICAgICAgICAgICAgdmVyc2lvbiAtPSAxO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5hbWVJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5hbWVJbmRleCwgbmFtZSkgfHwgbmFtZUluZGV4W25hbWVdICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGhhcyB0aGUgc2lkZS1lZmZlY3QgdGhhdCBjbGFzc2VzIGFscmVhZHkgcHJlc2VudCB3aGljaCBhcmUgYWRkZWQgYWdhaW4sXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZW1vdmVkIGlmIHRoZXkncmUgbm90IHByZXNlbnQgaW4gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIEJldHRlciB3b3VsZCBiZSBkbyBoYXZlIHNvbWUgY29uZmlndXJhYmlsaXR5IGZvciB0aGlzIGJlaGF2aW9yLCBhbGxvd2luZyB0aGUgdXNlciB0b1xuICAgICAgICAgICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGluaXRpYWwgY2xhc3NlcyBhbHdheXMgbmVlZCB0byBiZSBrZXB0LCBhbHdheXMgcmVtb3ZlZCwgb3Igc29tZXRoaW5nIGluIGJldHdlZW5cbiAgICAgICAgICAgICAgICB0aGlzLm9iai5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZENsYXNzZXNBbmRVcGRhdGVJbmRleChjbGFzc2VzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm9iajtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmFtZUluZGV4W2NsYXNzTmFtZV0gPSB0aGlzLnZlcnNpb247XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc2VzVG9BZGQob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzcGxpdENsYXNzU3RyaW5nKG9iamVjdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZW1wdHlBcnJheTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG9iamVjdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKC4uLmdldENsYXNzZXNUb0FkZChvYmplY3RbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2xhc3NlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgIC8vIExldCBub24gdHlwaWNhbCB2YWx1ZXMgYWxzbyBldmFsdWF0ZSB0cnVlIHNvIGRpc2FibGUgYm9vbCBjaGVja1xuICAgICAgICBpZiAoQm9vbGVhbihvYmplY3RbcHJvcGVydHldKSkge1xuICAgICAgICAgICAgLy8gV2UgbXVzdCBkbyB0aGlzIGluIGNhc2Ugb2JqZWN0IHByb3BlcnR5IGhhcyBhIHNwYWNlIGluIHRoZSBuYW1lIHdoaWNoIHJlc3VsdHMgaW4gdHdvIGNsYXNzZXNcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5pbmNsdWRlcygnICcpKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKC4uLnNwbGl0Q2xhc3NTdHJpbmcocHJvcGVydHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzZXM7XG59XG5mdW5jdGlvbiBzcGxpdENsYXNzU3RyaW5nKGNsYXNzU3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGNsYXNzU3RyaW5nLm1hdGNoKC9cXFMrL2cpO1xuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsYXNzLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcy5tYXAiLCIvKipcbiAqIEF0dHJpYnV0ZSBhY2Nlc3NvciBmb3IgSFRNTCBlbGVtZW50cy5cbiAqIE5vdGUgdGhhdCBBdXJlbGlhIHdvcmtzIHdpdGggcHJvcGVydGllcywgc28gaW4gYWxsIGNhc2UgaXQgd2lsbCB0cnkgdG8gYXNzaWduIHRvIHByb3BlcnR5IGluc3RlYWQgb2YgYXR0cmlidXRlcy5cbiAqIFVubGVzcyB0aGUgcHJvcGVydHkgZmFsbHMgaW50byBhIHNwZWNpYWwgc2V0LCB0aGVuIGl0IHdpbGwgdXNlIGF0dHJpYnV0ZSBmb3IgaXQuXG4gKlxuICogQHNlZSBFbGVtZW50UHJvcGVydHlBY2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgRGF0YUF0dHJpYnV0ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9ICcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgIC8vIE9ic2VydmVyVHlwZS5MYXlvdXQgaXMgbm90IGFsd2F5cyB0cnVlLCBpdCBkZXBlbmRzIG9uIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBidXQgZm9yIHNpbXBsaWNpdHksIGFsd2F5cyB0cmVhdCBhcyBzdWNoXG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTm9kZSAqLyB8IDQgLyogTGF5b3V0ICovO1xuICAgIH1cbiAgICBnZXRWYWx1ZShvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gb2JqLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MsIG9iaiwga2V5KSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9iai5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgYXR0ckFjY2Vzc29yID0gbmV3IERhdGFBdHRyaWJ1dGVBY2Nlc3NvcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1hdHRyaWJ1dGUtYWNjZXNzb3IuanMubWFwIiwiaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24gfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbi8qKlxuICogT2JzZXJ2ZXIgZm9yIGhhbmRsaW5nIHR3by13YXkgYmluZGluZyB3aXRoIGF0dHJpYnV0ZXNcbiAqIEhhcyBkaWZmZXJlbnQgc3RyYXRlZ3kgZm9yIGNsYXNzL3N0eWxlIGFuZCBub3JtYWwgYXR0cmlidXRlc1xuICogVE9ETzogaGFuZGxlIFNWRy9hdHRyaWJ1dGVzIHdpdGggbmFtZXNwYWNlXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm0sIG9ic2VydmVyTG9jYXRvciwgb2JqLCBwcm9wZXJ0eUtleSwgdGFyZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIHRoaXMudGFyZ2V0QXR0cmlidXRlID0gdGFyZ2V0QXR0cmlidXRlO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gbGF5b3V0IGlzIG5vdCBjZXJ0YWluLCBkZXBlbmRzIG9uIHRoZSBhdHRyaWJ1dGUgYmVpbmcgZmx1c2hlZCB0byBvd25lciBlbGVtZW50XG4gICAgICAgIC8vIGJ1dCBmb3Igc2ltcGxlIHN0YXJ0LCBhbHdheXMgdHJlYXQgYXMgc3VjaFxuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCAxIC8qIE9ic2VydmVyICovIHwgNCAvKiBMYXlvdXQgKi87XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICAvLyBpcyBpdCBzYWZlIHRvIGFzc3VtZSB0aGUgb2JzZXJ2ZXIgaGFzIHRoZSBsYXRlc3QgdmFsdWU/XG4gICAgICAgIC8vIHRvZG86IGFiaWxpdHkgdG8gdHVybiBvbi9vZmYgY2FjaGUgYmFzZWQgb24gdHlwZVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBuZXdWYWx1ZSAhPT0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgaWYgKChmbGFncyAmIDQwOTYgLyogbm9GbHVzaCAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDaGFuZ2VzKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaENoYW5nZXMoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFyZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoeSBkb2VzIGNsYXNzIGF0dHJpYnV0ZSBvYnNlcnZlciBzZXRWYWx1ZSBsb29rIGRpZmZlcmVudCB3aXRoIGNsYXNzIGF0dHJpYnV0ZSBhY2Nlc3Nvcj9cbiAgICAgICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNsYXNzIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3VmFsdWUgaXMgc2ltcGx5IGNoZWNrZWQgaWYgdHJ1dGh5IG9yIGZhbHN5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0b2dnbGUgdGhlIGNsYXNzIGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgICAgIC8vIC0tIHRoZSBydWxlIG9mIHRoaXMgaXMgcXVpdGUgZGlmZmVyZW50IHRvIG5vcm1hbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNsYXNzIGF0dHJpYnV0ZSwgb2JzZXJ2ZXIgaXMgZGlmZmVyZW50IGluIGEgd2F5IHRoYXQgaXQgb25seSBvYnNlcnZlcyBvbmUgY2xhc3MgYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBjb21lcyBmcm9tIHN5bnRheCwgd2hlcmUgaXQgd291bGQgdHlwaWNhbGx5IGJlIG15LWNsYXNzLmNsYXNzPVwic29tZVByb3BlcnR5XCJcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhlcmUgaXMgbm8gbmVlZCBmb3Igc2VwYXJhdGluZyBjbGFzcyBieSBzcGFjZSBhbmQgYWRkIGFsbCBvZiB0aGVtIGxpa2UgY2xhc3MgYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogbm90IHVzaW5nIC50b2dnbGUgQVBJIHNvIHRoYXQgZW52aXJvbm1lbnQgd2l0aCBicm9rZW4gaW1wbCAoSUUxMSkgd29uJ3QgbmVlZCB0byBwb2xmeWZpbGwgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoISFjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLmNsYXNzTGlzdC5hZGQodGhpcy5wcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai5jbGFzc0xpc3QucmVtb3ZlKHRoaXMucHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ3N0cmluZycgJiYgbmV3VmFsdWUuaW5jbHVkZXMoJyFpbXBvcnRhbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSAnaW1wb3J0YW50JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUucmVwbGFjZSgnIWltcG9ydGFudCcsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai5zdHlsZS5zZXRQcm9wZXJ0eSh0aGlzLnByb3BlcnR5S2V5LCBuZXdWYWx1ZSwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVNdXRhdGlvbihtdXRhdGlvblJlY29yZHMpIHtcbiAgICAgICAgbGV0IHNob3VsZFByb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbXV0YXRpb25SZWNvcmRzLmxlbmd0aDsgaWkgPiBpOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IG11dGF0aW9uUmVjb3Jkc1tpXTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSB0aGlzLnByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkUHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFByb2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50YXJnZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5vYmouY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMucHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5vYmouc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh0aGlzLnByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0YXJnZXRBdHRyaWJ1dGU6ICR7dGhpcy50YXJnZXRBdHRyaWJ1dGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50VmFsdWUgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLm9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShuZXdWYWx1ZSwgY3VycmVudFZhbHVlLCAwIC8qIG5vbmUgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLm9sZFZhbHVlID0gdGhpcy5vYmouZ2V0QXR0cmlidXRlKHRoaXMucHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgc3RhcnRPYnNlcnZhdGlvbih0aGlzLm9iai5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk11dGF0aW9uT2JzZXJ2ZXIsIHRoaXMub2JqLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMucmVtb3ZlKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3RvcE9ic2VydmF0aW9uKHRoaXMub2JqLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnN1YnNjcmliZXJDb2xsZWN0aW9uKEF0dHJpYnV0ZU9ic2VydmVyKTtcbmNvbnN0IHN0YXJ0T2JzZXJ2YXRpb24gPSAoJE11dGF0aW9uT2JzZXJ2ZXIsIGVsZW1lbnQsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgIGlmIChlbGVtZW50LiRlTU9ic2VydmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnQuJGVNT2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC4kbU9ic2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgKGVsZW1lbnQuJG1PYnNlcnZlciA9IG5ldyAkTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbikpLm9ic2VydmUoZWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgIH1cbiAgICBlbGVtZW50LiRlTU9ic2VydmVycy5hZGQoc3Vic2NyaXB0aW9uKTtcbn07XG5jb25zdCBzdG9wT2JzZXJ2YXRpb24gPSAoZWxlbWVudCwgc3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgY29uc3QgJGVNT2JzZXJ2ZXJzID0gZWxlbWVudC4kZU1PYnNlcnZlcnM7XG4gICAgaWYgKCRlTU9ic2VydmVycyAmJiAkZU1PYnNlcnZlcnMuZGVsZXRlKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgaWYgKCRlTU9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBlbGVtZW50LiRtT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZWxlbWVudC4kbU9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgaGFuZGxlTXV0YXRpb24gPSAobXV0YXRpb25SZWNvcmRzKSA9PiB7XG4gICAgbXV0YXRpb25SZWNvcmRzWzBdLnRhcmdldC4kZU1PYnNlcnZlcnMuZm9yRWFjaChpbnZva2VIYW5kbGVNdXRhdGlvbiwgbXV0YXRpb25SZWNvcmRzKTtcbn07XG5mdW5jdGlvbiBpbnZva2VIYW5kbGVNdXRhdGlvbihzKSB7XG4gICAgcy5oYW5kbGVNdXRhdGlvbih0aGlzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnQtYXR0cmlidXRlLW9ic2VydmVyLmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IGZhbHNlLFxufTtcbmNsYXNzIExpc3RlbmVyVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IocHVibGlzaGVyLCBldmVudE5hbWUsIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHB1Ymxpc2hlcjtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmNhcHR1cmVMb29rdXBzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmJ1YmJsZUxvb2t1cHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGluY3JlbWVudCgpIHtcbiAgICAgICAgaWYgKCsrdGhpcy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNyZW1lbnQoKSB7XG4gICAgICAgIGlmICgtLXRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYXB0dXJlTG9va3Vwcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmJ1YmJsZUxvb2t1cHMuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldExvb2t1cCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgbG9va3VwcyA9IHRoaXMub3B0aW9ucy5jYXB0dXJlID09PSB0cnVlID8gdGhpcy5jYXB0dXJlTG9va3VwcyA6IHRoaXMuYnViYmxlTG9va3VwcztcbiAgICAgICAgbGV0IGxvb2t1cCA9IGxvb2t1cHMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmIChsb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbG9va3Vwcy5zZXQodGFyZ2V0LCBsb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbG9va3VwcyA9IHRoaXMub3B0aW9ucy5jYXB0dXJlID09PSB0cnVlID8gdGhpcy5jYXB0dXJlTG9va3VwcyA6IHRoaXMuYnViYmxlTG9va3VwcztcbiAgICAgICAgY29uc3QgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNhcHR1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBhdGgucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IGxvb2t1cHMuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAobG9va3VwID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gbG9va3VwW3RoaXMuZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRW5hYmxlIGRpc3Bvc2UoKSBwYXR0ZXJuIGZvciBgZGVsZWdhdGVgICYgYGNhcHR1cmVgIGNvbW1hbmRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWxlZ2F0ZVN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgbG9va3VwLCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gICAgICAgIHRoaXMubG9va3VwID0gbG9va3VwO1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgdHJhY2tlci5pbmNyZW1lbnQoKTtcbiAgICAgICAgbG9va3VwW2V2ZW50TmFtZV0gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFja2VyLmRlY3JlbWVudCgpO1xuICAgICAgICB0aGlzLmxvb2t1cFt0aGlzLmV2ZW50TmFtZV0gPSB2b2lkIDA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEV2ZW50U3Vic2NyaWJlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgfVxuICAgIHN1YnNjcmliZShub2RlLCBjYWxsYmFja09yTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBub2RlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjYWxsYmFja09yTGlzdGVuZXI7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5jb25maWcuZXZlbnRzKSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrT3JMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIGhhbmRsZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwgJiYgaGFuZGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLmNvbmZpZy5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJRXZlbnREZWxlZ2F0b3IgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lFdmVudERlbGVnYXRvcicsIHggPT4geC5zaW5nbGV0b24oRXZlbnREZWxlZ2F0b3IpKTtcbmV4cG9ydCBjbGFzcyBFdmVudERlbGVnYXRvciB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudHJhY2tlck1hcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKHB1Ymxpc2hlciwgdGFyZ2V0LCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdHJhY2tlck1hcCA9IChfYSA9IHRoaXMudHJhY2tlck1hcHMpW2V2ZW50TmFtZV0gPz8gKF9hW2V2ZW50TmFtZV0gPSBuZXcgTWFwKCkpO1xuICAgICAgICBsZXQgdHJhY2tlciA9IHRyYWNrZXJNYXAuZ2V0KHB1Ymxpc2hlcik7XG4gICAgICAgIGlmICh0cmFja2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRyYWNrZXJNYXAuc2V0KHB1Ymxpc2hlciwgdHJhY2tlciA9IG5ldyBMaXN0ZW5lclRyYWNrZXIocHVibGlzaGVyLCBldmVudE5hbWUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERlbGVnYXRlU3Vic2NyaXB0aW9uKHRyYWNrZXIsIHRyYWNrZXIuZ2V0TG9va3VwKHRhcmdldCksIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiB0aGlzLnRyYWNrZXJNYXBzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2VyTWFwID0gdGhpcy50cmFja2VyTWFwc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFja2VyIG9mIHRyYWNrZXJNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrZXJNYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LWRlbGVnYXRvci5qcy5tYXAiLCJpbXBvcnQgeyBlbXB0eU9iamVjdCwgSVNlcnZpY2VMb2NhdG9yLCBSZWdpc3RyYXRpb24gfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSURpcnR5Q2hlY2tlciwgSU5vZGVPYnNlcnZlckxvY2F0b3IsIFByb3BlcnR5QWNjZXNzb3IsIFNldHRlck9ic2VydmVyLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgQXR0cmlidXRlTlNBY2Nlc3NvciB9IGZyb20gJy4vYXR0cmlidXRlLW5zLWFjY2Vzc29yLmpzJztcbmltcG9ydCB7IENoZWNrZWRPYnNlcnZlciB9IGZyb20gJy4vY2hlY2tlZC1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBDbGFzc0F0dHJpYnV0ZUFjY2Vzc29yIH0gZnJvbSAnLi9jbGFzcy1hdHRyaWJ1dGUtYWNjZXNzb3IuanMnO1xuaW1wb3J0IHsgYXR0ckFjY2Vzc29yIH0gZnJvbSAnLi9kYXRhLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcyc7XG5pbXBvcnQgeyBFdmVudFN1YnNjcmliZXIgfSBmcm9tICcuL2V2ZW50LWRlbGVnYXRvci5qcyc7XG5pbXBvcnQgeyBTZWxlY3RWYWx1ZU9ic2VydmVyIH0gZnJvbSAnLi9zZWxlY3QtdmFsdWUtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgU3R5bGVBdHRyaWJ1dGVBY2Nlc3NvciB9IGZyb20gJy4vc3R5bGUtYXR0cmlidXRlLWFjY2Vzc29yLmpzJztcbmltcG9ydCB7IElTVkdBbmFseXplciB9IGZyb20gJy4vc3ZnLWFuYWx5emVyLmpzJztcbmltcG9ydCB7IFZhbHVlQXR0cmlidXRlT2JzZXJ2ZXIgfSBmcm9tICcuL3ZhbHVlLWF0dHJpYnV0ZS1vYnNlcnZlci5qcyc7XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbmFtZXNwYWNlc1xuY29uc3QgaHRtbE5TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgbWF0aG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgeG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcbmNvbnN0IHhtbG5zTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5jb25zdCBuc0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUxvb2t1cCgpLCB7XG4gICAgJ3hsaW5rOmFjdHVhdGUnOiBbJ2FjdHVhdGUnLCB4bGlua05TXSxcbiAgICAneGxpbms6YXJjcm9sZSc6IFsnYXJjcm9sZScsIHhsaW5rTlNdLFxuICAgICd4bGluazpocmVmJzogWydocmVmJywgeGxpbmtOU10sXG4gICAgJ3hsaW5rOnJvbGUnOiBbJ3JvbGUnLCB4bGlua05TXSxcbiAgICAneGxpbms6c2hvdyc6IFsnc2hvdycsIHhsaW5rTlNdLFxuICAgICd4bGluazp0aXRsZSc6IFsndGl0bGUnLCB4bGlua05TXSxcbiAgICAneGxpbms6dHlwZSc6IFsndHlwZScsIHhsaW5rTlNdLFxuICAgICd4bWw6bGFuZyc6IFsnbGFuZycsIHhtbE5TXSxcbiAgICAneG1sOnNwYWNlJzogWydzcGFjZScsIHhtbE5TXSxcbiAgICAneG1sbnMnOiBbJ3htbG5zJywgeG1sbnNOU10sXG4gICAgJ3htbG5zOnhsaW5rJzogWyd4bGluaycsIHhtbG5zTlNdLFxufSk7XG5jb25zdCBlbGVtZW50UHJvcGVydHlBY2Nlc3NvciA9IG5ldyBQcm9wZXJ0eUFjY2Vzc29yKCk7XG5lbGVtZW50UHJvcGVydHlBY2Nlc3Nvci50eXBlID0gMiAvKiBOb2RlICovIHwgNCAvKiBMYXlvdXQgKi87XG5leHBvcnQgY2xhc3MgTm9kZU9ic2VydmVyQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy50eXBlID0gY29uZmlnLnR5cGUgPz8gVmFsdWVBdHRyaWJ1dGVPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBjb25maWcuZXZlbnRzO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gY29uZmlnLnJlYWRvbmx5O1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb25maWcuZGVmYXVsdDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm9kZU9ic2VydmVyTG9jYXRvciB7XG4gICAgY29uc3RydWN0b3IobG9jYXRvciwgcGxhdGZvcm0sIGRpcnR5Q2hlY2tlciwgc3ZnQW5hbHl6ZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLmRpcnR5Q2hlY2tlciA9IGRpcnR5Q2hlY2tlcjtcbiAgICAgICAgdGhpcy5zdmdBbmFseXplciA9IHN2Z0FuYWx5emVyO1xuICAgICAgICB0aGlzLmFsbG93RGlydHlDaGVjayA9IHRydWU7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gY3JlYXRlTG9va3VwKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRzID0gY3JlYXRlTG9va3VwKCk7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVzID0gY3JlYXRlTG9va3VwKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsT3ZlcnJpZGVzID0gY3JlYXRlTG9va3VwKCk7XG4gICAgICAgIC8vIHRvZG86IGF0bSwgcGxhdGZvcm0gaXMgcmVxdWlyZWQgdG8gYmUgcmVzb2x2ZWQgdG9vIGVhZ2VybHkgZm9yIHRoZSBgLmhhbmRsZXMoKWAgY2hlY2tcbiAgICAgICAgLy8gYWxzbyBhIGxvdCBvZiB0ZXN0cyBhc3N1bWUgZGVmYXVsdCBhdmFpbGFiaWxpdHkgb2Ygb2JzZXJ2YXRpb25cbiAgICAgICAgLy8gdGhvc2UgMiBhc3N1bXB0aW9ucyBtYWtlIGl0IG5vdCB0aGUgcmlnaHQgdGltZSB0byBleHRyYWN0IHRoZSBmb2xsb3dpbmcgbGluZSBpbnRvIGFcbiAgICAgICAgLy8gZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBOb2RlT2JzZXJ2ZXJMb2NhdG9yIHlldFxuICAgICAgICAvLyBidXQgaW4gdGhlIGZ1dHVyZSwgdGhleSBzaG91bGQgYmUsIHNvIGFwcHMgdGhhdCBkb24ndCB1c2UgY2hlY2sgYm94L3NlbGVjdCwgb3IgaW1wbGVtZW50IGEgZGlmZmVyZW50XG4gICAgICAgIC8vIG9ic2VydmVyIGRvbid0IGhhdmUgdG8gcGF5IHRoZSBvZiB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBjb25zdCBpbnB1dEV2ZW50cyA9IFsnY2hhbmdlJywgJ2lucHV0J107XG4gICAgICAgIGNvbnN0IGlucHV0RXZlbnRzQ29uZmlnID0geyBldmVudHM6IGlucHV0RXZlbnRzLCBkZWZhdWx0OiAnJyB9O1xuICAgICAgICB0aGlzLnVzZUNvbmZpZyh7XG4gICAgICAgICAgICBJTlBVVDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dEV2ZW50c0NvbmZpZyxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiB7IHR5cGU6IENoZWNrZWRPYnNlcnZlciwgZXZlbnRzOiBpbnB1dEV2ZW50cyB9LFxuICAgICAgICAgICAgICAgIGZpbGVzOiB7IGV2ZW50czogaW5wdXRFdmVudHMsIHJlYWRvbmx5OiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU0VMRUNUOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHsgdHlwZTogU2VsZWN0VmFsdWVPYnNlcnZlciwgZXZlbnRzOiBbJ2NoYW5nZSddLCBkZWZhdWx0OiAnJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFRFWFRBUkVBOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0RXZlbnRzQ29uZmlnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRFdmVudHNDb25maWcgPSB7IGV2ZW50czogWydjaGFuZ2UnLCAnaW5wdXQnLCAnYmx1cicsICdrZXl1cCcsICdwYXN0ZSddLCBkZWZhdWx0OiAnJyB9O1xuICAgICAgICBjb25zdCBzY3JvbGxFdmVudHNDb25maWcgPSB7IGV2ZW50czogWydzY3JvbGwnXSwgZGVmYXVsdDogMCB9O1xuICAgICAgICB0aGlzLnVzZUNvbmZpZ0dsb2JhbCh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbEV2ZW50c0NvbmZpZyxcbiAgICAgICAgICAgIHNjcm9sbExlZnQ6IHNjcm9sbEV2ZW50c0NvbmZpZyxcbiAgICAgICAgICAgIHRleHRDb250ZW50OiBjb250ZW50RXZlbnRzQ29uZmlnLFxuICAgICAgICAgICAgaW5uZXJIVE1MOiBjb250ZW50RXZlbnRzQ29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vdmVycmlkZUFjY2Vzc29yR2xvYmFsKCdjc3MnLCAnc3R5bGUnLCAnY2xhc3MnKTtcbiAgICAgICAgdGhpcy5vdmVycmlkZUFjY2Vzc29yKHtcbiAgICAgICAgICAgIElOUFVUOiBbJ3ZhbHVlJywgJ2NoZWNrZWQnLCAnbW9kZWwnXSxcbiAgICAgICAgICAgIFNFTEVDVDogWyd2YWx1ZSddLFxuICAgICAgICAgICAgVEVYVEFSRUE6IFsndmFsdWUnXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgUmVnaXN0cmF0aW9uLmFsaWFzVG8oSU5vZGVPYnNlcnZlckxvY2F0b3IsIE5vZGVPYnNlcnZlckxvY2F0b3IpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oSU5vZGVPYnNlcnZlckxvY2F0b3IsIE5vZGVPYnNlcnZlckxvY2F0b3IpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG4gICAgaGFuZGxlcyhvYmosIF9rZXkpIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHRoaXMucGxhdGZvcm0uTm9kZTtcbiAgICB9XG4gICAgdXNlQ29uZmlnKG5vZGVOYW1lT3JDb25maWcsIGtleSwgZXZlbnRzQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMuZXZlbnRzO1xuICAgICAgICBsZXQgZXhpc3RpbmdNYXBwaW5nO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGVOYW1lT3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBleGlzdGluZ01hcHBpbmcgPSBsb29rdXBbbm9kZU5hbWVPckNvbmZpZ10gPz8gKGxvb2t1cFtub2RlTmFtZU9yQ29uZmlnXSA9IGNyZWF0ZUxvb2t1cCgpKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ01hcHBpbmdba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdNYXBwaW5nW2tleV0gPSBuZXcgTm9kZU9ic2VydmVyQ29uZmlnKGV2ZW50c0NvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd01hcHBpbmdFeGlzdGVkKG5vZGVOYW1lT3JDb25maWcsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGVOYW1lIGluIG5vZGVOYW1lT3JDb25maWcpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ01hcHBpbmcgPSBsb29rdXBbbm9kZU5hbWVdID8/IChsb29rdXBbbm9kZU5hbWVdID0gY3JlYXRlTG9va3VwKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld01hcHBpbmcgPSBub2RlTmFtZU9yQ29uZmlnW25vZGVOYW1lXTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBuZXdNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ01hcHBpbmdba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ01hcHBpbmdba2V5XSA9IG5ldyBOb2RlT2JzZXJ2ZXJDb25maWcobmV3TWFwcGluZ1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93TWFwcGluZ0V4aXN0ZWQobm9kZU5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXNlQ29uZmlnR2xvYmFsKGNvbmZpZ09yS2V5LCBldmVudHNDb25maWcpIHtcbiAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5nbG9iYWxFdmVudHM7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnT3JLZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWdPcktleSkge1xuICAgICAgICAgICAgICAgIGlmIChsb29rdXBba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFtrZXldID0gbmV3IE5vZGVPYnNlcnZlckNvbmZpZyhjb25maWdPcktleVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93TWFwcGluZ0V4aXN0ZWQoJyonLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb29rdXBbY29uZmlnT3JLZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb29rdXBbY29uZmlnT3JLZXldID0gbmV3IE5vZGVPYnNlcnZlckNvbmZpZyhldmVudHNDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dNYXBwaW5nRXhpc3RlZCgnKicsIGNvbmZpZ09yS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHRsaW5lXG4gICAgZ2V0QWNjZXNzb3Iob2JqLCBrZXksIHJlcXVlc3Rvcikge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuZ2xvYmFsT3ZlcnJpZGVzIHx8IChrZXkgaW4gKHRoaXMub3ZlcnJpZGVzW29iai50YWdOYW1lXSA/PyBlbXB0eU9iamVjdCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPYnNlcnZlcihvYmosIGtleSwgcmVxdWVzdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgLy8gY2xhc3MgLyBzdHlsZSAvIGNzcyBhdHRyaWJ1dGUgd2lsbCBiZSBvYnNlcnZlZCB1c2luZyAuZ2V0T2JzZXJ2ZXIoKSBwZXIgb3ZlcnJpZGVzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogdGhlcmUgYXJlIChtYW55KSBtb3JlIHNpdHVhdGlvbiB3aGVyZSB3ZSB3YW50IHRvIGRlZmF1bHQgdG8gRGF0YUF0dHJpYnV0ZUFjY2Vzc29yLFxuICAgICAgICAgICAgLy8gYnV0IGZvciBub3cgc3RpY2sgdG8gd2hhdCB2Q3VycmVudCBkb2VzXG4gICAgICAgICAgICBjYXNlICdzcmMnOlxuICAgICAgICAgICAgY2FzZSAnaHJlZic6XG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCN3YWktYXJpYVxuICAgICAgICAgICAgY2FzZSAncm9sZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJBY2Nlc3NvcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuc1Byb3BzID0gbnNBdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG5zUHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXR0cmlidXRlTlNBY2Nlc3Nvci5mb3JOcyhuc1Byb3BzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0YUF0dHJpYnV0ZShvYmosIGtleSwgdGhpcy5zdmdBbmFseXplcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJBY2Nlc3NvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRQcm9wZXJ0eUFjY2Vzc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG92ZXJyaWRlQWNjZXNzb3IodGFnTmFtZU9yT3ZlcnJpZGVzLCBrZXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IGV4aXN0aW5nVGFnT3ZlcnJpZGU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZU9yT3ZlcnJpZGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXhpc3RpbmdUYWdPdmVycmlkZSA9IChfYSA9IHRoaXMub3ZlcnJpZGVzKVt0YWdOYW1lT3JPdmVycmlkZXNdID8/IChfYVt0YWdOYW1lT3JPdmVycmlkZXNdID0gY3JlYXRlTG9va3VwKCkpO1xuICAgICAgICAgICAgZXhpc3RpbmdUYWdPdmVycmlkZVtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnTmFtZSBpbiB0YWdOYW1lT3JPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0YWdOYW1lT3JPdmVycmlkZXNbdGFnTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUYWdPdmVycmlkZSA9IChfYiA9IHRoaXMub3ZlcnJpZGVzKVt0YWdOYW1lXSA/PyAoX2JbdGFnTmFtZV0gPSBjcmVhdGVMb29rdXAoKSk7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFnT3ZlcnJpZGVba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBhbGwgZWxlbWVudHM6XG4gICAgICogY29tcG9zZSBhIGxpc3Qgb2YgcHJvcGVydGllcyxcbiAgICAgKiB0byBpbmRpY2F0ZSB0aGF0IGFuIG92ZXJzZXIgc2hvdWxkIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYW4gYWNjZXNzb3IgaW4gYC5nZXRBY2Nlc3NvcigpYFxuICAgICAqL1xuICAgIG92ZXJyaWRlQWNjZXNzb3JHbG9iYWwoLi4ua2V5cykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbE92ZXJyaWRlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPYnNlcnZlcihlbCwga2V5LCByZXF1ZXN0b3IpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JvbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyQWNjZXNzb3I7XG4gICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzc0F0dHJpYnV0ZUFjY2Vzc29yKGVsKTtcbiAgICAgICAgICAgIGNhc2UgJ2Nzcyc6XG4gICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZUF0dHJpYnV0ZUFjY2Vzc29yKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudHNDb25maWcgPSB0aGlzLmV2ZW50c1tlbC50YWdOYW1lXT8uW2tleV0gPz8gdGhpcy5nbG9iYWxFdmVudHNba2V5XTtcbiAgICAgICAgaWYgKGV2ZW50c0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV2ZW50c0NvbmZpZy50eXBlKGVsLCBrZXksIG5ldyBFdmVudFN1YnNjcmliZXIoZXZlbnRzQ29uZmlnKSwgcmVxdWVzdG9yLCB0aGlzLmxvY2F0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5zUHJvcHMgPSBuc0F0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgaWYgKG5zUHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZU5TQWNjZXNzb3IuZm9yTnMobnNQcm9wc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF0YUF0dHJpYnV0ZShlbCwga2V5LCB0aGlzLnN2Z0FuYWx5emVyKSkge1xuICAgICAgICAgICAgLy8gdG9kbzogc2hvdWxkIG9ic2VydmVcbiAgICAgICAgICAgIHJldHVybiBhdHRyQWNjZXNzb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSBpbiBlbC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93RGlydHlDaGVjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcnR5Q2hlY2tlci5jcmVhdGVQcm9wZXJ0eShlbCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNpZGVyOlxuICAgICAgICAgICAgLy8gLSBtYXliZSBhZGQgYSBhZGFwdGVyIEFQSSB0byBoYW5kbGUgdW5rbm93biBvYmova2V5IGNvbWJvXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBvYnNlcnZlIHByb3BlcnR5ICR7U3RyaW5nKGtleSl9LiBSZWdpc3RlciBvYnNlcnZhdGlvbiBtYXBwaW5nIHdpdGggLnVzZUNvbmZpZygpLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9kbzogcHJvYmFibHkgc3RpbGwgbmVlZHMgdG8gZ2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHZpYSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGJ1dCBsZXQncyBzdGFydCB3aXRoIHNpbXBsZXN0IHNjZW5hcmlvXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldHRlck9ic2VydmVyKGVsLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuTm9kZU9ic2VydmVyTG9jYXRvci5pbmplY3QgPSBbSVNlcnZpY2VMb2NhdG9yLCBJUGxhdGZvcm0sIElEaXJ0eUNoZWNrZXIsIElTVkdBbmFseXplcl07XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbk9ic2VydmVyKGNvbGxlY3Rpb24sIG9ic2VydmVyTG9jYXRvcikge1xuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyTG9jYXRvci5nZXRBcnJheU9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXJMb2NhdG9yLmdldE1hcE9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXJMb2NhdG9yLmdldFNldE9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRocm93TWFwcGluZ0V4aXN0ZWQobm9kZU5hbWUsIGtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTWFwcGluZyBmb3IgcHJvcGVydHkgJHtTdHJpbmcoa2V5KX0gb2YgPCR7bm9kZU5hbWV9IC8+IGFscmVhZHkgZXhpc3RzYCk7XG59XG5jb25zdCBJc0RhdGFBdHRyaWJ1dGUgPSBjcmVhdGVMb29rdXAoKTtcbmZ1bmN0aW9uIGlzRGF0YUF0dHJpYnV0ZShvYmosIGtleSwgc3ZnQW5hbHl6ZXIpIHtcbiAgICBpZiAoSXNEYXRhQXR0cmlidXRlW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IGtleS5zbGljZSgwLCA1KTtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCN3YWktYXJpYVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI2N1c3RvbS1kYXRhLWF0dHJpYnV0ZVxuICAgIHJldHVybiBJc0RhdGFBdHRyaWJ1dGVba2V5XSA9XG4gICAgICAgIHByZWZpeCA9PT0gJ2FyaWEtJyB8fFxuICAgICAgICAgICAgcHJlZml4ID09PSAnZGF0YS0nIHx8XG4gICAgICAgICAgICBzdmdBbmFseXplci5pc1N0YW5kYXJkU3ZnQXR0cmlidXRlKG9iaiwga2V5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvb2t1cCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmVyLWxvY2F0b3IuanMubWFwIiwiaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24sIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgY2hpbGRPYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRNYXRjaGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbmV4cG9ydCBjbGFzcyBTZWxlY3RWYWx1ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvYmosIFxuICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG4gICAgX2tleSwgaGFuZGxlciwgb2JzZXJ2ZXJMb2NhdG9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyVHlwZS5MYXlvdXQgaXMgbm90IGFsd2F5cyB0cnVlXG4gICAgICAgIC8vIGJ1dCBmb3Igc2ltcGxpY2l0eSwgYWx3YXlzIHRyZWF0IGFzIHN1Y2hcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBOb2RlICovIHwgMSAvKiBPYnNlcnZlciAqLyB8IDQgLyogTGF5b3V0ICovO1xuICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubm9kZU9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9ic2VydmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIC8vIGlzIGl0IHNhZmUgdG8gYXNzdW1lIHRoZSBvYnNlcnZlciBoYXMgdGhlIGxhdGVzdCB2YWx1ZT9cbiAgICAgICAgLy8gdG9kbzogYWJpbGl0eSB0byB0dXJuIG9uL29mZiBjYWNoZSBiYXNlZCBvbiB0eXBlXG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmluZ1xuICAgICAgICAgICAgPyB0aGlzLmN1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgOiB0aGlzLm9iai5tdWx0aXBsZVxuICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbSh0aGlzLm9iai5vcHRpb25zKS5tYXAobyA9PiBvLnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdGhpcy5vYmoudmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBuZXdWYWx1ZSAhPT0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlQXJyYXkobmV3VmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IG5ld1ZhbHVlIDogbnVsbCk7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA0MDk2IC8qIG5vRmx1c2ggKi8pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ2hhbmdlcyhmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hDaGFuZ2VzKGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zeW5jaHJvbml6ZU9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICAvLyBhbHdheXMgc3luYyBcInNlbGVjdGVkXCIgcHJvcGVydHkgb2YgPG9wdGlvbnMvPlxuICAgICAgICAvLyBpbW1lZGlhdGVseSB3aGVuZXZlciB0aGUgYXJyYXkgbm90aWZpZXMgaXRzIG11dGF0aW9uXG4gICAgICAgIHRoaXMuc3luY2hyb25pemVPcHRpb25zKCk7XG4gICAgfVxuICAgIG5vdGlmeShmbGFncykge1xuICAgICAgICBpZiAoKGZsYWdzICYgMzIgLyogZnJvbUJpbmQgKi8pID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy5ub3RpZnkobmV3VmFsdWUsIG9sZFZhbHVlLCBmbGFncyk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KCkge1xuICAgICAgICBjb25zdCBzaG91bGROb3RpZnkgPSB0aGlzLnN5bmNocm9uaXplVmFsdWUoKTtcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeSh0aGlzLmN1cnJlbnRWYWx1ZSwgdGhpcy5vbGRWYWx1ZSwgMCAvKiBub25lICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jaHJvbml6ZU9wdGlvbnMoaW5kZXhNYXApIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VmFsdWUsIG9iaiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlciA9IG9iai5tYXRjaGVyICE9PSB2b2lkIDAgPyBvYmoubWF0Y2hlciA6IGRlZmF1bHRNYXRjaGVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gb2JqLm9wdGlvbnM7XG4gICAgICAgIGxldCBpID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBoYXNPd24uY2FsbChvcHRpb24sICdtb2RlbCcpID8gb3B0aW9uLm1vZGVsIDogb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBjdXJyZW50VmFsdWUuZmluZEluZGV4KGl0ZW0gPT4gISFtYXRjaGVyKG9wdGlvblZhbHVlLCBpdGVtKSkgIT09IC0xO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gISFtYXRjaGVyKG9wdGlvblZhbHVlLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmNocm9uaXplVmFsdWUoKSB7XG4gICAgICAgIC8vIFNwZWMgZm9yIHN5bmNocm9uaXppbmcgdmFsdWUgZnJvbSBgPHNlbGVjdC8+YCAgdG8gYFNlbGVjdE9ic2VydmVyYFxuICAgICAgICAvLyBXaGVuIHN5bmNocm9uaXppbmcgdmFsdWUgdG8gb2JzZXJ2ZWQgPHNlbGVjdC8+IGVsZW1lbnQsIGRvIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAgICAgIC8vIEEuIElmIGA8c2VsZWN0Lz5gIGlzIG11bHRpcGxlXG4gICAgICAgIC8vICAgIDEuIENoZWNrIGlmIGN1cnJlbnQgdmFsdWUsIGNhbGxlZCBgY3VycmVudFZhbHVlYCBpcyBhbiBhcnJheVxuICAgICAgICAvLyAgICAgIGEuIElmIG5vdCBhbiBhcnJheSwgcmV0dXJuIHRydWUgdG8gc2lnbmFsIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgICAgIC8vICAgICAgYi4gSWYgaXMgYW4gYXJyYXk6XG4gICAgICAgIC8vICAgICAgICBpLiBnYXRoZXIgYWxsIGN1cnJlbnQgc2VsZWN0ZWQgPG9wdGlvbi8+LCBpbiB0byBhcnJheSBjYWxsZWQgYHZhbHVlc2BcbiAgICAgICAgLy8gICAgICAgIGlpLiBsb29wIHRocm91Z2ggdGhlIGBjdXJyZW50VmFsdWVgIGFycmF5IGFuZCByZW1vdmUgaXRlbXMgdGhhdCBhcmUgbm9sb25nZXIgc2VsZWN0ZWQgYmFzZWQgb24gbWF0Y2hlclxuICAgICAgICAvLyAgICAgICAgaWlpLiBsb29wIHRocm91Z2ggdGhlIGB2YWx1ZXNgIGFycmF5IGFuZCBhZGQgaXRlbXMgdGhhdCBhcmUgc2VsZWN0ZWQgYmFzZWQgb24gbWF0Y2hlclxuICAgICAgICAvLyAgICAgICAgaXYuIFJldHVybiBmYWxzZSB0byBzaWduYWwgdmFsdWUgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgLy8gQi4gSWYgdGhlIHNlbGVjdCBpcyBzaW5nbGVcbiAgICAgICAgLy8gICAgMS4gTGV0IGB2YWx1ZWAgZXF1YWwgdGhlIGZpcnN0IHNlbGVjdGVkIG9wdGlvbiwgaWYgbm8gb3B0aW9uIHNlbGVjdGVkLCB0aGVuIGB2YWx1ZWAgaXMgYG51bGxgXG4gICAgICAgIC8vICAgIDIuIGFzc2lnbiBgdGhpcy5jdXJyZW50VmFsdWVgIHRvIGB0aGlzLm9sZFZhbHVlYFxuICAgICAgICAvLyAgICAzLiBhc3NpZ24gYHZhbHVlYCB0byBgdGhpcy5jdXJyZW50VmFsdWVgXG4gICAgICAgIC8vICAgIDQuIHJldHVybiBgdHJ1ZWAgdG8gc2lnbmFsIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gb2JqLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBpZiAob2JqLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAvLyBBLlxuICAgICAgICAgICAgaWYgKCEoY3VycmVudFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQS4xLmFcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEuMS5iXG4gICAgICAgICAgICAvLyBtdWx0aSBzZWxlY3RcbiAgICAgICAgICAgIGxldCBvcHRpb247XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gb2JqLm1hdGNoZXIgfHwgZGVmYXVsdE1hdGNoZXI7XG4gICAgICAgICAgICAvLyBBLjEuYi5pXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGhhc093bi5jYWxsKG9wdGlvbiwgJ21vZGVsJylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3B0aW9uLm1vZGVsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEuMS5iLmlpXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgY3VycmVudFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjdXJyZW50VmFsdWVbaV07XG4gICAgICAgICAgICAgICAgLy8gVG9kbzogcmVtb3ZlIGFycm93IGZuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5maW5kSW5kZXgoYiA9PiAhIW1hdGNoZXIoYSwgYikpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEuMS5iLmlpaVxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFRvZG86IHJlbW92ZSBhcnJvdyBmblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUuZmluZEluZGV4KGIgPT4gISFtYXRjaGVyKGEsIGIpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEuMS5iLml2XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQi4gc2luZ2xlIHNlbGVjdFxuICAgICAgICAvLyBCLjFcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoYXNPd24uY2FsbChvcHRpb24sICdtb2RlbCcpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9uLm1vZGVsXG4gICAgICAgICAgICAgICAgICAgIDogb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEIuMlxuICAgICAgICB0aGlzLm9sZFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgIC8vIEIuM1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAvLyBCLjRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICAodGhpcy5ub2RlT2JzZXJ2ZXIgPSBuZXcgdGhpcy5vYmoub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5NdXRhdGlvbk9ic2VydmVyKHRoaXMuaGFuZGxlTm9kZUNoYW5nZS5iaW5kKHRoaXMpKSlcbiAgICAgICAgICAgIC5vYnNlcnZlKHRoaXMub2JqLCBjaGlsZE9ic2VydmVyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHRoaXMuY3VycmVudFZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLmN1cnJlbnRWYWx1ZSA6IG51bGwpO1xuICAgICAgICB0aGlzLm9ic2VydmluZyA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMubm9kZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5hcnJheU9ic2VydmVyPy51bnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlT2JzZXJ2ZXJcbiAgICAgICAgICAgID0gdGhpcy5hcnJheU9ic2VydmVyXG4gICAgICAgICAgICAgICAgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHRvZG86IG9ic2VydmUgYWxsIGtpbmQgb2YgY29sbGVjdGlvblxuICAgIG9ic2VydmVBcnJheShhcnJheSkge1xuICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXI/LnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIGlmIChhcnJheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub2JqLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG51bGwgb3IgQXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBib3VuZCB0byBhIG11bHRpLXNlbGVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh0aGlzLmFycmF5T2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyTG9jYXRvci5nZXRBcnJheU9ic2VydmVyKGFycmF5KSkuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU5vZGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IHNob3VsZE5vdGlmeSA9IHRoaXMuc3luY2hyb25pemVWYWx1ZSgpO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgwIC8qIG5vbmUgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnN1YnNjcmliZSh0aGlzLm9iaiwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLnJlbW92ZShzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnN1YnNjcmliZXJDb2xsZWN0aW9uKFNlbGVjdFZhbHVlT2JzZXJ2ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LXZhbHVlLW9ic2VydmVyLmpzLm1hcCIsImltcG9ydCB7IGVtcHR5QXJyYXksIGtlYmFiQ2FzZSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5jb25zdCBjdXN0b21Qcm9wZXJ0eVByZWZpeCA9ICctLSc7XG5leHBvcnQgY2xhc3MgU3R5bGVBdHRyaWJ1dGVBY2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCA0IC8qIExheW91dCAqLztcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iai5zdHlsZS5jc3NUZXh0O1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gbmV3VmFsdWUgIT09IHRoaXMub2xkVmFsdWU7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA0MDk2IC8qIG5vRmx1c2ggKi8pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ2hhbmdlcyhmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U3R5bGVUdXBsZXNGcm9tU3RyaW5nKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICBjb25zdCBzdHlsZVR1cGxlcyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxSZWdleFRlc3RlciA9IC91cmxcXChbXildKyQvO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDaHVuayA9ICcnO1xuICAgICAgICBsZXQgbmV4dFNwbGl0O1xuICAgICAgICBsZXQgaW5kZXhPZkNvbG9uO1xuICAgICAgICBsZXQgYXR0cmlidXRlO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0U3BsaXQgPSBjdXJyZW50VmFsdWUuaW5kZXhPZignOycsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAobmV4dFNwbGl0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5leHRTcGxpdCA9IGN1cnJlbnRWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q2h1bmsgKz0gY3VycmVudFZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG5leHRTcGxpdCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBuZXh0U3BsaXQgKyAxO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIG5ldmVyIHNwbGl0IGEgdXJsIHNvIGFkdmFuY2UgdG8gbmV4dFxuICAgICAgICAgICAgaWYgKHVybFJlZ2V4VGVzdGVyLnRlc3QoY3VycmVudENodW5rKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuayArPSAnOyc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleE9mQ29sb24gPSBjdXJyZW50Q2h1bmsuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgYXR0cmlidXRlID0gY3VycmVudENodW5rLnN1YnN0cmluZygwLCBpbmRleE9mQ29sb24pLnRyaW0oKTtcbiAgICAgICAgICAgIHZhbHVlID0gY3VycmVudENodW5rLnN1YnN0cmluZyhpbmRleE9mQ29sb24gKyAxKS50cmltKCk7XG4gICAgICAgICAgICBzdHlsZVR1cGxlcy5wdXNoKFthdHRyaWJ1dGUsIHZhbHVlXSk7XG4gICAgICAgICAgICBjdXJyZW50Q2h1bmsgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVUdXBsZXM7XG4gICAgfVxuICAgIGdldFN0eWxlVHVwbGVzRnJvbU9iamVjdChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY3VycmVudFZhbHVlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgdGFtcGVyZWQgd2l0aFxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5zdGFydHNXaXRoKGN1c3RvbVByb3BlcnR5UHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChbcHJvcGVydHksIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChba2ViYWJDYXNlKHByb3BlcnR5KSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKC4uLnRoaXMuZ2V0U3R5bGVUdXBsZXModmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbiAgICBnZXRTdHlsZVR1cGxlc0Zyb21BcnJheShjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGVuID0gY3VycmVudFZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKC4uLnRoaXMuZ2V0U3R5bGVUdXBsZXMoY3VycmVudFZhbHVlW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgIH1cbiAgICBnZXRTdHlsZVR1cGxlcyhjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdHlsZVR1cGxlc0Zyb21TdHJpbmcoY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlVHVwbGVzRnJvbUFycmF5KGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVUdXBsZXNGcm9tT2JqZWN0KGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgfVxuICAgIGZsdXNoQ2hhbmdlcyhmbGFncykge1xuICAgICAgICBpZiAodGhpcy5oYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXM7XG4gICAgICAgICAgICBjb25zdCBzdHlsZVR1cGxlcyA9IHRoaXMuZ2V0U3R5bGVUdXBsZXMoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIGxldCBzdHlsZTtcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0dXBsZTtcbiAgICAgICAgICAgIGxldCBuYW1lO1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gc3R5bGVUdXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHR1cGxlID0gc3R5bGVUdXBsZXNbaV07XG4gICAgICAgICAgICAgICAgbmFtZSA9IHR1cGxlWzBdO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHVwbGVbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3R5bGVzW25hbWVdID0gdmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uICs9IDE7XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlcnNpb24gLT0gMTtcbiAgICAgICAgICAgIGZvciAoc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3R5bGVzLCBzdHlsZSkgfHwgc3R5bGVzW3N0eWxlXSAhPT0gdmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vYmouc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFByb3BlcnR5KHN0eWxlLCB2YWx1ZSkge1xuICAgICAgICBsZXQgcHJpb3JpdHkgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLmluZGV4T2YgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuaW5jbHVkZXMoJyFpbXBvcnRhbnQnKSkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSAnaW1wb3J0YW50JztcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnIWltcG9ydGFudCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9iai5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgYmluZChmbGFncykge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMub2xkVmFsdWUgPSB0aGlzLm9iai5zdHlsZS5jc3NUZXh0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcy5tYXAiLCJpbXBvcnQgeyBESSwgUmVnaXN0cmF0aW9uIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcbmV4cG9ydCBjb25zdCBJU1ZHQW5hbHl6ZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lTVkdBbmFseXplcicsIHggPT4geC5zaW5nbGV0b24oTm9vcFNWR0FuYWx5emVyKSk7XG5leHBvcnQgY2xhc3MgTm9vcFNWR0FuYWx5emVyIHtcbiAgICBpc1N0YW5kYXJkU3ZnQXR0cmlidXRlKG5vZGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG8oa2V5cykge1xuICAgIGNvbnN0IGxvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBsb29rdXBba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBsb29rdXA7XG59XG5leHBvcnQgY2xhc3MgU1ZHQW5hbHl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICdhJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0YXJnZXQnLCAndHJhbnNmb3JtJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdhbHRHbHlwaCc6IG8oWydjbGFzcycsICdkeCcsICdkeScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2Zvcm1hdCcsICdnbHlwaFJlZicsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3JvdGF0ZScsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd4JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2FsdGdseXBoJzogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICdhbHRHbHlwaERlZic6IG8oWydpZCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnYWx0Z2x5cGhkZWYnOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgJ2FsdEdseXBoSXRlbSc6IG8oWydpZCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnYWx0Z2x5cGhpdGVtJzogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICdhbmltYXRlJzogbyhbJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYXR0cmlidXRlTmFtZScsICdhdHRyaWJ1dGVUeXBlJywgJ2JlZ2luJywgJ2J5JywgJ2NhbGNNb2RlJywgJ2R1cicsICdlbmQnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmaWxsJywgJ2Zyb20nLCAnaWQnLCAna2V5U3BsaW5lcycsICdrZXlUaW1lcycsICdtYXgnLCAnbWluJywgJ29uYmVnaW4nLCAnb25lbmQnLCAnb25sb2FkJywgJ29ucmVwZWF0JywgJ3JlcGVhdENvdW50JywgJ3JlcGVhdER1cicsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyZXN0YXJ0JywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RvJywgJ3ZhbHVlcycsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnYW5pbWF0ZUNvbG9yJzogbyhbJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYXR0cmlidXRlTmFtZScsICdhdHRyaWJ1dGVUeXBlJywgJ2JlZ2luJywgJ2J5JywgJ2NhbGNNb2RlJywgJ2R1cicsICdlbmQnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmaWxsJywgJ2Zyb20nLCAnaWQnLCAna2V5U3BsaW5lcycsICdrZXlUaW1lcycsICdtYXgnLCAnbWluJywgJ29uYmVnaW4nLCAnb25lbmQnLCAnb25sb2FkJywgJ29ucmVwZWF0JywgJ3JlcGVhdENvdW50JywgJ3JlcGVhdER1cicsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyZXN0YXJ0JywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RvJywgJ3ZhbHVlcycsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnYW5pbWF0ZU1vdGlvbic6IG8oWydhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2JlZ2luJywgJ2J5JywgJ2NhbGNNb2RlJywgJ2R1cicsICdlbmQnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmaWxsJywgJ2Zyb20nLCAnaWQnLCAna2V5UG9pbnRzJywgJ2tleVNwbGluZXMnLCAna2V5VGltZXMnLCAnbWF4JywgJ21pbicsICdvbmJlZ2luJywgJ29uZW5kJywgJ29ubG9hZCcsICdvbnJlcGVhdCcsICdvcmlnaW4nLCAncGF0aCcsICdyZXBlYXRDb3VudCcsICdyZXBlYXREdXInLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncmVzdGFydCcsICdyb3RhdGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndG8nLCAndmFsdWVzJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdhbmltYXRlVHJhbnNmb3JtJzogbyhbJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYXR0cmlidXRlTmFtZScsICdhdHRyaWJ1dGVUeXBlJywgJ2JlZ2luJywgJ2J5JywgJ2NhbGNNb2RlJywgJ2R1cicsICdlbmQnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmaWxsJywgJ2Zyb20nLCAnaWQnLCAna2V5U3BsaW5lcycsICdrZXlUaW1lcycsICdtYXgnLCAnbWluJywgJ29uYmVnaW4nLCAnb25lbmQnLCAnb25sb2FkJywgJ29ucmVwZWF0JywgJ3JlcGVhdENvdW50JywgJ3JlcGVhdER1cicsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyZXN0YXJ0JywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RvJywgJ3R5cGUnLCAndmFsdWVzJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdjaXJjbGUnOiBvKFsnY2xhc3MnLCAnY3gnLCAnY3knLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3InLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdjbGlwUGF0aCc6IG8oWydjbGFzcycsICdjbGlwUGF0aFVuaXRzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdjb2xvci1wcm9maWxlJzogbyhbJ2lkJywgJ2xvY2FsJywgJ25hbWUnLCAncmVuZGVyaW5nLWludGVudCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnY3Vyc29yJzogbyhbJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAneCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdkZWZzJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2Rlc2MnOiBvKFsnY2xhc3MnLCAnaWQnLCAnc3R5bGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2VsbGlwc2UnOiBvKFsnY2xhc3MnLCAnY3gnLCAnY3knLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3J4JywgJ3J5JywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZmVCbGVuZCc6IG8oWydjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAnaW4yJywgJ21vZGUnLCAncmVzdWx0JywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVDb2xvck1hdHJpeCc6IG8oWydjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAncmVzdWx0JywgJ3N0eWxlJywgJ3R5cGUnLCAndmFsdWVzJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVDb21wb25lbnRUcmFuc2Zlcic6IG8oWydjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAncmVzdWx0JywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVDb21wb3NpdGUnOiBvKFsnY2xhc3MnLCAnaGVpZ2h0JywgJ2lkJywgJ2luJywgJ2luMicsICdrMScsICdrMicsICdrMycsICdrNCcsICdvcGVyYXRvcicsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZUNvbnZvbHZlTWF0cml4JzogbyhbJ2JpYXMnLCAnY2xhc3MnLCAnZGl2aXNvcicsICdlZGdlTW9kZScsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAna2VybmVsTWF0cml4JywgJ2tlcm5lbFVuaXRMZW5ndGgnLCAnb3JkZXInLCAncHJlc2VydmVBbHBoYScsICdyZXN1bHQnLCAnc3R5bGUnLCAndGFyZ2V0WCcsICd0YXJnZXRZJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVEaWZmdXNlTGlnaHRpbmcnOiBvKFsnY2xhc3MnLCAnZGlmZnVzZUNvbnN0YW50JywgJ2hlaWdodCcsICdpZCcsICdpbicsICdrZXJuZWxVbml0TGVuZ3RoJywgJ3Jlc3VsdCcsICdzdHlsZScsICdzdXJmYWNlU2NhbGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZURpc3BsYWNlbWVudE1hcCc6IG8oWydjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAnaW4yJywgJ3Jlc3VsdCcsICdzY2FsZScsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3hDaGFubmVsU2VsZWN0b3InLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knLCAneUNoYW5uZWxTZWxlY3RvciddKSxcbiAgICAgICAgICAgICdmZURpc3RhbnRMaWdodCc6IG8oWydhemltdXRoJywgJ2VsZXZhdGlvbicsICdpZCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZmVGbG9vZCc6IG8oWydjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAncmVzdWx0JywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVGdW5jQSc6IG8oWydhbXBsaXR1ZGUnLCAnZXhwb25lbnQnLCAnaWQnLCAnaW50ZXJjZXB0JywgJ29mZnNldCcsICdzbG9wZScsICd0YWJsZVZhbHVlcycsICd0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmZUZ1bmNCJzogbyhbJ2FtcGxpdHVkZScsICdleHBvbmVudCcsICdpZCcsICdpbnRlcmNlcHQnLCAnb2Zmc2V0JywgJ3Nsb3BlJywgJ3RhYmxlVmFsdWVzJywgJ3R5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2ZlRnVuY0cnOiBvKFsnYW1wbGl0dWRlJywgJ2V4cG9uZW50JywgJ2lkJywgJ2ludGVyY2VwdCcsICdvZmZzZXQnLCAnc2xvcGUnLCAndGFibGVWYWx1ZXMnLCAndHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZmVGdW5jUic6IG8oWydhbXBsaXR1ZGUnLCAnZXhwb25lbnQnLCAnaWQnLCAnaW50ZXJjZXB0JywgJ29mZnNldCcsICdzbG9wZScsICd0YWJsZVZhbHVlcycsICd0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmZUdhdXNzaWFuQmx1cic6IG8oWydjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAncmVzdWx0JywgJ3N0ZERldmlhdGlvbicsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZlSW1hZ2UnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdoZWlnaHQnLCAnaWQnLCAncHJlc2VydmVBc3BlY3RSYXRpbycsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZU1lcmdlJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZU1lcmdlTm9kZSc6IG8oWydpZCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZmVNb3JwaG9sb2d5JzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdvcGVyYXRvcicsICdyYWRpdXMnLCAncmVzdWx0JywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVPZmZzZXQnOiBvKFsnY2xhc3MnLCAnZHgnLCAnZHknLCAnaGVpZ2h0JywgJ2lkJywgJ2luJywgJ3Jlc3VsdCcsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZlUG9pbnRMaWdodCc6IG8oWydpZCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5JywgJ3onXSksXG4gICAgICAgICAgICAnZmVTcGVjdWxhckxpZ2h0aW5nJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdrZXJuZWxVbml0TGVuZ3RoJywgJ3Jlc3VsdCcsICdzcGVjdWxhckNvbnN0YW50JywgJ3NwZWN1bGFyRXhwb25lbnQnLCAnc3R5bGUnLCAnc3VyZmFjZVNjYWxlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVTcG90TGlnaHQnOiBvKFsnaWQnLCAnbGltaXRpbmdDb25lQW5nbGUnLCAncG9pbnRzQXRYJywgJ3BvaW50c0F0WScsICdwb2ludHNBdFonLCAnc3BlY3VsYXJFeHBvbmVudCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5JywgJ3onXSksXG4gICAgICAgICAgICAnZmVUaWxlJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZVR1cmJ1bGVuY2UnOiBvKFsnYmFzZUZyZXF1ZW5jeScsICdjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAnbnVtT2N0YXZlcycsICdyZXN1bHQnLCAnc2VlZCcsICdzdGl0Y2hUaWxlcycsICdzdHlsZScsICd0eXBlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmlsdGVyJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZmlsdGVyUmVzJywgJ2ZpbHRlclVuaXRzJywgJ2hlaWdodCcsICdpZCcsICdwcmltaXRpdmVVbml0cycsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZvbnQnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdob3Jpei1vcmlnaW4teScsICdpZCcsICdzdHlsZScsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZm9udC1mYWNlJzogbyhbJ2FjY2VudC1oZWlnaHQnLCAnYWxwaGFiZXRpYycsICdhc2NlbnQnLCAnYmJveCcsICdjYXAtaGVpZ2h0JywgJ2Rlc2NlbnQnLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdoYW5naW5nJywgJ2lkJywgJ2lkZW9ncmFwaGljJywgJ21hdGhlbWF0aWNhbCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFub3NlLTEnLCAnc2xvcGUnLCAnc3RlbWgnLCAnc3RlbXYnLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAnd2lkdGhzJywgJ3gtaGVpZ2h0JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmb250LWZhY2UtZm9ybWF0JzogbyhbJ2lkJywgJ3N0cmluZycsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZm9udC1mYWNlLW5hbWUnOiBvKFsnaWQnLCAnbmFtZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZm9udC1mYWNlLXNyYyc6IG8oWydpZCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZm9udC1mYWNlLXVyaSc6IG8oWydpZCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZm9yZWlnbk9iamVjdCc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2hlaWdodCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2cnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZ2x5cGgnOiBvKFsnYXJhYmljLWZvcm0nLCAnY2xhc3MnLCAnZCcsICdnbHlwaC1uYW1lJywgJ2hvcml6LWFkdi14JywgJ2lkJywgJ2xhbmcnLCAnb3JpZW50YXRpb24nLCAnc3R5bGUnLCAndW5pY29kZScsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZ2x5cGhSZWYnOiBvKFsnY2xhc3MnLCAnZHgnLCAnZHknLCAnZm9ybWF0JywgJ2dseXBoUmVmJywgJ2lkJywgJ3N0eWxlJywgJ3gnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZ2x5cGhyZWYnOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgJ2hrZXJuJzogbyhbJ2cxJywgJ2cyJywgJ2lkJywgJ2snLCAndTEnLCAndTInLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2ltYWdlJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaGVpZ2h0JywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncHJlc2VydmVBc3BlY3RSYXRpbycsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAnd2lkdGgnLCAneCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdsaW5lJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAneDEnLCAneDInLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3kxJywgJ3kyJ10pLFxuICAgICAgICAgICAgJ2xpbmVhckdyYWRpZW50JzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZ3JhZGllbnRUcmFuc2Zvcm0nLCAnZ3JhZGllbnRVbml0cycsICdpZCcsICdzcHJlYWRNZXRob2QnLCAnc3R5bGUnLCAneDEnLCAneDInLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneTEnLCAneTInXSksXG4gICAgICAgICAgICAnbWFya2VyJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnbWFya2VySGVpZ2h0JywgJ21hcmtlclVuaXRzJywgJ21hcmtlcldpZHRoJywgJ29yaWVudCcsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3JlZlgnLCAncmVmWScsICdzdHlsZScsICd2aWV3Qm94JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdtYXNrJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaGVpZ2h0JywgJ2lkJywgJ21hc2tDb250ZW50VW5pdHMnLCAnbWFza1VuaXRzJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiBvKFsnaWQnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ21pc3NpbmctZ2x5cGgnOiBvKFsnY2xhc3MnLCAnZCcsICdob3Jpei1hZHYteCcsICdpZCcsICdzdHlsZScsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnbXBhdGgnOiBvKFsnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAncGF0aCc6IG8oWydjbGFzcycsICdkJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdwYXRoTGVuZ3RoJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAncGF0dGVybic6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2hlaWdodCcsICdpZCcsICdwYXR0ZXJuQ29udGVudFVuaXRzJywgJ3BhdHRlcm5UcmFuc2Zvcm0nLCAncGF0dGVyblVuaXRzJywgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndmlld0JveCcsICd3aWR0aCcsICd4JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ3BvbHlnb24nOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3BvaW50cycsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3BvbHlsaW5lJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdwb2ludHMnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdyYWRpYWxHcmFkaWVudCc6IG8oWydjbGFzcycsICdjeCcsICdjeScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2Z4JywgJ2Z5JywgJ2dyYWRpZW50VHJhbnNmb3JtJywgJ2dyYWRpZW50VW5pdHMnLCAnaWQnLCAncicsICdzcHJlYWRNZXRob2QnLCAnc3R5bGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAncmVjdCc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2hlaWdodCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3J4JywgJ3J5JywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ3NjcmlwdCc6IG8oWydleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ3R5cGUnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3NldCc6IG8oWydhdHRyaWJ1dGVOYW1lJywgJ2F0dHJpYnV0ZVR5cGUnLCAnYmVnaW4nLCAnZHVyJywgJ2VuZCcsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZpbGwnLCAnaWQnLCAnbWF4JywgJ21pbicsICdvbmJlZ2luJywgJ29uZW5kJywgJ29ubG9hZCcsICdvbnJlcGVhdCcsICdyZXBlYXRDb3VudCcsICdyZXBlYXREdXInLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncmVzdGFydCcsICdzeXN0ZW1MYW5ndWFnZScsICd0bycsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnc3RvcCc6IG8oWydjbGFzcycsICdpZCcsICdvZmZzZXQnLCAnc3R5bGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3N0eWxlJzogbyhbJ2lkJywgJ21lZGlhJywgJ3RpdGxlJywgJ3R5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3N2Zyc6IG8oWydiYXNlUHJvZmlsZScsICdjbGFzcycsICdjb250ZW50U2NyaXB0VHlwZScsICdjb250ZW50U3R5bGVUeXBlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaGVpZ2h0JywgJ2lkJywgJ29uYWJvcnQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZXJyb3InLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ29ucmVzaXplJywgJ29uc2Nyb2xsJywgJ29udW5sb2FkJywgJ29uem9vbScsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3ZlcnNpb24nLCAndmlld0JveCcsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5JywgJ3pvb21BbmRQYW4nXSksXG4gICAgICAgICAgICAnc3dpdGNoJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncHJlc2VydmVBc3BlY3RSYXRpbycsICdzdHlsZScsICd2aWV3Qm94JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICd0ZXh0JzogbyhbJ2NsYXNzJywgJ2R4JywgJ2R5JywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnbGVuZ3RoQWRqdXN0JywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncm90YXRlJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RleHRMZW5ndGgnLCAndHJhbnNmb3JtJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAndGV4dFBhdGgnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdsZW5ndGhBZGp1c3QnLCAnbWV0aG9kJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3BhY2luZycsICdzdGFydE9mZnNldCcsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0ZXh0TGVuZ3RoJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3RpdGxlJzogbyhbJ2NsYXNzJywgJ2lkJywgJ3N0eWxlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICd0cmVmJzogbyhbJ2NsYXNzJywgJ2R4JywgJ2R5JywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnbGVuZ3RoQWRqdXN0JywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncm90YXRlJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RleHRMZW5ndGgnLCAneCcsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ3RzcGFuJzogbyhbJ2NsYXNzJywgJ2R4JywgJ2R5JywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnbGVuZ3RoQWRqdXN0JywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncm90YXRlJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RleHRMZW5ndGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICd1c2UnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdoZWlnaHQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAnd2lkdGgnLCAneCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICd2aWV3JzogbyhbJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAncHJlc2VydmVBc3BlY3RSYXRpbycsICd2aWV3Qm94JywgJ3ZpZXdUYXJnZXQnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3pvb21BbmRQYW4nXSksXG4gICAgICAgICAgICAndmtlcm4nOiBvKFsnZzEnLCAnZzInLCAnaWQnLCAnaycsICd1MScsICd1MicsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN2Z1ByZXNlbnRhdGlvbkVsZW1lbnRzID0gbyhbXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAnYWx0R2x5cGgnLFxuICAgICAgICAgICAgJ2FuaW1hdGUnLFxuICAgICAgICAgICAgJ2FuaW1hdGVDb2xvcicsXG4gICAgICAgICAgICAnY2lyY2xlJyxcbiAgICAgICAgICAgICdjbGlwUGF0aCcsXG4gICAgICAgICAgICAnZGVmcycsXG4gICAgICAgICAgICAnZWxsaXBzZScsXG4gICAgICAgICAgICAnZmVCbGVuZCcsXG4gICAgICAgICAgICAnZmVDb2xvck1hdHJpeCcsXG4gICAgICAgICAgICAnZmVDb21wb25lbnRUcmFuc2ZlcicsXG4gICAgICAgICAgICAnZmVDb21wb3NpdGUnLFxuICAgICAgICAgICAgJ2ZlQ29udm9sdmVNYXRyaXgnLFxuICAgICAgICAgICAgJ2ZlRGlmZnVzZUxpZ2h0aW5nJyxcbiAgICAgICAgICAgICdmZURpc3BsYWNlbWVudE1hcCcsXG4gICAgICAgICAgICAnZmVGbG9vZCcsXG4gICAgICAgICAgICAnZmVHYXVzc2lhbkJsdXInLFxuICAgICAgICAgICAgJ2ZlSW1hZ2UnLFxuICAgICAgICAgICAgJ2ZlTWVyZ2UnLFxuICAgICAgICAgICAgJ2ZlTW9ycGhvbG9neScsXG4gICAgICAgICAgICAnZmVPZmZzZXQnLFxuICAgICAgICAgICAgJ2ZlU3BlY3VsYXJMaWdodGluZycsXG4gICAgICAgICAgICAnZmVUaWxlJyxcbiAgICAgICAgICAgICdmZVR1cmJ1bGVuY2UnLFxuICAgICAgICAgICAgJ2ZpbHRlcicsXG4gICAgICAgICAgICAnZm9udCcsXG4gICAgICAgICAgICAnZm9yZWlnbk9iamVjdCcsXG4gICAgICAgICAgICAnZycsXG4gICAgICAgICAgICAnZ2x5cGgnLFxuICAgICAgICAgICAgJ2dseXBoUmVmJyxcbiAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICAnbGluZScsXG4gICAgICAgICAgICAnbGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAgJ21hcmtlcicsXG4gICAgICAgICAgICAnbWFzaycsXG4gICAgICAgICAgICAnbWlzc2luZy1nbHlwaCcsXG4gICAgICAgICAgICAncGF0aCcsXG4gICAgICAgICAgICAncGF0dGVybicsXG4gICAgICAgICAgICAncG9seWdvbicsXG4gICAgICAgICAgICAncG9seWxpbmUnLFxuICAgICAgICAgICAgJ3JhZGlhbEdyYWRpZW50JyxcbiAgICAgICAgICAgICdyZWN0JyxcbiAgICAgICAgICAgICdzdG9wJyxcbiAgICAgICAgICAgICdzdmcnLFxuICAgICAgICAgICAgJ3N3aXRjaCcsXG4gICAgICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICd0ZXh0UGF0aCcsXG4gICAgICAgICAgICAndHJlZicsXG4gICAgICAgICAgICAndHNwYW4nLFxuICAgICAgICAgICAgJ3VzZScsXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnN2Z1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMgPSBvKFtcbiAgICAgICAgICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICAgICAgICAgICAgJ2Jhc2VsaW5lLXNoaWZ0JyxcbiAgICAgICAgICAgICdjbGlwLXBhdGgnLFxuICAgICAgICAgICAgJ2NsaXAtcnVsZScsXG4gICAgICAgICAgICAnY2xpcCcsXG4gICAgICAgICAgICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgICAgICAgICAgICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcbiAgICAgICAgICAgICdjb2xvci1wcm9maWxlJyxcbiAgICAgICAgICAgICdjb2xvci1yZW5kZXJpbmcnLFxuICAgICAgICAgICAgJ2NvbG9yJyxcbiAgICAgICAgICAgICdjdXJzb3InLFxuICAgICAgICAgICAgJ2RpcmVjdGlvbicsXG4gICAgICAgICAgICAnZGlzcGxheScsXG4gICAgICAgICAgICAnZG9taW5hbnQtYmFzZWxpbmUnLFxuICAgICAgICAgICAgJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknLFxuICAgICAgICAgICAgJ2ZpbGwtcnVsZScsXG4gICAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgICAnZmlsdGVyJyxcbiAgICAgICAgICAgICdmbG9vZC1jb2xvcicsXG4gICAgICAgICAgICAnZmxvb2Qtb3BhY2l0eScsXG4gICAgICAgICAgICAnZm9udC1mYW1pbHknLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZS1hZGp1c3QnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZScsXG4gICAgICAgICAgICAnZm9udC1zdHJldGNoJyxcbiAgICAgICAgICAgICdmb250LXN0eWxlJyxcbiAgICAgICAgICAgICdmb250LXZhcmlhbnQnLFxuICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgICAgICAgICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgICAgICAgICAgICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXG4gICAgICAgICAgICAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgICAgICAgICAgICdrZXJuaW5nJyxcbiAgICAgICAgICAgICdsZXR0ZXItc3BhY2luZycsXG4gICAgICAgICAgICAnbGlnaHRpbmctY29sb3InLFxuICAgICAgICAgICAgJ21hcmtlci1lbmQnLFxuICAgICAgICAgICAgJ21hcmtlci1taWQnLFxuICAgICAgICAgICAgJ21hcmtlci1zdGFydCcsXG4gICAgICAgICAgICAnbWFzaycsXG4gICAgICAgICAgICAnb3BhY2l0eScsXG4gICAgICAgICAgICAnb3ZlcmZsb3cnLFxuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJyxcbiAgICAgICAgICAgICdzaGFwZS1yZW5kZXJpbmcnLFxuICAgICAgICAgICAgJ3N0b3AtY29sb3InLFxuICAgICAgICAgICAgJ3N0b3Atb3BhY2l0eScsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICAgICAgICAgICAgJ3N0cm9rZS1saW5lY2FwJyxcbiAgICAgICAgICAgICdzdHJva2UtbGluZWpvaW4nLFxuICAgICAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eScsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJyxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgJ3RleHQtYW5jaG9yJyxcbiAgICAgICAgICAgICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAgICAgJ3RleHQtcmVuZGVyaW5nJyxcbiAgICAgICAgICAgICd1bmljb2RlLWJpZGknLFxuICAgICAgICAgICAgJ3Zpc2liaWxpdHknLFxuICAgICAgICAgICAgJ3dvcmQtc3BhY2luZycsXG4gICAgICAgICAgICAnd3JpdGluZy1tb2RlJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuU1ZHRWxlbWVudCA9IHBsYXRmb3JtLmdsb2JhbFRoaXMuU1ZHRWxlbWVudDtcbiAgICAgICAgY29uc3QgZGl2ID0gcGxhdGZvcm0uZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHN2Zz48YWx0R2x5cGggLz48L3N2Zz4nO1xuICAgICAgICBpZiAoZGl2LmZpcnN0RWxlbWVudENoaWxkLm5vZGVOYW1lID09PSAnYWx0Z2x5cGgnKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgY2hyb21lIGNhc2luZyBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0VsZW1lbnRzO1xuICAgICAgICAgICAgbGV0IHRtcCA9IHN2Zy5hbHRHbHlwaDtcbiAgICAgICAgICAgIHN2Zy5hbHRHbHlwaCA9IHN2Zy5hbHRnbHlwaDtcbiAgICAgICAgICAgIHN2Zy5hbHRnbHlwaCA9IHRtcDtcbiAgICAgICAgICAgIHRtcCA9IHN2Zy5hbHRHbHlwaERlZjtcbiAgICAgICAgICAgIHN2Zy5hbHRHbHlwaERlZiA9IHN2Zy5hbHRnbHlwaGRlZjtcbiAgICAgICAgICAgIHN2Zy5hbHRnbHlwaGRlZiA9IHRtcDtcbiAgICAgICAgICAgIHRtcCA9IHN2Zy5hbHRHbHlwaEl0ZW07XG4gICAgICAgICAgICBzdmcuYWx0R2x5cGhJdGVtID0gc3ZnLmFsdGdseXBoaXRlbTtcbiAgICAgICAgICAgIHN2Zy5hbHRnbHlwaGl0ZW0gPSB0bXA7XG4gICAgICAgICAgICB0bXAgPSBzdmcuZ2x5cGhSZWY7XG4gICAgICAgICAgICBzdmcuZ2x5cGhSZWYgPSBzdmcuZ2x5cGhyZWY7XG4gICAgICAgICAgICBzdmcuZ2x5cGhyZWYgPSB0bXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihJU1ZHQW5hbHl6ZXIsIHRoaXMpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIGlzU3RhbmRhcmRTdmdBdHRyaWJ1dGUobm9kZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgdGhpcy5TVkdFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5zdmdQcmVzZW50YXRpb25FbGVtZW50c1tub2RlLm5vZGVOYW1lXSA9PT0gdHJ1ZSAmJiB0aGlzLnN2Z1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPT09IHRydWUgfHxcbiAgICAgICAgICAgIHRoaXMuc3ZnRWxlbWVudHNbbm9kZS5ub2RlTmFtZV0/LlthdHRyaWJ1dGVOYW1lXSA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuU1ZHQW5hbHl6ZXIuaW5qZWN0ID0gW0lQbGF0Zm9ybV07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdmctYW5hbHl6ZXIuanMubWFwIiwiaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24gfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbi8qKlxuICogT2JzZXJ2ZXIgZm9yIG5vbi1yYWRpbywgbm9uLWNoZWNrYm94IGlucHV0LlxuICovXG5leHBvcnQgY2xhc3MgVmFsdWVBdHRyaWJ1dGVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob2JqLCBwcm9wZXJ0eUtleSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyVHlwZS5MYXlvdXQgaXMgbm90IGFsd2F5cyB0cnVlLCBpdCBkZXBlbmRzIG9uIHRoZSBlbGVtZW50ICYgcHJvcGVydHkgY29tYm9cbiAgICAgICAgLy8gYnV0IGZvciBzaW1wbGljaXR5LCBhbHdheXMgdHJlYXQgYXMgc3VjaFxuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCAxIC8qIE9ic2VydmVyICovIHwgNCAvKiBMYXlvdXQgKi87XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgLy8gaXMgaXQgc2FmZSB0byBhc3N1bWUgdGhlIG9ic2VydmVyIGhhcyB0aGUgbGF0ZXN0IHZhbHVlP1xuICAgICAgICAvLyB0b2RvOiBhYmlsaXR5IHRvIHR1cm4gb24vb2ZmIGNhY2hlIGJhc2VkIG9uIHR5cGVcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZhbHVlO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gbmV3VmFsdWUgIT09IHRoaXMub2xkVmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5oYW5kbGVyLmNvbmZpZy5yZWFkb25seSAmJiAoZmxhZ3MgJiA0MDk2IC8qIG5vRmx1c2ggKi8pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ2hhbmdlcyhmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hDaGFuZ2VzKGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMub2xkVmFsdWU7XG4gICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV0gPSBjdXJyZW50VmFsdWUgPz8gdGhpcy5oYW5kbGVyLmNvbmZpZy5kZWZhdWx0O1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIDMyIC8qIGZyb21CaW5kICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkoY3VycmVudFZhbHVlLCBvbGRWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KCkge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMub2xkVmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN1YnMubm90aWZ5KGN1cnJlbnRWYWx1ZSwgb2xkVmFsdWUsIDAgLyogbm9uZSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuc3Vic2NyaWJlKHRoaXMub2JqLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5vbGRWYWx1ZSA9IHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oVmFsdWVBdHRyaWJ1dGVPYnNlcnZlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZS1hdHRyaWJ1dGUtb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgSVBsYXRmb3JtIGFzICRJUGxhdGZvcm0gfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IGNvbnN0IElQbGF0Zm9ybSA9ICRJUGxhdGZvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IE1ldGFkYXRhLCBSZWdpc3RyYXRpb24sIERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdNb2RlLCBJRXhwcmVzc2lvblBhcnNlciwgSU9ic2VydmVyTG9jYXRvciwgQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbiwgQmluZGluZ0JlaGF2aW9yRmFjdG9yeSwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IENhbGxCaW5kaW5nIH0gZnJvbSAnLi9iaW5kaW5nL2NhbGwtYmluZGluZy5qcyc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVCaW5kaW5nIH0gZnJvbSAnLi9iaW5kaW5nL2F0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBJbnRlcnBvbGF0aW9uQmluZGluZyB9IGZyb20gJy4vYmluZGluZy9pbnRlcnBvbGF0aW9uLWJpbmRpbmcuanMnO1xuaW1wb3J0IHsgTGV0QmluZGluZyB9IGZyb20gJy4vYmluZGluZy9sZXQtYmluZGluZy5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUJpbmRpbmcgfSBmcm9tICcuL2JpbmRpbmcvcHJvcGVydHktYmluZGluZy5qcyc7XG5pbXBvcnQgeyBSZWZCaW5kaW5nIH0gZnJvbSAnLi9iaW5kaW5nL3JlZi1iaW5kaW5nLmpzJztcbmltcG9ydCB7IExpc3RlbmVyIH0gZnJvbSAnLi9iaW5kaW5nL2xpc3RlbmVyLmpzJztcbmltcG9ydCB7IElFdmVudERlbGVnYXRvciB9IGZyb20gJy4vb2JzZXJ2YXRpb24vZXZlbnQtZGVsZWdhdG9yLmpzJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBnZXRSZW5kZXJDb250ZXh0IH0gZnJvbSAnLi90ZW1wbGF0aW5nL3JlbmRlci1jb250ZXh0LmpzJztcbmltcG9ydCB7IEN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgY29udmVydFRvUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnLi90ZW1wbGF0aW5nL2NvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5leHBvcnQgdmFyIEluc3RydWN0aW9uVHlwZTtcbihmdW5jdGlvbiAoSW5zdHJ1Y3Rpb25UeXBlKSB7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wiaHlkcmF0ZUVsZW1lbnRcIl0gPSBcInJhXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wiaHlkcmF0ZUF0dHJpYnV0ZVwiXSA9IFwicmJcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJoeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyXCJdID0gXCJyY1wiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcImh5ZHJhdGVMZXRFbGVtZW50XCJdID0gXCJyZFwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcInNldFByb3BlcnR5XCJdID0gXCJyZVwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcImludGVycG9sYXRpb25cIl0gPSBcInJmXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wicHJvcGVydHlCaW5kaW5nXCJdID0gXCJyZ1wiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcImNhbGxCaW5kaW5nXCJdID0gXCJyaFwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcImxldEJpbmRpbmdcIl0gPSBcInJpXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wicmVmQmluZGluZ1wiXSA9IFwicmpcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJpdGVyYXRvckJpbmRpbmdcIl0gPSBcInJrXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1widGV4dEJpbmRpbmdcIl0gPSBcImhhXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wibGlzdGVuZXJCaW5kaW5nXCJdID0gXCJoYlwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcImF0dHJpYnV0ZUJpbmRpbmdcIl0gPSBcImhjXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wic3R5bGVQcm9wZXJ0eUJpbmRpbmdcIl0gPSBcImhkXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wic2V0QXR0cmlidXRlXCJdID0gXCJoZVwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcInNldENsYXNzQXR0cmlidXRlXCJdID0gXCJoZlwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcInNldFN0eWxlQXR0cmlidXRlXCJdID0gXCJoZ1wiO1xufSkoSW5zdHJ1Y3Rpb25UeXBlIHx8IChJbnN0cnVjdGlvblR5cGUgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IElJbnN0cnVjdGlvbiA9IERJLmNyZWF0ZUludGVyZmFjZSgnSW5zdHJ1Y3Rpb24nKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0luc3RydWN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnR5cGU7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiB0eXBlLmxlbmd0aCA9PT0gMjtcbn1cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJmXCIgLyogaW50ZXJwb2xhdGlvbiAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIFByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgbW9kZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJyZ1wiIC8qIHByb3BlcnR5QmluZGluZyAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIEl0ZXJhdG9yQmluZGluZ0luc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJya1wiIC8qIGl0ZXJhdG9yQmluZGluZyAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJoXCIgLyogY2FsbEJpbmRpbmcgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBSZWZCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJqXCIgLyogcmVmQmluZGluZyAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIFNldFByb3BlcnR5SW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0bykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJlXCIgLyogc2V0UHJvcGVydHkgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBIeWRyYXRlRWxlbWVudEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZXMsIGFsaWFzLCBpbnN0cnVjdGlvbnMsIHNsb3RJbmZvKSB7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLnNsb3RJbmZvID0gc2xvdEluZm87XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJyYVwiIC8qIGh5ZHJhdGVFbGVtZW50ICovOyB9XG59XG5leHBvcnQgY2xhc3MgSHlkcmF0ZUF0dHJpYnV0ZUluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZXMsIGFsaWFzLCBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJyYlwiIC8qIGh5ZHJhdGVBdHRyaWJ1dGUgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZWYsIHJlcywgYWxpYXMsIGluc3RydWN0aW9ucykge1xuICAgICAgICB0aGlzLmRlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJyY1wiIC8qIGh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBIeWRyYXRlTGV0RWxlbWVudEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbnMsIHRvQmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgICAgIHRoaXMudG9CaW5kaW5nQ29udGV4dCA9IHRvQmluZGluZ0NvbnRleHQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJyZFwiIC8qIGh5ZHJhdGVMZXRFbGVtZW50ICovOyB9XG59XG5leHBvcnQgY2xhc3MgTGV0QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJyaVwiIC8qIGxldEJpbmRpbmcgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBUZXh0QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJoYVwiIC8qIHRleHRCaW5kaW5nICovOyB9XG59XG5leHBvcnQgY2xhc3MgTGlzdGVuZXJCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBwcmV2ZW50RGVmYXVsdCwgc3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcImhiXCIgLyogbGlzdGVuZXJCaW5kaW5nICovOyB9XG59XG5leHBvcnQgY2xhc3MgU3R5bGVQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIFwiaGRcIiAvKiBzdHlsZVByb3BlcnR5QmluZGluZyAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIFNldEF0dHJpYnV0ZUluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG8pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJoZVwiIC8qIHNldEF0dHJpYnV0ZSAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIFNldENsYXNzQXR0cmlidXRlSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJoZlwiIC8qIHNldENsYXNzQXR0cmlidXRlICovO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXRTdHlsZUF0dHJpYnV0ZUluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiaGdcIiAvKiBzZXRTdHlsZUF0dHJpYnV0ZSAqLztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBgYXR0cmAgYW5kIGB0b2AgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBvbiBhIG5vcm1hbCBhdHRyaWJ1dGVcbiAgICAgKiBXaWxsIGJlIGRpZmZlcmVudCBvbiBgY2xhc3NgIGFuZCBgc3R5bGVgXG4gICAgICogb24gYGNsYXNzYDogYXR0ciA9IGBjbGFzc2AgKGZyb20gYmluZGluZyBjb21tYW5kKSwgdG8gPSBhdHRyaWJ1dGUgbmFtZVxuICAgICAqIG9uIGBzdHlsZWA6IGF0dHIgPSBgc3R5bGVgIChmcm9tIGJpbmRpbmcgY29tbWFuZCksIHRvID0gYXR0cmlidXRlIG5hbWVcbiAgICAgKi9cbiAgICBhdHRyLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJoY1wiIC8qIGF0dHJpYnV0ZUJpbmRpbmcgKi87IH1cbn1cbmV4cG9ydCBjb25zdCBJVGVtcGxhdGVDb21waWxlciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVRlbXBsYXRlQ29tcGlsZXInKTtcbmV4cG9ydCBjb25zdCBJUmVuZGVyZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lSZW5kZXJlcicpO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcmVyKGluc3RydWN0aW9uVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICAgIC8vIHdyYXAgdGhlIGNvbnN0cnVjdG9yIHRvIHNldCB0aGUgaW5zdHJ1Y3Rpb25UeXBlIHRvIHRoZSBpbnN0YW5jZSAoZm9yIGJldHRlciBwZXJmb3JtYW5jZSB0aGFuIHdoZW4gc2V0IG9uIHRoZSBwcm90b3R5cGUpXG4gICAgICAgIGNvbnN0IGRlY29yYXRlZFRhcmdldCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyB0YXJnZXQoLi4uYXJncyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5pbnN0cnVjdGlvblR5cGUgPSBpbnN0cnVjdGlvblR5cGU7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSByZWdpc3RlciB0aGUgZGVjb3JhdGVkIGNvbnN0cnVjdG9yIHdpdGggRElcbiAgICAgICAgZGVjb3JhdGVkVGFyZ2V0LnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBSZWdpc3RyYXRpb24uc2luZ2xldG9uKElSZW5kZXJlciwgZGVjb3JhdGVkVGFyZ2V0KS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjb3B5IG92ZXIgYW55IG1ldGFkYXRhIHN1Y2ggYXMgYW5ub3RhdGlvbnMgKHNldCBieSBwcmVjZWRpbmcgZGVjb3JhdG9ycykgYXMgd2VsbCBhcyBzdGF0aWMgcHJvcGVydGllcyBzZXQgYnkgdGhlIHVzZXJcbiAgICAgICAgLy8gYWxzbyBjb3B5IHRoZSBuYW1lLCB0byBiZSBsZXNzIGNvbmZ1c2luZyB0byB1c2VycyAoc28gdGhleSBjYW4gc3RpbGwgdXNlIGNvbnN0cnVjdG9yLm5hbWUgZm9yIHdoYXRldmVyIHJlYXNvbilcbiAgICAgICAgLy8gdGhlIGxlbmd0aCAobnVtYmVyIG9mIGN0b3IgYXJndW1lbnRzKSBpcyBjb3BpZWQgZm9yIHRoZSBzYW1lIHJlYXNvblxuICAgICAgICBjb25zdCBtZXRhZGF0YUtleXMgPSBNZXRhZGF0YS5nZXRPd25LZXlzKHRhcmdldCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1ldGFkYXRhS2V5cykge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKGtleSwgTWV0YWRhdGEuZ2V0T3duKGtleSwgdGFyZ2V0KSwgZGVjb3JhdGVkVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvd25Qcm9wZXJ0aWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGFyZ2V0KTtcbiAgICAgICAgT2JqZWN0LmtleXMob3duUHJvcGVydGllcykuZmlsdGVyKHByb3AgPT4gcHJvcCAhPT0gJ3Byb3RvdHlwZScpLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRlY29yYXRlZFRhcmdldCwgcHJvcCwgb3duUHJvcGVydGllc1twcm9wXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVjb3JhdGVkVGFyZ2V0O1xuICAgIH07XG59XG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uKHBhcnNlciwgc3JjT3JFeHByLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygc3JjT3JFeHByID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyY09yRXhwciwgYmluZGluZ1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3JjT3JFeHByO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHBvdGVudGlhbFRhcmdldCkge1xuICAgIGlmIChwb3RlbnRpYWxUYXJnZXQudmlld01vZGVsICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBvdGVudGlhbFRhcmdldC52aWV3TW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBwb3RlbnRpYWxUYXJnZXQ7XG59XG5mdW5jdGlvbiBnZXRSZWZUYXJnZXQocmVmSG9zdCwgcmVmVGFyZ2V0TmFtZSkge1xuICAgIGlmIChyZWZUYXJnZXROYW1lID09PSAnZWxlbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIHJlZkhvc3Q7XG4gICAgfVxuICAgIHN3aXRjaCAocmVmVGFyZ2V0TmFtZSkge1xuICAgICAgICBjYXNlICdjb250cm9sbGVyJzpcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaXQgc3VwcG9ydHMgcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbUVsZW1lbnQuZm9yKHJlZkhvc3QpO1xuICAgICAgICBjYXNlICd2aWV3JzpcbiAgICAgICAgICAgIC8vIHRvZG86IHJldHVybnMgbm9kZSBzZXF1ZW5jZXMgZm9yIGZ1bj9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBBUEknKTtcbiAgICAgICAgY2FzZSAndmlldy1tb2RlbCc6XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGl0IHN1cHBvcnRzIHJldHVybmluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiBDdXN0b21FbGVtZW50LmZvcihyZWZIb3N0KS52aWV3TW9kZWw7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGNhQ29udHJvbGxlciA9IEN1c3RvbUF0dHJpYnV0ZS5mb3IocmVmSG9zdCwgcmVmVGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICBpZiAoY2FDb250cm9sbGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FDb250cm9sbGVyLnZpZXdNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNlQ29udHJvbGxlciA9IEN1c3RvbUVsZW1lbnQuZm9yKHJlZkhvc3QsIHsgbmFtZTogcmVmVGFyZ2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGlmIChjZUNvbnRyb2xsZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIHJlZmVyZW5jZSBcIiR7cmVmVGFyZ2V0TmFtZX1cIiwgYnV0IGl0IHdhcyBub3QgZm91bmQgYW1vbmdzdCB0aGUgdGFyZ2V0J3MgQVBJLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNlQ29udHJvbGxlci52aWV3TW9kZWw7XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgU2V0UHJvcGVydHlSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2V0UHJvcGVydHlSZW5kZXJlciB7XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAob2JqLiRvYnNlcnZlcnMgIT09IHZvaWQgMCAmJiBvYmouJG9ic2VydmVyc1tpbnN0cnVjdGlvbi50b10gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb2JqLiRvYnNlcnZlcnNbaW5zdHJ1Y3Rpb24udG9dLnNldFZhbHVlKGluc3RydWN0aW9uLnZhbHVlLCAzMiAvKiBmcm9tQmluZCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmpbaW5zdHJ1Y3Rpb24udG9dID0gaW5zdHJ1Y3Rpb24udmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuU2V0UHJvcGVydHlSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwicmVcIiAvKiBzZXRQcm9wZXJ0eSAqLylcbiAgICAvKiogQGludGVybmFsICovXG5dLCBTZXRQcm9wZXJ0eVJlbmRlcmVyKTtcbmV4cG9ydCB7IFNldFByb3BlcnR5UmVuZGVyZXIgfTtcbmxldCBDdXN0b21FbGVtZW50UmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIEN1c3RvbUVsZW1lbnRSZW5kZXJlciB7XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGxldCB2aWV3RmFjdG9yeTtcbiAgICAgICAgY29uc3Qgc2xvdEluZm8gPSBpbnN0cnVjdGlvbi5zbG90SW5mbztcbiAgICAgICAgaWYgKHNsb3RJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uQ3R4ID0gc2xvdEluZm8ucHJvamVjdGlvbkNvbnRleHQ7XG4gICAgICAgICAgICB2aWV3RmFjdG9yeSA9IGdldFJlbmRlckNvbnRleHQocHJvamVjdGlvbkN0eC5jb250ZW50LCBjb250ZXh0KS5nZXRWaWV3RmFjdG9yeSh2b2lkIDAsIHNsb3RJbmZvLnR5cGUsIHByb2plY3Rpb25DdHguc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSBjb250ZXh0LmdldENvbXBvbmVudEZhY3RvcnkoXG4gICAgICAgIC8qIHBhcmVudENvbnRyb2xsZXIgKi8gY29udHJvbGxlciwgXG4gICAgICAgIC8qIGhvc3QgICAgICAgICAgICAgKi8gdGFyZ2V0LCBcbiAgICAgICAgLyogaW5zdHJ1Y3Rpb24gICAgICAqLyBpbnN0cnVjdGlvbiwgXG4gICAgICAgIC8qIHZpZXdGYWN0b3J5ICAgICAgKi8gdmlld0ZhY3RvcnksIFxuICAgICAgICAvKiBsb2NhdGlvbiAgICAgICAgICovIHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGtleSA9IEN1c3RvbUVsZW1lbnQua2V5RnJvbShpbnN0cnVjdGlvbi5yZXMpO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmYWN0b3J5LmNyZWF0ZUNvbXBvbmVudChrZXkpO1xuICAgICAgICBjb25zdCBjaGlsZENvbnRyb2xsZXIgPSBDb250cm9sbGVyLmZvckN1c3RvbUVsZW1lbnQoXG4gICAgICAgIC8qIHJvb3QgICAgICAgICAgICAgICAgKi8gY29udHJvbGxlci5yb290LCBcbiAgICAgICAgLyogY29udGFpbmVyICAgICAgICAgICAqLyBjb250ZXh0LCBcbiAgICAgICAgLyogdmlld01vZGVsICAgICAgICAgICAqLyBjb21wb25lbnQsIFxuICAgICAgICAvKiBob3N0ICAgICAgICAgICAgICAgICovIHRhcmdldCwgXG4gICAgICAgIC8qIHRhcmdldGVkUHJvamVjdGlvbnMgKi8gY29udGV4dC5nZXRQcm9qZWN0aW9uRm9yKGluc3RydWN0aW9uKSwgXG4gICAgICAgIC8qIGZsYWdzICAgICAgICAgICAgICAgKi8gZmxhZ3MpO1xuICAgICAgICBmbGFncyA9IGNoaWxkQ29udHJvbGxlci5mbGFncztcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKGtleSwgY2hpbGRDb250cm9sbGVyLCB0YXJnZXQpO1xuICAgICAgICBjb250ZXh0LnJlbmRlckNoaWxkcmVuKFxuICAgICAgICAvKiBmbGFncyAgICAgICAgKi8gZmxhZ3MsIFxuICAgICAgICAvKiBpbnN0cnVjdGlvbnMgKi8gaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb25zLCBcbiAgICAgICAgLyogY29udHJvbGxlciAgICovIGNvbnRyb2xsZXIsIFxuICAgICAgICAvKiB0YXJnZXQgICAgICAgKi8gY2hpbGRDb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5hZGRDb250cm9sbGVyKGNoaWxkQ29udHJvbGxlcik7XG4gICAgICAgIGZhY3RvcnkuZGlzcG9zZSgpO1xuICAgIH1cbn07XG5DdXN0b21FbGVtZW50UmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcInJhXCIgLyogaHlkcmF0ZUVsZW1lbnQgKi8pXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuXSwgQ3VzdG9tRWxlbWVudFJlbmRlcmVyKTtcbmV4cG9ydCB7IEN1c3RvbUVsZW1lbnRSZW5kZXJlciB9O1xubGV0IEN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBDdXN0b21BdHRyaWJ1dGVSZW5kZXJlciB7XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSBjb250ZXh0LmdldENvbXBvbmVudEZhY3RvcnkoXG4gICAgICAgIC8qIHBhcmVudENvbnRyb2xsZXIgKi8gY29udHJvbGxlciwgXG4gICAgICAgIC8qIGhvc3QgICAgICAgICAgICAgKi8gdGFyZ2V0LCBcbiAgICAgICAgLyogaW5zdHJ1Y3Rpb24gICAgICAqLyBpbnN0cnVjdGlvbiwgXG4gICAgICAgIC8qIHZpZXdGYWN0b3J5ICAgICAgKi8gdm9pZCAwLCBcbiAgICAgICAgLyogbG9jYXRpb24gICAgICAgICAqLyB2b2lkIDApO1xuICAgICAgICBjb25zdCBrZXkgPSBDdXN0b21BdHRyaWJ1dGUua2V5RnJvbShpbnN0cnVjdGlvbi5yZXMpO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmYWN0b3J5LmNyZWF0ZUNvbXBvbmVudChrZXkpO1xuICAgICAgICBjb25zdCBjaGlsZENvbnRyb2xsZXIgPSBDb250cm9sbGVyLmZvckN1c3RvbUF0dHJpYnV0ZShcbiAgICAgICAgLyogcm9vdCAgICAgICovIGNvbnRyb2xsZXIucm9vdCwgXG4gICAgICAgIC8qIGNvbnRhaW5lciAqLyBjb250ZXh0LCBcbiAgICAgICAgLyogdmlld01vZGVsICovIGNvbXBvbmVudCwgXG4gICAgICAgIC8qIGhvc3QgICAgICAqLyB0YXJnZXQsIFxuICAgICAgICAvKiBmbGFncyAgICAgKi8gZmxhZ3MpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoa2V5LCBjaGlsZENvbnRyb2xsZXIsIHRhcmdldCk7XG4gICAgICAgIGNvbnRleHQucmVuZGVyQ2hpbGRyZW4oXG4gICAgICAgIC8qIGZsYWdzICAgICAgICAqLyBmbGFncywgXG4gICAgICAgIC8qIGluc3RydWN0aW9ucyAqLyBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbnMsIFxuICAgICAgICAvKiBjb250cm9sbGVyICAgKi8gY29udHJvbGxlciwgXG4gICAgICAgIC8qIHRhcmdldCAgICAgICAqLyBjaGlsZENvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLmFkZENvbnRyb2xsZXIoY2hpbGRDb250cm9sbGVyKTtcbiAgICAgICAgZmFjdG9yeS5kaXNwb3NlKCk7XG4gICAgfVxufTtcbkN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJyYlwiIC8qIGh5ZHJhdGVBdHRyaWJ1dGUgKi8pXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuXSwgQ3VzdG9tQXR0cmlidXRlUmVuZGVyZXIpO1xuZXhwb3J0IHsgQ3VzdG9tQXR0cmlidXRlUmVuZGVyZXIgfTtcbmxldCBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgVGVtcGxhdGVDb250cm9sbGVyUmVuZGVyZXIge1xuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCB2aWV3RmFjdG9yeSA9IGdldFJlbmRlckNvbnRleHQoaW5zdHJ1Y3Rpb24uZGVmLCBjb250ZXh0KS5nZXRWaWV3RmFjdG9yeSgpO1xuICAgICAgICBjb25zdCByZW5kZXJMb2NhdGlvbiA9IGNvbnZlcnRUb1JlbmRlckxvY2F0aW9uKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEZhY3RvcnkgPSBjb250ZXh0LmdldENvbXBvbmVudEZhY3RvcnkoXG4gICAgICAgIC8qIHBhcmVudENvbnRyb2xsZXIgKi8gY29udHJvbGxlciwgXG4gICAgICAgIC8qIGhvc3QgICAgICAgICAgICAgKi8gdGFyZ2V0LCBcbiAgICAgICAgLyogaW5zdHJ1Y3Rpb24gICAgICAqLyBpbnN0cnVjdGlvbiwgXG4gICAgICAgIC8qIHZpZXdGYWN0b3J5ICAgICAgKi8gdmlld0ZhY3RvcnksIFxuICAgICAgICAvKiBsb2NhdGlvbiAgICAgICAgICovIHJlbmRlckxvY2F0aW9uKTtcbiAgICAgICAgY29uc3Qga2V5ID0gQ3VzdG9tQXR0cmlidXRlLmtleUZyb20oaW5zdHJ1Y3Rpb24ucmVzKTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGVDb21wb25lbnQoa2V5KTtcbiAgICAgICAgY29uc3QgY2hpbGRDb250cm9sbGVyID0gQ29udHJvbGxlci5mb3JDdXN0b21BdHRyaWJ1dGUoXG4gICAgICAgIC8qIHJvb3QgICAgICAqLyBjb250cm9sbGVyLnJvb3QsIFxuICAgICAgICAvKiBjb250YWluZXIgKi8gY29udGV4dCwgXG4gICAgICAgIC8qIHZpZXdNb2RlbCAqLyBjb21wb25lbnQsIFxuICAgICAgICAvKiBob3N0ICAgICAgKi8gdGFyZ2V0LCBcbiAgICAgICAgLyogZmxhZ3MgICAgICovIGZsYWdzKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKGtleSwgY2hpbGRDb250cm9sbGVyLCByZW5kZXJMb2NhdGlvbik7XG4gICAgICAgIGNvbXBvbmVudC5saW5rPy4oZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIGNoaWxkQ29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbik7XG4gICAgICAgIGNvbnRleHQucmVuZGVyQ2hpbGRyZW4oXG4gICAgICAgIC8qIGZsYWdzICAgICAgICAqLyBmbGFncywgXG4gICAgICAgIC8qIGluc3RydWN0aW9ucyAqLyBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbnMsIFxuICAgICAgICAvKiBjb250cm9sbGVyICAgKi8gY29udHJvbGxlciwgXG4gICAgICAgIC8qIHRhcmdldCAgICAgICAqLyBjaGlsZENvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLmFkZENvbnRyb2xsZXIoY2hpbGRDb250cm9sbGVyKTtcbiAgICAgICAgY29tcG9uZW50RmFjdG9yeS5kaXNwb3NlKCk7XG4gICAgfVxufTtcblRlbXBsYXRlQ29udHJvbGxlclJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJyY1wiIC8qIGh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIgKi8pXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuXSwgVGVtcGxhdGVDb250cm9sbGVyUmVuZGVyZXIpO1xuZXhwb3J0IHsgVGVtcGxhdGVDb250cm9sbGVyUmVuZGVyZXIgfTtcbmxldCBMZXRFbGVtZW50UmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIExldEVsZW1lbnRSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBvYnNlcnZlckxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgIH1cbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICBjb25zdCBjaGlsZEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9uLmluc3RydWN0aW9ucztcbiAgICAgICAgY29uc3QgdG9CaW5kaW5nQ29udGV4dCA9IGluc3RydWN0aW9uLnRvQmluZGluZ0NvbnRleHQ7XG4gICAgICAgIGxldCBjaGlsZEluc3RydWN0aW9uO1xuICAgICAgICBsZXQgZXhwcjtcbiAgICAgICAgbGV0IGJpbmRpbmc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkSW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb24gPSBjaGlsZEluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgIGV4cHIgPSBlbnN1cmVFeHByZXNzaW9uKHRoaXMucGFyc2VyLCBjaGlsZEluc3RydWN0aW9uLmZyb20sIDQ4IC8qIElzUHJvcGVydHlDb21tYW5kICovKTtcbiAgICAgICAgICAgIGJpbmRpbmcgPSBhcHBseUJpbmRpbmdCZWhhdmlvcihuZXcgTGV0QmluZGluZyhleHByLCBjaGlsZEluc3RydWN0aW9uLnRvLCB0aGlzLm9ic2VydmVyTG9jYXRvciwgY29udGV4dCwgdG9CaW5kaW5nQ29udGV4dCksIGV4cHIsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkxldEVsZW1lbnRSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwicmRcIiAvKiBoeWRyYXRlTGV0RWxlbWVudCAqLylcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLFxuICAgIF9fcGFyYW0oMCwgSUV4cHJlc3Npb25QYXJzZXIpLFxuICAgIF9fcGFyYW0oMSwgSU9ic2VydmVyTG9jYXRvcilcbl0sIExldEVsZW1lbnRSZW5kZXJlcik7XG5leHBvcnQgeyBMZXRFbGVtZW50UmVuZGVyZXIgfTtcbmxldCBDYWxsQmluZGluZ1JlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBDYWxsQmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgMTUzIC8qIENhbGxDb21tYW5kICovKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKG5ldyBDYWxsQmluZGluZyhleHByLCBnZXRUYXJnZXQodGFyZ2V0KSwgaW5zdHJ1Y3Rpb24udG8sIHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCBjb250ZXh0KSwgZXhwciwgY29udGV4dCk7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICB9XG59O1xuQ2FsbEJpbmRpbmdSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwicmhcIiAvKiBjYWxsQmluZGluZyAqLylcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLFxuICAgIF9fcGFyYW0oMCwgSUV4cHJlc3Npb25QYXJzZXIpLFxuICAgIF9fcGFyYW0oMSwgSU9ic2VydmVyTG9jYXRvcilcbl0sIENhbGxCaW5kaW5nUmVuZGVyZXIpO1xuZXhwb3J0IHsgQ2FsbEJpbmRpbmdSZW5kZXJlciB9O1xubGV0IFJlZkJpbmRpbmdSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUmVmQmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgNTM3NiAvKiBJc1JlZiAqLyk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBhcHBseUJpbmRpbmdCZWhhdmlvcihuZXcgUmVmQmluZGluZyhleHByLCBnZXRSZWZUYXJnZXQodGFyZ2V0LCBpbnN0cnVjdGlvbi50byksIGNvbnRleHQpLCBleHByLCBjb250ZXh0KTtcbiAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbn07XG5SZWZCaW5kaW5nUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcInJqXCIgLyogcmVmQmluZGluZyAqLylcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLFxuICAgIF9fcGFyYW0oMCwgSUV4cHJlc3Npb25QYXJzZXIpXG5dLCBSZWZCaW5kaW5nUmVuZGVyZXIpO1xuZXhwb3J0IHsgUmVmQmluZGluZ1JlbmRlcmVyIH07XG5sZXQgSW50ZXJwb2xhdGlvbkJpbmRpbmdSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgSW50ZXJwb2xhdGlvbkJpbmRpbmdSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBvYnNlcnZlckxvY2F0b3IsIHBsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIH1cbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXhwciA9IGVuc3VyZUV4cHJlc3Npb24odGhpcy5wYXJzZXIsIGluc3RydWN0aW9uLmZyb20sIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBuZXcgSW50ZXJwb2xhdGlvbkJpbmRpbmcodGhpcy5vYnNlcnZlckxvY2F0b3IsIGV4cHIsIGdldFRhcmdldCh0YXJnZXQpLCBpbnN0cnVjdGlvbi50bywgQmluZGluZ01vZGUudG9WaWV3LCBjb250ZXh0LCB0aGlzLnBsYXRmb3JtLmRvbVdyaXRlUXVldWUpO1xuICAgICAgICBjb25zdCBwYXJ0QmluZGluZ3MgPSBiaW5kaW5nLnBhcnRCaW5kaW5ncztcbiAgICAgICAgbGV0IHBhcnRCaW5kaW5nO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJ0QmluZGluZ3MubGVuZ3RoOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAgICAgcGFydEJpbmRpbmcgPSBwYXJ0QmluZGluZ3NbaV07XG4gICAgICAgICAgICBwYXJ0QmluZGluZ3NbaV0gPSBhcHBseUJpbmRpbmdCZWhhdmlvcihwYXJ0QmluZGluZywgcGFydEJpbmRpbmcuc291cmNlRXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbn07XG5JbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJyZlwiIC8qIGludGVycG9sYXRpb24gKi8pXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICxcbiAgICBfX3BhcmFtKDAsIElFeHByZXNzaW9uUGFyc2VyKSxcbiAgICBfX3BhcmFtKDEsIElPYnNlcnZlckxvY2F0b3IpLFxuICAgIF9fcGFyYW0oMiwgSVBsYXRmb3JtKVxuXSwgSW50ZXJwb2xhdGlvbkJpbmRpbmdSZW5kZXJlcik7XG5leHBvcnQgeyBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyIH07XG5sZXQgUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFByb3BlcnR5QmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvciwgcGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgNDggLyogSXNQcm9wZXJ0eUNvbW1hbmQgKi8gfCBpbnN0cnVjdGlvbi5tb2RlKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKG5ldyBQcm9wZXJ0eUJpbmRpbmcoZXhwciwgZ2V0VGFyZ2V0KHRhcmdldCksIGluc3RydWN0aW9uLnRvLCBpbnN0cnVjdGlvbi5tb2RlLCB0aGlzLm9ic2VydmVyTG9jYXRvciwgY29udGV4dCwgdGhpcy5wbGF0Zm9ybS5kb21Xcml0ZVF1ZXVlKSwgZXhwciwgY29udGV4dCk7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICB9XG59O1xuUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcInJnXCIgLyogcHJvcGVydHlCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJT2JzZXJ2ZXJMb2NhdG9yKSxcbiAgICBfX3BhcmFtKDIsIElQbGF0Zm9ybSlcbl0sIFByb3BlcnR5QmluZGluZ1JlbmRlcmVyKTtcbmV4cG9ydCB7IFByb3BlcnR5QmluZGluZ1JlbmRlcmVyIH07XG5sZXQgSXRlcmF0b3JCaW5kaW5nUmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvciwgcGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgNTM5IC8qIEZvckNvbW1hbmQgKi8pO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gYXBwbHlCaW5kaW5nQmVoYXZpb3IobmV3IFByb3BlcnR5QmluZGluZyhleHByLCBnZXRUYXJnZXQodGFyZ2V0KSwgaW5zdHJ1Y3Rpb24udG8sIEJpbmRpbmdNb2RlLnRvVmlldywgdGhpcy5vYnNlcnZlckxvY2F0b3IsIGNvbnRleHQsIHRoaXMucGxhdGZvcm0uZG9tV3JpdGVRdWV1ZSksIGV4cHIsIGNvbnRleHQpO1xuICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgfVxufTtcbkl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJya1wiIC8qIGl0ZXJhdG9yQmluZGluZyAqLylcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLFxuICAgIF9fcGFyYW0oMCwgSUV4cHJlc3Npb25QYXJzZXIpLFxuICAgIF9fcGFyYW0oMSwgSU9ic2VydmVyTG9jYXRvciksXG4gICAgX19wYXJhbSgyLCBJUGxhdGZvcm0pXG5dLCBJdGVyYXRvckJpbmRpbmdSZW5kZXJlcik7XG5leHBvcnQgeyBJdGVyYXRvckJpbmRpbmdSZW5kZXJlciB9O1xubGV0IGJlaGF2aW9yRXhwcmVzc2lvbkluZGV4ID0gMDtcbmNvbnN0IGJlaGF2aW9yRXhwcmVzc2lvbnMgPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUJpbmRpbmdCZWhhdmlvcihiaW5kaW5nLCBleHByZXNzaW9uLCBsb2NhdG9yKSB7XG4gICAgd2hpbGUgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uKSB7XG4gICAgICAgIGJlaGF2aW9yRXhwcmVzc2lvbnNbYmVoYXZpb3JFeHByZXNzaW9uSW5kZXgrK10gPSBleHByZXNzaW9uO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5leHByZXNzaW9uO1xuICAgIH1cbiAgICB3aGlsZSAoYmVoYXZpb3JFeHByZXNzaW9uSW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IGJlaGF2aW9yRXhwcmVzc2lvbiA9IGJlaGF2aW9yRXhwcmVzc2lvbnNbLS1iZWhhdmlvckV4cHJlc3Npb25JbmRleF07XG4gICAgICAgIGNvbnN0IGJlaGF2aW9yT3JGYWN0b3J5ID0gbG9jYXRvci5nZXQoYmVoYXZpb3JFeHByZXNzaW9uLmJlaGF2aW9yS2V5KTtcbiAgICAgICAgaWYgKGJlaGF2aW9yT3JGYWN0b3J5IGluc3RhbmNlb2YgQmluZGluZ0JlaGF2aW9yRmFjdG9yeSkge1xuICAgICAgICAgICAgYmluZGluZyA9IGJlaGF2aW9yT3JGYWN0b3J5LmNvbnN0cnVjdChiaW5kaW5nLCBiZWhhdmlvckV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJlaGF2aW9yRXhwcmVzc2lvbnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gYmluZGluZztcbn1cbmxldCBUZXh0QmluZGluZ1JlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBUZXh0QmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvciwgcGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnQVUtTScpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IG5ldyBJbnRlcnBvbGF0aW9uQmluZGluZyh0aGlzLm9ic2VydmVyTG9jYXRvciwgZXhwciwgbmV4dCwgJ3RleHRDb250ZW50JywgQmluZGluZ01vZGUudG9WaWV3LCBjb250ZXh0LCB0aGlzLnBsYXRmb3JtLmRvbVdyaXRlUXVldWUpO1xuICAgICAgICBjb25zdCBwYXJ0QmluZGluZ3MgPSBiaW5kaW5nLnBhcnRCaW5kaW5ncztcbiAgICAgICAgbGV0IHBhcnRCaW5kaW5nO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJ0QmluZGluZ3MubGVuZ3RoOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAgICAgcGFydEJpbmRpbmcgPSBwYXJ0QmluZGluZ3NbaV07XG4gICAgICAgICAgICBwYXJ0QmluZGluZ3NbaV0gPSBhcHBseUJpbmRpbmdCZWhhdmlvcihwYXJ0QmluZGluZywgcGFydEJpbmRpbmcuc291cmNlRXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbn07XG5UZXh0QmluZGluZ1JlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJoYVwiIC8qIHRleHRCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJT2JzZXJ2ZXJMb2NhdG9yKSxcbiAgICBfX3BhcmFtKDIsIElQbGF0Zm9ybSlcbl0sIFRleHRCaW5kaW5nUmVuZGVyZXIpO1xuZXhwb3J0IHsgVGV4dEJpbmRpbmdSZW5kZXJlciB9O1xubGV0IExpc3RlbmVyQmluZGluZ1JlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBMaXN0ZW5lckJpbmRpbmdSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBldmVudERlbGVnYXRvcikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5ldmVudERlbGVnYXRvciA9IGV2ZW50RGVsZWdhdG9yO1xuICAgIH1cbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXhwciA9IGVuc3VyZUV4cHJlc3Npb24odGhpcy5wYXJzZXIsIGluc3RydWN0aW9uLmZyb20sIDgwIC8qIElzRXZlbnRDb21tYW5kICovIHwgKGluc3RydWN0aW9uLnN0cmF0ZWd5ICsgNiAvKiBEZWxlZ2F0aW9uU3RyYXRlZ3lEZWx0YSAqLykpO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gYXBwbHlCaW5kaW5nQmVoYXZpb3IobmV3IExpc3RlbmVyKGNvbnRleHQucGxhdGZvcm0sIGluc3RydWN0aW9uLnRvLCBpbnN0cnVjdGlvbi5zdHJhdGVneSwgZXhwciwgdGFyZ2V0LCBpbnN0cnVjdGlvbi5wcmV2ZW50RGVmYXVsdCwgdGhpcy5ldmVudERlbGVnYXRvciwgY29udGV4dCksIGV4cHIsIGNvbnRleHQpO1xuICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgfVxufTtcbkxpc3RlbmVyQmluZGluZ1JlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJoYlwiIC8qIGxpc3RlbmVyQmluZGluZyAqLylcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLFxuICAgIF9fcGFyYW0oMCwgSUV4cHJlc3Npb25QYXJzZXIpLFxuICAgIF9fcGFyYW0oMSwgSUV2ZW50RGVsZWdhdG9yKVxuXSwgTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXIpO1xuZXhwb3J0IHsgTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXIgfTtcbmxldCBTZXRBdHRyaWJ1dGVSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2V0QXR0cmlidXRlUmVuZGVyZXIge1xuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKGluc3RydWN0aW9uLnRvLCBpbnN0cnVjdGlvbi52YWx1ZSk7XG4gICAgfVxufTtcblNldEF0dHJpYnV0ZVJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJoZVwiIC8qIHNldEF0dHJpYnV0ZSAqLylcbiAgICAvKiogQGludGVybmFsICovXG5dLCBTZXRBdHRyaWJ1dGVSZW5kZXJlcik7XG5leHBvcnQgeyBTZXRBdHRyaWJ1dGVSZW5kZXJlciB9O1xubGV0IFNldENsYXNzQXR0cmlidXRlUmVuZGVyZXIgPSBjbGFzcyBTZXRDbGFzc0F0dHJpYnV0ZVJlbmRlcmVyIHtcbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgYWRkQ2xhc3Nlcyh0YXJnZXQuY2xhc3NMaXN0LCBpbnN0cnVjdGlvbi52YWx1ZSk7XG4gICAgfVxufTtcblNldENsYXNzQXR0cmlidXRlUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcImhmXCIgLyogc2V0Q2xhc3NBdHRyaWJ1dGUgKi8pXG5dLCBTZXRDbGFzc0F0dHJpYnV0ZVJlbmRlcmVyKTtcbmV4cG9ydCB7IFNldENsYXNzQXR0cmlidXRlUmVuZGVyZXIgfTtcbmxldCBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyID0gY2xhc3MgU2V0U3R5bGVBdHRyaWJ1dGVSZW5kZXJlciB7XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IGluc3RydWN0aW9uLnZhbHVlO1xuICAgIH1cbn07XG5TZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJoZ1wiIC8qIHNldFN0eWxlQXR0cmlidXRlICovKVxuXSwgU2V0U3R5bGVBdHRyaWJ1dGVSZW5kZXJlcik7XG5leHBvcnQgeyBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyIH07XG5sZXQgU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBvYnNlcnZlckxvY2F0b3IsIHBsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIH1cbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXhwciA9IGVuc3VyZUV4cHJlc3Npb24odGhpcy5wYXJzZXIsIGluc3RydWN0aW9uLmZyb20sIDQ4IC8qIElzUHJvcGVydHlDb21tYW5kICovIHwgQmluZGluZ01vZGUudG9WaWV3KTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKG5ldyBQcm9wZXJ0eUJpbmRpbmcoZXhwciwgdGFyZ2V0LnN0eWxlLCBpbnN0cnVjdGlvbi50bywgQmluZGluZ01vZGUudG9WaWV3LCB0aGlzLm9ic2VydmVyTG9jYXRvciwgY29udGV4dCwgdGhpcy5wbGF0Zm9ybS5kb21Xcml0ZVF1ZXVlKSwgZXhwciwgY29udGV4dCk7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICB9XG59O1xuU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwiaGRcIiAvKiBzdHlsZVByb3BlcnR5QmluZGluZyAqLylcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLFxuICAgIF9fcGFyYW0oMCwgSUV4cHJlc3Npb25QYXJzZXIpLFxuICAgIF9fcGFyYW0oMSwgSU9ic2VydmVyTG9jYXRvciksXG4gICAgX19wYXJhbSgyLCBJUGxhdGZvcm0pXG5dLCBTdHlsZVByb3BlcnR5QmluZGluZ1JlbmRlcmVyKTtcbmV4cG9ydCB7IFN0eWxlUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIgfTtcbmxldCBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIEF0dHJpYnV0ZUJpbmRpbmdSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBvYnNlcnZlckxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgIH1cbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXhwciA9IGVuc3VyZUV4cHJlc3Npb24odGhpcy5wYXJzZXIsIGluc3RydWN0aW9uLmZyb20sIDQ4IC8qIElzUHJvcGVydHlDb21tYW5kICovIHwgQmluZGluZ01vZGUudG9WaWV3KTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKG5ldyBBdHRyaWJ1dGVCaW5kaW5nKGV4cHIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24uYXR0ciAvKiB0YXJnZXRBdHRyaWJ1dGUgKi8sIGluc3RydWN0aW9uLnRvIC8qIHRhcmdldEtleSAqLywgQmluZGluZ01vZGUudG9WaWV3LCB0aGlzLm9ic2VydmVyTG9jYXRvciwgY29udGV4dCksIGV4cHIsIGNvbnRleHQpO1xuICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgfVxufTtcbkF0dHJpYnV0ZUJpbmRpbmdSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwiaGNcIiAvKiBhdHRyaWJ1dGVCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJT2JzZXJ2ZXJMb2NhdG9yKVxuXSwgQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyKTtcbmV4cG9ydCB7IEF0dHJpYnV0ZUJpbmRpbmdSZW5kZXJlciB9O1xuLy8gaHR0cDovL2pzYmVuLmNoLzduNUt0XG5mdW5jdGlvbiBhZGRDbGFzc2VzKGNsYXNzTGlzdCwgY2xhc3NOYW1lKSB7XG4gICAgY29uc3QgbGVuID0gY2xhc3NOYW1lLmxlbmd0aDtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNsYXNzTmFtZS5jaGFyQ29kZUF0KGkpID09PSAweDIwKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5zbGljZShzdGFydCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpICsgMSA9PT0gbGVuKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5zbGljZShzdGFydCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyZXIuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBESSwgTWV0YWRhdGEsIGVtcHR5QXJyYXksIFByb3RvY29sLCBSZWdpc3RyYXRpb24sIGFsbCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgQ2hhclNwZWMge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJzLCByZXBlYXQsIGlzU3ltYm9sLCBpc0ludmVydGVkKSB7XG4gICAgICAgIHRoaXMuY2hhcnMgPSBjaGFycztcbiAgICAgICAgdGhpcy5yZXBlYXQgPSByZXBlYXQ7XG4gICAgICAgIHRoaXMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICAgICAgdGhpcy5pc0ludmVydGVkID0gaXNJbnZlcnRlZDtcbiAgICAgICAgaWYgKGlzSW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhcyA9IHRoaXMuaGFzT2ZOb25lSW52ZXJzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhcyA9IHRoaXMuaGFzT2ZTaW5nbGVJbnZlcnNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhcyA9IHRoaXMuaGFzT2ZNdWx0aXBsZUludmVyc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXMgPSB0aGlzLmhhc09mTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhcyA9IHRoaXMuaGFzT2ZTaW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzID0gdGhpcy5oYXNPZk11bHRpcGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFycyA9PT0gb3RoZXIuY2hhcnNcbiAgICAgICAgICAgICYmIHRoaXMucmVwZWF0ID09PSBvdGhlci5yZXBlYXRcbiAgICAgICAgICAgICYmIHRoaXMuaXNTeW1ib2wgPT09IG90aGVyLmlzU3ltYm9sXG4gICAgICAgICAgICAmJiB0aGlzLmlzSW52ZXJ0ZWQgPT09IG90aGVyLmlzSW52ZXJ0ZWQ7XG4gICAgfVxuICAgIGhhc09mTXVsdGlwbGUoY2hhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFycy5pbmNsdWRlcyhjaGFyKTtcbiAgICB9XG4gICAgaGFzT2ZTaW5nbGUoY2hhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFycyA9PT0gY2hhcjtcbiAgICB9XG4gICAgaGFzT2ZOb25lKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNPZk11bHRpcGxlSW52ZXJzZShjaGFyKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jaGFycy5pbmNsdWRlcyhjaGFyKTtcbiAgICB9XG4gICAgaGFzT2ZTaW5nbGVJbnZlcnNlKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnMgIT09IGNoYXI7XG4gICAgfVxuICAgIGhhc09mTm9uZUludmVyc2UoY2hhcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW50ZXJwcmV0YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcnRzID0gZW1wdHlBcnJheTtcbiAgICAgICAgdGhpcy5fcGF0dGVybiA9ICcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZWNvcmQgPSB7fTtcbiAgICAgICAgdGhpcy5wYXJ0c1JlY29yZCA9IHt9O1xuICAgIH1cbiAgICBnZXQgcGF0dGVybigpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9wYXR0ZXJuO1xuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgcGF0dGVybih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGF0dGVybiA9ICcnO1xuICAgICAgICAgICAgdGhpcy5wYXJ0cyA9IGVtcHR5QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXR0ZXJuID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBhcnRzID0gdGhpcy5wYXJ0c1JlY29yZFt2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kKHBhdHRlcm4sIGNoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFJlY29yZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN1cnJlbnRSZWNvcmRbcGF0dGVybl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudFJlY29yZFtwYXR0ZXJuXSA9IGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFJlY29yZFtwYXR0ZXJuXSArPSBjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KHBhdHRlcm4pIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50UmVjb3JkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoY3VycmVudFJlY29yZFtwYXR0ZXJuXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBhcnRzUmVjb3JkIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBhcnRzUmVjb3JkW3BhdHRlcm5dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1JlY29yZFtwYXR0ZXJuXSA9IFtjdXJyZW50UmVjb3JkW3BhdHRlcm5dXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzUmVjb3JkW3BhdHRlcm5dLnB1c2goY3VycmVudFJlY29yZFtwYXR0ZXJuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50UmVjb3JkW3BhdHRlcm5dID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFyU3BlYywgLi4ucGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy5jaGFyU3BlYyA9IGNoYXJTcGVjO1xuICAgICAgICB0aGlzLm5leHRTdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy50eXBlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNFbmRwb2ludCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgfVxuICAgIGdldCBwYXR0ZXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuZHBvaW50ID8gdGhpcy5wYXR0ZXJuc1swXSA6IG51bGw7XG4gICAgfVxuICAgIGZpbmRDaGlsZChjaGFyU3BlYykge1xuICAgICAgICBjb25zdCBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzO1xuICAgICAgICBjb25zdCBsZW4gPSBuZXh0U3RhdGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IGNoaWxkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY2hpbGQgPSBuZXh0U3RhdGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoYXJTcGVjLmVxdWFscyhjaGlsZC5jaGFyU3BlYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFwcGVuZChjaGFyU3BlYywgcGF0dGVybikge1xuICAgICAgICBjb25zdCB7IHBhdHRlcm5zIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXBhdHRlcm5zLmluY2x1ZGVzKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICBwYXR0ZXJucy5wdXNoKHBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZmluZENoaWxkKGNoYXJTcGVjKTtcbiAgICAgICAgaWYgKHN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKGNoYXJTcGVjLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChjaGFyU3BlYy5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZmluZE1hdGNoZXMoY2gsIGludGVycHJldGF0aW9uKSB7XG4gICAgICAgIC8vIFRPRE86IHJldXNlIHByZWFsbG9jYXRlZCBhcnJheXNcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzO1xuICAgICAgICBjb25zdCBsZW4gPSBuZXh0U3RhdGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IGNoaWxkTGVuID0gMDtcbiAgICAgICAgbGV0IGNoaWxkID0gbnVsbDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNoaWxkID0gbmV4dFN0YXRlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5jaGFyU3BlYy5oYXMoY2gpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZExlbiA9IGNoaWxkLnBhdHRlcm5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hhclNwZWMuaXNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGogPCBjaGlsZExlbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRhdGlvbi5uZXh0KGNoaWxkLnBhdHRlcm5zW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGogPCBjaGlsZExlbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRhdGlvbi5hcHBlbmQoY2hpbGQucGF0dGVybnNbal0sIGNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU3RhdGljU2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICBjb25zdCBzcGVjcyA9IHRoaXMuc3BlY3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgc3BlY3MucHVzaChuZXcgQ2hhclNwZWModGV4dFtpXSwgZmFsc2UsIGZhbHNlLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgbGVuLCBzcGVjcyB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY2FsbGJhY2soc3BlY3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzeW1ib2xzKSB7XG4gICAgICAgIHRoaXMudGV4dCA9ICdQQVJUJztcbiAgICAgICAgdGhpcy5zcGVjID0gbmV3IENoYXJTcGVjKHN5bWJvbHMsIHRydWUsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5zcGVjKTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU3ltYm9sU2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnNwZWMgPSBuZXcgQ2hhclNwZWModGV4dCwgZmFsc2UsIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5zcGVjKTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU2VnbWVudFR5cGVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGF0aWNzID0gMDtcbiAgICAgICAgdGhpcy5keW5hbWljcyA9IDA7XG4gICAgICAgIHRoaXMuc3ltYm9scyA9IDA7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElTeW50YXhJbnRlcnByZXRlciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVN5bnRheEludGVycHJldGVyJywgeCA9PiB4LnNpbmdsZXRvbihTeW50YXhJbnRlcnByZXRlcikpO1xuZXhwb3J0IGNsYXNzIFN5bnRheEludGVycHJldGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yb290U3RhdGUgPSBuZXcgU3RhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFN0YXRlcyA9IFt0aGlzLnJvb3RTdGF0ZV07XG4gICAgfVxuICAgIGFkZChkZWZPckRlZnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZPckRlZnMpKSB7XG4gICAgICAgICAgICBjb25zdCBpaSA9IGRlZk9yRGVmcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChkZWZPckRlZnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSB0aGlzLnJvb3RTdGF0ZTtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmT3JEZWZzO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gZGVmLnBhdHRlcm47XG4gICAgICAgIGNvbnN0IHR5cGVzID0gbmV3IFNlZ21lbnRUeXBlcygpO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMucGFyc2UoZGVmLCB0eXBlcyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoY2gpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5hcHBlbmQoY2gsIHBhdHRlcm4pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHNlZ21lbnRzW2ldLmVhY2hDaGFyKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50U3RhdGUudHlwZXMgPSB0eXBlcztcbiAgICAgICAgY3VycmVudFN0YXRlLmlzRW5kcG9pbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpbnRlcnByZXQobmFtZSkge1xuICAgICAgICBjb25zdCBpbnRlcnByZXRhdGlvbiA9IG5ldyBJbnRlcnByZXRhdGlvbigpO1xuICAgICAgICBsZXQgc3RhdGVzID0gdGhpcy5pbml0aWFsU3RhdGVzO1xuICAgICAgICBjb25zdCBsZW4gPSBuYW1lLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgc3RhdGVzID0gdGhpcy5nZXROZXh0U3RhdGVzKHN0YXRlcywgbmFtZS5jaGFyQXQoaSksIGludGVycHJldGF0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLmlzRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWIuaXNFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pc0VuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFUeXBlcyA9IGEudHlwZXM7XG4gICAgICAgICAgICBjb25zdCBiVHlwZXMgPSBiLnR5cGVzO1xuICAgICAgICAgICAgaWYgKGFUeXBlcy5zdGF0aWNzICE9PSBiVHlwZXMuc3RhdGljcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBiVHlwZXMuc3RhdGljcyAtIGFUeXBlcy5zdGF0aWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFUeXBlcy5keW5hbWljcyAhPT0gYlR5cGVzLmR5bmFtaWNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJUeXBlcy5keW5hbWljcyAtIGFUeXBlcy5keW5hbWljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhVHlwZXMuc3ltYm9scyAhPT0gYlR5cGVzLnN5bWJvbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYlR5cGVzLnN5bWJvbHMgLSBhVHlwZXMuc3ltYm9scztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0YXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlc1swXTtcbiAgICAgICAgICAgIGlmICghc3RhdGUuY2hhclNwZWMuaXNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnByZXRhdGlvbi5uZXh0KHN0YXRlLnBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJwcmV0YXRpb24ucGF0dGVybiA9IHN0YXRlLnBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVycHJldGF0aW9uO1xuICAgIH1cbiAgICBnZXROZXh0U3RhdGVzKHN0YXRlcywgY2gsIGludGVycHJldGF0aW9uKSB7XG4gICAgICAgIC8vIFRPRE86IHJldXNlIHByZWFsbG9jYXRlZCBhcnJheXNcbiAgICAgICAgY29uc3QgbmV4dFN0YXRlcyA9IFtdO1xuICAgICAgICBsZXQgc3RhdGUgPSBudWxsO1xuICAgICAgICBjb25zdCBsZW4gPSBzdGF0ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICAgICAgICAgIG5leHRTdGF0ZXMucHVzaCguLi5zdGF0ZS5maW5kTWF0Y2hlcyhjaCwgaW50ZXJwcmV0YXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFN0YXRlcztcbiAgICB9XG4gICAgcGFyc2UoZGVmLCB0eXBlcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGRlZi5wYXR0ZXJuO1xuICAgICAgICBjb25zdCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgYyA9ICcnO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgYyA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKCFkZWYuc3ltYm9scy5pbmNsdWRlcyhjKSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ1AnICYmIHBhdHRlcm4uc2xpY2UoaSwgaSArIDQpID09PSAnUEFSVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSA9IChpICsgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRHluYW1pY1NlZ21lbnQoZGVmLnN5bWJvbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrdHlwZXMuZHluYW1pY3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpICE9PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGF0aWNTZWdtZW50KHBhdHRlcm4uc2xpY2Uoc3RhcnQsIGkpKSk7XG4gICAgICAgICAgICAgICAgKyt0eXBlcy5zdGF0aWNzO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTeW1ib2xTZWdtZW50KHBhdHRlcm4uc2xpY2Uoc3RhcnQsIGkgKyAxKSkpO1xuICAgICAgICAgICAgICAgICsrdHlwZXMuc3ltYm9scztcbiAgICAgICAgICAgICAgICBzdGFydCA9ICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgIT09IGkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGF0aWNTZWdtZW50KHBhdHRlcm4uc2xpY2Uoc3RhcnQsIGkpKSk7XG4gICAgICAgICAgICArK3R5cGVzLnN0YXRpY3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXR0clN5bnRheCB7XG4gICAgY29uc3RydWN0b3IocmF3TmFtZSwgcmF3VmFsdWUsIHRhcmdldCwgY29tbWFuZCkge1xuICAgICAgICB0aGlzLnJhd05hbWUgPSByYXdOYW1lO1xuICAgICAgICB0aGlzLnJhd1ZhbHVlID0gcmF3VmFsdWU7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJQXR0cmlidXRlUGF0dGVybiA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUF0dHJpYnV0ZVBhdHRlcm4nKTtcbmV4cG9ydCBjb25zdCBJQXR0cmlidXRlUGFyc2VyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJQXR0cmlidXRlUGFyc2VyJywgeCA9PiB4LnNpbmdsZXRvbihBdHRyaWJ1dGVQYXJzZXIpKTtcbmxldCBBdHRyaWJ1dGVQYXJzZXIgPSBjbGFzcyBBdHRyaWJ1dGVQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGludGVycHJldGVyLCBhdHRyUGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy5pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gdGhpcy5wYXR0ZXJucyA9IHt9O1xuICAgICAgICBhdHRyUGF0dGVybnMuZm9yRWFjaChhdHRyUGF0dGVybiA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZzID0gQXR0cmlidXRlUGF0dGVybi5nZXRQYXR0ZXJuRGVmaW5pdGlvbnMoYXR0clBhdHRlcm4uY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgaW50ZXJwcmV0ZXIuYWRkKGRlZnMpO1xuICAgICAgICAgICAgZGVmcy5mb3JFYWNoKGRlZiA9PiB7XG4gICAgICAgICAgICAgICAgcGF0dGVybnNbZGVmLnBhdHRlcm5dID0gYXR0clBhdHRlcm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnRlcnByZXRhdGlvbiA9IHRoaXMuY2FjaGVbbmFtZV07XG4gICAgICAgIGlmIChpbnRlcnByZXRhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnRlcnByZXRhdGlvbiA9IHRoaXMuY2FjaGVbbmFtZV0gPSB0aGlzLmludGVycHJldGVyLmludGVycHJldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gaW50ZXJwcmV0YXRpb24ucGF0dGVybjtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3ludGF4KG5hbWUsIHZhbHVlLCBuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm5zW3BhdHRlcm5dW3BhdHRlcm5dKG5hbWUsIHZhbHVlLCBpbnRlcnByZXRhdGlvbi5wYXJ0cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuQXR0cmlidXRlUGFyc2VyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJU3ludGF4SW50ZXJwcmV0ZXIpLFxuICAgIF9fcGFyYW0oMSwgYWxsKElBdHRyaWJ1dGVQYXR0ZXJuKSlcbl0sIEF0dHJpYnV0ZVBhcnNlcik7XG5leHBvcnQgeyBBdHRyaWJ1dGVQYXJzZXIgfTtcbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVQYXR0ZXJuKC4uLnBhdHRlcm5EZWZzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZVBhdHRlcm4uZGVmaW5lKHBhdHRlcm5EZWZzLCB0YXJnZXQpO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgQXR0cmlidXRlUGF0dGVyblJlc291cmNlRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoVHlwZSkge1xuICAgICAgICB0aGlzLlR5cGUgPSBUeXBlO1xuICAgICAgICB0aGlzLm5hbWUgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oSUF0dHJpYnV0ZVBhdHRlcm4sIHRoaXMuVHlwZSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgQXR0cmlidXRlUGF0dGVybiA9IE9iamVjdC5mcmVlemUoe1xuICAgIG5hbWU6IFByb3RvY29sLnJlc291cmNlLmtleUZvcignYXR0cmlidXRlLXBhdHRlcm4nKSxcbiAgICBkZWZpbml0aW9uQW5ub3RhdGlvbktleTogJ2F0dHJpYnV0ZS1wYXR0ZXJuLWRlZmluaXRpb25zJyxcbiAgICBkZWZpbmUocGF0dGVybkRlZnMsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IG5ldyBBdHRyaWJ1dGVQYXR0ZXJuUmVzb3VyY2VEZWZpbml0aW9uKFR5cGUpO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRlZmluaXRpb25Bbm5vdGF0aW9uS2V5IH0gPSBBdHRyaWJ1dGVQYXR0ZXJuO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUobmFtZSwgZGVmaW5pdGlvbiwgVHlwZSk7XG4gICAgICAgIFByb3RvY29sLnJlc291cmNlLmFwcGVuZFRvKFR5cGUsIG5hbWUpO1xuICAgICAgICBQcm90b2NvbC5hbm5vdGF0aW9uLnNldChUeXBlLCBkZWZpbml0aW9uQW5ub3RhdGlvbktleSwgcGF0dGVybkRlZnMpO1xuICAgICAgICBQcm90b2NvbC5hbm5vdGF0aW9uLmFwcGVuZFRvKFR5cGUsIGRlZmluaXRpb25Bbm5vdGF0aW9uS2V5KTtcbiAgICAgICAgcmV0dXJuIFR5cGU7XG4gICAgfSxcbiAgICBnZXRQYXR0ZXJuRGVmaW5pdGlvbnMoVHlwZSkge1xuICAgICAgICByZXR1cm4gUHJvdG9jb2wuYW5ub3RhdGlvbi5nZXQoVHlwZSwgQXR0cmlidXRlUGF0dGVybi5kZWZpbml0aW9uQW5ub3RhdGlvbktleSk7XG4gICAgfVxufSk7XG5sZXQgRG90U2VwYXJhdGVkQXR0cmlidXRlUGF0dGVybiA9IGNsYXNzIERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm4ge1xuICAgICdQQVJULlBBUlQnKHJhd05hbWUsIHJhd1ZhbHVlLCBwYXJ0cykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTeW50YXgocmF3TmFtZSwgcmF3VmFsdWUsIHBhcnRzWzBdLCBwYXJ0c1sxXSk7XG4gICAgfVxuICAgICdQQVJULlBBUlQuUEFSVCcocmF3TmFtZSwgcmF3VmFsdWUsIHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN5bnRheChyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHNbMF0sIHBhcnRzWzJdKTtcbiAgICB9XG59O1xuRG90U2VwYXJhdGVkQXR0cmlidXRlUGF0dGVybiA9IF9fZGVjb3JhdGUoW1xuICAgIGF0dHJpYnV0ZVBhdHRlcm4oeyBwYXR0ZXJuOiAnUEFSVC5QQVJUJywgc3ltYm9sczogJy4nIH0sIHsgcGF0dGVybjogJ1BBUlQuUEFSVC5QQVJUJywgc3ltYm9sczogJy4nIH0pXG5dLCBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuKTtcbmV4cG9ydCB7IERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm4gfTtcbmxldCBSZWZBdHRyaWJ1dGVQYXR0ZXJuID0gY2xhc3MgUmVmQXR0cmlidXRlUGF0dGVybiB7XG4gICAgJ3JlZicocmF3TmFtZSwgcmF3VmFsdWUsIHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN5bnRheChyYXdOYW1lLCByYXdWYWx1ZSwgJ2VsZW1lbnQnLCAncmVmJyk7XG4gICAgfVxuICAgICdQQVJULnJlZicocmF3TmFtZSwgcmF3VmFsdWUsIHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN5bnRheChyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHNbMF0sICdyZWYnKTtcbiAgICB9XG59O1xuUmVmQXR0cmlidXRlUGF0dGVybiA9IF9fZGVjb3JhdGUoW1xuICAgIGF0dHJpYnV0ZVBhdHRlcm4oeyBwYXR0ZXJuOiAncmVmJywgc3ltYm9sczogJycgfSwgeyBwYXR0ZXJuOiAnUEFSVC5yZWYnLCBzeW1ib2xzOiAnLicgfSlcbl0sIFJlZkF0dHJpYnV0ZVBhdHRlcm4pO1xuZXhwb3J0IHsgUmVmQXR0cmlidXRlUGF0dGVybiB9O1xubGV0IENvbG9uUHJlZml4ZWRCaW5kQXR0cmlidXRlUGF0dGVybiA9IGNsYXNzIENvbG9uUHJlZml4ZWRCaW5kQXR0cmlidXRlUGF0dGVybiB7XG4gICAgJzpQQVJUJyhyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3ludGF4KHJhd05hbWUsIHJhd1ZhbHVlLCBwYXJ0c1swXSwgJ2JpbmQnKTtcbiAgICB9XG59O1xuQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuID0gX19kZWNvcmF0ZShbXG4gICAgYXR0cmlidXRlUGF0dGVybih7IHBhdHRlcm46ICc6UEFSVCcsIHN5bWJvbHM6ICc6JyB9KVxuXSwgQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuKTtcbmV4cG9ydCB7IENvbG9uUHJlZml4ZWRCaW5kQXR0cmlidXRlUGF0dGVybiB9O1xubGV0IEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVybiA9IGNsYXNzIEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVybiB7XG4gICAgJ0BQQVJUJyhyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3ludGF4KHJhd05hbWUsIHJhd1ZhbHVlLCBwYXJ0c1swXSwgJ3RyaWdnZXInKTtcbiAgICB9XG59O1xuQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuID0gX19kZWNvcmF0ZShbXG4gICAgYXR0cmlidXRlUGF0dGVybih7IHBhdHRlcm46ICdAUEFSVCcsIHN5bWJvbHM6ICdAJyB9KVxuXSwgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuKTtcbmV4cG9ydCB7IEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVybiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0cmlidXRlLXBhdHRlcm4uanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgYmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBhdHRyQWNjZXNzb3IgfSBmcm9tICcuLi8uLi9vYnNlcnZhdGlvbi9kYXRhLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcyc7XG5sZXQgQXR0ckJpbmRpbmdCZWhhdmlvciA9IGNsYXNzIEF0dHJCaW5kaW5nQmVoYXZpb3Ige1xuICAgIGJpbmQoZmxhZ3MsIF9zY29wZSwgX2hvc3RTY29wZSwgYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLnRhcmdldE9ic2VydmVyID0gYXR0ckFjY2Vzc29yO1xuICAgIH1cbiAgICB1bmJpbmQoZmxhZ3MsIF9zY29wZSwgX2hvc3RTY29wZSwgYmluZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufTtcbkF0dHJCaW5kaW5nQmVoYXZpb3IgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQmVoYXZpb3IoJ2F0dHInKVxuXSwgQXR0ckJpbmRpbmdCZWhhdmlvcik7XG5leHBvcnQgeyBBdHRyQmluZGluZ0JlaGF2aW9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IGJpbmRpbmdCZWhhdmlvciB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVNlbGZFdmVudChldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgIGlmICh0aGlzLnRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VsZkV2ZW50Q2FsbFNvdXJjZShldmVudCk7XG59XG5sZXQgU2VsZkJpbmRpbmdCZWhhdmlvciA9IGNsYXNzIFNlbGZCaW5kaW5nQmVoYXZpb3Ige1xuICAgIGJpbmQoZmxhZ3MsIF9zY29wZSwgX2hvc3RTY29wZSwgYmluZGluZykge1xuICAgICAgICBpZiAoIWJpbmRpbmcuY2FsbFNvdXJjZSB8fCAhYmluZGluZy50YXJnZXRFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWxmIGJpbmRpbmcgYmVoYXZpb3Igb25seSBzdXBwb3J0cyBldmVudHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZy5zZWxmRXZlbnRDYWxsU291cmNlID0gYmluZGluZy5jYWxsU291cmNlO1xuICAgICAgICBiaW5kaW5nLmNhbGxTb3VyY2UgPSBoYW5kbGVTZWxmRXZlbnQ7XG4gICAgfVxuICAgIHVuYmluZChmbGFncywgX3Njb3BlLCBfaG9zdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcuY2FsbFNvdXJjZSA9IGJpbmRpbmcuc2VsZkV2ZW50Q2FsbFNvdXJjZTtcbiAgICAgICAgYmluZGluZy5zZWxmRXZlbnRDYWxsU291cmNlID0gbnVsbDtcbiAgICB9XG59O1xuU2VsZkJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdCZWhhdmlvcignc2VsZicpXG5dLCBTZWxmQmluZGluZ0JlaGF2aW9yKTtcbmV4cG9ydCB7IFNlbGZCaW5kaW5nQmVoYXZpb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGYuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBCaW5kaW5nTW9kZSwgSU9ic2VydmVyTG9jYXRvciwgYmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBFdmVudFN1YnNjcmliZXIgfSBmcm9tICcuLi8uLi9vYnNlcnZhdGlvbi9ldmVudC1kZWxlZ2F0b3IuanMnO1xuaW1wb3J0IHsgTm9kZU9ic2VydmVyQ29uZmlnIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YXRpb24vb2JzZXJ2ZXItbG9jYXRvci5qcyc7XG5sZXQgVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvciA9IGNsYXNzIFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICB9XG4gICAgYmluZChmbGFncywgX3Njb3BlLCBfaG9zdFNjb3BlLCBiaW5kaW5nLCAuLi5ldmVudHMpIHtcbiAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHVwZGF0ZVRyaWdnZXIgYmluZGluZyBiZWhhdmlvciByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZXZlbnQgbmFtZSBhcmd1bWVudDogZWcgPGlucHV0IHZhbHVlLmJpbmQ9XCJmaXJzdE5hbWUgJiB1cGRhdGVUcmlnZ2VyOlxcJ2JsdXJcXCdcIj4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZGluZy5tb2RlICE9PSBCaW5kaW5nTW9kZS50d29XYXkgJiYgYmluZGluZy5tb2RlICE9PSBCaW5kaW5nTW9kZS5mcm9tVmlldykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdXBkYXRlVHJpZ2dlciBiaW5kaW5nIGJlaGF2aW9yIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdHdvLXdheS8gZnJvbS12aWV3IGJpbmRpbmdzIG9uIGlucHV0L3NlbGVjdCBlbGVtZW50cy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgdGhlIGJpbmRpbmcncyB0YXJnZXQgb2JzZXJ2ZXIgaGFzIGJlZW4gc2V0LlxuICAgICAgICBjb25zdCB0YXJnZXRPYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJMb2NhdG9yLmdldE9ic2VydmVyKGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLnRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgaWYgKCF0YXJnZXRPYnNlcnZlci5oYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB1cGRhdGVUcmlnZ2VyIGJpbmRpbmcgYmVoYXZpb3IgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0d28td2F5LyBmcm9tLXZpZXcgYmluZGluZ3Mgb24gaW5wdXQvc2VsZWN0IGVsZW1lbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGJpbmRpbmcudGFyZ2V0T2JzZXJ2ZXIgPSB0YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgLy8gc3Rhc2ggdGhlIG9yaWdpbmFsIGVsZW1lbnQgc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBvcmlnaW5hbEhhbmRsZXIgPSB0YXJnZXRPYnNlcnZlci5oYW5kbGVyO1xuICAgICAgICB0YXJnZXRPYnNlcnZlci5vcmlnaW5hbEhhbmRsZXIgPSBvcmlnaW5hbEhhbmRsZXI7XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIGVsZW1lbnQgc3Vic2NyaWJlIGZ1bmN0aW9uIHdpdGggb25lIHRoYXQgdXNlcyB0aGUgY29ycmVjdCBldmVudHMuXG4gICAgICAgIHRhcmdldE9ic2VydmVyLmhhbmRsZXIgPSBuZXcgRXZlbnRTdWJzY3JpYmVyKG5ldyBOb2RlT2JzZXJ2ZXJDb25maWcoe1xuICAgICAgICAgICAgZGVmYXVsdDogb3JpZ2luYWxIYW5kbGVyLmNvbmZpZy5kZWZhdWx0LFxuICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgICAgcmVhZG9ubHk6IG9yaWdpbmFsSGFuZGxlci5jb25maWcucmVhZG9ubHlcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICB1bmJpbmQoZmxhZ3MsIF9zY29wZSwgX2hvc3RTY29wZSwgYmluZGluZykge1xuICAgICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiB0aGUgYmluZGluZy5cbiAgICAgICAgYmluZGluZy50YXJnZXRPYnNlcnZlci5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgYmluZGluZy50YXJnZXRPYnNlcnZlci5oYW5kbGVyID0gYmluZGluZy50YXJnZXRPYnNlcnZlci5vcmlnaW5hbEhhbmRsZXI7XG4gICAgICAgIGJpbmRpbmcudGFyZ2V0T2JzZXJ2ZXIub3JpZ2luYWxIYW5kbGVyID0gbnVsbDtcbiAgICB9XG59O1xuVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdCZWhhdmlvcigndXBkYXRlVHJpZ2dlcicpLFxuICAgIF9fcGFyYW0oMCwgSU9ic2VydmVyTG9jYXRvcilcbl0sIFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3IpO1xuZXhwb3J0IHsgVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlLXRyaWdnZXIuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBSZWdpc3RyYXRpb24sIG1lcmdlQXJyYXlzLCBQcm90b2NvbCwgZmlyc3REZWZpbmVkLCBNZXRhZGF0YSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBCaW5kaW5nTW9kZSwgRGVsZWdhdGlvblN0cmF0ZWd5LCByZWdpc3RlckFsaWFzZXMgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IEF0dHJpYnV0ZUJpbmRpbmdJbnN0cnVjdGlvbiwgUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24sIENhbGxCaW5kaW5nSW5zdHJ1Y3Rpb24sIEl0ZXJhdG9yQmluZGluZ0luc3RydWN0aW9uLCBSZWZCaW5kaW5nSW5zdHJ1Y3Rpb24sIExpc3RlbmVyQmluZGluZ0luc3RydWN0aW9uLCB9IGZyb20gJy4uL3JlbmRlcmVyLmpzJztcbmltcG9ydCB7IEJpbmRpbmdTeW1ib2wgfSBmcm9tICcuLi9zZW1hbnRpYy1tb2RlbC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gYmluZGluZ0NvbW1hbmQobmFtZU9yRGVmaW5pdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBCaW5kaW5nQ29tbWFuZC5kZWZpbmUobmFtZU9yRGVmaW5pdGlvbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIEJpbmRpbmdDb21tYW5kRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoVHlwZSwgbmFtZSwgYWxpYXNlcywga2V5LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuVHlwZSA9IFR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXNlcyA9IGFsaWFzZXM7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgbGV0IGRlZjtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JEZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRGVmO1xuICAgICAgICAgICAgZGVmID0geyBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRGVmLm5hbWU7XG4gICAgICAgICAgICBkZWYgPSBuYW1lT3JEZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nQ29tbWFuZERlZmluaXRpb24oVHlwZSwgZmlyc3REZWZpbmVkKEJpbmRpbmdDb21tYW5kLmdldEFubm90YXRpb24oVHlwZSwgJ25hbWUnKSwgbmFtZSksIG1lcmdlQXJyYXlzKEJpbmRpbmdDb21tYW5kLmdldEFubm90YXRpb24oVHlwZSwgJ2FsaWFzZXMnKSwgZGVmLmFsaWFzZXMsIFR5cGUuYWxpYXNlcyksIEJpbmRpbmdDb21tYW5kLmtleUZyb20obmFtZSksIGZpcnN0RGVmaW5lZChCaW5kaW5nQ29tbWFuZC5nZXRBbm5vdGF0aW9uKFR5cGUsICd0eXBlJyksIGRlZi50eXBlLCBUeXBlLnR5cGUsIG51bGwpKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHsgVHlwZSwga2V5LCBhbGlhc2VzIH0gPSB0aGlzO1xuICAgICAgICBSZWdpc3RyYXRpb24uc2luZ2xldG9uKGtleSwgVHlwZSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgUmVnaXN0cmF0aW9uLmFsaWFzVG8oa2V5LCBUeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICByZWdpc3RlckFsaWFzZXMoYWxpYXNlcywgQmluZGluZ0NvbW1hbmQsIGtleSwgY29udGFpbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgQmluZGluZ0NvbW1hbmQgPSB7XG4gICAgbmFtZTogUHJvdG9jb2wucmVzb3VyY2Uua2V5Rm9yKCdiaW5kaW5nLWNvbW1hbmQnKSxcbiAgICBrZXlGcm9tKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke0JpbmRpbmdDb21tYW5kLm5hbWV9OiR7bmFtZX1gO1xuICAgIH0sXG4gICAgaXNUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgTWV0YWRhdGEuaGFzT3duKEJpbmRpbmdDb21tYW5kLm5hbWUsIHZhbHVlKTtcbiAgICB9LFxuICAgIGRlZmluZShuYW1lT3JEZWYsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEJpbmRpbmdDb21tYW5kRGVmaW5pdGlvbi5jcmVhdGUobmFtZU9yRGVmLCBUeXBlKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEJpbmRpbmdDb21tYW5kLm5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb24uVHlwZSk7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShCaW5kaW5nQ29tbWFuZC5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uKTtcbiAgICAgICAgUHJvdG9jb2wucmVzb3VyY2UuYXBwZW5kVG8oVHlwZSwgQmluZGluZ0NvbW1hbmQubmFtZSk7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLlR5cGU7XG4gICAgfSxcbiAgICBnZXREZWZpbml0aW9uKFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmID0gTWV0YWRhdGEuZ2V0T3duKEJpbmRpbmdDb21tYW5kLm5hbWUsIFR5cGUpO1xuICAgICAgICBpZiAoZGVmID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVmaW5pdGlvbiBmb3VuZCBmb3IgdHlwZSAke1R5cGUubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH0sXG4gICAgYW5ub3RhdGUoVHlwZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKHByb3ApLCB2YWx1ZSwgVHlwZSk7XG4gICAgfSxcbiAgICBnZXRBbm5vdGF0aW9uKFR5cGUsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLmdldE93bihQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcihwcm9wKSwgVHlwZSk7XG4gICAgfSxcbn07XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFyZ2V0KGJpbmRpbmcsIG1ha2VDYW1lbENhc2UpIHtcbiAgICBpZiAoYmluZGluZy5mbGFncyAmIDI1NiAvKiBpc0JpbmRpbmcgKi8pIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmcuYmluZGFibGUucHJvcE5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ha2VDYW1lbENhc2UpIHtcbiAgICAgICAgcmV0dXJuIGNhbWVsQ2FzZShiaW5kaW5nLnN5bnRheC50YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmcuc3ludGF4LnRhcmdldDtcbiAgICB9XG59XG5sZXQgT25lVGltZUJpbmRpbmdDb21tYW5kID0gY2xhc3MgT25lVGltZUJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDQ5IC8qIE9uZVRpbWVDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIEJpbmRpbmdNb2RlLm9uZVRpbWUpO1xuICAgIH1cbn07XG5PbmVUaW1lQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgnb25lLXRpbWUnKVxuXSwgT25lVGltZUJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IE9uZVRpbWVCaW5kaW5nQ29tbWFuZCB9O1xubGV0IFRvVmlld0JpbmRpbmdDb21tYW5kID0gY2xhc3MgVG9WaWV3QmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gNTAgLyogVG9WaWV3Q29tbWFuZCAqLztcbiAgICB9XG4gICAgY29tcGlsZShiaW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24oYmluZGluZy5leHByZXNzaW9uLCBnZXRUYXJnZXQoYmluZGluZywgZmFsc2UpLCBCaW5kaW5nTW9kZS50b1ZpZXcpO1xuICAgIH1cbn07XG5Ub1ZpZXdCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdDb21tYW5kKCd0by12aWV3Jylcbl0sIFRvVmlld0JpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IFRvVmlld0JpbmRpbmdDb21tYW5kIH07XG5sZXQgRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIEZyb21WaWV3QmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gNTEgLyogRnJvbVZpZXdDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIEJpbmRpbmdNb2RlLmZyb21WaWV3KTtcbiAgICB9XG59O1xuRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdDb21tYW5kKCdmcm9tLXZpZXcnKVxuXSwgRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCk7XG5leHBvcnQgeyBGcm9tVmlld0JpbmRpbmdDb21tYW5kIH07XG5sZXQgVHdvV2F5QmluZGluZ0NvbW1hbmQgPSBjbGFzcyBUd29XYXlCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSA1MiAvKiBUd29XYXlDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIEJpbmRpbmdNb2RlLnR3b1dheSk7XG4gICAgfVxufTtcblR3b1dheUJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ3R3by13YXknKVxuXSwgVHdvV2F5QmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgVHdvV2F5QmluZGluZ0NvbW1hbmQgfTtcbmxldCBEZWZhdWx0QmluZGluZ0NvbW1hbmQgPSBjbGFzcyBEZWZhdWx0QmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gNTMgLyogQmluZENvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICBsZXQgbW9kZSA9IEJpbmRpbmdNb2RlLmRlZmF1bHQ7XG4gICAgICAgIGlmIChiaW5kaW5nIGluc3RhbmNlb2YgQmluZGluZ1N5bWJvbCkge1xuICAgICAgICAgICAgbW9kZSA9IGJpbmRpbmcuYmluZGFibGUubW9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBiaW5kaW5nLnN5bnRheC5jb21tYW5kO1xuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmluZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG8tdmlldyc6XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBCaW5kaW5nTW9kZS50b1ZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29uZS10aW1lJzpcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJpbmRpbmdNb2RlLm9uZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Zyb20tdmlldyc6XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBCaW5kaW5nTW9kZS5mcm9tVmlldztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHdvLXdheSc6XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBCaW5kaW5nTW9kZS50d29XYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24oYmluZGluZy5leHByZXNzaW9uLCBnZXRUYXJnZXQoYmluZGluZywgZmFsc2UpLCBtb2RlID09PSBCaW5kaW5nTW9kZS5kZWZhdWx0ID8gQmluZGluZ01vZGUudG9WaWV3IDogbW9kZSk7XG4gICAgfVxufTtcbkRlZmF1bHRCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdDb21tYW5kKCdiaW5kJylcbl0sIERlZmF1bHRCaW5kaW5nQ29tbWFuZCk7XG5leHBvcnQgeyBEZWZhdWx0QmluZGluZ0NvbW1hbmQgfTtcbmxldCBDYWxsQmluZGluZ0NvbW1hbmQgPSBjbGFzcyBDYWxsQmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gMTUzIC8qIENhbGxDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsQmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIHRydWUpKTtcbiAgICB9XG59O1xuQ2FsbEJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ2NhbGwnKVxuXSwgQ2FsbEJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IENhbGxCaW5kaW5nQ29tbWFuZCB9O1xubGV0IEZvckJpbmRpbmdDb21tYW5kID0gY2xhc3MgRm9yQmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gNTM5IC8qIEZvckNvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSk7XG4gICAgfVxufTtcbkZvckJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ2ZvcicpXG5dLCBGb3JCaW5kaW5nQ29tbWFuZCk7XG5leHBvcnQgeyBGb3JCaW5kaW5nQ29tbWFuZCB9O1xubGV0IFRyaWdnZXJCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIFRyaWdnZXJCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSA0MTgyIC8qIFRyaWdnZXJDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZW5lckJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIHRydWUsIERlbGVnYXRpb25TdHJhdGVneS5ub25lKTtcbiAgICB9XG59O1xuVHJpZ2dlckJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ3RyaWdnZXInKVxuXSwgVHJpZ2dlckJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IFRyaWdnZXJCaW5kaW5nQ29tbWFuZCB9O1xubGV0IERlbGVnYXRlQmluZGluZ0NvbW1hbmQgPSBjbGFzcyBEZWxlZ2F0ZUJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDQxODQgLyogRGVsZWdhdGVDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZW5lckJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIGZhbHNlLCBEZWxlZ2F0aW9uU3RyYXRlZ3kuYnViYmxpbmcpO1xuICAgIH1cbn07XG5EZWxlZ2F0ZUJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ2RlbGVnYXRlJylcbl0sIERlbGVnYXRlQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgRGVsZWdhdGVCaW5kaW5nQ29tbWFuZCB9O1xubGV0IENhcHR1cmVCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIENhcHR1cmVCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSA0MTgzIC8qIENhcHR1cmVDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZW5lckJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIGZhbHNlLCBEZWxlZ2F0aW9uU3RyYXRlZ3kuY2FwdHVyaW5nKTtcbiAgICB9XG59O1xuQ2FwdHVyZUJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ2NhcHR1cmUnKVxuXSwgQ2FwdHVyZUJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IENhcHR1cmVCaW5kaW5nQ29tbWFuZCB9O1xuLyoqXG4gKiBBdHRyIGJpbmRpbmcgY29tbWFuZC4gQ29tcGlsZSBhdHRyIHdpdGggYmluZGluZyBzeW1ib2wgd2l0aCBjb21tYW5kIGBhdHRyYCB0byBgQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uYFxuICovXG5sZXQgQXR0ckJpbmRpbmdDb21tYW5kID0gY2xhc3MgQXR0ckJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDMyIC8qIElzUHJvcGVydHkgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoYmluZGluZywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZUJpbmRpbmdJbnN0cnVjdGlvbih0YXJnZXQsIGJpbmRpbmcuZXhwcmVzc2lvbiwgdGFyZ2V0KTtcbiAgICB9XG59O1xuQXR0ckJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ2F0dHInKVxuXSwgQXR0ckJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IEF0dHJCaW5kaW5nQ29tbWFuZCB9O1xuLyoqXG4gKiBTdHlsZSBiaW5kaW5nIGNvbW1hbmQuIENvbXBpbGUgYXR0ciB3aXRoIGJpbmRpbmcgc3ltYm9sIHdpdGggY29tbWFuZCBgc3R5bGVgIHRvIGBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb25gXG4gKi9cbmxldCBTdHlsZUJpbmRpbmdDb21tYW5kID0gY2xhc3MgU3R5bGVCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSAzMiAvKiBJc1Byb3BlcnR5ICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb24oJ3N0eWxlJywgYmluZGluZy5leHByZXNzaW9uLCBnZXRUYXJnZXQoYmluZGluZywgZmFsc2UpKTtcbiAgICB9XG59O1xuU3R5bGVCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdDb21tYW5kKCdzdHlsZScpXG5dLCBTdHlsZUJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IFN0eWxlQmluZGluZ0NvbW1hbmQgfTtcbi8qKlxuICogQ2xhc3MgYmluZGluZyBjb21tYW5kLiBDb21waWxlIGF0dHIgd2l0aCBiaW5kaW5nIHN5bWJvbCB3aXRoIGNvbW1hbmQgYGNsYXNzYCB0byBgQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uYFxuICovXG5sZXQgQ2xhc3NCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIENsYXNzQmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gMzIgLyogSXNQcm9wZXJ0eSAqLztcbiAgICB9XG4gICAgY29tcGlsZShiaW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uKCdjbGFzcycsIGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSk7XG4gICAgfVxufTtcbkNsYXNzQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgnY2xhc3MnKVxuXSwgQ2xhc3NCaW5kaW5nQ29tbWFuZCk7XG5leHBvcnQgeyBDbGFzc0JpbmRpbmdDb21tYW5kIH07XG4vKipcbiAqIEJpbmRpbmcgY29tbWFuZCB0byByZWZlciBkaWZmZXJlbnQgdGFyZ2V0cyAoZWxlbWVudCwgY3VzdG9tIGVsZW1lbnQvYXR0cmlidXRlIHZpZXcgbW9kZWxzLCBjb250cm9sbGVyKSBhdHRhY2hlZCB0byBhbiBlbGVtZW50XG4gKi9cbmxldCBSZWZCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIFJlZkJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDMyIC8qIElzUHJvcGVydHkgKi8gfCA0MDk2IC8qIElnbm9yZUN1c3RvbUF0dHIgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZkJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSkpO1xuICAgIH1cbn07XG5SZWZCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdDb21tYW5kKCdyZWYnKVxuXSwgUmVmQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgUmVmQmluZGluZ0NvbW1hbmQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmctY29tbWFuZC5qcy5tYXAiLCJpbXBvcnQgeyBSZWdpc3RyYXRpb24sIFByb3RvY29sLCBNZXRhZGF0YSwgbWVyZ2VBcnJheXMsIGZpcnN0RGVmaW5lZCwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQmluZGluZ01vZGUsIHJlZ2lzdGVyQWxpYXNlcywgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IEJpbmRhYmxlLCB9IGZyb20gJy4uL2JpbmRhYmxlLmpzJztcbmltcG9ydCB7IFdhdGNoIH0gZnJvbSAnLi4vd2F0Y2guanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbUF0dHJpYnV0ZShuYW1lT3JEZWYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gQ3VzdG9tQXR0cmlidXRlLmRlZmluZShuYW1lT3JEZWYsIHRhcmdldCk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUNvbnRyb2xsZXIobmFtZU9yRGVmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIEN1c3RvbUF0dHJpYnV0ZS5kZWZpbmUodHlwZW9mIG5hbWVPckRlZiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8geyBpc1RlbXBsYXRlQ29udHJvbGxlcjogdHJ1ZSwgbmFtZTogbmFtZU9yRGVmIH1cbiAgICAgICAgICAgIDogeyBpc1RlbXBsYXRlQ29udHJvbGxlcjogdHJ1ZSwgLi4ubmFtZU9yRGVmIH0sIHRhcmdldCk7XG4gICAgfTtcbn1cbmV4cG9ydCBjbGFzcyBDdXN0b21BdHRyaWJ1dGVEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihUeXBlLCBuYW1lLCBhbGlhc2VzLCBrZXksIGRlZmF1bHRCaW5kaW5nTW9kZSwgaXNUZW1wbGF0ZUNvbnRyb2xsZXIsIGJpbmRhYmxlcywgbm9NdWx0aUJpbmRpbmdzLCB3YXRjaGVzKSB7XG4gICAgICAgIHRoaXMuVHlwZSA9IFR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXNlcyA9IGFsaWFzZXM7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmRlZmF1bHRCaW5kaW5nTW9kZSA9IGRlZmF1bHRCaW5kaW5nTW9kZTtcbiAgICAgICAgdGhpcy5pc1RlbXBsYXRlQ29udHJvbGxlciA9IGlzVGVtcGxhdGVDb250cm9sbGVyO1xuICAgICAgICB0aGlzLmJpbmRhYmxlcyA9IGJpbmRhYmxlcztcbiAgICAgICAgdGhpcy5ub011bHRpQmluZGluZ3MgPSBub011bHRpQmluZGluZ3M7XG4gICAgICAgIHRoaXMud2F0Y2hlcyA9IHdhdGNoZXM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUobmFtZU9yRGVmLCBUeXBlKSB7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBsZXQgZGVmO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVPckRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JEZWY7XG4gICAgICAgICAgICBkZWYgPSB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JEZWYubmFtZTtcbiAgICAgICAgICAgIGRlZiA9IG5hbWVPckRlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUF0dHJpYnV0ZURlZmluaXRpb24oVHlwZSwgZmlyc3REZWZpbmVkKEN1c3RvbUF0dHJpYnV0ZS5nZXRBbm5vdGF0aW9uKFR5cGUsICduYW1lJyksIG5hbWUpLCBtZXJnZUFycmF5cyhDdXN0b21BdHRyaWJ1dGUuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYWxpYXNlcycpLCBkZWYuYWxpYXNlcywgVHlwZS5hbGlhc2VzKSwgQ3VzdG9tQXR0cmlidXRlLmtleUZyb20obmFtZSksIGZpcnN0RGVmaW5lZChDdXN0b21BdHRyaWJ1dGUuZ2V0QW5ub3RhdGlvbihUeXBlLCAnZGVmYXVsdEJpbmRpbmdNb2RlJyksIGRlZi5kZWZhdWx0QmluZGluZ01vZGUsIFR5cGUuZGVmYXVsdEJpbmRpbmdNb2RlLCBCaW5kaW5nTW9kZS50b1ZpZXcpLCBmaXJzdERlZmluZWQoQ3VzdG9tQXR0cmlidXRlLmdldEFubm90YXRpb24oVHlwZSwgJ2lzVGVtcGxhdGVDb250cm9sbGVyJyksIGRlZi5pc1RlbXBsYXRlQ29udHJvbGxlciwgVHlwZS5pc1RlbXBsYXRlQ29udHJvbGxlciwgZmFsc2UpLCBCaW5kYWJsZS5mcm9tKC4uLkJpbmRhYmxlLmdldEFsbChUeXBlKSwgQ3VzdG9tQXR0cmlidXRlLmdldEFubm90YXRpb24oVHlwZSwgJ2JpbmRhYmxlcycpLCBUeXBlLmJpbmRhYmxlcywgZGVmLmJpbmRhYmxlcyksIGZpcnN0RGVmaW5lZChDdXN0b21BdHRyaWJ1dGUuZ2V0QW5ub3RhdGlvbihUeXBlLCAnbm9NdWx0aUJpbmRpbmdzJyksIGRlZi5ub011bHRpQmluZGluZ3MsIFR5cGUubm9NdWx0aUJpbmRpbmdzLCBmYWxzZSksIG1lcmdlQXJyYXlzKFdhdGNoLmdldEFubm90YXRpb24oVHlwZSksIFR5cGUud2F0Y2hlcykpO1xuICAgIH1cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgeyBUeXBlLCBrZXksIGFsaWFzZXMgfSA9IHRoaXM7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi50cmFuc2llbnQoa2V5LCBUeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICBSZWdpc3RyYXRpb24uYWxpYXNUbyhrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIHJlZ2lzdGVyQWxpYXNlcyhhbGlhc2VzLCBDdXN0b21BdHRyaWJ1dGUsIGtleSwgY29udGFpbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgQ3VzdG9tQXR0cmlidXRlID0ge1xuICAgIG5hbWU6IFByb3RvY29sLnJlc291cmNlLmtleUZvcignY3VzdG9tLWF0dHJpYnV0ZScpLFxuICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7Q3VzdG9tQXR0cmlidXRlLm5hbWV9OiR7bmFtZX1gO1xuICAgIH0sXG4gICAgaXNUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgTWV0YWRhdGEuaGFzT3duKEN1c3RvbUF0dHJpYnV0ZS5uYW1lLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBmb3Iobm9kZSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKEN1c3RvbUF0dHJpYnV0ZS5rZXlGcm9tKG5hbWUpLCBub2RlKTtcbiAgICB9LFxuICAgIGRlZmluZShuYW1lT3JEZWYsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEN1c3RvbUF0dHJpYnV0ZURlZmluaXRpb24uY3JlYXRlKG5hbWVPckRlZiwgVHlwZSk7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShDdXN0b21BdHRyaWJ1dGUubmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbi5UeXBlKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUF0dHJpYnV0ZS5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uKTtcbiAgICAgICAgUHJvdG9jb2wucmVzb3VyY2UuYXBwZW5kVG8oVHlwZSwgQ3VzdG9tQXR0cmlidXRlLm5hbWUpO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5UeXBlO1xuICAgIH0sXG4gICAgZ2V0RGVmaW5pdGlvbihUeXBlKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IE1ldGFkYXRhLmdldE93bihDdXN0b21BdHRyaWJ1dGUubmFtZSwgVHlwZSk7XG4gICAgICAgIGlmIChkZWYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZWZpbml0aW9uIGZvdW5kIGZvciB0eXBlICR7VHlwZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfSxcbiAgICBhbm5vdGF0ZShUeXBlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIHZhbHVlLCBUeXBlKTtcbiAgICB9LFxuICAgIGdldEFubm90YXRpb24oVHlwZSwgcHJvcCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKHByb3ApLCBUeXBlKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1c3RvbS1hdHRyaWJ1dGUuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBlbXB0eUFycmF5IH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IElOb2RlIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uLy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IGN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tICcuLi8uLi9iaW5kYWJsZS5qcyc7XG5jb25zdCB1bnNldCA9IFN5bWJvbCgpO1xuLy8gVXNpbmcgcGFzc2l2ZSB0byBoZWxwIHdpdGggcGVyZm9ybWFuY2VcbmNvbnN0IGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0ID0ge1xuICAgIHBhc3NpdmU6IHRydWUsXG4gICAgY2FwdHVyZTogdHJ1ZVxufTtcbi8vIFVzaW5nIHBhc3NpdmUgdG8gaGVscCB3aXRoIHBlcmZvcm1hbmNlXG5jb25zdCBkZWZhdWx0QnViYmxlRXZlbnRJbml0ID0ge1xuICAgIHBhc3NpdmU6IHRydWVcbn07XG4vLyB3ZWFrbHkgY29ubmVjdCBhIGRvY3VtZW50IHRvIGEgYmx1ciBtYW5hZ2VyXG4vLyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGRvY3VtZW50IHByb3BlcnRpZXNcbmNvbnN0IGJsdXJEb2NNYXAgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNsYXNzIEJsdXJNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMuYmx1cnMgPSBbXTtcbiAgICAgICAgYmx1ckRvY01hcC5zZXQocGxhdGZvcm0uZG9jdW1lbnQsIHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuYmx1cnMpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRm9yKHBsYXRmb3JtKSB7XG4gICAgICAgIHJldHVybiBibHVyRG9jTWFwLmdldChwbGF0Zm9ybS5kb2N1bWVudCkgfHwgbmV3IEJsdXJNYW5hZ2VyKHBsYXRmb3JtKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoYmx1cikge1xuICAgICAgICBjb25zdCBibHVycyA9IHRoaXMuYmx1cnM7XG4gICAgICAgIGlmICghYmx1cnMuaW5jbHVkZXMoYmx1cikgJiYgYmx1cnMucHVzaChibHVyKSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZ2lzdGVyKGJsdXIpIHtcbiAgICAgICAgY29uc3QgYmx1cnMgPSB0aGlzLmJsdXJzO1xuICAgICAgICBjb25zdCBpbmRleCA9IGJsdXJzLmluZGV4T2YoYmx1cik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBibHVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibHVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTGlzdGVuZXJzKCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wbGF0Zm9ybTtcbiAgICAgICAgY29uc3QgZG9jID0gcC5kb2N1bWVudDtcbiAgICAgICAgY29uc3Qgd2luID0gcC53aW5kb3c7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG4gICAgICAgIGlmICh3aW4ubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVyLCBkZWZhdWx0Q2FwdHVyZUV2ZW50SW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVyLCBkZWZhdWx0Q2FwdHVyZUV2ZW50SW5pdCk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVyLCBkZWZhdWx0Q2FwdHVyZUV2ZW50SW5pdCk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVyLCBkZWZhdWx0QnViYmxlRXZlbnRJbml0KTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wbGF0Zm9ybTtcbiAgICAgICAgY29uc3QgZG9jID0gcC5kb2N1bWVudDtcbiAgICAgICAgY29uc3Qgd2luID0gcC53aW5kb3c7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG4gICAgICAgIGlmICh3aW4ubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVyLCBkZWZhdWx0Q2FwdHVyZUV2ZW50SW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVyLCBkZWZhdWx0Q2FwdHVyZUV2ZW50SW5pdCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVyLCBkZWZhdWx0Q2FwdHVyZUV2ZW50SW5pdCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVyLCBkZWZhdWx0QnViYmxlRXZlbnRJbml0KTtcbiAgICB9XG59XG5sZXQgQmx1ciA9IGNsYXNzIEJsdXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHApIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBiZWhhdmlvciBzaG91bGQgYmUgbGVhc3Qgc3VycHJpc2UgcG9zc2libGUsIHRoYXQ6XG4gICAgICAgICAqXG4gICAgICAgICAqIGl0IHNlYXJjaGVzIGZvciBhbnl0aGluZyBmcm9tIHJvb3QgY29udGV4dCxcbiAgICAgICAgICogYW5kIHJvb3QgY29udGV4dCBpcyBkb2N1bWVudCBib2R5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmtlZE11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWFyY2hTdWJUcmVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saW5raW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bnNldDtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gQmx1ck1hbmFnZXIuY3JlYXRlRm9yKHApO1xuICAgIH1cbiAgICBhdHRhY2hlZCgpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgICBkZXRhY2hpbmcoKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci51bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucDtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gcC53aW5kb3cgfHwgdGFyZ2V0ID09PSBwLmRvY3VtZW50IHx8ICF0aGlzLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWlucyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVscztcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBqLCBqajtcbiAgICAgICAgbGV0IGxpbms7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGlmIChjb250YWluc0VsZW1lbnRPclNoYWRvd1Jvb3QoZWxlbWVudCwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmxpbmtlZFdpdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLnAuZG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGxpbmtlZFdpdGggPSB0aGlzLmxpbmtlZFdpdGg7XG4gICAgICAgIGNvbnN0IGxpbmtpbmdDb250ZXh0ID0gdGhpcy5saW5raW5nQ29udGV4dDtcbiAgICAgICAgY29uc3Qgc2VhcmNoU3ViVHJlZSA9IHRoaXMuc2VhcmNoU3ViVHJlZTtcbiAgICAgICAgY29uc3QgbGlua2VkTXVsdGlwbGUgPSB0aGlzLmxpbmtlZE11bHRpcGxlO1xuICAgICAgICBjb25zdCBsaW5rcyA9IEFycmF5LmlzQXJyYXkobGlua2VkV2l0aCkgPyBsaW5rZWRXaXRoIDogW2xpbmtlZFdpdGhdO1xuICAgICAgICBjb25zdCBjb250ZXh0Tm9kZSA9ICh0eXBlb2YgbGlua2luZ0NvbnRleHQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGRvYy5xdWVyeVNlbGVjdG9yKGxpbmtpbmdDb250ZXh0KVxuICAgICAgICAgICAgOiBsaW5raW5nQ29udGV4dClcbiAgICAgICAgICAgIHx8IGRvYy5ib2R5O1xuICAgICAgICBjb25zdCBpaSA9IGxpbmtzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaWkgPiBpOyArK2kpIHtcbiAgICAgICAgICAgIGxpbmsgPSBsaW5rc1tpXTtcbiAgICAgICAgICAgIC8vIFdoZW4gdXNlciBzcGVjaWZ5IHRvIGxpbmsgd2l0aCBzb21ldGhpbmcgYnkgYSBzdHJpbmcsIGl0IGFjdHMgYXMgYSBDU1Mgc2VsZWN0b3JcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gc29tZSBxdWVyeWluZyBzdHVmZiB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGFib3ZlIGlzIGNvbnRhaW5lZC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGluayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yLCBzZWFyY2ggdGhlIHdob2xlIHRyZWUsIGZyb20gY29udGV4dCB0aGF0IHVzZXIgc3BlY2lmaWVkLCB3aGljaCBkZWZhdWx0IHRvIGRvY3VtZW50IGJvZHlcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoU3ViVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBhcmUgdGhlcmUgdG9vIG1hbnkga25vYnM/PyBDb25zaWRlciByZW1vdmUgXCJsaW5rZWRNdWx0aXBsZVwiPz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5rZWRNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBjb250ZXh0Tm9kZS5xdWVyeVNlbGVjdG9yKGxpbmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzID0gZWwgIT09IG51bGwgPyBbZWxdIDogZW1wdHlBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVscyA9IGNvbnRleHROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwobGluayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgamogPSBlbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqaiA+IGo7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsc1tqXS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gZG9jdW1lbnQgYm9keSwgaWYgdXNlciBkaWRuJ3QgZGVmaW5lIGEgbGlua2luZyBjb250ZXh0LCBhbmQgd2FudGVkIHRvIGlnbm9yZSBzdWJ0cmVlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHNwZWNpZmljYWxseSBwZXJmb3JtYW50IGFuZCB1c2VmdWwgZm9yIGRpYWxvZ3MsIHBsdWdpbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB1c3VhbGx5IGdlbmVyYXRlIGNvbnRlbnRzIHRvIGRvY3VtZW50IGJvZHlcbiAgICAgICAgICAgICAgICAgICAgZWxzID0gY29udGV4dE5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIGpqID0gZWxzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgamogPiBqOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbHNbal0ubWF0Y2hlcyhsaW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIHBhc3NlZCBpbiBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBzdHJpbmcsXG4gICAgICAgICAgICAgICAgLy8gc2ltcGx5IGNoZWNrIGlmIGhhcyBtZXRob2QgYGNvbnRhaW5zYCAoYWxsb3cgZHVjayB0eXBpbmcpXG4gICAgICAgICAgICAgICAgLy8gYW5kIGNhbGwgaXQgYWdhaW5zdCB0YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBlbmFibGVzIGZsZXhpYmxlIHVzYWdlc1xuICAgICAgICAgICAgICAgIGlmIChsaW5rICYmIGxpbmsuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cmlnZ2VyQmx1cigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub25CbHVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmx1ci5jYWxsKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIEJsdXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSgpXG5dLCBCbHVyLnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIEJsdXIucHJvdG90eXBlLCBcImxpbmtlZFdpdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIEJsdXIucHJvdG90eXBlLCBcImxpbmtlZE11bHRpcGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSgpXG5dLCBCbHVyLnByb3RvdHlwZSwgXCJzZWFyY2hTdWJUcmVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSgpXG5dLCBCbHVyLnByb3RvdHlwZSwgXCJsaW5raW5nQ29udGV4dFwiLCB2b2lkIDApO1xuQmx1ciA9IF9fZGVjb3JhdGUoW1xuICAgIGN1c3RvbUF0dHJpYnV0ZSgnYmx1cicpLFxuICAgIF9fcGFyYW0oMCwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMSwgSVBsYXRmb3JtKVxuXSwgQmx1cik7XG5leHBvcnQgeyBCbHVyIH07XG5jb25zdCBjb250YWluc0VsZW1lbnRPclNoYWRvd1Jvb3QgPSAoY29udGFpbmVyLCB0YXJnZXQpID0+IHtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBwYXJlbnROb2RlID0gbnVsbDtcbiAgICB3aGlsZSAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnROb2RlID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lmhvc3Q7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSBwYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgY3JlYXRlSGFuZGxlciA9IChtYW5hZ2VyLCBjaGVja1RhcmdldHMpID0+IHtcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gRVZFTlRTIE9SREVSXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBwb2ludGVyZG93blxuICAgIC8vIHRvdWNoc3RhcnRcbiAgICAvLyBwb2ludGVydXBcbiAgICAvLyB0b3VjaGVuZFxuICAgIC8vIG1vdXNlZG93blxuICAgIC8vIC0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQkxVUlxuICAgIC8vIEZPQ1VTXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBtb3VzZXVwXG4gICAgLy8gY2xpY2tcbiAgICAvL1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vXG4gICAgLy8gVGhlcmUgYXJlIGNhc2VzIGZvY3VzIGhhcHBlbnMgd2l0aG91dCBtb3VzZSBpbnRlcmFjdGlvbiAoa2V5Ym9hcmQpXG4gICAgLy8gU28gaXQgbmVlZHMgdG8gY2FwdHVyZSBib3RoIG1vdXNlIC8gZm9jdXMgbW92ZW1lbnRcbiAgICAvL1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIGxldCBoYXNDaGVja2VkID0gZmFsc2U7XG4gICAgY29uc3QgcmV2ZXJ0Q2hlY2thZ2UgPSAoKSA9PiB7XG4gICAgICAgIGhhc0NoZWNrZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hcmtDaGVja2VkID0gKCkgPT4ge1xuICAgICAgICBoYXNDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgbWFuYWdlci5wbGF0Zm9ybS5kb21Xcml0ZVF1ZXVlLnF1ZXVlVGFzayhyZXZlcnRDaGVja2FnZSwgeyBwcmVlbXB0OiB0cnVlIH0pO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlTW91c2Vkb3duID0gKGUpID0+IHtcbiAgICAgICAgaWYgKCFoYXNDaGVja2VkKSB7XG4gICAgICAgICAgICBoYW5kbGVFdmVudChlKTtcbiAgICAgICAgICAgIG1hcmtDaGVja2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBnbG9iYWxseSBjYXB0dXJlZCBmb2N1cyBldmVudFxuICAgICAqIFRoaXMgY2FuIGhhcHBlbiB2aWEgYSBmZXcgd2F5OlxuICAgICAqIFVzZXIgY2xpY2tzIG9uIGEgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgKiBVc2VyIHVzZXMga2V5Ym9hcmQgdG8gbmF2aWdhdGUgdG8gYSBmb2N1c2FibGUgZWxlbWVudFxuICAgICAqIFVzZXIgZ29lcyBiYWNrIHRvIHRoZSB3aW5kb3cgZnJvbSBhbm90aGVyIGJyb3dzZXIgdGFiXG4gICAgICogVXNlciBjbGlja3Mgb24gYSBub24tZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgKiBVc2VyIGNsaWNrcyBvbiB0aGUgd2luZG93LCBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudFxuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGhhc0NoZWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVyZSBhcmUgdHdvIHdheSBhIGZvY3VzIGdldHMgY2FwdHVyZWQgb24gd2luZG93XG4gICAgICAgIC8vIHdoZW4gdGhlIHdpbmRvd3MgaXRzZWxmIGdvdCBmb2N1c1xuICAgICAgICAvLyBhbmQgd2hlbiBhbiBlbGVtZW50IGluIHRoZSBkb2N1bWVudCBnZXRzIGZvY3VzXG4gICAgICAgIC8vIHdoZW4gdGhlIHdpbmRvdyBpdHNlbGYgZ290IGZvY3VzLCByZWFjdGluZyB0byBpdCBpcyBxdWl0ZSB1bm5lY2Vzc2FyeVxuICAgICAgICAvLyBhcyBpdCBkb2Vzbid0IHJlYWxseSBhZmZlY3QgZWxlbWVudCBpbnNpZGUgdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIERvIGEgc2ltcGxlIGNoZWNrIGFuZCBiYWlsIGltbWVkaWF0ZWx5XG4gICAgICAgIGNvbnN0IGlzV2luZG93ID0gZS50YXJnZXQgPT09IG1hbmFnZXIucGxhdGZvcm0ud2luZG93O1xuICAgICAgICBpZiAoaXNXaW5kb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoZWNrVGFyZ2V0cy5sZW5ndGg7IGlpID4gaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tUYXJnZXRzW2ldLnRyaWdnZXJCbHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVFdmVudChlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrQ2hlY2tlZCgpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlV2luZG93Qmx1ciA9ICgpID0+IHtcbiAgICAgICAgaGFzQ2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGVja1RhcmdldHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY2hlY2tUYXJnZXRzW2ldLnRyaWdnZXJCbHVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUV2ZW50ID0gKGUpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jb21wb3NlZCA/IGUuY29tcG9zZWRQYXRoKClbMF0gOiBlLnRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoZWNrVGFyZ2V0cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjaGVja1RhcmdldHNbaV0uaGFuZGxlRXZlbnRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25wb2ludGVyZG93bjogaGFuZGxlTW91c2Vkb3duLFxuICAgICAgICBvbnRvdWNoc3RhcnQ6IGhhbmRsZU1vdXNlZG93bixcbiAgICAgICAgb25tb3VzZWRvd246IGhhbmRsZU1vdXNlZG93bixcbiAgICAgICAgb25mb2N1czogaGFuZGxlRm9jdXMsXG4gICAgICAgIG9uYmx1cjogaGFuZGxlV2luZG93Qmx1cixcbiAgICAgICAgaGFuZGxlRXZlbnQoZSkge1xuICAgICAgICAgICAgdGhpc1tgb24ke2UudHlwZX1gXShlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ymx1ci5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IEJpbmRpbmdNb2RlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBJTm9kZSB9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBjdXN0b21BdHRyaWJ1dGUgfSBmcm9tICcuLi9jdXN0b20tYXR0cmlidXRlLmpzJztcbmltcG9ydCB7IGJpbmRhYmxlIH0gZnJvbSAnLi4vLi4vYmluZGFibGUuanMnO1xuLyoqXG4gKiBGb2N1cyBhdHRyaWJ1dGUgZm9yIGVsZW1lbnQgZm9jdXMgYmluZGluZ1xuICovXG5sZXQgRm9jdXMgPSBjbGFzcyBGb2N1cyB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgcCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYGFwcGx5YCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gYGF0dGFjaGVkYCBjYWxsYmFjayBpcyBpbnZva2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5lZWRzQXBwbHkgPSBmYWxzZTtcbiAgICB9XG4gICAgYmluZGluZygpIHtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCBldmVyeXRpbWUgdGhlIGJvdW5kIHZhbHVlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgLSBUaGUgbmV3IHZhbHVlLlxuICAgICAqL1xuICAgIHZhbHVlQ2hhbmdlZCgpIHtcbiAgICAgICAgLy8gSW4gdGhlb3J5LCB3ZSBjb3VsZC9zaG91bGQgcmVhY3QgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gYnV0IGZvY3VzIHN0YXRlIG9mIGFuIGVsZW1lbnQgY2Fubm90IGJlIGFjaGlldmVkXG4gICAgICAgIC8vIHdoaWxlIGl0J3MgZGlzY29ubmVjdGVkIGZyb20gdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIHRodXMsIHRoZXJlIG5lZXNkIHRvIGJlIGEgY2hlY2sgaWYgaXQncyBjdXJyZW50bHkgY29ubmVjdGVkIG9yIG5vdFxuICAgICAgICAvLyBiZWZvcmUgYXBwbHlpbmcgdGhlIHZhbHVlIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIGlmICh0aGlzLiRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgY3VycmVudGx5IGNvbm5lY3RcbiAgICAgICAgICAgIC8vIHRvZ2dsZSB0aGUgZmxhZyB0byBhZGQgcGVuZGluZyB3b3JrIGZvciBsYXRlclxuICAgICAgICAgICAgLy8gaW4gYXR0YWNoZWQgbGlmZWN5Y2xlXG4gICAgICAgICAgICB0aGlzLm5lZWRzQXBwbHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICovXG4gICAgYXR0YWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzQXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMubmVlZHNBcHBseSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGFmdGVyRGV0YWNoQ2hpbGRyZW4gZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuICAgIGFmdGVyRGV0YWNoQ2hpbGRyZW4oKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50VGFyZ2V0IGludGVyZmFjZSBoYW5kbGVyIGZvciBiZXR0ZXIgbWVtb3J5IHVzYWdlXG4gICAgICovXG4gICAgaGFuZGxlRXZlbnQoZSkge1xuICAgICAgICAvLyB0aGVyZSBhcmUgb25seSB0d28gZXZlbnQgbGlzdGVuZWQgdG9cbiAgICAgICAgLy8gaWYgdGhlIGV2ZW4gaXMgZm9jdXMsIGl0IG1lbmFucyB0aGUgZWxlbWVudCBpcyBmb2N1c2VkXG4gICAgICAgIC8vIG9ubHkgbmVlZCB0byBzd2l0Y2ggdGhlIHZhbHVlIHRvIHRydWVcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaXNFbEZvY3VzZWQpIHtcbiAgICAgICAgICAgIC8vIGVsc2UsIGl0J3MgYmx1ciBldmVudFxuICAgICAgICAgICAgLy8gd2hlbiBhIGJsdXIgZXZlbnQgaGFwcGVucywgdGhlcmUgYXJlIHR3byBzaXR1YXRpb25zXG4gICAgICAgICAgICAvLyAxLiB0aGUgZWxlbWVudCBpdHNlbGYgbG9zdCB0aGUgZm9jdXNcbiAgICAgICAgICAgIC8vIDIuIHdpbmRvdyBsb3N0IHRoZSBmb2N1c1xuICAgICAgICAgICAgLy8gVG8gaGFuZGxlIGJvdGggKDEpIGFuZCAoMiksIG9ubHkgbmVlZCB0byBjaGVjayBpZlxuICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgZWxlbWVudCBpcyBzdGlsbCB0aGUgc2FtZSBlbGVtZW50IG9mIHRoaXMgZm9jdXMgY3VzdG9tIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gSWYgaXQncyBub3QsIGl0J3MgYSBibHVyIGV2ZW50IGhhcHBlbmVkIG9uIFdpbmRvdyBiZWNhdXNlIHRoZSBicm93c2VyIHRhYiBsb3N0IGZvY3VzXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXMvYmx1ciBiYXNlZCBvbiBjdXJyZW50IHZhbHVlXG4gICAgICovXG4gICAgYXBwbHkoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBjb25zdCBpc0ZvY3VzZWQgPSB0aGlzLmlzRWxGb2N1c2VkO1xuICAgICAgICBjb25zdCBzaG91bGRGb2N1cyA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmIChzaG91bGRGb2N1cyAmJiAhaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzaG91bGRGb2N1cyAmJiBpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIGVsLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNFbEZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQgPT09IHRoaXMucC5kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSh7IG1vZGU6IEJpbmRpbmdNb2RlLnR3b1dheSB9KVxuXSwgRm9jdXMucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5Gb2N1cyA9IF9fZGVjb3JhdGUoW1xuICAgIGN1c3RvbUF0dHJpYnV0ZSgnZm9jdXMnKSxcbiAgICBfX3BhcmFtKDAsIElOb2RlKSxcbiAgICBfX3BhcmFtKDEsIElQbGF0Zm9ybSlcbl0sIEZvY3VzKTtcbmV4cG9ydCB7IEZvY3VzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGFsaWFzIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBJTm9kZSB9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBjdXN0b21BdHRyaWJ1dGUgfSBmcm9tICcuLi9jdXN0b20tYXR0cmlidXRlLmpzJztcbmltcG9ydCB7IGJpbmRhYmxlIH0gZnJvbSAnLi4vLi4vYmluZGFibGUuanMnO1xuaW1wb3J0IHsgSUluc3RydWN0aW9uIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXIuanMnO1xubGV0IFNob3cgPSBjbGFzcyBTaG93IHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgcCwgaW5zdHIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuJHZhbCA9ICcnO1xuICAgICAgICB0aGlzLiRwcmlvID0gJyc7XG4gICAgICAgIHRoaXMudXBkYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgICAgIC8vIE9ubHkgY29tcGFyZSBhdCB0aGUgc3luY2hyb25vdXMgbW9tZW50IHdoZW4gd2UncmUgYWJvdXQgdG8gdXBkYXRlLCBiZWNhdXNlIHRoZSB2YWx1ZSBtaWdodCBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIHVwZGF0ZSB3YXMgcXVldWVkLlxuICAgICAgICAgICAgaWYgKEJvb2xlYW4odGhpcy52YWx1ZSkgIT09IHRoaXMuaXNUb2dnbGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkID09PSB0aGlzLmJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RvZ2dsZWQgPSAhdGhpcy5iYXNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBpbiB2MSB3ZSB1c2VkIHRoZSAnYXUtaGlkZScgY2xhc3MsIGJ1dCBpbiB2MiBpdCdzIHNvIHRyaXZpYWwgdG8gY29uZGl0aW9uYWxseSBhcHBseSBjbGFzc2VzIChlLmcuICdoaWRlLmNsYXNzPVwic29tZUNvbmRpdGlvblwiJyksXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXQncyBwcm9iYWJseSBiZXR0ZXIgdG8gYXZvaWQgdGhlIENTUyBpbmplY3QgaW5mcmEgaW52b2x2ZW1lbnQgYW5kIGtlZXAgdGhpcyBDQSBhcyBzaW1wbGUgYXMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQsIGp1c3Qgc3RvcmUgYW5kIHJlc3RvcmUgdGhlIHByb3BlcnR5IHZhbHVlcyAod2l0aCBlYWNoIG11dGF0aW9uLCB0byBhY2NvdW50IGZvciBpbi1iZXR3ZWVuIHVwZGF0ZXMpLCB0byBjb3ZlciB0aGUgY29tbW9uIGNhc2VzLCB1bnRpbCB0aGVyZSBpcyBjb252aW5jaW5nIGZlZWRiYWNrIHRvIGRvIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdmFsID0gdGhpcy5lbC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHByaW8gPSB0aGlzLmVsLnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2Rpc3BsYXknKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJywgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RvZ2dsZWQgPSB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCB0aGlzLiR2YWwsIHRoaXMuJHByaW8pO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3R5bGUgYXR0cmlidXRlIGlzIG5vdyBlbXB0eSwgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBkZWNsYXJlZCBhcyBhICdoaWRlJyBhdHRyaWJ1dGUsIHRoZW4gdGhpcy5iYXNlIHdpbGwgYmUgZmFsc2UsIGludmVydGluZyBldmVyeXRoaW5nLlxuICAgICAgICB0aGlzLmlzVG9nZ2xlZCA9IHRoaXMuYmFzZSA9IGluc3RyLmFsaWFzICE9PSAnaGlkZSc7XG4gICAgfVxuICAgIGJpbmRpbmcoKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBkZXRhY2hpbmcoKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50YXNrPy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICB9XG4gICAgdmFsdWVDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLnRhc2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGFzayA9IHRoaXMucC5kb21Xcml0ZVF1ZXVlLnF1ZXVlVGFzayh0aGlzLnVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFNob3cucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5TaG93ID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tQXR0cmlidXRlKCdzaG93JyksXG4gICAgYWxpYXMoJ2hpZGUnKSxcbiAgICBfX3BhcmFtKDAsIElOb2RlKSxcbiAgICBfX3BhcmFtKDEsIElQbGF0Zm9ybSksXG4gICAgX19wYXJhbSgyLCBJSW5zdHJ1Y3Rpb24pXG5dLCBTaG93KTtcbmV4cG9ydCB7IFNob3cgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNob3cuanMubWFwIiwiaW1wb3J0IHsgREksIFJlZ2lzdHJhdGlvbiwgUHJvdG9jb2wsIE1ldGFkYXRhLCBtZXJnZUFycmF5cywgZnJvbURlZmluaXRpb25PckRlZmF1bHQsIHBhc2NhbENhc2UsIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0LCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCwgZW1wdHlBcnJheSwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgcmVnaXN0ZXJBbGlhc2VzLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgQmluZGFibGUsIH0gZnJvbSAnLi4vYmluZGFibGUuanMnO1xuaW1wb3J0IHsgZ2V0RWZmZWN0aXZlUGFyZW50Tm9kZSB9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQgeyBDaGlsZHJlbiB9IGZyb20gJy4uL3RlbXBsYXRpbmcvY2hpbGRyZW4uanMnO1xuaW1wb3J0IHsgV2F0Y2ggfSBmcm9tICcuLi93YXRjaC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tRWxlbWVudChuYW1lT3JEZWYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gQ3VzdG9tRWxlbWVudC5kZWZpbmUobmFtZU9yRGVmLCB0YXJnZXQpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlU2hhZG93RE9NKHRhcmdldE9yT3B0aW9ucykge1xuICAgIGlmICh0YXJnZXRPck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCR0YXJnZXQpIHtcbiAgICAgICAgICAgIEN1c3RvbUVsZW1lbnQuYW5ub3RhdGUoJHRhcmdldCwgJ3NoYWRvd09wdGlvbnMnLCB7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRPck9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgkdGFyZ2V0KSB7XG4gICAgICAgICAgICBDdXN0b21FbGVtZW50LmFubm90YXRlKCR0YXJnZXQsICdzaGFkb3dPcHRpb25zJywgdGFyZ2V0T3JPcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ3VzdG9tRWxlbWVudC5hbm5vdGF0ZSh0YXJnZXRPck9wdGlvbnMsICdzaGFkb3dPcHRpb25zJywgeyBtb2RlOiAnb3BlbicgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udGFpbmVybGVzcyh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgkdGFyZ2V0KSB7XG4gICAgICAgICAgICBDdXN0b21FbGVtZW50LmFubm90YXRlKCR0YXJnZXQsICdjb250YWluZXJsZXNzJywgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIEN1c3RvbUVsZW1lbnQuYW5ub3RhdGUodGFyZ2V0LCAnY29udGFpbmVybGVzcycsIHRydWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmljdCh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgkdGFyZ2V0KSB7XG4gICAgICAgICAgICBDdXN0b21FbGVtZW50LmFubm90YXRlKCR0YXJnZXQsICdpc1N0cmljdEJpbmRpbmcnLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ3VzdG9tRWxlbWVudC5hbm5vdGF0ZSh0YXJnZXQsICdpc1N0cmljdEJpbmRpbmcnLCB0cnVlKTtcbn1cbmNvbnN0IGRlZmluaXRpb25Mb29rdXAgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNsYXNzIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihUeXBlLCBuYW1lLCBhbGlhc2VzLCBrZXksIGNhY2hlLCB0ZW1wbGF0ZSwgaW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMsIGluamVjdGFibGUsIG5lZWRzQ29tcGlsZSwgc3Vycm9nYXRlcywgYmluZGFibGVzLCBjaGlsZHJlbk9ic2VydmVycywgY29udGFpbmVybGVzcywgaXNTdHJpY3RCaW5kaW5nLCBzaGFkb3dPcHRpb25zLCBoYXNTbG90cywgZW5oYW5jZSwgcHJvamVjdGlvbnNNYXAsIHdhdGNoZXMpIHtcbiAgICAgICAgdGhpcy5UeXBlID0gVHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gYWxpYXNlcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuaW5qZWN0YWJsZSA9IGluamVjdGFibGU7XG4gICAgICAgIHRoaXMubmVlZHNDb21waWxlID0gbmVlZHNDb21waWxlO1xuICAgICAgICB0aGlzLnN1cnJvZ2F0ZXMgPSBzdXJyb2dhdGVzO1xuICAgICAgICB0aGlzLmJpbmRhYmxlcyA9IGJpbmRhYmxlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbk9ic2VydmVycyA9IGNoaWxkcmVuT2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLmNvbnRhaW5lcmxlc3MgPSBjb250YWluZXJsZXNzO1xuICAgICAgICB0aGlzLmlzU3RyaWN0QmluZGluZyA9IGlzU3RyaWN0QmluZGluZztcbiAgICAgICAgdGhpcy5zaGFkb3dPcHRpb25zID0gc2hhZG93T3B0aW9ucztcbiAgICAgICAgdGhpcy5oYXNTbG90cyA9IGhhc1Nsb3RzO1xuICAgICAgICB0aGlzLmVuaGFuY2UgPSBlbmhhbmNlO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25zTWFwID0gcHJvamVjdGlvbnNNYXA7XG4gICAgICAgIHRoaXMud2F0Y2hlcyA9IHdhdGNoZXM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUobmFtZU9yRGVmLCBUeXBlID0gbnVsbCkge1xuICAgICAgICBpZiAoVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVmID0gbmFtZU9yRGVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGEgY3VzdG9tIGVsZW1lbnQgZGVmaW5pdGlvbiB3aXRoIG9ubHkgYSBuYW1lIGFuZCBubyB0eXBlOiAke25hbWVPckRlZn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnbmFtZScsIGRlZiwgQ3VzdG9tRWxlbWVudC5nZW5lcmF0ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYuVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgYSBjbG9uZSAoaXQgd2lsbCB1c3VhbGx5IGJlIHRoZSBjb21waWxlciBjYWxsaW5nIHRoaXMgc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgZG9jdW1lbnRlZCB0aGF0IHBhc3NpbmcgaW4gdGhlIHR5cGUgdmlhIHRoZSBkZWZpbml0aW9uICh3aGlsZSBwYXNzaW5nIGluIG51bGxcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgXCJUeXBlXCIgcGFyYW1ldGVyKSBlZmZlY3RpdmVseSBza2lwcyB0eXBlIGFuYWx5c2lzLCBzbyBpdCBzaG91bGQgb25seSBiZSB1c2VkIHRoaXMgd2F5IGZvciBjbG9uaW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgICAgIFR5cGUgPSBkZWYuVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFR5cGUgPSBDdXN0b21FbGVtZW50LmdlbmVyYXRlVHlwZShwYXNjYWxDYXNlKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRWxlbWVudERlZmluaXRpb24oVHlwZSwgbmFtZSwgbWVyZ2VBcnJheXMoZGVmLmFsaWFzZXMpLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgna2V5JywgZGVmLCAoKSA9PiBDdXN0b21FbGVtZW50LmtleUZyb20obmFtZSkpLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnY2FjaGUnLCBkZWYsICgpID0+IDApLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgndGVtcGxhdGUnLCBkZWYsICgpID0+IG51bGwpLCBtZXJnZUFycmF5cyhkZWYuaW5zdHJ1Y3Rpb25zKSwgbWVyZ2VBcnJheXMoZGVmLmRlcGVuZGVuY2llcyksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdpbmplY3RhYmxlJywgZGVmLCAoKSA9PiBudWxsKSwgZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ25lZWRzQ29tcGlsZScsIGRlZiwgKCkgPT4gdHJ1ZSksIG1lcmdlQXJyYXlzKGRlZi5zdXJyb2dhdGVzKSwgQmluZGFibGUuZnJvbShkZWYuYmluZGFibGVzKSwgQ2hpbGRyZW4uZnJvbShkZWYuY2hpbGRyZW5PYnNlcnZlcnMpLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnY29udGFpbmVybGVzcycsIGRlZiwgKCkgPT4gZmFsc2UpLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnaXNTdHJpY3RCaW5kaW5nJywgZGVmLCAoKSA9PiBmYWxzZSksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdzaGFkb3dPcHRpb25zJywgZGVmLCAoKSA9PiBudWxsKSwgZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ2hhc1Nsb3RzJywgZGVmLCAoKSA9PiBmYWxzZSksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdlbmhhbmNlJywgZGVmLCAoKSA9PiBmYWxzZSksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdwcm9qZWN0aW9uc01hcCcsIGRlZiwgKCkgPT4gbmV3IE1hcCgpKSwgZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ3dhdGNoZXMnLCBkZWYsICgpID0+IGVtcHR5QXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHR5cGUgaXMgcGFzc2VkIGluLCB3ZSBpZ25vcmUgdGhlIFR5cGUgcHJvcGVydHkgb24gdGhlIGRlZmluaXRpb24gaWYgaXQgZXhpc3RzLlxuICAgICAgICAvLyBUT0RPOiBkb2N1bWVudCB0aGlzIGJlaGF2aW9yXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yRGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FbGVtZW50RGVmaW5pdGlvbihUeXBlLCBuYW1lT3JEZWYsIG1lcmdlQXJyYXlzKEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYWxpYXNlcycpLCBUeXBlLmFsaWFzZXMpLCBDdXN0b21FbGVtZW50LmtleUZyb20obmFtZU9yRGVmKSwgZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQoJ2NhY2hlJywgVHlwZSwgKCkgPT4gMCksIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KCd0ZW1wbGF0ZScsIFR5cGUsICgpID0+IG51bGwpLCBtZXJnZUFycmF5cyhDdXN0b21FbGVtZW50LmdldEFubm90YXRpb24oVHlwZSwgJ2luc3RydWN0aW9ucycpLCBUeXBlLmluc3RydWN0aW9ucyksIG1lcmdlQXJyYXlzKEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnZGVwZW5kZW5jaWVzJyksIFR5cGUuZGVwZW5kZW5jaWVzKSwgZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQoJ2luamVjdGFibGUnLCBUeXBlLCAoKSA9PiBudWxsKSwgZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQoJ25lZWRzQ29tcGlsZScsIFR5cGUsICgpID0+IHRydWUpLCBtZXJnZUFycmF5cyhDdXN0b21FbGVtZW50LmdldEFubm90YXRpb24oVHlwZSwgJ3N1cnJvZ2F0ZXMnKSwgVHlwZS5zdXJyb2dhdGVzKSwgQmluZGFibGUuZnJvbSguLi5CaW5kYWJsZS5nZXRBbGwoVHlwZSksIEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYmluZGFibGVzJyksIFR5cGUuYmluZGFibGVzKSwgQ2hpbGRyZW4uZnJvbSguLi5DaGlsZHJlbi5nZXRBbGwoVHlwZSksIEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnY2hpbGRyZW5PYnNlcnZlcnMnKSwgVHlwZS5jaGlsZHJlbk9ic2VydmVycyksIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KCdjb250YWluZXJsZXNzJywgVHlwZSwgKCkgPT4gZmFsc2UpLCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCgnaXNTdHJpY3RCaW5kaW5nJywgVHlwZSwgKCkgPT4gZmFsc2UpLCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCgnc2hhZG93T3B0aW9ucycsIFR5cGUsICgpID0+IG51bGwpLCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCgnaGFzU2xvdHMnLCBUeXBlLCAoKSA9PiBmYWxzZSksIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KCdlbmhhbmNlJywgVHlwZSwgKCkgPT4gZmFsc2UpLCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCgncHJvamVjdGlvbnNNYXAnLCBUeXBlLCAoKSA9PiBuZXcgTWFwKCkpLCBtZXJnZUFycmF5cyhXYXRjaC5nZXRBbm5vdGF0aW9uKFR5cGUpLCBUeXBlLndhdGNoZXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHRoZSB0eXBpY2FsIGRlZmF1bHQgYmVoYXZpb3IsIGUuZy4gZnJvbSByZWd1bGFyIEN1c3RvbUVsZW1lbnQuZGVmaW5lIGludm9jYXRpb25zIG9yIGZyb20gQGN1c3RvbUVsZW1lbnQgZGVjb1xuICAgICAgICAvLyBUaGUgVmlld1ZhbHVlQ29udmVydGVyIGFsc28gdXNlcyB0aGlzIHNpZ25hdHVyZSBhbmQgcGFzc2VzIGluIGEgZGVmaW5pdGlvbiB3aGVyZSBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlICdob29rcydcbiAgICAgICAgLy8gcHJvcGVydHkgbmVlZHMgdG8gYmUgY29waWVkLiBTbyB3ZSBoYXZlIHRoYXQgZXhjZXB0aW9uIGZvciAnaG9va3MnLCBidXQgd2UgbWF5IG5lZWQgdG8gcmV2aXNpdCB0aGF0IGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgLy8gaWYgdGhpcyB0dXJucyBvdXQgdG8gYmUgdG9vIG9waW5pb25hdGVkLlxuICAgICAgICBjb25zdCBuYW1lID0gZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ25hbWUnLCBuYW1lT3JEZWYsIEN1c3RvbUVsZW1lbnQuZ2VuZXJhdGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FbGVtZW50RGVmaW5pdGlvbihUeXBlLCBuYW1lLCBtZXJnZUFycmF5cyhDdXN0b21FbGVtZW50LmdldEFubm90YXRpb24oVHlwZSwgJ2FsaWFzZXMnKSwgbmFtZU9yRGVmLmFsaWFzZXMsIFR5cGUuYWxpYXNlcyksIEN1c3RvbUVsZW1lbnQua2V5RnJvbShuYW1lKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ2NhY2hlJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiAwKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ3RlbXBsYXRlJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiBudWxsKSwgbWVyZ2VBcnJheXMoQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdpbnN0cnVjdGlvbnMnKSwgbmFtZU9yRGVmLmluc3RydWN0aW9ucywgVHlwZS5pbnN0cnVjdGlvbnMpLCBtZXJnZUFycmF5cyhDdXN0b21FbGVtZW50LmdldEFubm90YXRpb24oVHlwZSwgJ2RlcGVuZGVuY2llcycpLCBuYW1lT3JEZWYuZGVwZW5kZW5jaWVzLCBUeXBlLmRlcGVuZGVuY2llcyksIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0KCdpbmplY3RhYmxlJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiBudWxsKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ25lZWRzQ29tcGlsZScsIG5hbWVPckRlZiwgVHlwZSwgKCkgPT4gdHJ1ZSksIG1lcmdlQXJyYXlzKEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnc3Vycm9nYXRlcycpLCBuYW1lT3JEZWYuc3Vycm9nYXRlcywgVHlwZS5zdXJyb2dhdGVzKSwgQmluZGFibGUuZnJvbSguLi5CaW5kYWJsZS5nZXRBbGwoVHlwZSksIEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYmluZGFibGVzJyksIFR5cGUuYmluZGFibGVzLCBuYW1lT3JEZWYuYmluZGFibGVzKSwgQ2hpbGRyZW4uZnJvbSguLi5DaGlsZHJlbi5nZXRBbGwoVHlwZSksIEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnY2hpbGRyZW5PYnNlcnZlcnMnKSwgVHlwZS5jaGlsZHJlbk9ic2VydmVycywgbmFtZU9yRGVmLmNoaWxkcmVuT2JzZXJ2ZXJzKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ2NvbnRhaW5lcmxlc3MnLCBuYW1lT3JEZWYsIFR5cGUsICgpID0+IGZhbHNlKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ2lzU3RyaWN0QmluZGluZycsIG5hbWVPckRlZiwgVHlwZSwgKCkgPT4gZmFsc2UpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgnc2hhZG93T3B0aW9ucycsIG5hbWVPckRlZiwgVHlwZSwgKCkgPT4gbnVsbCksIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0KCdoYXNTbG90cycsIG5hbWVPckRlZiwgVHlwZSwgKCkgPT4gZmFsc2UpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgnZW5oYW5jZScsIG5hbWVPckRlZiwgVHlwZSwgKCkgPT4gZmFsc2UpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgncHJvamVjdGlvbnNNYXAnLCBuYW1lT3JEZWYsIFR5cGUsICgpID0+IG5ldyBNYXAoKSksIG1lcmdlQXJyYXlzKG5hbWVPckRlZi53YXRjaGVzLCBXYXRjaC5nZXRBbm5vdGF0aW9uKFR5cGUpLCBUeXBlLndhdGNoZXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE9yQ3JlYXRlKHBhcnRpYWxEZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChwYXJ0aWFsRGVmaW5pdGlvbiBpbnN0YW5jZW9mIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbERlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluaXRpb25Mb29rdXAuaGFzKHBhcnRpYWxEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25Mb29rdXAuZ2V0KHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uY3JlYXRlKHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgZGVmaW5pdGlvbkxvb2t1cC5zZXQocGFydGlhbERlZmluaXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZ1bGwgZGVmaW5pdGlvbiBjYW4gYmUgcmV0cmlldmVkIGZyb20gZHluYW1pY2FsbHkgY3JlYXRlZCBjbGFzc2VzIGFzIHdlbGxcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUVsZW1lbnQubmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbi5UeXBlKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCB7IFR5cGUsIGtleSwgYWxpYXNlcyB9ID0gdGhpcztcbiAgICAgICAgUmVnaXN0cmF0aW9uLnRyYW5zaWVudChrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5hbGlhc1RvKGtleSwgVHlwZSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgcmVnaXN0ZXJBbGlhc2VzKGFsaWFzZXMsIEN1c3RvbUVsZW1lbnQsIGtleSwgY29udGFpbmVyKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0Rm9yT3B0cyA9IHtcbiAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgc2VhcmNoUGFyZW50czogZmFsc2UsXG4gICAgb3B0aW9uYWw6IGZhbHNlLFxufTtcbmV4cG9ydCBjb25zdCBDdXN0b21FbGVtZW50ID0ge1xuICAgIG5hbWU6IFByb3RvY29sLnJlc291cmNlLmtleUZvcignY3VzdG9tLWVsZW1lbnQnKSxcbiAgICBrZXlGcm9tKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke0N1c3RvbUVsZW1lbnQubmFtZX06JHtuYW1lfWA7XG4gICAgfSxcbiAgICBpc1R5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBNZXRhZGF0YS5oYXNPd24oQ3VzdG9tRWxlbWVudC5uYW1lLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBmb3Iobm9kZSwgb3B0cyA9IGRlZmF1bHRGb3JPcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm5hbWUgPT09IHZvaWQgMCAmJiBvcHRzLnNlYXJjaFBhcmVudHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBNZXRhZGF0YS5nZXRPd24oQ3VzdG9tRWxlbWVudC5uYW1lLCBub2RlKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5vcHRpb25hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcHJvdmlkZWQgbm9kZSBpcyBub3QgYSBjdXN0b20gZWxlbWVudCBvciBjb250YWluZXJsZXNzIGhvc3QuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5uYW1lICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnNlYXJjaFBhcmVudHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gTWV0YWRhdGEuZ2V0T3duKEN1c3RvbUVsZW1lbnQubmFtZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwcm92aWRlZCBub2RlIGlzIG5vdCBhIGN1c3RvbSBlbGVtZW50IG9yIGNvbnRhaW5lcmxlc3MgaG9zdC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXMob3B0cy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1ciA9IG5vZGU7XG4gICAgICAgICAgICBsZXQgZm91bmRBQ29udHJvbGxlciA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKGN1ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBNZXRhZGF0YS5nZXRPd24oQ3VzdG9tRWxlbWVudC5uYW1lLCBjdXIpO1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRBQ29udHJvbGxlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLmlzKG9wdHMubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ciA9IGdldEVmZmVjdGl2ZVBhcmVudE5vZGUoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEFDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcHJvdmlkZWQgbm9kZSBkb2VzIGRvZXMgbm90IGFwcGVhciB0byBiZSBwYXJ0IG9mIGFuIEF1cmVsaWEgYXBwIERPTSB0cmVlLCBvciBpdCB3YXMgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHdheSB0aGF0IEF1cmVsaWEgY2Fubm90IHByb3Blcmx5IHJlc29sdmUgaXRzIHBvc2l0aW9uIGluIHRoZSBjb21wb25lbnQgdHJlZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKGN1ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE1ldGFkYXRhLmdldE93bihDdXN0b21FbGVtZW50Lm5hbWUsIGN1cik7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBnZXRFZmZlY3RpdmVQYXJlbnROb2RlKGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcHJvdmlkZWQgbm9kZSBkb2VzIGRvZXMgbm90IGFwcGVhciB0byBiZSBwYXJ0IG9mIGFuIEF1cmVsaWEgYXBwIERPTSB0cmVlLCBvciBpdCB3YXMgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHdheSB0aGF0IEF1cmVsaWEgY2Fubm90IHByb3Blcmx5IHJlc29sdmUgaXRzIHBvc2l0aW9uIGluIHRoZSBjb21wb25lbnQgdHJlZS5gKTtcbiAgICB9LFxuICAgIGRlZmluZShuYW1lT3JEZWYsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLmNyZWF0ZShuYW1lT3JEZWYsIFR5cGUpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ3VzdG9tRWxlbWVudC5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLlR5cGUpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ3VzdG9tRWxlbWVudC5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uKTtcbiAgICAgICAgUHJvdG9jb2wucmVzb3VyY2UuYXBwZW5kVG8oZGVmaW5pdGlvbi5UeXBlLCBDdXN0b21FbGVtZW50Lm5hbWUpO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5UeXBlO1xuICAgIH0sXG4gICAgZ2V0RGVmaW5pdGlvbihUeXBlKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IE1ldGFkYXRhLmdldE93bihDdXN0b21FbGVtZW50Lm5hbWUsIFR5cGUpO1xuICAgICAgICBpZiAoZGVmID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVmaW5pdGlvbiBmb3VuZCBmb3IgdHlwZSAke1R5cGUubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH0sXG4gICAgYW5ub3RhdGUoVHlwZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKHByb3ApLCB2YWx1ZSwgVHlwZSk7XG4gICAgfSxcbiAgICBnZXRBbm5vdGF0aW9uKFR5cGUsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLmdldE93bihQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcihwcm9wKSwgVHlwZSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZU5hbWU6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBpZCA9IDA7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYHVubmFtZWQtJHsrK2lkfWA7XG4gICAgICAgIH07XG4gICAgfSkoKSxcbiAgICBjcmVhdGVJbmplY3RhYmxlKCkge1xuICAgICAgICBjb25zdCAkaW5qZWN0YWJsZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCBpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblBhcmFtdHlwZXMgPSBESS5nZXRPckNyZWF0ZUFubm90YXRpb25QYXJhbVR5cGVzKHRhcmdldCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uUGFyYW10eXBlc1tpbmRleF0gPSAkaW5qZWN0YWJsZTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgICRpbmplY3RhYmxlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNvbnRhaW5lciwgcmVxdWVzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuaGFzKCRpbmplY3RhYmxlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Rvci5nZXQoJGluamVjdGFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRpbmplY3RhYmxlO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVUeXBlOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBuYW1lRGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBkZWZhdWx0UHJvdG8gPSB7fTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBwcm90byA9IGRlZmF1bHRQcm90bykge1xuICAgICAgICAgICAgLy8gQW5vbnltb3VzIGNsYXNzIGVuc3VyZXMgdGhhdCBtaW5pZmljYXRpb24gY2Fubm90IGNhdXNlIHVuaW50ZW5kZWQgc2lkZS1lZmZlY3RzLCBhbmQga2VlcHMgdGhlIGNsYXNzXG4gICAgICAgICAgICAvLyBsb29raW5nIHNpbWlsYXJseSBmcm9tIHRoZSBvdXRzaWRlICh3aGVuIGluc3BlY3RlZCB2aWEgZGVidWdnZXIsIGV0YykuXG4gICAgICAgICAgICBjb25zdCBUeXBlID0gY2xhc3Mge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIERlZmluZSB0aGUgbmFtZSBwcm9wZXJ0eSBzbyB0aGF0IFR5cGUubmFtZSBjYW4gYmUgdXNlZCBieSBlbmQgdXNlcnMgLyBwbHVnaW4gYXV0aG9ycyBpZiB0aGV5IHJlYWxseSBuZWVkIHRvLFxuICAgICAgICAgICAgLy8gZXZlbiB3aGVuIG1pbmlmaWVkLlxuICAgICAgICAgICAgbmFtZURlc2NyaXB0b3IudmFsdWUgPSBuYW1lO1xuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShUeXBlLCAnbmFtZScsIG5hbWVEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIC8vIEFzc2lnbiBhbnl0aGluZyBmcm9tIHRoZSBwcm90b3R5cGUgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAocHJvdG8gIT09IGRlZmF1bHRQcm90bykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oVHlwZS5wcm90b3R5cGUsIHByb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUeXBlO1xuICAgICAgICB9O1xuICAgIH0pKCksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLWVsZW1lbnQuanMubWFwIiwiaW1wb3J0IHsgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSVJlbmRlckxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IGN1c3RvbUVsZW1lbnQgfSBmcm9tICcuLi9jdXN0b20tZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBJVmlld0ZhY3RvcnkgfSBmcm9tICcuLi8uLi90ZW1wbGF0aW5nL3ZpZXcuanMnO1xuZXhwb3J0IGNvbnN0IElQcm9qZWN0aW9ucyA9IERJLmNyZWF0ZUludGVyZmFjZShcIklQcm9qZWN0aW9uc1wiKTtcbmV4cG9ydCB2YXIgQXVTbG90Q29udGVudFR5cGU7XG4oZnVuY3Rpb24gKEF1U2xvdENvbnRlbnRUeXBlKSB7XG4gICAgQXVTbG90Q29udGVudFR5cGVbQXVTbG90Q29udGVudFR5cGVbXCJQcm9qZWN0aW9uXCJdID0gMF0gPSBcIlByb2plY3Rpb25cIjtcbiAgICBBdVNsb3RDb250ZW50VHlwZVtBdVNsb3RDb250ZW50VHlwZVtcIkZhbGxiYWNrXCJdID0gMV0gPSBcIkZhbGxiYWNrXCI7XG59KShBdVNsb3RDb250ZW50VHlwZSB8fCAoQXVTbG90Q29udGVudFR5cGUgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIFNsb3RJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBwcm9qZWN0aW9uQ29udGV4dCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25Db250ZXh0ID0gcHJvamVjdGlvbkNvbnRleHQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFByb2plY3Rpb25Db250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50LCBzY29wZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZWdpc3RlcmVkUHJvamVjdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlLCBwcm9qZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbnMgPSBwcm9qZWN0aW9ucztcbiAgICB9XG59XG5leHBvcnQgY29uc3QgSVByb2plY3Rpb25Qcm92aWRlciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVByb2plY3Rpb25Qcm92aWRlcicsIHggPT4geC5zaW5nbGV0b24oUHJvamVjdGlvblByb3ZpZGVyKSk7XG5jb25zdCBwcm9qZWN0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBQcm9qZWN0aW9uUHJvdmlkZXIge1xuICAgIHJlZ2lzdGVyUHJvamVjdGlvbnMocHJvamVjdGlvbnMsIHNjb3BlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2luc3RydWN0aW9uLCAkcHJvamVjdGlvbnNdIG9mIHByb2plY3Rpb25zKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uTWFwLnNldChpbnN0cnVjdGlvbiwgbmV3IFJlZ2lzdGVyZWRQcm9qZWN0aW9ucyhzY29wZSwgJHByb2plY3Rpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHJvamVjdGlvbkZvcihpbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbk1hcC5nZXQoaW5zdHJ1Y3Rpb24pID8/IG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1U2xvdCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5ob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXcgPSBmYWN0b3J5LmNyZWF0ZSgpLnNldExvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgICAgdGhpcy5pc1Byb2plY3Rpb24gPSBmYWN0b3J5LmNvbnRlbnRUeXBlID09PSBBdVNsb3RDb250ZW50VHlwZS5Qcm9qZWN0aW9uO1xuICAgICAgICB0aGlzLm91dGVyU2NvcGUgPSBmYWN0b3J5LnByb2plY3Rpb25TY29wZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGdldCBpbmplY3QoKSB7IHJldHVybiBbSVZpZXdGYWN0b3J5LCBJUmVuZGVyTG9jYXRpb25dOyB9XG4gICAgYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5ob3N0U2NvcGUgPSB0aGlzLiRjb250cm9sbGVyLnNjb3BlLnBhcmVudFNjb3BlO1xuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuYWN0aXZhdGUoaW5pdGlhdG9yLCAkY29udHJvbGxlciwgZmxhZ3MsIHRoaXMub3V0ZXJTY29wZSA/PyB0aGlzLmhvc3RTY29wZSwgdGhpcy5ob3N0U2NvcGUpO1xuICAgIH1cbiAgICBkZXRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZGVhY3RpdmF0ZShpbml0aWF0b3IsIHRoaXMuJGNvbnRyb2xsZXIsIGZsYWdzKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKHZvaWQgMCk7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXc/LmFjY2VwdCh2aXNpdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jdXN0b21FbGVtZW50KHsgbmFtZTogJ2F1LXNsb3QnLCB0ZW1wbGF0ZTogbnVsbCwgY29udGFpbmVybGVzczogdHJ1ZSB9KShBdVNsb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXUtc2xvdC5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IG5leHRJZCwgb25SZXNvbHZlIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdNb2RlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vLi4vY3JlYXRlLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgSUluc3RydWN0aW9uIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgZ2V0UmVuZGVyQ29udGV4dCB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvcmVuZGVyLWNvbnRleHQuanMnO1xuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudERlZmluaXRpb24gfSBmcm9tICcuLi9jdXN0b20tZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBiaW5kYWJsZSB9IGZyb20gJy4uLy4uL2JpbmRhYmxlLmpzJztcbmZ1bmN0aW9uIHRvTG9va3VwKGFjYywgaXRlbSkge1xuICAgIGNvbnN0IHRvID0gaXRlbS50bztcbiAgICBpZiAodG8gIT09IHZvaWQgMCAmJiB0byAhPT0gJ3N1YmplY3QnICYmIHRvICE9PSAnY29tcG9zaW5nJykge1xuICAgICAgICBhY2NbdG9dID0gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbn1cbmxldCBDb21wb3NlID0gY2xhc3MgQ29tcG9zZSB7XG4gICAgY29uc3RydWN0b3IocCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJZCgnYXUkY29tcG9uZW50Jyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxhc3RTdWJqZWN0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbnMucmVkdWNlKHRvTG9va3VwLCB7fSk7XG4gICAgfVxuICAgIGF0dGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyBzdWJqZWN0LCB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAodmlldyA9PT0gdm9pZCAwIHx8IHRoaXMubGFzdFN1YmplY3QgIT09IHN1YmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zZSh2b2lkIDAsIHN1YmplY3QsIGluaXRpYXRvciwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvc2Uodmlldywgc3ViamVjdCwgaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVhY3RpdmF0ZSh0aGlzLnZpZXcsIGluaXRpYXRvciwgZmxhZ3MpO1xuICAgIH1cbiAgICBzdWJqZWN0Q2hhbmdlZChuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKCEkY29udHJvbGxlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhc3RTdWJqZWN0ID09PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFN1YmplY3QgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSB0cnVlO1xuICAgICAgICBmbGFncyB8PSAkY29udHJvbGxlci5mbGFncztcbiAgICAgICAgY29uc3QgcmV0ID0gb25SZXNvbHZlKHRoaXMuZGVhY3RpdmF0ZSh0aGlzLnZpZXcsIG51bGwsIGZsYWdzKSwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGhhbmRsZSAmIHRlc3QgcmFjZSBjb25kaXRpb25cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvc2Uodm9pZCAwLCBuZXdWYWx1ZSwgbnVsbCwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldC5jYXRjaChlcnIgPT4geyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2Uodmlldywgc3ViamVjdCwgaW5pdGlhdG9yLCBmbGFncykge1xuICAgICAgICByZXR1cm4gb25SZXNvbHZlKHZpZXcgPT09IHZvaWQgMFxuICAgICAgICAgICAgPyBvblJlc29sdmUoc3ViamVjdCwgcmVzb2x2ZWRTdWJqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlVmlldyhyZXNvbHZlZFN1YmplY3QsIGZsYWdzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHZpZXcsIHJlc29sdmVkVmlldyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZShyZXNvbHZlZFZpZXcsIGluaXRpYXRvciwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZSh2aWV3LCBpbml0aWF0b3IsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiB2aWV3Py5kZWFjdGl2YXRlKGluaXRpYXRvciA/PyB2aWV3LCB0aGlzLiRjb250cm9sbGVyLCBmbGFncyk7XG4gICAgfVxuICAgIGFjdGl2YXRlKHZpZXcsIGluaXRpYXRvciwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSh2aWV3Py5hY3RpdmF0ZShpbml0aWF0b3IgPz8gdmlldywgJGNvbnRyb2xsZXIsIGZsYWdzLCAkY29udHJvbGxlci5zY29wZSwgJGNvbnRyb2xsZXIuaG9zdFNjb3BlKSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVWaWV3KHN1YmplY3QsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnByb3ZpZGVWaWV3Rm9yKHN1YmplY3QsIGZsYWdzKTtcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcuc2V0TG9jYXRpb24odGhpcy4kY29udHJvbGxlci5sb2NhdGlvbik7XG4gICAgICAgICAgICB2aWV3LmxvY2tTY29wZSh0aGlzLiRjb250cm9sbGVyLnNjb3BlKTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHByb3ZpZGVWaWV3Rm9yKHN1YmplY3QsIGZsYWdzKSB7XG4gICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250cm9sbGVyKHN1YmplY3QpKSB7IC8vIElDb250cm9sbGVyXG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2NyZWF0ZVZpZXcnIGluIHN1YmplY3QpIHsgLy8gUmVuZGVyUGxhblxuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3QuY3JlYXRlVmlldyh0aGlzLiRjb250cm9sbGVyLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnY3JlYXRlJyBpbiBzdWJqZWN0KSB7IC8vIElWaWV3RmFjdG9yeVxuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3QuY3JlYXRlKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3RlbXBsYXRlJyBpbiBzdWJqZWN0KSB7IC8vIFJhdyBUZW1wbGF0ZSBEZWZpbml0aW9uXG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uZ2V0T3JDcmVhdGUoc3ViamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVuZGVyQ29udGV4dChkZWZpbml0aW9uLCB0aGlzLiRjb250cm9sbGVyLmNvbnRleHQpLmdldFZpZXdGYWN0b3J5KCkuY3JlYXRlKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zdHJ1Y3RhYmxlIChDdXN0b20gRWxlbWVudCBDb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGhpcy5wLCBzdWJqZWN0LCB0aGlzLnByb3BlcnRpZXMsIHRoaXMuJGNvbnRyb2xsZXIuaG9zdC5jaGlsZE5vZGVzKS5jcmVhdGVWaWV3KHRoaXMuJGNvbnRyb2xsZXIuY29udGV4dCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMudmlldz8uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldz8uYWNjZXB0KHZpc2l0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgQ29tcG9zZS5wcm90b3R5cGUsIFwic3ViamVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoeyBtb2RlOiBCaW5kaW5nTW9kZS5mcm9tVmlldyB9KVxuXSwgQ29tcG9zZS5wcm90b3R5cGUsIFwiY29tcG9zaW5nXCIsIHZvaWQgMCk7XG5Db21wb3NlID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tRWxlbWVudCh7IG5hbWU6ICdhdS1jb21wb3NlJywgdGVtcGxhdGU6IG51bGwsIGNvbnRhaW5lcmxlc3M6IHRydWUgfSksXG4gICAgX19wYXJhbSgwLCBJUGxhdGZvcm0pLFxuICAgIF9fcGFyYW0oMSwgSUluc3RydWN0aW9uKVxuXSwgQ29tcG9zZSk7XG5leHBvcnQgeyBDb21wb3NlIH07XG5mdW5jdGlvbiBpc0NvbnRyb2xsZXIoc3ViamVjdCkge1xuICAgIHJldHVybiAnbG9ja1Njb3BlJyBpbiBzdWJqZWN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9zZS5qcy5tYXAiLCJpbXBvcnQgeyBuZXh0SWQgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSVJlbmRlckxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IElWaWV3RmFjdG9yeSB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvdmlldy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9jdXN0b20tYXR0cmlidXRlLmpzJztcbmNsYXNzIEZsYWdzVGVtcGxhdGVDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBsb2NhdGlvbiwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy52aWV3ID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSgpLnNldExvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICB9XG4gICAgYXR0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmFjdGl2YXRlKGluaXRpYXRvciwgJGNvbnRyb2xsZXIsIGZsYWdzIHwgdGhpcy5mbGFncywgJGNvbnRyb2xsZXIuc2NvcGUsICRjb250cm9sbGVyLmhvc3RTY29wZSk7XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciwgdGhpcy4kY29udHJvbGxlciwgZmxhZ3MpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldz8uYWNjZXB0KHZpc2l0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGcmVxdWVudE11dGF0aW9ucyBleHRlbmRzIEZsYWdzVGVtcGxhdGVDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBsb2NhdGlvbikge1xuICAgICAgICBzdXBlcihmYWN0b3J5LCBsb2NhdGlvbiwgODE5MiAvKiBwZXJzaXN0ZW50VGFyZ2V0T2JzZXJ2ZXJRdWV1ZSAqLyk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuRnJlcXVlbnRNdXRhdGlvbnMuaW5qZWN0ID0gW0lWaWV3RmFjdG9yeSwgSVJlbmRlckxvY2F0aW9uXTtcbmV4cG9ydCBjbGFzcyBPYnNlcnZlU2hhbGxvdyBleHRlbmRzIEZsYWdzVGVtcGxhdGVDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBsb2NhdGlvbikge1xuICAgICAgICBzdXBlcihmYWN0b3J5LCBsb2NhdGlvbiwgMjA0OCAvKiBvYnNlcnZlTGVhZlByb3BlcnRpZXNPbmx5ICovKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5PYnNlcnZlU2hhbGxvdy5pbmplY3QgPSBbSVZpZXdGYWN0b3J5LCBJUmVuZGVyTG9jYXRpb25dO1xudGVtcGxhdGVDb250cm9sbGVyKCdmcmVxdWVudC1tdXRhdGlvbnMnKShGcmVxdWVudE11dGF0aW9ucyk7XG50ZW1wbGF0ZUNvbnRyb2xsZXIoJ29ic2VydmUtc2hhbGxvdycpKE9ic2VydmVTaGFsbG93KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsYWdzLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgbmV4dElkLCBvblJlc29sdmUgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSVJlbmRlckxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IElWaWV3RmFjdG9yeSB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvdmlldy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9jdXN0b20tYXR0cmlidXRlLmpzJztcbmltcG9ydCB7IGJpbmRhYmxlIH0gZnJvbSAnLi4vLi4vYmluZGFibGUuanMnO1xubGV0IElmID0gY2xhc3MgSWYge1xuICAgIGNvbnN0cnVjdG9yKGlmRmFjdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZkZhY3RvcnkgPSBpZkZhY3Rvcnk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJZCgnYXUkY29tcG9uZW50Jyk7XG4gICAgICAgIHRoaXMuZWxzZUZhY3RvcnkgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuZWxzZVZpZXcgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuaWZWaWV3ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnZpZXcgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgYXR0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy52aWV3ID0gdGhpcy51cGRhdGVWaWV3KHRoaXMudmFsdWUsIGZsYWdzKTtcbiAgICAgICAgaWYgKHZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciB9ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmFjdGl2YXRlKGluaXRpYXRvciwgJGNvbnRyb2xsZXIsIGZsYWdzLCAkY29udHJvbGxlci5zY29wZSwgJGNvbnRyb2xsZXIuaG9zdFNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciwgdGhpcy4kY29udHJvbGxlciwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmICghJGNvbnRyb2xsZXIuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBvblJlc29sdmUodGhpcy52aWV3Py5kZWFjdGl2YXRlKHRoaXMudmlldywgJGNvbnRyb2xsZXIsIGZsYWdzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmlldyA9IHRoaXMudXBkYXRlVmlldyh0aGlzLnZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICBpZiAodmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGFkZCBsb2dpYyB0byB0aGUgY29udHJvbGxlciB0aGF0IGVuc3VyZXMgY29ycmVjdCBoYW5kbGluZyBvZiByYWNlIGNvbmRpdGlvbnMgYW5kIGFkZCBhIHZhcmlldHkgb2YgYGlmYCBpbnRlZ3JhdGlvbiB0ZXN0c1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LmFjdGl2YXRlKHZpZXcsICRjb250cm9sbGVyLCBmbGFncywgJGNvbnRyb2xsZXIuc2NvcGUsICRjb250cm9sbGVyLmhvc3RTY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHVwZGF0ZVZpZXcodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWZWaWV3ID0gdGhpcy5lbnN1cmVWaWV3KHRoaXMuaWZWaWV3LCB0aGlzLmlmRmFjdG9yeSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsc2VGYWN0b3J5ICE9IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxzZVZpZXcgPSB0aGlzLmVuc3VyZVZpZXcodGhpcy5lbHNlVmlldywgdGhpcy5lbHNlRmFjdG9yeSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBlbnN1cmVWaWV3KHZpZXcsIGZhY3RvcnksIGZsYWdzKSB7XG4gICAgICAgIGlmICh2aWV3ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZpZXcgPSBmYWN0b3J5LmNyZWF0ZShmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5zZXRMb2NhdGlvbih0aGlzLmxvY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlmVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLmlmVmlldy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmlmVmlldyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbHNlVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLmVsc2VWaWV3LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZWxzZVZpZXcgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3ID0gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy52aWV3Py5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBJZi5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbklmID0gX19kZWNvcmF0ZShbXG4gICAgdGVtcGxhdGVDb250cm9sbGVyKCdpZicpLFxuICAgIF9fcGFyYW0oMCwgSVZpZXdGYWN0b3J5KSxcbiAgICBfX3BhcmFtKDEsIElSZW5kZXJMb2NhdGlvbilcbl0sIElmKTtcbmV4cG9ydCB7IElmIH07XG5sZXQgRWxzZSA9IGNsYXNzIEVsc2Uge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJZCgnYXUkY29tcG9uZW50Jyk7XG4gICAgfVxuICAgIGxpbmsoZmxhZ3MsIHBhcmVudENvbnRleHQsIGNvbnRyb2xsZXIsIF9jaGlsZENvbnRyb2xsZXIsIF90YXJnZXQsIF9pbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRyb2xsZXIuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGlmQmVoYXZpb3IgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGlmQmVoYXZpb3IgaW5zdGFuY2VvZiBJZikge1xuICAgICAgICAgICAgaWZCZWhhdmlvci5lbHNlRmFjdG9yeSA9IHRoaXMuZmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZkJlaGF2aW9yLnZpZXdNb2RlbCBpbnN0YW5jZW9mIElmKSB7XG4gICAgICAgICAgICBpZkJlaGF2aW9yLnZpZXdNb2RlbC5lbHNlRmFjdG9yeSA9IHRoaXMuZmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgSWZCZWhhdmlvcmApOyAvLyBUT0RPOiBjcmVhdGUgZXJyb3IgY29kZVxuICAgICAgICB9XG4gICAgfVxufTtcbkVsc2UgPSBfX2RlY29yYXRlKFtcbiAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoeyBuYW1lOiAnZWxzZScgfSksXG4gICAgX19wYXJhbSgwLCBJVmlld0ZhY3RvcnkpXG5dLCBFbHNlKTtcbmV4cG9ydCB7IEVsc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgbmV4dElkLCBvblJlc29sdmUgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSVJlbmRlckxvY2F0aW9uLCBzZXRFZmZlY3RpdmVQYXJlbnROb2RlIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uLy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IElWaWV3RmFjdG9yeSB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvdmlldy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9jdXN0b20tYXR0cmlidXRlLmpzJztcbmltcG9ydCB7IGJpbmRhYmxlIH0gZnJvbSAnLi4vLi4vYmluZGFibGUuanMnO1xubGV0IFBvcnRhbCA9IGNsYXNzIFBvcnRhbCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSwgb3JpZ2luYWxMb2MsIHApIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbExvYyA9IG9yaWdpbmFsTG9jO1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgLy8gdG8gbWFrZSB0aGUgc2hhcGUgb2YgdGhpcyBvYmplY3QgY29uc2lzdGVudC5cbiAgICAgICAgLy8gdG9kbzogaXMgdGhpcyBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gcC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy52aWV3ID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSgpO1xuICAgICAgICBzZXRFZmZlY3RpdmVQYXJlbnROb2RlKHRoaXMudmlldy5ub2Rlcywgb3JpZ2luYWxMb2MpO1xuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQ29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IHRoaXMuJGNvbnRyb2xsZXIuc2NvcGUuYmluZGluZ0NvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGhpcy5yZXNvbHZlVGFyZ2V0KCk7XG4gICAgICAgIHRoaXMudmlldy5zZXRIb3N0KG5ld1RhcmdldCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRhY3RpdmF0aW5nKGluaXRpYXRvciwgbmV3VGFyZ2V0LCBmbGFncyk7XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRlYWN0aXZhdGluZyhpbml0aWF0b3IsIHRoaXMuY3VycmVudFRhcmdldCwgZmxhZ3MpO1xuICAgIH1cbiAgICB0YXJnZXRDaGFuZ2VkKCkge1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoISRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuICAgICAgICBjb25zdCBuZXdUYXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0aGlzLnJlc29sdmVUYXJnZXQoKTtcbiAgICAgICAgaWYgKG9sZFRhcmdldCA9PT0gbmV3VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnNldEhvc3QobmV3VGFyZ2V0KTtcbiAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGZpeCBhbmQgdGVzdCBwb3NzaWJsZSByYWNlIGNvbmRpdGlvblxuICAgICAgICBjb25zdCByZXQgPSBvblJlc29sdmUodGhpcy4kZGVhY3RpdmF0aW5nKG51bGwsIG5ld1RhcmdldCwgJGNvbnRyb2xsZXIuZmxhZ3MpLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kYWN0aXZhdGluZyhudWxsLCBuZXdUYXJnZXQsICRjb250cm9sbGVyLmZsYWdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXQuY2F0Y2goZXJyID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkYWN0aXZhdGluZyhpbml0aWF0b3IsIHRhcmdldCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmF0aW5nLCBjYWxsYmFja0NvbnRleHQsIHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIHZpZXcuc2V0SG9zdCh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gb25SZXNvbHZlKGFjdGl2YXRpbmc/LmNhbGwoY2FsbGJhY2tDb250ZXh0LCB0YXJnZXQsIHZpZXcpLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZShpbml0aWF0b3IsIHRhcmdldCwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWN0aXZhdGUoaW5pdGlhdG9yLCB0YXJnZXQsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIsIHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpbml0aWF0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXcubm9kZXMuYXBwZW5kVG8odGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8oZmtsZXV2ZXIpOiBmaXggYW5kIHRlc3QgcG9zc2libGUgcmFjZSBjb25kaXRpb25cbiAgICAgICAgICAgIHJldHVybiBvblJlc29sdmUodmlldy5hY3RpdmF0ZShpbml0aWF0b3IgPz8gdmlldywgJGNvbnRyb2xsZXIsIGZsYWdzLCAkY29udHJvbGxlci5zY29wZSksICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kYWN0aXZhdGVkKHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4kYWN0aXZhdGVkKHRhcmdldCk7XG4gICAgfVxuICAgICRhY3RpdmF0ZWQodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHsgYWN0aXZhdGVkLCBjYWxsYmFja0NvbnRleHQsIHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhY3RpdmF0ZWQ/LmNhbGwoY2FsbGJhY2tDb250ZXh0LCB0YXJnZXQsIHZpZXcpO1xuICAgIH1cbiAgICAkZGVhY3RpdmF0aW5nKGluaXRpYXRvciwgdGFyZ2V0LCBmbGFncykge1xuICAgICAgICBjb25zdCB7IGRlYWN0aXZhdGluZywgY2FsbGJhY2tDb250ZXh0LCB2aWV3IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gb25SZXNvbHZlKGRlYWN0aXZhdGluZz8uY2FsbChjYWxsYmFja0NvbnRleHQsIHRhcmdldCwgdmlldyksICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlYWN0aXZhdGUoaW5pdGlhdG9yLCB0YXJnZXQsIGZsYWdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoaW5pdGlhdG9yLCB0YXJnZXQsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIsIHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpbml0aWF0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXcubm9kZXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHZpZXcuZGVhY3RpdmF0ZShpbml0aWF0b3IsICRjb250cm9sbGVyLCBmbGFncyksICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZGVhY3RpdmF0ZWQodGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiRkZWFjdGl2YXRlZCh0YXJnZXQpO1xuICAgIH1cbiAgICAkZGVhY3RpdmF0ZWQodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHsgZGVhY3RpdmF0ZWQsIGNhbGxiYWNrQ29udGV4dCwgdmlldyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGRlYWN0aXZhdGVkPy5jYWxsKGNhbGxiYWNrQ29udGV4dCwgdGFyZ2V0LCB2aWV3KTtcbiAgICB9XG4gICAgcmVzb2x2ZVRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucDtcbiAgICAgICAgLy8gd2l0aCBhICQgaW4gZnJvbnQgdG8gbWFrZSBpdCBsZXNzIGNvbmZ1c2luZy9lcnJvciBwcm9uZVxuICAgICAgICBjb25zdCAkZG9jdW1lbnQgPSBwLmRvY3VtZW50O1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5yZW5kZXJDb250ZXh0O1xuICAgICAgICBpZiAodGFyZ2V0ID09PSAnJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBxdWVyeVNlbGVjdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJGRvY3VtZW50LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnlDb250ZXh0ID0gJGRvY3VtZW50O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSAkZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgcC5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldCA9IHF1ZXJ5Q29udGV4dC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIHAuTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydGFsIHRhcmdldCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodm9pZCAwKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy52aWV3Py5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKHsgcHJpbWFyeTogdHJ1ZSB9KVxuXSwgUG9ydGFsLnByb3RvdHlwZSwgXCJ0YXJnZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKHsgY2FsbGJhY2s6ICd0YXJnZXRDaGFuZ2VkJyB9KVxuXSwgUG9ydGFsLnByb3RvdHlwZSwgXCJyZW5kZXJDb250ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSgpXG5dLCBQb3J0YWwucHJvdG90eXBlLCBcInN0cmljdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgUG9ydGFsLnByb3RvdHlwZSwgXCJkZWFjdGl2YXRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIFBvcnRhbC5wcm90b3R5cGUsIFwiYWN0aXZhdGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgUG9ydGFsLnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgUG9ydGFsLnByb3RvdHlwZSwgXCJhY3RpdmF0ZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIFBvcnRhbC5wcm90b3R5cGUsIFwiY2FsbGJhY2tDb250ZXh0XCIsIHZvaWQgMCk7XG5Qb3J0YWwgPSBfX2RlY29yYXRlKFtcbiAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ3BvcnRhbCcpLFxuICAgIF9fcGFyYW0oMCwgSVZpZXdGYWN0b3J5KSxcbiAgICBfX3BhcmFtKDEsIElSZW5kZXJMb2NhdGlvbiksXG4gICAgX19wYXJhbSgyLCBJUGxhdGZvcm0pXG5dLCBQb3J0YWwpO1xuZXhwb3J0IHsgUG9ydGFsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3J0YWwuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBjb21wYXJlTnVtYmVyLCBuZXh0SWQsIG9uUmVzb2x2ZSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBhcHBseU11dGF0aW9uc1RvSW5kaWNlcywgQmluZGluZ0NvbnRleHQsIGdldENvbGxlY3Rpb25PYnNlcnZlciwgU2NvcGUsIHN5bmNocm9uaXplSW5kaWNlcywgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IElSZW5kZXJMb2NhdGlvbiB9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQgeyBJVmlld0ZhY3RvcnkgfSBmcm9tICcuLi8uLi90ZW1wbGF0aW5nL3ZpZXcuanMnO1xuaW1wb3J0IHsgdGVtcGxhdGVDb250cm9sbGVyIH0gZnJvbSAnLi4vY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBJQ29udHJvbGxlciB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvY29udHJvbGxlci5qcyc7XG5pbXBvcnQgeyBiaW5kYWJsZSB9IGZyb20gJy4uLy4uL2JpbmRhYmxlLmpzJztcbmZ1bmN0aW9uIGRpc3Bvc2UoZGlzcG9zYWJsZSkge1xuICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xufVxubGV0IFJlcGVhdCA9IGNsYXNzIFJlcGVhdCB7XG4gICAgY29uc3RydWN0b3IobG9jYXRpb24sIHBhcmVudCwgZmFjdG9yeSkge1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nSW5zdGFuY2VNdXRhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWRJdGVtcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0NvbGxlY3Rpb25PYnNlcnZlcihmbGFncyk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5wYXJlbnQuYmluZGluZ3M7XG4gICAgICAgIGxldCBiaW5kaW5nID0gKHZvaWQgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJpbmRpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnRhcmdldCA9PT0gdGhpcyAmJiBiaW5kaW5nLnRhcmdldFByb3BlcnR5ID09PSAnaXRlbXMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JPZiA9IGJpbmRpbmcuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsID0gdGhpcy5mb3JPZi5kZWNsYXJhdGlvbi5ldmFsdWF0ZShmbGFncywgdGhpcy4kY29udHJvbGxlci5zY29wZSwgbnVsbCwgYmluZGluZy5sb2NhdG9yLCBudWxsKTtcbiAgICB9XG4gICAgYXR0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZVRvQXJyYXkoZmxhZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZUFsbFZpZXdzKGluaXRpYXRvciwgZmxhZ3MpO1xuICAgIH1cbiAgICBkZXRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb2xsZWN0aW9uT2JzZXJ2ZXIoZmxhZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWFjdGl2YXRlQWxsVmlld3MoaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgfVxuICAgIC8vIGNhbGxlZCBieSBTZXR0ZXJPYnNlcnZlclxuICAgIGl0ZW1zQ2hhbmdlZChmbGFncykge1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoISRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3MgfD0gJGNvbnRyb2xsZXIuZmxhZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDb2xsZWN0aW9uT2JzZXJ2ZXIoZmxhZ3MpO1xuICAgICAgICBmbGFncyB8PSA4IC8qIHVwZGF0ZVRhcmdldCAqLztcbiAgICAgICAgdGhpcy5ub3JtYWxpemVUb0FycmF5KGZsYWdzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gb25SZXNvbHZlKHRoaXMuZGVhY3RpdmF0ZUFsbFZpZXdzKG51bGwsIGZsYWdzKSwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGFkZCBsb2dpYyB0byB0aGUgY29udHJvbGxlciB0aGF0IGVuc3VyZXMgY29ycmVjdCBoYW5kbGluZyBvZiByYWNlIGNvbmRpdGlvbnMgYW5kIGFkZCBhIHZhcmlldHkgb2YgYGlmYCBpbnRlZ3JhdGlvbiB0ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVBbGxWaWV3cyhudWxsLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2FsbGVkIGJ5IGEgQ29sbGVjdGlvbk9ic2VydmVyXG4gICAgaGFuZGxlQ29sbGVjdGlvbkNoYW5nZShpbmRleE1hcCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKCEkY29udHJvbGxlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZsYWdzIHw9ICRjb250cm9sbGVyLmZsYWdzO1xuICAgICAgICBmbGFncyB8PSA4IC8qIHVwZGF0ZVRhcmdldCAqLztcbiAgICAgICAgdGhpcy5ub3JtYWxpemVUb0FycmF5KGZsYWdzKTtcbiAgICAgICAgaWYgKGluZGV4TWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IG9uUmVzb2x2ZSh0aGlzLmRlYWN0aXZhdGVBbGxWaWV3cyhudWxsLCBmbGFncyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogYWRkIGxvZ2ljIHRvIHRoZSBjb250cm9sbGVyIHRoYXQgZW5zdXJlcyBjb3JyZWN0IGhhbmRsaW5nIG9mIHJhY2UgY29uZGl0aW9ucyBhbmQgYWRkIGEgdmFyaWV0eSBvZiBgaWZgIGludGVncmF0aW9uIHRlc3RzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVBbGxWaWV3cyhudWxsLCBmbGFncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvbGRMZW5ndGggPSB0aGlzLnZpZXdzLmxlbmd0aDtcbiAgICAgICAgICAgIGFwcGx5TXV0YXRpb25zVG9JbmRpY2VzKGluZGV4TWFwKTtcbiAgICAgICAgICAgIC8vIGZpcnN0IGRldGFjaCt1bmJpbmQrKHJlbW92ZSBmcm9tIGFycmF5KSB0aGUgZGVsZXRlZCB2aWV3IGluZGljZXNcbiAgICAgICAgICAgIGlmIChpbmRleE1hcC5kZWxldGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5zb3J0KGNvbXBhcmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IG9uUmVzb2x2ZSh0aGlzLmRlYWN0aXZhdGVBbmRSZW1vdmVWaWV3c0J5S2V5KGluZGV4TWFwLCBmbGFncyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGFkZCBsb2dpYyB0byB0aGUgY29udHJvbGxlciB0aGF0IGVuc3VyZXMgY29ycmVjdCBoYW5kbGluZyBvZiByYWNlIGNvbmRpdGlvbnMgYW5kIGFkZCBhIHZhcmlldHkgb2YgYGlmYCBpbnRlZ3JhdGlvbiB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRBY3RpdmF0ZUFuZFNvcnRWaWV3c0J5S2V5KG9sZExlbmd0aCwgaW5kZXhNYXAsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXQuY2F0Y2goZXJyID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogYWRkIGxvZ2ljIHRvIHRoZSBjb250cm9sbGVyIHRoYXQgZW5zdXJlcyBjb3JyZWN0IGhhbmRsaW5nIG9mIHJhY2UgY29uZGl0aW9ucyBhbmQgYWRkIGludGVncmF0aW9uIHRlc3RzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQW5kQWN0aXZhdGVBbmRTb3J0Vmlld3NCeUtleShvbGRMZW5ndGgsIGluZGV4TWFwLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdG9kbzogc3Vic2NyaWJlIHRvIGNvbGxlY3Rpb24gZnJvbSBpbm5lciBleHByZXNzaW9uXG4gICAgY2hlY2tDb2xsZWN0aW9uT2JzZXJ2ZXIoZmxhZ3MpIHtcbiAgICAgICAgY29uc3Qgb2xkT2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgICBpZiAoKGZsYWdzICYgNjQgLyogZnJvbVVuYmluZCAqLykpIHtcbiAgICAgICAgICAgIGlmIChvbGRPYnNlcnZlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgb2xkT2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kY29udHJvbGxlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3T2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gZ2V0Q29sbGVjdGlvbk9ic2VydmVyKHRoaXMuaXRlbXMpO1xuICAgICAgICAgICAgaWYgKG9sZE9ic2VydmVyICE9PSBuZXdPYnNlcnZlciAmJiBvbGRPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIG9sZE9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZVRvQXJyYXkoZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkSXRlbXMgPSBpdGVtcztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JPZiA9IHRoaXMuZm9yT2Y7XG4gICAgICAgIGlmIChmb3JPZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEl0ZW1zID0gW107XG4gICAgICAgIHRoaXMuZm9yT2YuaXRlcmF0ZShmbGFncywgaXRlbXMsIChhcnIsIGluZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBub3JtYWxpemVkSXRlbXNbaW5kZXhdID0gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9ybWFsaXplZEl0ZW1zID0gbm9ybWFsaXplZEl0ZW1zO1xuICAgIH1cbiAgICBhY3RpdmF0ZUFsbFZpZXdzKGluaXRpYXRvciwgZmxhZ3MpIHtcbiAgICAgICAgbGV0IHByb21pc2VzID0gdm9pZCAwO1xuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgbGV0IHZpZXdTY29wZTtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciwgZmFjdG9yeSwgbG9jYWwsIGxvY2F0aW9uLCBpdGVtcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcGFyZW50U2NvcGUgPSAkY29udHJvbGxlci5zY29wZTtcbiAgICAgICAgY29uc3QgaG9zdFNjb3BlID0gJGNvbnRyb2xsZXIuaG9zdFNjb3BlO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSB0aGlzLmZvck9mLmNvdW50KGZsYWdzLCBpdGVtcyk7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gdGhpcy52aWV3cyA9IEFycmF5KG5ld0xlbik7XG4gICAgICAgIHRoaXMuZm9yT2YuaXRlcmF0ZShmbGFncywgaXRlbXMsIChhcnIsIGksIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHZpZXcgPSB2aWV3c1tpXSA9IGZhY3RvcnkuY3JlYXRlKGZsYWdzKS5zZXRMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICAgICAgICB2aWV3Lm5vZGVzLnVubGluaygpO1xuICAgICAgICAgICAgdmlld1Njb3BlID0gU2NvcGUuZnJvbVBhcmVudChwYXJlbnRTY29wZSwgQmluZGluZ0NvbnRleHQuY3JlYXRlKGxvY2FsLCBpdGVtKSk7XG4gICAgICAgICAgICBzZXRDb250ZXh0dWFsUHJvcGVydGllcyh2aWV3U2NvcGUub3ZlcnJpZGVDb250ZXh0LCBpLCBuZXdMZW4pO1xuICAgICAgICAgICAgcmV0ID0gdmlldy5hY3RpdmF0ZShpbml0aWF0b3IgPz8gdmlldywgJGNvbnRyb2xsZXIsIGZsYWdzLCB2aWV3U2NvcGUsIGhvc3RTY29wZSk7XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIChwcm9taXNlcyA/PyAocHJvbWlzZXMgPSBbXSkpLnB1c2gocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9taXNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgPyBwcm9taXNlc1swXVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGVBbGxWaWV3cyhpbml0aWF0b3IsIGZsYWdzKSB7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IHZvaWQgMDtcbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIGNvbnN0IHsgdmlld3MsICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2aWV3cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICB2aWV3ID0gdmlld3NbaV07XG4gICAgICAgICAgICB2aWV3LnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHJldCA9IHZpZXcuZGVhY3RpdmF0ZShpbml0aWF0b3IgPz8gdmlldywgJGNvbnRyb2xsZXIsIGZsYWdzKTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgKHByb21pc2VzID8/IChwcm9taXNlcyA9IFtdKSkucHVzaChyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgPyBwcm9taXNlc1swXVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGVBbmRSZW1vdmVWaWV3c0J5S2V5KGluZGV4TWFwLCBmbGFncykge1xuICAgICAgICBsZXQgcHJvbWlzZXMgPSB2b2lkIDA7XG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyLCB2aWV3cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZGVsZXRlZCA9IGluZGV4TWFwLmRlbGV0ZWRJdGVtcztcbiAgICAgICAgY29uc3QgZGVsZXRlZExlbiA9IGRlbGV0ZWQubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgZGVsZXRlZExlbjsgKytpKSB7XG4gICAgICAgICAgICB2aWV3ID0gdmlld3NbZGVsZXRlZFtpXV07XG4gICAgICAgICAgICB2aWV3LnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHJldCA9IHZpZXcuZGVhY3RpdmF0ZSh2aWV3LCAkY29udHJvbGxlciwgZmxhZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAocHJvbWlzZXMgPz8gKHByb21pc2VzID0gW10pKS5wdXNoKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBkZWxldGVkTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGogPSBkZWxldGVkW2ldIC0gaTtcbiAgICAgICAgICAgIHZpZXdzLnNwbGljZShqLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZXMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgID8gcHJvbWlzZXNbMF1cbiAgICAgICAgICAgICAgICA6IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVBbmRBY3RpdmF0ZUFuZFNvcnRWaWV3c0J5S2V5KG9sZExlbmd0aCwgaW5kZXhNYXAsIGZsYWdzKSB7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IHZvaWQgMDtcbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIGxldCB2aWV3U2NvcGU7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIsIGZhY3RvcnksIGxvY2FsLCBub3JtYWxpemVkSXRlbXMsIGxvY2F0aW9uLCB2aWV3cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwTGVuID0gaW5kZXhNYXAubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcExlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhNYXBbaV0gPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdmlldyA9IGZhY3RvcnkuY3JlYXRlKGZsYWdzKTtcbiAgICAgICAgICAgICAgICB2aWV3cy5zcGxpY2UoaSwgMCwgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXdzLmxlbmd0aCAhPT0gbWFwTGVuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBjcmVhdGUgZXJyb3IgY29kZSBhbmQgdXNlIHJlcG9ydGVyIHdpdGggbW9yZSBpbmZvcm1hdGl2ZSBtZXNzYWdlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZpZXdzTGVuPSR7dmlld3MubGVuZ3RofSwgbWFwTGVuPSR7bWFwTGVufWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFNjb3BlID0gJGNvbnRyb2xsZXIuc2NvcGU7XG4gICAgICAgIGNvbnN0IGhvc3RTY29wZSA9ICRjb250cm9sbGVyLmhvc3RTY29wZTtcbiAgICAgICAgY29uc3QgbmV3TGVuID0gaW5kZXhNYXAubGVuZ3RoO1xuICAgICAgICBzeW5jaHJvbml6ZUluZGljZXModmlld3MsIGluZGV4TWFwKTtcbiAgICAgICAgLy8gdGhpcyBhbGdvcml0aG0gcmV0cmlldmVzIHRoZSBpbmRpY2VzIG9mIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgaXRlbXMgaW4gdGhlIHJlcGVhdGVyXG4gICAgICAgIC8vIHRoZSBpdGVtcyBvbiB0aG9zZSBpbmRpY2VzIGFyZSBub3QgbW92ZWQ7IHRoaXMgbWluaW1pemVzIHRoZSBudW1iZXIgb2YgRE9NIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHRvIGJlIHBlcmZvcm1lZFxuICAgICAgICBjb25zdCBzZXEgPSBsb25nZXN0SW5jcmVhc2luZ1N1YnNlcXVlbmNlKGluZGV4TWFwKTtcbiAgICAgICAgY29uc3Qgc2VxTGVuID0gc2VxLmxlbmd0aDtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGxldCBqID0gc2VxTGVuIC0gMTtcbiAgICAgICAgbGV0IGkgPSBuZXdMZW4gLSAxO1xuICAgICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHZpZXcgPSB2aWV3c1tpXTtcbiAgICAgICAgICAgIG5leHQgPSB2aWV3c1tpICsgMV07XG4gICAgICAgICAgICB2aWV3Lm5vZGVzLmxpbmsobmV4dD8ubm9kZXMgPz8gbG9jYXRpb24pO1xuICAgICAgICAgICAgaWYgKGluZGV4TWFwW2ldID09PSAtMikge1xuICAgICAgICAgICAgICAgIHZpZXdTY29wZSA9IFNjb3BlLmZyb21QYXJlbnQocGFyZW50U2NvcGUsIEJpbmRpbmdDb250ZXh0LmNyZWF0ZShsb2NhbCwgbm9ybWFsaXplZEl0ZW1zW2ldKSk7XG4gICAgICAgICAgICAgICAgc2V0Q29udGV4dHVhbFByb3BlcnRpZXModmlld1Njb3BlLm92ZXJyaWRlQ29udGV4dCwgaSwgbmV3TGVuKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldExvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICByZXQgPSB2aWV3LmFjdGl2YXRlKHZpZXcsICRjb250cm9sbGVyLCBmbGFncywgdmlld1Njb3BlLCBob3N0U2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIChwcm9taXNlcyA/PyAocHJvbWlzZXMgPSBbXSkpLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqIDwgMCB8fCBzZXFMZW4gPT09IDEgfHwgaSAhPT0gc2VxW2pdKSB7XG4gICAgICAgICAgICAgICAgc2V0Q29udGV4dHVhbFByb3BlcnRpZXModmlldy5zY29wZS5vdmVycmlkZUNvbnRleHQsIGksIG5ld0xlbik7XG4gICAgICAgICAgICAgICAgdmlldy5ub2Rlcy5pbnNlcnRCZWZvcmUodmlldy5sb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkTGVuZ3RoICE9PSBuZXdMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29udGV4dHVhbFByb3BlcnRpZXModmlldy5zY29wZS5vdmVycmlkZUNvbnRleHQsIGksIG5ld0xlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZXMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgID8gcHJvbWlzZXNbMF1cbiAgICAgICAgICAgICAgICA6IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnZpZXdzLmZvckVhY2goZGlzcG9zZSk7XG4gICAgICAgIHRoaXMudmlld3MgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgY29uc3QgeyB2aWV3cyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHZpZXdzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZpZXdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlld3NbaV0uYWNjZXB0KHZpc2l0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgUmVwZWF0LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB2b2lkIDApO1xuUmVwZWF0ID0gX19kZWNvcmF0ZShbXG4gICAgdGVtcGxhdGVDb250cm9sbGVyKCdyZXBlYXQnKSxcbiAgICBfX3BhcmFtKDAsIElSZW5kZXJMb2NhdGlvbiksXG4gICAgX19wYXJhbSgxLCBJQ29udHJvbGxlciksXG4gICAgX19wYXJhbSgyLCBJVmlld0ZhY3RvcnkpXG5dLCBSZXBlYXQpO1xuZXhwb3J0IHsgUmVwZWF0IH07XG5sZXQgbWF4TGVuID0gMTY7XG5sZXQgcHJldkluZGljZXMgPSBuZXcgSW50MzJBcnJheShtYXhMZW4pO1xubGV0IHRhaWxJbmRpY2VzID0gbmV3IEludDMyQXJyYXkobWF4TGVuKTtcbi8vIEJhc2VkIG9uIGluZmVybm8ncyBsaXNfYWxnb3JpdGhtIEAgaHR0cHM6Ly9naXRodWIuY29tL2luZmVybm9qcy9pbmZlcm5vL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2luZmVybm8vc3JjL0RPTS9wYXRjaGluZy50cyNMNzMyXG4vLyB3aXRoIHNvbWUgdHdlYWtzIHRvIG1ha2UgaXQganVzdCBhIGJpdCBmYXN0ZXIgKyBhY2NvdW50IGZvciBJbmRleE1hcCAoYW5kIHNvbWUgbmFtZXMgY2hhbmdlcyBmb3IgcmVhZGFiaWxpdHkpXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gbG9uZ2VzdEluY3JlYXNpbmdTdWJzZXF1ZW5jZShpbmRleE1hcCkge1xuICAgIGNvbnN0IGxlbiA9IGluZGV4TWFwLmxlbmd0aDtcbiAgICBpZiAobGVuID4gbWF4TGVuKSB7XG4gICAgICAgIG1heExlbiA9IGxlbjtcbiAgICAgICAgcHJldkluZGljZXMgPSBuZXcgSW50MzJBcnJheShsZW4pO1xuICAgICAgICB0YWlsSW5kaWNlcyA9IG5ldyBJbnQzMkFycmF5KGxlbik7XG4gICAgfVxuICAgIGxldCBjdXJzb3IgPSAwO1xuICAgIGxldCBjdXIgPSAwO1xuICAgIGxldCBwcmV2ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gMDtcbiAgICBsZXQgbWlkID0gMDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGN1ciA9IGluZGV4TWFwW2ldO1xuICAgICAgICBpZiAoY3VyICE9PSAtMikge1xuICAgICAgICAgICAgaiA9IHByZXZJbmRpY2VzW2N1cnNvcl07XG4gICAgICAgICAgICBwcmV2ID0gaW5kZXhNYXBbal07XG4gICAgICAgICAgICBpZiAocHJldiAhPT0gLTIgJiYgcHJldiA8IGN1cikge1xuICAgICAgICAgICAgICAgIHRhaWxJbmRpY2VzW2ldID0gajtcbiAgICAgICAgICAgICAgICBwcmV2SW5kaWNlc1srK2N1cnNvcl0gPSBpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG93ID0gMDtcbiAgICAgICAgICAgIGhpZ2ggPSBjdXJzb3I7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICAgIG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgICAgIHByZXYgPSBpbmRleE1hcFtwcmV2SW5kaWNlc1ttaWRdXTtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gLTIgJiYgcHJldiA8IGN1cikge1xuICAgICAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gaW5kZXhNYXBbcHJldkluZGljZXNbbG93XV07XG4gICAgICAgICAgICBpZiAoY3VyIDwgcHJldiB8fCBwcmV2ID09PSAtMikge1xuICAgICAgICAgICAgICAgIGlmIChsb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhaWxJbmRpY2VzW2ldID0gcHJldkluZGljZXNbbG93IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZJbmRpY2VzW2xvd10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGkgPSArK2N1cnNvcjtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShpKTtcbiAgICBjdXIgPSBwcmV2SW5kaWNlc1tjdXJzb3IgLSAxXTtcbiAgICB3aGlsZSAoY3Vyc29yLS0gPiAwKSB7XG4gICAgICAgIHJlc3VsdFtjdXJzb3JdID0gY3VyO1xuICAgICAgICBjdXIgPSB0YWlsSW5kaWNlc1tjdXJdO1xuICAgIH1cbiAgICB3aGlsZSAoaS0tID4gMClcbiAgICAgICAgcHJldkluZGljZXNbaV0gPSAwO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0dWFsUHJvcGVydGllcyhvYywgaW5kZXgsIGxlbmd0aCkge1xuICAgIGNvbnN0IGlzRmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICBjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gbGVuZ3RoIC0gMTtcbiAgICBjb25zdCBpc0V2ZW4gPSBpbmRleCAlIDIgPT09IDA7XG4gICAgb2MuJGluZGV4ID0gaW5kZXg7XG4gICAgb2MuJGZpcnN0ID0gaXNGaXJzdDtcbiAgICBvYy4kbGFzdCA9IGlzTGFzdDtcbiAgICBvYy4kbWlkZGxlID0gIWlzRmlyc3QgJiYgIWlzTGFzdDtcbiAgICBvYy4kZXZlbiA9IGlzRXZlbjtcbiAgICBvYy4kb2RkID0gIWlzRXZlbjtcbiAgICBvYy4kbGVuZ3RoID0gbGVuZ3RoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgSUxvZ2dlciwgbmV4dElkLCBvblJlc29sdmUsIHJlc29sdmVBbGwsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdNb2RlLCBJT2JzZXJ2ZXJMb2NhdG9yLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgSVJlbmRlckxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IHRlbXBsYXRlQ29udHJvbGxlciB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgSVZpZXdGYWN0b3J5IH0gZnJvbSAnLi4vLi4vdGVtcGxhdGluZy92aWV3LmpzJztcbmltcG9ydCB7IGJpbmRhYmxlIH0gZnJvbSAnLi4vLi4vYmluZGFibGUuanMnO1xubGV0IFN3aXRjaCA9IGNsYXNzIFN3aXRjaCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNhc2VzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FzZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMga2VwdCBhcm91bmQgaGVyZSBzbyB0aGF0IGNoYW5nZXMgY2FuIGJlIGF3YWl0ZWQgZnJvbSB0aGUgdGVzdHMuXG4gICAgICAgICAqIFRoaXMgbmVlZHMgdG8gYmUgcmVtb3ZlZCBhZnRlciB0aGUgc2NoZWR1bGVyIGlzIHJlYWR5IHRvIGhhbmRsZS9xdWV1ZSB0aGUgZmxvYXRpbmcgcHJvbWlzZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb21pc2UgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxpbmsoZmxhZ3MsIF9wYXJlbnRDb250ZXh0LCBfY29udHJvbGxlciwgX2NoaWxkQ29udHJvbGxlciwgX3RhcmdldCwgX2luc3RydWN0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoZmxhZ3MsIHRoaXMuJGNvbnRyb2xsZXIpLnNldExvY2F0aW9uKHRoaXMubG9jYXRpb24pO1xuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgICAgIGNvbnN0ICRjb250cm9sbGVyID0gdGhpcy4kY29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5xdWV1ZSgoKSA9PiB2aWV3LmFjdGl2YXRlKGluaXRpYXRvciwgJGNvbnRyb2xsZXIsIGZsYWdzLCAkY29udHJvbGxlci5zY29wZSwgJGNvbnRyb2xsZXIuaG9zdFNjb3BlKSk7XG4gICAgICAgIHRoaXMucXVldWUoKCkgPT4gdGhpcy5zd2FwKGluaXRpYXRvciwgZmxhZ3MsIHRoaXMudmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG4gICAgZGV0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICB0aGlzLnF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciwgdGhpcy4kY29udHJvbGxlciwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy52aWV3Py5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmlldyA9ICh2b2lkIDApO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZWQoX25ld1ZhbHVlLCBfb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy4kY29udHJvbGxlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWUoKCkgPT4gdGhpcy5zd2FwKG51bGwsIGZsYWdzLCB0aGlzLnZhbHVlKSk7XG4gICAgfVxuICAgIGNhc2VDaGFuZ2VkKCRjYXNlLCBmbGFncykge1xuICAgICAgICB0aGlzLnF1ZXVlKCgpID0+IHRoaXMuaGFuZGxlQ2FzZUNoYW5nZSgkY2FzZSwgZmxhZ3MpKTtcbiAgICB9XG4gICAgaGFuZGxlQ2FzZUNoYW5nZSgkY2FzZSwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgaXNNYXRjaCA9ICRjYXNlLmlzTWF0Y2godGhpcy52YWx1ZSwgZmxhZ3MpO1xuICAgICAgICBjb25zdCBhY3RpdmVDYXNlcyA9IHRoaXMuYWN0aXZlQ2FzZXM7XG4gICAgICAgIGNvbnN0IG51bUFjdGl2ZUNhc2VzID0gYWN0aXZlQ2FzZXMubGVuZ3RoO1xuICAgICAgICAvLyBFYXJseSB0ZXJtaW5hdGlvbiAjMVxuICAgICAgICBpZiAoIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgIC8qKiBUaGUgcHJldmlvdXMgbWF0Y2ggc3RhcnRlZCB3aXRoIHRoaXM7IHRodXMgY2xlYXIuICovXG4gICAgICAgICAgICBpZiAobnVtQWN0aXZlQ2FzZXMgPiAwICYmIGFjdGl2ZUNhc2VzWzBdLmlkID09PSAkY2FzZS5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsZWFyQWN0aXZlQ2FzZXMobnVsbCwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGVyZSBhcmUgMiBkaWZmZXJlbnQgc2NlbmFyaW9zIGhlcmU6XG4gICAgICAgICAgICAgKiAxLiAkY2FzZSBpbiBhY3RpdmVDYXNlczogSW5kaWNhdGVzIGJ5LXByb2R1Y3Qgb2YgZmFsbHRocm91Z2guIFRoZSBzdGFydGluZyBjYXNlIHN0aWxsIHNhdGlzZmllcy4gUmV0dXJuLlxuICAgICAgICAgICAgICogMi4gJGNhc2Ugbm90IGluIGFjdGl2ZUNhc2VzOiBJdCB3YXMgcHJldmlvdXNseSBub3QgYWN0aXZlLCBhbmQgY3VycmVudGx5IGFsc28gbm90IGEgbWF0Y2guIFJldHVybi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uICMyXG4gICAgICAgIGlmIChudW1BY3RpdmVDYXNlcyA+IDAgJiYgYWN0aXZlQ2FzZXNbMF0uaWQgPCAkY2FzZS5pZCkge1xuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGlzIGNhc2Ugbm93IGEgbWF0Y2gsIHRoZSBwcmV2aW91cyBjYXNlIHN0aWxsIHdpbnMgYnkgYXMgdGhhdCBoYXMgbG93ZXIgb3JkaW5hbC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIHRoZSBuZXcgYWN0aXZlIGNhc2VzXG4gICAgICAgIGNvbnN0IG5ld0FjdGl2ZUNhc2VzID0gW107XG4gICAgICAgIGxldCBmYWxsVGhyb3VnaCA9ICRjYXNlLmZhbGxUaHJvdWdoO1xuICAgICAgICBpZiAoIWZhbGxUaHJvdWdoKSB7XG4gICAgICAgICAgICBuZXdBY3RpdmVDYXNlcy5wdXNoKCRjYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhc2VzID0gdGhpcy5jYXNlcztcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhc2VzLmluZGV4T2YoJGNhc2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGlkeCwgaWkgPSBjYXNlcy5sZW5ndGg7IGkgPCBpaSAmJiBmYWxsVGhyb3VnaDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNhc2VzW2ldO1xuICAgICAgICAgICAgICAgIG5ld0FjdGl2ZUNhc2VzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgZmFsbFRocm91Z2ggPSBjLmZhbGxUaHJvdWdoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5jbGVhckFjdGl2ZUNhc2VzKG51bGwsIGZsYWdzLCBuZXdBY3RpdmVDYXNlcyksICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FzZXMgPSBuZXdBY3RpdmVDYXNlcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlQ2FzZXMobnVsbCwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3dhcChpbml0aWF0b3IsIGZsYWdzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdBY3RpdmVDYXNlcyA9IFtdO1xuICAgICAgICBsZXQgZmFsbFRocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCAkY2FzZSBvZiB0aGlzLmNhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZmFsbFRocm91Z2ggfHwgJGNhc2UuaXNNYXRjaCh2YWx1ZSwgZmxhZ3MpKSB7XG4gICAgICAgICAgICAgICAgbmV3QWN0aXZlQ2FzZXMucHVzaCgkY2FzZSk7XG4gICAgICAgICAgICAgICAgZmFsbFRocm91Z2ggPSAkY2FzZS5mYWxsVGhyb3VnaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdBY3RpdmVDYXNlcy5sZW5ndGggPiAwICYmICFmYWxsVGhyb3VnaCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDYXNlID0gdGhpcy5kZWZhdWx0Q2FzZTtcbiAgICAgICAgaWYgKG5ld0FjdGl2ZUNhc2VzLmxlbmd0aCA9PT0gMCAmJiBkZWZhdWx0Q2FzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBuZXdBY3RpdmVDYXNlcy5wdXNoKGRlZmF1bHRDYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb25SZXNvbHZlKHRoaXMuYWN0aXZlQ2FzZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyB0aGlzLmNsZWFyQWN0aXZlQ2FzZXMoaW5pdGlhdG9yLCBmbGFncywgbmV3QWN0aXZlQ2FzZXMpXG4gICAgICAgICAgICA6IHZvaWQgMCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDYXNlcyA9IG5ld0FjdGl2ZUNhc2VzO1xuICAgICAgICAgICAgaWYgKG5ld0FjdGl2ZUNhc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlQ2FzZXMoaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY3RpdmF0ZUNhc2VzKGluaXRpYXRvciwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuJGNvbnRyb2xsZXI7XG4gICAgICAgIGlmICghY29udHJvbGxlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhc2VzID0gdGhpcy5hY3RpdmVDYXNlcztcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2FzZXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NvcGUgPSBjb250cm9sbGVyLnNjb3BlO1xuICAgICAgICBjb25zdCBob3N0U2NvcGUgPSBjb250cm9sbGVyLmhvc3RTY29wZTtcbiAgICAgICAgLy8gbW9zdCBjb21tb24gY2FzZVxuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZXNbMF0uYWN0aXZhdGUoaW5pdGlhdG9yLCBmbGFncywgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVBbGwoLi4uY2FzZXMubWFwKCgkY2FzZSkgPT4gJGNhc2UuYWN0aXZhdGUoaW5pdGlhdG9yLCBmbGFncywgc2NvcGUsIGhvc3RTY29wZSkpKTtcbiAgICB9XG4gICAgY2xlYXJBY3RpdmVDYXNlcyhpbml0aWF0b3IsIGZsYWdzLCBuZXdBY3RpdmVDYXNlcyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGNhc2VzID0gdGhpcy5hY3RpdmVDYXNlcztcbiAgICAgICAgY29uc3QgbnVtQ2FzZXMgPSBjYXNlcy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1DYXNlcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1DYXNlcyA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDYXNlID0gY2FzZXNbMF07XG4gICAgICAgICAgICBpZiAoIW5ld0FjdGl2ZUNhc2VzLmluY2x1ZGVzKGZpcnN0Q2FzZSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdENhc2UuZGVhY3RpdmF0ZShpbml0aWF0b3IsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb25SZXNvbHZlKHJlc29sdmVBbGwoLi4uY2FzZXMucmVkdWNlKChhY2MsICRjYXNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5ld0FjdGl2ZUNhc2VzLmluY2x1ZGVzKCRjYXNlKSkge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKCRjYXNlLmRlYWN0aXZhdGUoaW5pdGlhdG9yLCBmbGFncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pKSwgKCkgPT4ge1xuICAgICAgICAgICAgY2FzZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXVlKGFjdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91c1Byb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgICAgIGxldCBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5wcm9taXNlID0gb25SZXNvbHZlKG9uUmVzb2x2ZShwcmV2aW91c1Byb21pc2UsIGFjdGlvbiksICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb21pc2UgPT09IHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy4kY29udHJvbGxlci5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNhc2VzLnNvbWUoeCA9PiB4LmFjY2VwdCh2aXNpdG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBTd2l0Y2gucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5Td2l0Y2ggPSBfX2RlY29yYXRlKFtcbiAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ3N3aXRjaCcpLFxuICAgIF9fcGFyYW0oMCwgSVZpZXdGYWN0b3J5KSxcbiAgICBfX3BhcmFtKDEsIElSZW5kZXJMb2NhdGlvbilcbl0sIFN3aXRjaCk7XG5leHBvcnQgeyBTd2l0Y2ggfTtcbmxldCBDYXNlID0gY2xhc3MgQ2FzZSB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSwgbG9jYXRvciwgbG9jYXRpb24sIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5mYWxsVGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlYnVnID0gbG9nZ2VyLmNvbmZpZy5sZXZlbCA8PSAxIC8qIGRlYnVnICovO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlci5zY29wZVRvKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0tIyR7dGhpcy5pZH1gKTtcbiAgICAgICAgdGhpcy52aWV3ID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSgpLnNldExvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICB9XG4gICAgbGluayhmbGFncywgcGFyZW50Q29udGV4dCwgY29udHJvbGxlciwgX2NoaWxkQ29udHJvbGxlciwgX3RhcmdldCwgX2luc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHN3aXRjaENvbnRyb2xsZXIgPSBjb250cm9sbGVyLnBhcmVudDtcbiAgICAgICAgY29uc3QgJHN3aXRjaCA9IHN3aXRjaENvbnRyb2xsZXI/LnZpZXdNb2RlbDtcbiAgICAgICAgaWYgKCRzd2l0Y2ggaW5zdGFuY2VvZiBTd2l0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuJHN3aXRjaCA9ICRzd2l0Y2g7XG4gICAgICAgICAgICB0aGlzLmxpbmtUb1N3aXRjaCgkc3dpdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhcmVudCBzd2l0Y2ggbm90IGZvdW5kOyBvbmx5IGAqW3N3aXRjaF0gPiAqW2Nhc2V8ZGVmYXVsdC1jYXNlXWAgcmVsYXRpb24gaXMgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVhY3RpdmF0ZShpbml0aWF0b3IsIGZsYWdzKTtcbiAgICB9XG4gICAgaXNNYXRjaCh2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdpc01hdGNoKCknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSgkdmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IHRoaXMub2JzZXJ2ZUNvbGxlY3Rpb24oZmxhZ3MsICR2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHZhbHVlLmluY2x1ZGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHZhbHVlID09PSB2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWVDaGFuZ2VkKG5ld1ZhbHVlLCBfb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcj8udW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyID0gdGhpcy5vYnNlcnZlQ29sbGVjdGlvbihmbGFncywgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub2JzZXJ2ZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci51bnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzd2l0Y2guY2FzZUNoYW5nZWQodGhpcywgZmxhZ3MpO1xuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKF9pbmRleE1hcCwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy4kc3dpdGNoLmNhc2VDaGFuZ2VkKHRoaXMsIGZsYWdzKTtcbiAgICB9XG4gICAgYWN0aXZhdGUoaW5pdGlhdG9yLCBmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy52aWV3O1xuICAgICAgICBpZiAodmlldy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3LmFjdGl2YXRlKGluaXRpYXRvciA/PyB2aWV3LCB0aGlzLiRjb250cm9sbGVyLCBmbGFncywgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoaW5pdGlhdG9yLCBmbGFncykge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy52aWV3O1xuICAgICAgICBpZiAoIXZpZXcuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciA/PyB2aWV3LCB0aGlzLiRjb250cm9sbGVyLCBmbGFncyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXI/LnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB0aGlzLnZpZXc/LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKHZvaWQgMCk7XG4gICAgfVxuICAgIGxpbmtUb1N3aXRjaChhdVN3aXRjaCkge1xuICAgICAgICBhdVN3aXRjaC5jYXNlcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBvYnNlcnZlQ29sbGVjdGlvbihmbGFncywgJHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5sb2NhdG9yLmdldEFycmF5T2JzZXJ2ZXIoJHZhbHVlKTtcbiAgICAgICAgb2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250cm9sbGVyLmFjY2VwdCh2aXNpdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlldz8uYWNjZXB0KHZpc2l0b3IpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgQ2FzZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKHtcbiAgICAgICAgc2V0OiB2ID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RydWUnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdmYWxzZSc6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuICEhdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogQmluZGluZ01vZGUub25lVGltZVxuICAgIH0pXG5dLCBDYXNlLnByb3RvdHlwZSwgXCJmYWxsVGhyb3VnaFwiLCB2b2lkIDApO1xuQ2FzZSA9IF9fZGVjb3JhdGUoW1xuICAgIHRlbXBsYXRlQ29udHJvbGxlcignY2FzZScpLFxuICAgIF9fcGFyYW0oMCwgSVZpZXdGYWN0b3J5KSxcbiAgICBfX3BhcmFtKDEsIElPYnNlcnZlckxvY2F0b3IpLFxuICAgIF9fcGFyYW0oMiwgSVJlbmRlckxvY2F0aW9uKSxcbiAgICBfX3BhcmFtKDMsIElMb2dnZXIpXG5dLCBDYXNlKTtcbmV4cG9ydCB7IENhc2UgfTtcbmxldCBEZWZhdWx0Q2FzZSA9IGNsYXNzIERlZmF1bHRDYXNlIGV4dGVuZHMgQ2FzZSB7XG4gICAgbGlua1RvU3dpdGNoKCRzd2l0Y2gpIHtcbiAgICAgICAgaWYgKCRzd2l0Y2guZGVmYXVsdENhc2UgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBcXCdkZWZhdWx0LWNhc2VcXCdzIGFyZSBub3QgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAkc3dpdGNoLmRlZmF1bHRDYXNlID0gdGhpcztcbiAgICB9XG59O1xuRGVmYXVsdENhc2UgPSBfX2RlY29yYXRlKFtcbiAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ2RlZmF1bHQtY2FzZScpXG5dLCBEZWZhdWx0Q2FzZSk7XG5leHBvcnQgeyBEZWZhdWx0Q2FzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgbmV4dElkIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBJUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHsgSVZpZXdGYWN0b3J5IH0gZnJvbSAnLi4vLi4vdGVtcGxhdGluZy92aWV3LmpzJztcbmltcG9ydCB7IHRlbXBsYXRlQ29udHJvbGxlciB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tICcuLi8uLi9iaW5kYWJsZS5qcyc7XG5sZXQgV2l0aCA9IGNsYXNzIFdpdGgge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnksIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJZCgnYXUkY29tcG9uZW50Jyk7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SWQoJ2F1JGNvbXBvbmVudCcpO1xuICAgICAgICB0aGlzLnZpZXcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKCkuc2V0TG9jYXRpb24obG9jYXRpb24pO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAodGhpcy4kY29udHJvbGxlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGFkZCBsb2dpYyB0byB0aGUgY29udHJvbGxlciB0aGF0IGVuc3VyZXMgY29ycmVjdCBoYW5kbGluZyBvZiByYWNlIGNvbmRpdGlvbnMgYW5kIGFkZCBpbnRlZ3JhdGlvbiB0ZXN0c1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVZpZXcodGhpcy52aWV3LCAzMiAvKiBmcm9tQmluZCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZVZpZXcoaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciwgdGhpcy4kY29udHJvbGxlciwgZmxhZ3MpO1xuICAgIH1cbiAgICBhY3RpdmF0ZVZpZXcoaW5pdGlhdG9yLCBmbGFncykge1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyLCB2YWx1ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBTY29wZS5mcm9tUGFyZW50KCRjb250cm9sbGVyLnNjb3BlLCB2YWx1ZSA9PT0gdm9pZCAwID8ge30gOiB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuYWN0aXZhdGUoaW5pdGlhdG9yLCAkY29udHJvbGxlciwgZmxhZ3MsIHNjb3BlLCAkY29udHJvbGxlci5ob3N0U2NvcGUpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldz8uYWNjZXB0KHZpc2l0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgV2l0aC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbldpdGggPSBfX2RlY29yYXRlKFtcbiAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ3dpdGgnKSxcbiAgICBfX3BhcmFtKDAsIElWaWV3RmFjdG9yeSksXG4gICAgX19wYXJhbSgxLCBJUmVuZGVyTG9jYXRpb24pXG5dLCBXaXRoKTtcbmV4cG9ydCB7IFdpdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGguanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBESSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyB2YWx1ZUNvbnZlcnRlciB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuY29uc3QgU0NSSVBUX1JFR0VYID0gLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2k7XG5leHBvcnQgY29uc3QgSVNhbml0aXplciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVNhbml0aXplcicsIHggPT4geC5zaW5nbGV0b24oY2xhc3Mge1xuICAgIHNhbml0aXplKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKFNDUklQVF9SRUdFWCwgJycpO1xuICAgIH1cbn0pKTtcbi8qKlxuICogU2ltcGxlIGh0bWwgc2FuaXRpemF0aW9uIGNvbnZlcnRlciB0byBwcmVzZXJ2ZSB3aGl0ZWxpc3RlZCBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBvbiBhIGJvdW5kIHByb3BlcnR5IGNvbnRhaW5pbmcgaHRtbC5cbiAqL1xubGV0IFNhbml0aXplVmFsdWVDb252ZXJ0ZXIgPSBjbGFzcyBTYW5pdGl6ZVZhbHVlQ29udmVydGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzYW5pdGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIHByb3ZpZGVkIG1hcmt1cCB0aGF0IGZsb3dzIHRvIHRoZSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVudHJ1c3RlZE1hcmt1cCAtIFRoZSB1bnRydXN0ZWQgbWFya3VwIHRvIGJlIHNhbml0aXplZC5cbiAgICAgKi9cbiAgICB0b1ZpZXcodW50cnVzdGVkTWFya3VwKSB7XG4gICAgICAgIGlmICh1bnRydXN0ZWRNYXJrdXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2FuaXRpemVyLnNhbml0aXplKHVudHJ1c3RlZE1hcmt1cCk7XG4gICAgfVxufTtcblNhbml0aXplVmFsdWVDb252ZXJ0ZXIgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElTYW5pdGl6ZXIpXG5dLCBTYW5pdGl6ZVZhbHVlQ29udmVydGVyKTtcbmV4cG9ydCB7IFNhbml0aXplVmFsdWVDb252ZXJ0ZXIgfTtcbnZhbHVlQ29udmVydGVyKCdzYW5pdGl6ZScpKFNhbml0aXplVmFsdWVDb252ZXJ0ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FuaXRpemUuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBJVmlld0xvY2F0b3IgfSBmcm9tICcuLi8uLi90ZW1wbGF0aW5nL3ZpZXcuanMnO1xuaW1wb3J0IHsgdmFsdWVDb252ZXJ0ZXIgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmxldCBWaWV3VmFsdWVDb252ZXJ0ZXIgPSBjbGFzcyBWaWV3VmFsdWVDb252ZXJ0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXdMb2NhdG9yKSB7XG4gICAgICAgIHRoaXMudmlld0xvY2F0b3IgPSB2aWV3TG9jYXRvcjtcbiAgICB9XG4gICAgdG9WaWV3KG9iamVjdCwgdmlld05hbWVPclNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdMb2NhdG9yLmdldFZpZXdDb21wb25lbnRGb3JPYmplY3Qob2JqZWN0LCB2aWV3TmFtZU9yU2VsZWN0b3IpO1xuICAgIH1cbn07XG5WaWV3VmFsdWVDb252ZXJ0ZXIgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElWaWV3TG9jYXRvcilcbl0sIFZpZXdWYWx1ZUNvbnZlcnRlcik7XG5leHBvcnQgeyBWaWV3VmFsdWVDb252ZXJ0ZXIgfTtcbnZhbHVlQ29udmVydGVyKCd2aWV3JykoVmlld1ZhbHVlQ29udmVydGVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXcuanMubWFwIiwiaW1wb3J0IHsga2ViYWJDYXNlIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdNb2RlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5leHBvcnQgdmFyIFN5bWJvbEZsYWdzO1xuKGZ1bmN0aW9uIChTeW1ib2xGbGFncykge1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1widHlwZVwiXSA9IDEwMjNdID0gXCJ0eXBlXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJpc1RlbXBsYXRlQ29udHJvbGxlclwiXSA9IDFdID0gXCJpc1RlbXBsYXRlQ29udHJvbGxlclwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaXNQcm9qZWN0aW9uXCJdID0gMl0gPSBcImlzUHJvamVjdGlvblwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaXNDdXN0b21BdHRyaWJ1dGVcIl0gPSA0XSA9IFwiaXNDdXN0b21BdHRyaWJ1dGVcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImlzUGxhaW5BdHRyaWJ1dGVcIl0gPSA4XSA9IFwiaXNQbGFpbkF0dHJpYnV0ZVwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaXNDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJpc0N1c3RvbUVsZW1lbnRcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImlzTGV0RWxlbWVudFwiXSA9IDMyXSA9IFwiaXNMZXRFbGVtZW50XCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJpc1BsYWluRWxlbWVudFwiXSA9IDY0XSA9IFwiaXNQbGFpbkVsZW1lbnRcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImlzVGV4dFwiXSA9IDEyOF0gPSBcImlzVGV4dFwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaXNCaW5kaW5nXCJdID0gMjU2XSA9IFwiaXNCaW5kaW5nXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJpc0F1U2xvdFwiXSA9IDUxMl0gPSBcImlzQXVTbG90XCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJoYXNNYXJrZXJcIl0gPSAxMDI0XSA9IFwiaGFzTWFya2VyXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJoYXNUZW1wbGF0ZVwiXSA9IDIwNDhdID0gXCJoYXNUZW1wbGF0ZVwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaGFzQXR0cmlidXRlc1wiXSA9IDQwOTZdID0gXCJoYXNBdHRyaWJ1dGVzXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJoYXNCaW5kaW5nc1wiXSA9IDgxOTJdID0gXCJoYXNCaW5kaW5nc1wiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaGFzQ2hpbGROb2Rlc1wiXSA9IDE2Mzg0XSA9IFwiaGFzQ2hpbGROb2Rlc1wiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaGFzUHJvamVjdGlvbnNcIl0gPSAzMjc2OF0gPSBcImhhc1Byb2plY3Rpb25zXCI7XG59KShTeW1ib2xGbGFncyB8fCAoU3ltYm9sRmxhZ3MgPSB7fSkpO1xuZnVuY3Rpb24gY3JlYXRlTWFya2VyKHApIHtcbiAgICBjb25zdCBtYXJrZXIgPSBwLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1LW0nKTtcbiAgICBtYXJrZXIuY2xhc3NOYW1lID0gJ2F1JztcbiAgICByZXR1cm4gbWFya2VyO1xufVxuLyoqXG4gKiBBIGh0bWwgYXR0cmlidXRlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcmVnaXN0ZXJlZCByZXNvdXJjZSwgc3BlY2lmaWNhbGx5IGEgdGVtcGxhdGUgY29udHJvbGxlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlQ29udHJvbGxlclN5bWJvbCB7XG4gICAgY29uc3RydWN0b3IocCwgc3ludGF4LCBpbmZvLCByZXMgPSBpbmZvLm5hbWUpIHtcbiAgICAgICAgdGhpcy5zeW50YXggPSBzeW50YXg7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLmZsYWdzID0gMSAvKiBpc1RlbXBsYXRlQ29udHJvbGxlciAqLyB8IDEwMjQgLyogaGFzTWFya2VyICovO1xuICAgICAgICB0aGlzLnBoeXNpY2FsTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBjcmVhdGVNYXJrZXIocCk7XG4gICAgfVxuICAgIGdldCBiaW5kaW5ncygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JpbmRpbmdzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA4MTkyIC8qIGhhc0JpbmRpbmdzICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5ncztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJvamVjdGlvblN5bWJvbCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmZsYWdzID0gMiAvKiBpc1Byb2plY3Rpb24gKi87XG4gICAgfVxufVxuLyoqXG4gKiBBIGh0bWwgYXR0cmlidXRlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcmVnaXN0ZXJlZCByZXNvdXJjZSwgYnV0IG5vdCBhIHRlbXBsYXRlIGNvbnRyb2xsZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBDdXN0b21BdHRyaWJ1dGVTeW1ib2wge1xuICAgIGNvbnN0cnVjdG9yKHN5bnRheCwgaW5mbywgcmVzID0gaW5mby5uYW1lKSB7XG4gICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgdGhpcy5mbGFncyA9IDQgLyogaXNDdXN0b21BdHRyaWJ1dGUgKi87XG4gICAgICAgIHRoaXMuX2JpbmRpbmdzID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGJpbmRpbmdzKCkge1xuICAgICAgICBpZiAodGhpcy5fYmluZGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDgxOTIgLyogaGFzQmluZGluZ3MgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzO1xuICAgIH1cbn1cbi8qKlxuICogQW4gYXR0cmlidXRlLCB3aXRoIGVpdGhlciBhIGJpbmRpbmcgY29tbWFuZCBvciBhbiBpbnRlcnBvbGF0aW9uLCB3aG9zZSB0YXJnZXQgaXMgdGhlIGh0bWxcbiAqIGF0dHJpYnV0ZSBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBUaGlzIHdpbGwgbmV2ZXIgdGFyZ2V0IGEgYmluZGFibGUgcHJvcGVydHkgb2YgYSBjdXN0b20gYXR0cmlidXRlIG9yIGVsZW1lbnQ7XG4gKi9cbmV4cG9ydCBjbGFzcyBQbGFpbkF0dHJpYnV0ZVN5bWJvbCB7XG4gICAgY29uc3RydWN0b3Ioc3ludGF4LCBjb21tYW5kLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLmZsYWdzID0gOCAvKiBpc1BsYWluQXR0cmlidXRlICovO1xuICAgIH1cbn1cbi8qKlxuICogRWl0aGVyIGFuIGF0dHJpYnV0ZSBvbiBhbiBjdXN0b20gZWxlbWVudCB0aGF0IG1hcHMgdG8gYSBkZWNsYXJlZCBiaW5kYWJsZSBwcm9wZXJ0eSBvZiB0aGF0IGVsZW1lbnQsXG4gKiBhIHNpbmdsZS12YWx1ZSBib3VuZCBjdXN0b20gYXR0cmlidXRlLCBvciBvbmUgb2Ygc2V2ZXJhbCBiaW5kYWJsZXMgdGhhdCB3ZXJlIGV4dHJhY3RlZCBmcm9tIHRoZSBhdHRyaWJ1dGVcbiAqIHZhbHVlIG9mIGEgY3VzdG9tIGF0dHJpYnV0ZSB3aXRoIG11bHRpcGxlIGJpbmRpbmdzIHVzYWdlLlxuICpcbiAqIFRoaXMgd2lsbCBhbHdheXMgdGFyZ2V0IGEgYmluZGFibGUgcHJvcGVydHkgb2YgYSBjdXN0b20gYXR0cmlidXRlIG9yIGVsZW1lbnQ7XG4gKi9cbmV4cG9ydCBjbGFzcyBCaW5kaW5nU3ltYm9sIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCBiaW5kYWJsZSwgZXhwcmVzc2lvbiwgcmF3VmFsdWUsIHRhcmdldCkge1xuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICB0aGlzLmJpbmRhYmxlID0gYmluZGFibGU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMucmF3VmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAyNTYgLyogaXNCaW5kaW5nICovO1xuICAgIH1cbn1cbi8qKlxuICogQSBodG1sIGVsZW1lbnQgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHJlc291cmNlIGVpdGhlciB2aWEgaXRzIChsb3dlckNhc2UpIGBub2RlTmFtZWBcbiAqIG9yIHRoZSB2YWx1ZSBvZiBpdHMgYGFzLWVsZW1lbnRgIGF0dHJpYnV0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEN1c3RvbUVsZW1lbnRTeW1ib2wge1xuICAgIGNvbnN0cnVjdG9yKHAsIHBoeXNpY2FsTm9kZSwgaW5mbywgcmVzID0gaW5mby5uYW1lLCBiaW5kYWJsZXMgPSBpbmZvLmJpbmRhYmxlcykge1xuICAgICAgICB0aGlzLnBoeXNpY2FsTm9kZSA9IHBoeXNpY2FsTm9kZTtcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMuYmluZGFibGVzID0gYmluZGFibGVzO1xuICAgICAgICB0aGlzLmZsYWdzID0gMTYgLyogaXNDdXN0b21FbGVtZW50ICovO1xuICAgICAgICB0aGlzLmlzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXN0b21BdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGxhaW5BdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGlsZE5vZGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvamVjdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAoaW5mby5jb250YWluZXJsZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29udGFpbmVybGVzcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IGNyZWF0ZU1hcmtlcihwKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gMTAyNCAvKiBoYXNNYXJrZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29udGFpbmVybGVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXN0b21BdHRyaWJ1dGVzKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VzdG9tQXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY3VzdG9tQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0MDk2IC8qIGhhc0F0dHJpYnV0ZXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbUF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGdldCBwbGFpbkF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wbGFpbkF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYWluQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0MDk2IC8qIGhhc0F0dHJpYnV0ZXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWluQXR0cmlidXRlcztcbiAgICB9XG4gICAgZ2V0IGJpbmRpbmdzKCkge1xuICAgICAgICBpZiAodGhpcy5fYmluZGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDgxOTIgLyogaGFzQmluZGluZ3MgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzO1xuICAgIH1cbiAgICBnZXQgY2hpbGROb2RlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkTm9kZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gMTYzODQgLyogaGFzQ2hpbGROb2RlcyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGROb2RlcztcbiAgICB9XG4gICAgZ2V0IHByb2plY3Rpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvamVjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3Rpb25zID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDMyNzY4IC8qIGhhc1Byb2plY3Rpb25zICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0aW9ucztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGV0RWxlbWVudFN5bWJvbCB7XG4gICAgY29uc3RydWN0b3IocCwgcGh5c2ljYWxOb2RlLCBtYXJrZXIgPSBjcmVhdGVNYXJrZXIocCkpIHtcbiAgICAgICAgdGhpcy5waHlzaWNhbE5vZGUgPSBwaHlzaWNhbE5vZGU7XG4gICAgICAgIHRoaXMubWFya2VyID0gbWFya2VyO1xuICAgICAgICB0aGlzLmZsYWdzID0gMzIgLyogaXNMZXRFbGVtZW50ICovIHwgMTAyNCAvKiBoYXNNYXJrZXIgKi87XG4gICAgICAgIHRoaXMudG9CaW5kaW5nQ29udGV4dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IG51bGw7XG4gICAgfVxuICAgIGdldCBiaW5kaW5ncygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JpbmRpbmdzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA4MTkyIC8qIGhhc0JpbmRpbmdzICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5ncztcbiAgICB9XG59XG4vKipcbiAqIEEgbm9ybWFsIGh0bWwgZWxlbWVudCB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYXR0cmlidXRlIGJlaGF2aW9ycyBhbmQvb3IgY2hpbGQgbm9kZSBiZWhhdmlvcnMuXG4gKlxuICogSXQgaXMgcG9zc2libGUgZm9yIGEgUGxhaW5FbGVtZW50U3ltYm9sIHRvIG5vdCB5aWVsZCBhbnkgaW5zdHJ1Y3Rpb25zIGR1cmluZyBjb21waWxhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYWluRWxlbWVudFN5bWJvbCB7XG4gICAgY29uc3RydWN0b3IocGh5c2ljYWxOb2RlKSB7XG4gICAgICAgIHRoaXMucGh5c2ljYWxOb2RlID0gcGh5c2ljYWxOb2RlO1xuICAgICAgICB0aGlzLmZsYWdzID0gNjQgLyogaXNQbGFpbkVsZW1lbnQgKi87XG4gICAgICAgIHRoaXMuaXNUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1Nsb3RzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1c3RvbUF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wbGFpbkF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGlsZE5vZGVzID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGN1c3RvbUF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXN0b21BdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXN0b21BdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQwOTYgLyogaGFzQXR0cmlidXRlcyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tQXR0cmlidXRlcztcbiAgICB9XG4gICAgZ2V0IHBsYWluQXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYWluQXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGxhaW5BdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQwOTYgLyogaGFzQXR0cmlidXRlcyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGxhaW5BdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBnZXQgY2hpbGROb2RlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkTm9kZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gMTYzODQgLyogaGFzQ2hpbGROb2RlcyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGROb2RlcztcbiAgICB9XG59XG4vKipcbiAqIEEgc3RhbmRhbG9uZSB0ZXh0IG5vZGUgdGhhdCBoYXMgYW4gaW50ZXJwb2xhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRTeW1ib2wge1xuICAgIGNvbnN0cnVjdG9yKHAsIHBoeXNpY2FsTm9kZSwgaW50ZXJwb2xhdGlvbiwgbWFya2VyID0gY3JlYXRlTWFya2VyKHApKSB7XG4gICAgICAgIHRoaXMucGh5c2ljYWxOb2RlID0gcGh5c2ljYWxOb2RlO1xuICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgICAgICB0aGlzLm1hcmtlciA9IG1hcmtlcjtcbiAgICAgICAgdGhpcy5mbGFncyA9IDEyOCAvKiBpc1RleHQgKi8gfCAxMDI0IC8qIGhhc01hcmtlciAqLztcbiAgICB9XG59XG4vKipcbiAqIEEgcHJlLXByb2Nlc3NlZCBwaWVjZSBvZiBpbmZvcm1hdGlvbiBhYm91dCBhIGRlZmluZWQgYmluZGFibGUgcHJvcGVydHkgb24gYSBjdXN0b21cbiAqIGVsZW1lbnQgb3IgYXR0cmlidXRlLCBvcHRpbWl6ZWQgZm9yIGNvbnN1bXB0aW9uIGJ5IHRoZSB0ZW1wbGF0ZSBjb21waWxlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEJpbmRhYmxlSW5mbyB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIHByZS1wcm9jZXNzZWQgKnByb3BlcnR5KiAobm90IGF0dHJpYnV0ZSkgbmFtZSBvZiB0aGUgYmluZGFibGUsIHdoaWNoIGlzXG4gICAgICogKGluIG9yZGVyIG9mIHByaW9yaXR5KTpcbiAgICAgKlxuICAgICAqIDEuIFRoZSBgcHJvcGVydHlgIGZyb20gdGhlIGRlc2NyaXB0aW9uIChpZiBkZWZpbmVkKVxuICAgICAqIDIuIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBvZiB0aGUgYmluZGFibGUgaXRzZWxmXG4gICAgICovXG4gICAgcHJvcE5hbWUsIFxuICAgIC8qKlxuICAgICAqIFRoZSBwcmUtcHJvY2Vzc2VkIChkZWZhdWx0KSBiaW5kaW5nTW9kZSBvZiB0aGUgYmluZGFibGUsIHdoaWNoIGlzIChpbiBvcmRlciBvZiBwcmlvcml0eSk6XG4gICAgICpcbiAgICAgKiAxLiBUaGUgYG1vZGVgIGZyb20gdGhlIGJpbmRhYmxlIChpZiBkZWZpbmVkIGFuZCBub3QgYmluZGluZ01vZGUuZGVmYXVsdClcbiAgICAgKiAyLiBUaGUgYGRlZmF1bHRCaW5kaW5nTW9kZWAgKGlmIGl0J3MgYW4gYXR0cmlidXRlLCBkZWZpbmVkLCBhbmQgbm90IGJpbmRpbmdNb2RlLmRlZmF1bHQpXG4gICAgICogMy4gYGJpbmRpbmdNb2RlLnRvVmlld2BcbiAgICAgKi9cbiAgICBtb2RlKSB7XG4gICAgICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB9XG59XG5jb25zdCBlbGVtZW50SW5mb0xvb2t1cCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFByZS1wcm9jZXNzZWQgaW5mb3JtYXRpb24gYWJvdXQgYSBjdXN0b20gZWxlbWVudCByZXNvdXJjZSwgb3B0aW1pemVkXG4gKiBmb3IgY29uc3VtcHRpb24gYnkgdGhlIHRlbXBsYXRlIGNvbXBpbGVyLlxuICovXG5leHBvcnQgY2xhc3MgRWxlbWVudEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFsaWFzLCBjb250YWluZXJsZXNzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5jb250YWluZXJsZXNzID0gY29udGFpbmVybGVzcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbG9va3VwIG9mIHRoZSBiaW5kYWJsZXMgb2YgdGhpcyBlbGVtZW50LCBpbmRleGVkIGJ5IHRoZSAocHJlLXByb2Nlc3NlZClcbiAgICAgICAgICogYXR0cmlidXRlIG5hbWVzIGFzIHRoZXkgd291bGQgYmUgZm91bmQgaW4gcGFyc2VkIG1hcmt1cC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZGFibGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZGVmLCBhbGlhcykge1xuICAgICAgICBpZiAoZGVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjID0gZWxlbWVudEluZm9Mb29rdXAuZ2V0KGRlZik7XG4gICAgICAgIGlmIChyZWMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZWxlbWVudEluZm9Mb29rdXAuc2V0KGRlZiwgcmVjID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZm8gPSByZWNbYWxpYXNdO1xuICAgICAgICBpZiAoaW5mbyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpbmZvID0gcmVjW2FsaWFzXSA9IG5ldyBFbGVtZW50SW5mbyhkZWYubmFtZSwgYWxpYXMgPT09IGRlZi5uYW1lID8gdm9pZCAwIDogYWxpYXMsIGRlZi5jb250YWluZXJsZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRhYmxlcyA9IGRlZi5iaW5kYWJsZXM7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0QmluZGluZ01vZGUgPSBCaW5kaW5nTW9kZS50b1ZpZXc7XG4gICAgICAgICAgICBsZXQgYmluZGFibGU7XG4gICAgICAgICAgICBsZXQgcHJvcDtcbiAgICAgICAgICAgIGxldCBhdHRyO1xuICAgICAgICAgICAgbGV0IG1vZGU7XG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gYmluZGFibGVzKSB7XG4gICAgICAgICAgICAgICAgYmluZGFibGUgPSBiaW5kYWJsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgLy8gZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0eSBuYW1lIGhhcyBwcmlvcml0eSBvdmVyIHRoZSBpbXBsaWNpdCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKGJpbmRhYmxlLnByb3BlcnR5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGJpbmRhYmxlLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdGx5IHByb3ZpZGVkIGF0dHJpYnV0ZSBuYW1lIGhhcyBwcmlvcml0eSBvdmVyIHRoZSBkZXJpdmVkIGltcGxpY2l0IGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKGJpbmRhYmxlLmF0dHJpYnV0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBiaW5kYWJsZS5hdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGF0dHJpYnV0ZSBuYW1lIGZyb20gdGhlIHJlc29sdmVkIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGtlYmFiQ2FzZShwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRhYmxlLm1vZGUgIT09IHZvaWQgMCAmJiBiaW5kYWJsZS5tb2RlICE9PSBCaW5kaW5nTW9kZS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBiaW5kYWJsZS5tb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IGRlZmF1bHRCaW5kaW5nTW9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5mby5iaW5kYWJsZXNbYXR0cl0gPSBuZXcgQmluZGFibGVJbmZvKHByb3AsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbn1cbmNvbnN0IGF0dHJJbmZvTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogUHJlLXByb2Nlc3NlZCBpbmZvcm1hdGlvbiBhYm91dCBhIGN1c3RvbSBhdHRyaWJ1dGUgcmVzb3VyY2UsIG9wdGltaXplZFxuICogZm9yIGNvbnN1bXB0aW9uIGJ5IHRoZSB0ZW1wbGF0ZSBjb21waWxlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhbGlhcywgaXNUZW1wbGF0ZUNvbnRyb2xsZXIsIG5vTXVsdGlCaW5kaW5ncykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gICAgICAgIHRoaXMuaXNUZW1wbGF0ZUNvbnRyb2xsZXIgPSBpc1RlbXBsYXRlQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5ub011bHRpQmluZGluZ3MgPSBub011bHRpQmluZGluZ3M7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxvb2t1cCBvZiB0aGUgYmluZGFibGVzIG9mIHRoaXMgYXR0cmlidXRlLCBpbmRleGVkIGJ5IHRoZSAocHJlLXByb2Nlc3NlZClcbiAgICAgICAgICogYmluZGFibGUgbmFtZXMgYXMgdGhleSB3b3VsZCBiZSBmb3VuZCBpbiB0aGUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmx5IGFwcGxpY2FibGUgdG8gbXVsdGkgYXR0cmlidXRlIGJpbmRpbmdzIChzZW1pY29sb24tc2VwYXJhdGVkKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZGFibGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaW5nbGUgb3IgZmlyc3QgYmluZGFibGUgb2YgdGhpcyBhdHRyaWJ1dGUsIG9yIGEgZGVmYXVsdCAndmFsdWUnXG4gICAgICAgICAqIGJpbmRhYmxlIGlmIG5vIGJpbmRhYmxlcyB3ZXJlIGRlZmluZWQgb24gdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogT25seSBhcHBsaWNhYmxlIHRvIHNpbmdsZSBhdHRyaWJ1dGUgYmluZGluZ3MgKHdoZXJlIHRoZSBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgICogY29udGFpbnMgbm8gc2VtaWNvbG9ucylcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZGFibGUgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShkZWYsIGFsaWFzKSB7XG4gICAgICAgIGlmIChkZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWMgPSBhdHRySW5mb0xvb2t1cC5nZXQoZGVmKTtcbiAgICAgICAgaWYgKHJlYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBhdHRySW5mb0xvb2t1cC5zZXQoZGVmLCByZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5mbyA9IHJlY1thbGlhc107XG4gICAgICAgIGlmIChpbmZvID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGluZm8gPSByZWNbYWxpYXNdID0gbmV3IEF0dHJJbmZvKGRlZi5uYW1lLCBhbGlhcyA9PT0gZGVmLm5hbWUgPyB2b2lkIDAgOiBhbGlhcywgZGVmLmlzVGVtcGxhdGVDb250cm9sbGVyLCBkZWYubm9NdWx0aUJpbmRpbmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRhYmxlcyA9IGRlZi5iaW5kYWJsZXM7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0QmluZGluZ01vZGUgPSBkZWYuZGVmYXVsdEJpbmRpbmdNb2RlICE9PSB2b2lkIDAgJiYgZGVmLmRlZmF1bHRCaW5kaW5nTW9kZSAhPT0gQmluZGluZ01vZGUuZGVmYXVsdFxuICAgICAgICAgICAgICAgID8gZGVmLmRlZmF1bHRCaW5kaW5nTW9kZVxuICAgICAgICAgICAgICAgIDogQmluZGluZ01vZGUudG9WaWV3O1xuICAgICAgICAgICAgbGV0IGJpbmRhYmxlO1xuICAgICAgICAgICAgbGV0IHByb3A7XG4gICAgICAgICAgICBsZXQgbW9kZTtcbiAgICAgICAgICAgIGxldCBoYXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYmluZGFibGVJbmZvO1xuICAgICAgICAgICAgZm9yIChwcm9wIGluIGJpbmRhYmxlcykge1xuICAgICAgICAgICAgICAgIGJpbmRhYmxlID0gYmluZGFibGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydHkgbmFtZSBoYXMgcHJpb3JpdHkgb3ZlciB0aGUgaW1wbGljaXQgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIGlmIChiaW5kYWJsZS5wcm9wZXJ0eSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBiaW5kYWJsZS5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRhYmxlLm1vZGUgIT09IHZvaWQgMCAmJiBiaW5kYWJsZS5tb2RlICE9PSBCaW5kaW5nTW9kZS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBiaW5kYWJsZS5tb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IGRlZmF1bHRCaW5kaW5nTW9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNQcmltYXJ5ID0gYmluZGFibGUucHJpbWFyeSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBiaW5kYWJsZUluZm8gPSBpbmZvLmJpbmRhYmxlc1twcm9wXSA9IG5ldyBCaW5kYWJsZUluZm8ocHJvcCwgbW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmltYXJ5IGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uYmluZGFibGUgPSBiaW5kYWJsZUluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCB0byBmaXJzdCBiaW5kYWJsZSBieSBjb252ZW50aW9uXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uYmluZGFibGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5iaW5kYWJsZSA9IGJpbmRhYmxlSW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBubyBiaW5kYWJsZXMgYXJlIHByZXNlbnQsIGRlZmF1bHQgdG8gXCJ2YWx1ZVwiXG4gICAgICAgICAgICBpZiAoaW5mby5iaW5kYWJsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZm8uYmluZGFibGUgPSBuZXcgQmluZGFibGVJbmZvKCd2YWx1ZScsIGRlZmF1bHRCaW5kaW5nTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VtYW50aWMtbW9kZWwuanMubWFwIiwiaW1wb3J0IHsgY2FtZWxDYXNlLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBCaW5kaW5nTW9kZSwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IEJpbmRpbmdDb21tYW5kIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1jb21tYW5kLmpzJztcbmltcG9ydCB7IEN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudCB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50LmpzJztcbmltcG9ydCB7IEJpbmRpbmdTeW1ib2wsIEN1c3RvbUF0dHJpYnV0ZVN5bWJvbCwgQ3VzdG9tRWxlbWVudFN5bWJvbCwgTGV0RWxlbWVudFN5bWJvbCwgUGxhaW5BdHRyaWJ1dGVTeW1ib2wsIFBsYWluRWxlbWVudFN5bWJvbCwgVGVtcGxhdGVDb250cm9sbGVyU3ltYm9sLCBUZXh0U3ltYm9sLCBQcm9qZWN0aW9uU3ltYm9sLCBBdHRySW5mbywgRWxlbWVudEluZm8sIEJpbmRhYmxlSW5mbywgfSBmcm9tICcuL3NlbWFudGljLW1vZGVsLmpzJztcbmNvbnN0IGludmFsaWRTdXJyb2dhdGVBdHRyaWJ1dGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAnaWQnOiB0cnVlLFxuICAgICdhdS1zbG90JzogdHJ1ZSxcbn0pO1xuY29uc3QgYXR0cmlidXRlc1RvSWdub3JlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJ2FzLWVsZW1lbnQnOiB0cnVlLFxufSk7XG5mdW5jdGlvbiBoYXNJbmxpbmVCaW5kaW5ncyhyYXdWYWx1ZSkge1xuICAgIGNvbnN0IGxlbiA9IHJhd1ZhbHVlLmxlbmd0aDtcbiAgICBsZXQgY2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgY2ggPSByYXdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IDkyIC8qIEJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgLy8gSWdub3JlIHdoYXRldmVyIGNvbWVzIG5leHQgYmVjYXVzZSBpdCdzIGVzY2FwZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gNTggLyogQ29sb24gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAzNiAvKiBEb2xsYXIgKi8gJiYgcmF3VmFsdWUuY2hhckNvZGVBdChpICsgMSkgPT09IDEyMyAvKiBPcGVuQnJhY2UgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcm9jZXNzSW50ZXJwb2xhdGlvblRleHQoc3ltYm9sKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN5bWJvbC5waHlzaWNhbE5vZGU7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAobm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCAmJiBub2RlLm5leHRTaWJsaW5nLm5vZGVUeXBlID09PSAzIC8qIFRleHQgKi8pIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlLm5leHRTaWJsaW5nKTtcbiAgICB9XG4gICAgbm9kZS50ZXh0Q29udGVudCA9ICcnO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN5bWJvbC5tYXJrZXIsIG5vZGUpO1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZUNvbnRyb2xsZXJPZihwcm94eSwgbWFuaWZlc3QpIHtcbiAgICByZXR1cm4gcHJveHkgIT09IG1hbmlmZXN0O1xufVxuLyoqXG4gKiBBICh0ZW1wb3JhcnkpIHN0YW5kYWxvbmUgZnVuY3Rpb24gdGhhdCBwdXJlbHkgZG9lcyB0aGUgRE9NIHByb2Nlc3NpbmcgKGxpZnRpbmcpIHJlbGF0ZWQgdG8gdGVtcGxhdGUgY29udHJvbGxlcnMuXG4gKiBJdCdzIGEgZmlyc3QgcmVmYWN0b3Jpbmcgc3RlcCB0b3dhcmRzIHNlcGFyYXRpbmcgRE9NIHBhcnNpbmcvYmluZGluZyBmcm9tIG11dGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1RlbXBsYXRlQ29udHJvbGxlcnMocCwgbWFuaWZlc3RQcm94eSwgbWFuaWZlc3QpIHtcbiAgICBjb25zdCBtYW5pZmVzdE5vZGUgPSBtYW5pZmVzdC5waHlzaWNhbE5vZGU7XG4gICAgbGV0IGN1cnJlbnQgPSBtYW5pZmVzdFByb3h5O1xuICAgIGxldCBjdXJyZW50VGVtcGxhdGU7XG4gICAgd2hpbGUgKGlzVGVtcGxhdGVDb250cm9sbGVyT2YoY3VycmVudCwgbWFuaWZlc3QpKSB7XG4gICAgICAgIGlmIChjdXJyZW50LnRlbXBsYXRlID09PSBtYW5pZmVzdCkge1xuICAgICAgICAgICAgLy8gdGhlIERPTSBsaW5rYWdlIGlzIHN0aWxsIGluIGl0cyBvcmlnaW5hbCBzdGF0ZSBoZXJlIHNvIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoZSBwYXJlbnROb2RlIGlzIG5vbi1udWxsXG4gICAgICAgICAgICBtYW5pZmVzdE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY3VycmVudC5tYXJrZXIsIG1hbmlmZXN0Tm9kZSk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbWFuaWZlc3QgaXMgYSB0ZW1wbGF0ZSBlbGVtZW50IChlLmcuIDx0ZW1wbGF0ZSByZXBlYXQuZm9yPVwiLi4uXCI+KSB0aGVuIHdlIGNhbiBza2lwIG9uZSBsaWZ0IG9wZXJhdGlvblxuICAgICAgICAgICAgLy8gYW5kIHNpbXBseSB1c2UgdGhlIHRlbXBsYXRlIGRpcmVjdGx5LCBzYXZpbmcgYSBiaXQgb2Ygd29ya1xuICAgICAgICAgICAgaWYgKG1hbmlmZXN0Tm9kZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucGh5c2ljYWxOb2RlID0gbWFuaWZlc3ROb2RlO1xuICAgICAgICAgICAgICAgIC8vIHRoZSB0ZW1wbGF0ZSBjb3VsZCBzYWZlbHkgc3RheSB3aXRob3V0IGFmZmVjdGluZyBhbnl0aGluZyB2aXNpYmxlLCBidXQgbGV0J3Mga2VlcCB0aGUgRE9NIHRpZHlcbiAgICAgICAgICAgICAgICBtYW5pZmVzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFuaWZlc3QgaXMgbm90IGEgdGVtcGxhdGUgZWxlbWVudCBzbyB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gb25lXG4gICAgICAgICAgICAgICAgY3VycmVudFRlbXBsYXRlID0gY3VycmVudC5waHlzaWNhbE5vZGUgPSBwLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQobWFuaWZlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRUZW1wbGF0ZSA9IGN1cnJlbnQucGh5c2ljYWxOb2RlID0gcC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgY3VycmVudFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoY3VycmVudC5tYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIG1hbmlmZXN0Tm9kZS5yZW1vdmVBdHRyaWJ1dGUoY3VycmVudC5zeW50YXgucmF3TmFtZSk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnRlbXBsYXRlO1xuICAgIH1cbn1cbi8qKlxuICogVGVtcGxhdGVCaW5kZXIuIFRvZG86IGRlc2NyaWJlIGdvYWwgb2YgdGhpcyBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVCaW5kZXIge1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtLCBjb250YWluZXIsIGF0dHJQYXJzZXIsIGV4cHJQYXJzZXIsIGF0dHJTeW50YXhUcmFuc2Zvcm1lcikge1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmF0dHJQYXJzZXIgPSBhdHRyUGFyc2VyO1xuICAgICAgICB0aGlzLmV4cHJQYXJzZXIgPSBleHByUGFyc2VyO1xuICAgICAgICB0aGlzLmF0dHJTeW50YXhUcmFuc2Zvcm1lciA9IGF0dHJTeW50YXhUcmFuc2Zvcm1lcjtcbiAgICAgICAgdGhpcy5jb21tYW5kTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgYmluZChub2RlKSB7XG4gICAgICAgIGNvbnN0IHN1cnJvZ2F0ZSA9IG5ldyBQbGFpbkVsZW1lbnRTeW1ib2wobm9kZSk7XG4gICAgICAgIGNvbnN0IGF0dHJTeW50YXhUcmFuc2Zvcm1lciA9IHRoaXMuYXR0clN5bnRheFRyYW5zZm9ybWVyO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgYXR0clN5bnRheCA9IHRoaXMuYXR0clBhcnNlci5wYXJzZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGludmFsaWRTdXJyb2dhdGVBdHRyaWJ1dGVbYXR0clN5bnRheC50YXJnZXRdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN1cnJvZ2F0ZSBhdHRyaWJ1dGU6ICR7YXR0clN5bnRheC50YXJnZXR9YCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdXNlIHJlcG9ydGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nQ29tbWFuZCA9IHRoaXMuZ2V0QmluZGluZ0NvbW1hbmQoYXR0clN5bnRheCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoYmluZGluZ0NvbW1hbmQgPT09IG51bGwgfHwgKGJpbmRpbmdDb21tYW5kLmJpbmRpbmdUeXBlICYgNDA5NiAvKiBJZ25vcmVDdXN0b21BdHRyICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJJbmZvID0gQXR0ckluZm8uZnJvbSh0aGlzLmNvbnRhaW5lci5maW5kKEN1c3RvbUF0dHJpYnV0ZSwgYXR0clN5bnRheC50YXJnZXQpLCBhdHRyU3ludGF4LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcCBzcGVjaWFsIGh0bWwgYXR0cmlidXRlcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgYXR0clN5bnRheFRyYW5zZm9ybWVyLnRyYW5zZm9ybShub2RlLCBhdHRyU3ludGF4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgYSBjdXN0b20gYXR0cmlidXRlIGJ1dCBtaWdodCBiZSBhIHJlZ3VsYXIgYm91bmQgYXR0cmlidXRlIG9yIGludGVycG9sYXRpb24gKGl0IG1pZ2h0IGFsc28gYmUgbm90aGluZylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kUGxhaW5BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJTeW50YXggKi8gYXR0clN5bnRheCwgXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHIgICAgICAgKi8gYXR0ciwgXG4gICAgICAgICAgICAgICAgICAgIC8qIHN1cnJvZ2F0ZSAgKi8gc3Vycm9nYXRlLCBcbiAgICAgICAgICAgICAgICAgICAgLyogbWFuaWZlc3QgICAqLyBzdXJyb2dhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRySW5mby5pc1RlbXBsYXRlQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIHRlbXBsYXRlIGNvbnRyb2xsZXIgb24gc3Vycm9nYXRlIGVsZW1lbnQuJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHVzZSByZXBvcnRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kQ3VzdG9tQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAvKiBhdHRyU3ludGF4ICovIGF0dHJTeW50YXgsIFxuICAgICAgICAgICAgICAgICAgICAvKiBhdHRySW5mbyAgICovIGF0dHJJbmZvLCBcbiAgICAgICAgICAgICAgICAgICAgLyogY29tbWFuZCAgICAqLyBiaW5kaW5nQ29tbWFuZCwgXG4gICAgICAgICAgICAgICAgICAgIC8qIG1hbmlmZXN0ICAgKi8gc3Vycm9nYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYXAgc3BlY2lhbCBodG1sIGF0dHJpYnV0ZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgYXR0clN5bnRheFRyYW5zZm9ybWVyLnRyYW5zZm9ybShub2RlLCBhdHRyU3ludGF4KTtcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBhIGN1c3RvbSBhdHRyaWJ1dGUgYnV0IG1pZ2h0IGJlIGEgcmVndWxhciBib3VuZCBhdHRyaWJ1dGUgb3IgaW50ZXJwb2xhdGlvbiAoaXQgbWlnaHQgYWxzbyBiZSBub3RoaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuYmluZFBsYWluQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgIC8qIGF0dHJTeW50YXggKi8gYXR0clN5bnRheCwgXG4gICAgICAgICAgICAgICAgLyogYXR0ciAgICAgICAqLyBhdHRyLCBcbiAgICAgICAgICAgICAgICAvKiBzdXJyb2dhdGUgICovIHN1cnJvZ2F0ZSwgXG4gICAgICAgICAgICAgICAgLyogbWFuaWZlc3QgICAqLyBzdXJyb2dhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZENoaWxkTm9kZXMoXG4gICAgICAgIC8qIG5vZGUgICAgICAgICAgICAgICAqLyBub2RlLCBcbiAgICAgICAgLyogc3Vycm9nYXRlICAgICAgICAgICovIHN1cnJvZ2F0ZSwgXG4gICAgICAgIC8qIG1hbmlmZXN0ICAgICAgICAgICAqLyBzdXJyb2dhdGUsIFxuICAgICAgICAvKiBtYW5pZmVzdFJvb3QgICAgICAgKi8gbnVsbCwgXG4gICAgICAgIC8qIHBhcmVudE1hbmlmZXN0Um9vdCAqLyBudWxsKTtcbiAgICAgICAgcmV0dXJuIHN1cnJvZ2F0ZTtcbiAgICB9XG4gICAgYmluZE1hbmlmZXN0KHBhcmVudE1hbmlmZXN0LCBub2RlLCBzdXJyb2dhdGUsIG1hbmlmZXN0LCBtYW5pZmVzdFJvb3QsIHBhcmVudE1hbmlmZXN0Um9vdCkge1xuICAgICAgICBsZXQgaXNBdVNsb3QgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChub2RlLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdMRVQnOlxuICAgICAgICAgICAgICAgIC8vIGxldCBjYW5ub3QgaGF2ZSBjaGlsZHJlbiBhbmQgaGFzIHNvbWUgZGlmZmVyZW50IHByb2Nlc3NpbmcgcnVsZXMsIHNvIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIHRoaXMuYmluZExldEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgLyogcGFyZW50TWFuaWZlc3QgKi8gcGFyZW50TWFuaWZlc3QsIFxuICAgICAgICAgICAgICAgIC8qIG5vZGUgICAgICAgICAgICovIG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ1NMT1QnOlxuICAgICAgICAgICAgICAgIHN1cnJvZ2F0ZS5oYXNTbG90cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBVS1TTE9UJzpcbiAgICAgICAgICAgICAgICBpc0F1U2xvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnYXMtZWxlbWVudCcpO1xuICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50SW5mbyA9IEVsZW1lbnRJbmZvLmZyb20odGhpcy5jb250YWluZXIuZmluZChDdXN0b21FbGVtZW50LCBuYW1lKSwgbmFtZSk7XG4gICAgICAgIGlmIChlbGVtZW50SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjdXN0b20gZWxlbWVudCB3aXRoIHRoaXMgbmFtZVxuICAgICAgICAgICAgbWFuaWZlc3QgPSBuZXcgUGxhaW5FbGVtZW50U3ltYm9sKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaXQncyBhIGN1c3RvbSBlbGVtZW50IHNvIHdlIHNldCB0aGUgbWFuaWZlc3RSb290IGFzIHdlbGwgKGZvciBzdG9yaW5nIHJlcGxhY2VzKVxuICAgICAgICAgICAgcGFyZW50TWFuaWZlc3RSb290ID0gbWFuaWZlc3RSb290O1xuICAgICAgICAgICAgY29uc3QgY2VTeW1ib2wgPSBuZXcgQ3VzdG9tRWxlbWVudFN5bWJvbCh0aGlzLnBsYXRmb3JtLCBub2RlLCBlbGVtZW50SW5mbyk7XG4gICAgICAgICAgICBpZiAoaXNBdVNsb3QpIHtcbiAgICAgICAgICAgICAgICBjZVN5bWJvbC5mbGFncyA9IDUxMiAvKiBpc0F1U2xvdCAqLztcbiAgICAgICAgICAgICAgICBjZVN5bWJvbC5zbG90TmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA/PyBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hbmlmZXN0Um9vdCA9IG1hbmlmZXN0ID0gY2VTeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGlmdGluZyBvcGVyYXRpb25zIGRvbmUgYnkgdGVtcGxhdGUgY29udHJvbGxlcnMgYW5kIHJlcGxhY2VzIGVmZmVjdGl2ZWx5IHVubGluayB0aGUgbm9kZXMsIHNvIHN0YXJ0IGF0IHRoZSBib3R0b21cbiAgICAgICAgdGhpcy5iaW5kQ2hpbGROb2RlcyhcbiAgICAgICAgLyogbm9kZSAgICAgICAgICAgICAgICovIG5vZGUsIFxuICAgICAgICAvKiBzdXJyb2dhdGUgICAgICAgICAgKi8gc3Vycm9nYXRlLCBcbiAgICAgICAgLyogbWFuaWZlc3QgICAgICAgICAgICovIG1hbmlmZXN0LCBcbiAgICAgICAgLyogbWFuaWZlc3RSb290ICAgICAgICovIG1hbmlmZXN0Um9vdCwgXG4gICAgICAgIC8qIHBhcmVudE1hbmlmZXN0Um9vdCAqLyBwYXJlbnRNYW5pZmVzdFJvb3QpO1xuICAgICAgICAvLyB0aGUgcGFyZW50TWFuaWZlc3Qgd2lsbCByZWNlaXZlIGVpdGhlciB0aGUgZGlyZWN0IGNoaWxkIG5vZGVzLCBvciB0aGUgdGVtcGxhdGUgY29udHJvbGxlcnMgLyByZXBsYWNlc1xuICAgICAgICAvLyB3cmFwcGluZyB0aGVtXG4gICAgICAgIHRoaXMuYmluZEF0dHJpYnV0ZXMoXG4gICAgICAgIC8qIG5vZGUgICAgICAgICAgICAgICAqLyBub2RlLCBcbiAgICAgICAgLyogcGFyZW50TWFuaWZlc3QgICAgICovIHBhcmVudE1hbmlmZXN0LCBcbiAgICAgICAgLyogc3Vycm9nYXRlICAgICAgICAgICovIHN1cnJvZ2F0ZSwgXG4gICAgICAgIC8qIG1hbmlmZXN0ICAgICAgICAgICAqLyBtYW5pZmVzdCwgXG4gICAgICAgIC8qIG1hbmlmZXN0Um9vdCAgICAgICAqLyBtYW5pZmVzdFJvb3QsIFxuICAgICAgICAvKiBwYXJlbnRNYW5pZmVzdFJvb3QgKi8gcGFyZW50TWFuaWZlc3RSb290KTtcbiAgICAgICAgaWYgKG1hbmlmZXN0Um9vdCA9PT0gbWFuaWZlc3QgJiYgbWFuaWZlc3QuaXNDb250YWluZXJsZXNzKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1hbmlmZXN0Lm1hcmtlciwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFuaWZlc3QuaXNUYXJnZXQpIHtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYXUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kTGV0RWxlbWVudChwYXJlbnRNYW5pZmVzdCwgbm9kZSkge1xuICAgICAgICBjb25zdCBzeW1ib2wgPSBuZXcgTGV0RWxlbWVudFN5bWJvbCh0aGlzLnBsYXRmb3JtLCBub2RlKTtcbiAgICAgICAgcGFyZW50TWFuaWZlc3QuY2hpbGROb2Rlcy5wdXNoKHN5bWJvbCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSAndG8tYmluZGluZy1jb250ZXh0Jykge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd0by1iaW5kaW5nLWNvbnRleHQnKTtcbiAgICAgICAgICAgICAgICBzeW1ib2wudG9CaW5kaW5nQ29udGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdHRyU3ludGF4ID0gdGhpcy5hdHRyUGFyc2VyLnBhcnNlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5nZXRCaW5kaW5nQ29tbWFuZChhdHRyU3ludGF4LCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nVHlwZSA9IGNvbW1hbmQgPT09IG51bGwgPyAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8gOiBjb21tYW5kLmJpbmRpbmdUeXBlO1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZXhwclBhcnNlci5wYXJzZShhdHRyU3ludGF4LnJhd1ZhbHVlLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICBjb25zdCB0byA9IGNhbWVsQ2FzZShhdHRyU3ludGF4LnRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gbmV3IEJpbmRhYmxlSW5mbyh0bywgQmluZGluZ01vZGUudG9WaWV3KTtcbiAgICAgICAgICAgIHN5bWJvbC5iaW5kaW5ncy5wdXNoKG5ldyBCaW5kaW5nU3ltYm9sKGNvbW1hbmQsIGluZm8sIGV4cHIsIGF0dHJTeW50YXgucmF3VmFsdWUsIHRvKSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzeW1ib2wubWFya2VyLCBub2RlKTtcbiAgICB9XG4gICAgYmluZEF0dHJpYnV0ZXMobm9kZSwgcGFyZW50TWFuaWZlc3QsIHN1cnJvZ2F0ZSwgbWFuaWZlc3QsIG1hbmlmZXN0Um9vdCwgcGFyZW50TWFuaWZlc3RSb290KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHRvcC1sZXZlbCBzeW1ib2wgZm9yIHRoZSBjdXJyZW50IGRlcHRoLlxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gdGVtcGxhdGUgY29udHJvbGxlcnMgb3IgcmVwbGFjZXMsIGl0IGlzIGFsd2F5cyB0aGUgbWFuaWZlc3QgaXRzZWxmLlxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgdGVtcGxhdGUgY29udHJvbGxlcnMsIHRoZW4gdGhpcyB3aWxsIGJlIHRoZSBvdXRlci1tb3N0IFRlbXBsYXRlQ29udHJvbGxlclN5bWJvbC5cbiAgICAgICAgbGV0IG1hbmlmZXN0UHJveHkgPSBtYW5pZmVzdDtcbiAgICAgICAgbGV0IHByZXZpb3VzQ29udHJvbGxlciA9ICh2b2lkIDApO1xuICAgICAgICBsZXQgY3VycmVudENvbnRyb2xsZXIgPSAodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzVG9JZ25vcmVbYXR0ci5uYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0clN5bnRheCA9IHRoaXMuYXR0clBhcnNlci5wYXJzZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgYmluZGluZ0NvbW1hbmQgPSB0aGlzLmdldEJpbmRpbmdDb21tYW5kKGF0dHJTeW50YXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGJpbmRpbmdDb21tYW5kID09PSBudWxsIHx8IChiaW5kaW5nQ29tbWFuZC5iaW5kaW5nVHlwZSAmIDQwOTYgLyogSWdub3JlQ3VzdG9tQXR0ciAqLykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRySW5mbyA9IEF0dHJJbmZvLmZyb20odGhpcy5jb250YWluZXIuZmluZChDdXN0b21BdHRyaWJ1dGUsIGF0dHJTeW50YXgudGFyZ2V0KSwgYXR0clN5bnRheC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRySW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXAgc3BlY2lhbCBodG1sIGF0dHJpYnV0ZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0clN5bnRheFRyYW5zZm9ybWVyLnRyYW5zZm9ybShub2RlLCBhdHRyU3ludGF4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgYSBjdXN0b20gYXR0cmlidXRlIGJ1dCBtaWdodCBiZSBhIHJlZ3VsYXIgYm91bmQgYXR0cmlidXRlIG9yIGludGVycG9sYXRpb24gKGl0IG1pZ2h0IGFsc28gYmUgbm90aGluZylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kUGxhaW5BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJTeW50YXggKi8gYXR0clN5bnRheCwgXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHIgICAgICAgKi8gYXR0ciwgXG4gICAgICAgICAgICAgICAgICAgIC8qIHN1cnJvZ2F0ZSAgKi8gc3Vycm9nYXRlLCBcbiAgICAgICAgICAgICAgICAgICAgLyogbWFuaWZlc3QgICAqLyBtYW5pZmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHJJbmZvLmlzVGVtcGxhdGVDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYW5pZmVzdCBpcyB3cmFwcGVkIGJ5IHRoZSBpbm5lci1tb3N0IHRlbXBsYXRlIGNvbnRyb2xsZXIgKGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBvbiB0aGUgc2FtZSBlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBrZWVwIHNldHRpbmcgbWFuaWZlc3QudGVtcGxhdGVDb250cm9sbGVyIHRvIHRoZSBsYXRlc3QgdGVtcGxhdGUgY29udHJvbGxlciB3ZSBmaW5kXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyID0gbWFuaWZlc3QudGVtcGxhdGVDb250cm9sbGVyID0gdGhpcy5kZWNsYXJlVGVtcGxhdGVDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgICAvKiBhdHRyU3ludGF4ICovIGF0dHJTeW50YXgsIFxuICAgICAgICAgICAgICAgICAgICAvKiBhdHRySW5mbyAgICovIGF0dHJJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3h5IGFuZCB0aGUgbWFuaWZlc3QgYXJlIG9ubHkgaWRlbnRpY2FsIHdoZW4gd2UncmUgYXQgdGhlIGZpcnN0IHRlbXBsYXRlIGNvbnRyb2xsZXIgKHNpbmNlIHRoZSBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFzc2lnbmVkIHRvIHRoZSBwcm94eSksIHNvIHRoaXMgZXZhbHVhdGVzIHRvIHRydWUgYXQgbW9zdCBvbmNlIHBlciBub2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW5pZmVzdFByb3h5ID09PSBtYW5pZmVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudGVtcGxhdGUgPSBtYW5pZmVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0UHJveHkgPSBjdXJyZW50Q29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnRlbXBsYXRlQ29udHJvbGxlciA9IHByZXZpb3VzQ29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnRlbXBsYXRlID0gcHJldmlvdXNDb250cm9sbGVyLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDb250cm9sbGVyLnRlbXBsYXRlID0gY3VycmVudENvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDb250cm9sbGVyID0gY3VycmVudENvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHJlZ3VsYXIgY3VzdG9tIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRDdXN0b21BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJTeW50YXggKi8gYXR0clN5bnRheCwgXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJJbmZvICAgKi8gYXR0ckluZm8sIFxuICAgICAgICAgICAgICAgICAgICAvKiBjb21tYW5kICAgICovIGJpbmRpbmdDb21tYW5kLCBcbiAgICAgICAgICAgICAgICAgICAgLyogbWFuaWZlc3QgICAqLyBtYW5pZmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbWFwIHNwZWNpYWwgaHRtbCBhdHRyaWJ1dGVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0clN5bnRheFRyYW5zZm9ybWVyLnRyYW5zZm9ybShub2RlLCBhdHRyU3ludGF4KTtcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBhIGN1c3RvbSBhdHRyaWJ1dGUgYnV0IG1pZ2h0IGJlIGEgcmVndWxhciBib3VuZCBhdHRyaWJ1dGUgb3IgaW50ZXJwb2xhdGlvbiAoaXQgbWlnaHQgYWxzbyBiZSBub3RoaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuYmluZFBsYWluQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgIC8qIGF0dHJTeW50YXggKi8gYXR0clN5bnRheCwgXG4gICAgICAgICAgICAgICAgLyogYXR0ciAgICAgICAqLyBhdHRyLCBcbiAgICAgICAgICAgICAgICAvKiBzdXJyb2dhdGUgICovIHN1cnJvZ2F0ZSwgXG4gICAgICAgICAgICAgICAgLyogbWFuaWZlc3QgICAqLyBtYW5pZmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUF0dHJpYnV0ZU9yZGVyKG1hbmlmZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvamVjdGlvbiA9IG5vZGUuZ2V0QXR0cmlidXRlKCdhdS1zbG90Jyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uID09PSAnJykge1xuICAgICAgICAgICAgcHJvamVjdGlvbiA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNQcm9qZWN0aW9uID0gcHJvamVjdGlvbiAhPT0gbnVsbDtcbiAgICAgICAgaWYgKGhhc1Byb2plY3Rpb24gJiYgaXNUZW1wbGF0ZUNvbnRyb2xsZXJPZihtYW5pZmVzdFByb3h5LCBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIDxzb21lLWVsIGF1LXNsb3QgVEVNUExBVEUuQ09OVFJPTExFUj48L3NvbWUtZWw+LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1c2FnZSBvZiBbYXUtc2xvdD1cIiR7cHJvamVjdGlvbn1cIl0gYWxvbmcgd2l0aCBhIHRlbXBsYXRlIGNvbnRyb2xsZXIgKGlmLCBlbHNlLCByZXBlYXQuZm9yIGV0Yy4pIGZvdW5kIChleGFtcGxlOiA8c29tZS1lbCBhdS1zbG90IGlmLmJpbmQ9XCJ0cnVlXCI+PC9zb21lLWVsPikuYCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE86IHByZXZlbnQgPHRlbXBsYXRlIFRFTVBMQVRFLkNPTlRST0xMRVI+PHNvbWUtZWwgYXUtc2xvdD48L3NvbWUtZWw+PC90ZW1wbGF0ZT4uXG4gICAgICAgICAgICAgKiBCdXQgdGhlcmUgaXMgbm90IGVhc3kgd2F5IGZvciBub3csIGFzIHRoZSBhdHRyaWJ1dGUgYmluZGluZyBpcyBkb25lIGFmdGVyIGJpbmRpbmcgdGhlIGNoaWxkIG5vZGVzLlxuICAgICAgICAgICAgICogVGhpcyBtZWFucyBieSB0aGUgdGltZSB0aGUgdGVtcGxhdGUgY29udHJvbGxlciBpbiB0aGUgYW5jZXN0b3IgaXMgcHJvY2Vzc2VkLCB0aGUgcHJvamVjdGlvbiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnROYW1lID0gbm9kZS5wYXJlbnROb2RlPy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaGFzUHJvamVjdGlvblxuICAgICAgICAgICAgJiYgKG1hbmlmZXN0Um9vdCA9PT0gbnVsbFxuICAgICAgICAgICAgICAgIHx8IHBhcmVudE5hbWUgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY29udGFpbmVyLmZpbmQoQ3VzdG9tRWxlbWVudCwgcGFyZW50TmFtZSkgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZXZlbnRzIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgICAgICAgKiAtIDx0ZW1wbGF0ZT48ZGl2IGF1LXNsb3Q+PC9kaXY+PC90ZW1wbGF0ZT5cbiAgICAgICAgICAgICAqIC0gPG15LWNlPjxkaXY+PGRpdiBhdS1zbG90PjwvZGl2PjwvZGl2PjwvbXktY2U+XG4gICAgICAgICAgICAgKiAtIDxteS1jZT48ZGl2IGF1LXNsb3Q9XCJzMVwiPjxkaXYgYXUtc2xvdD1cInMyXCI+PC9kaXY+PC9kaXY+PC9teS1jZT5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1c2FnZSBvZiBbYXUtc2xvdD1cIiR7cHJvamVjdGlvbn1cIl0uIEl0IHNlZW1zIHRoYXQgcHJvamVjdGlvbiBpcyBhdHRlbXB0ZWQsIGJ1dCBub3QgZm9yIGEgY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc1RlbXBsYXRlQ29udHJvbGxlcnModGhpcy5wbGF0Zm9ybSwgbWFuaWZlc3RQcm94eSwgbWFuaWZlc3QpO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uT3duZXIgPSBtYW5pZmVzdCA9PT0gbWFuaWZlc3RSb290ID8gcGFyZW50TWFuaWZlc3RSb290IDogbWFuaWZlc3RSb290O1xuICAgICAgICBpZiAoIWhhc1Byb2plY3Rpb24gfHwgcHJvamVjdGlvbk93bmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0aGUgcHJveHkgaXMgZWl0aGVyIHRoZSBtYW5pZmVzdCBpdHNlbGYgb3IgdGhlIG91dGVyLW1vc3QgY29udHJvbGxlcjsgYWRkIGl0IGRpcmVjdGx5IHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIHBhcmVudE1hbmlmZXN0LmNoaWxkTm9kZXMucHVzaChtYW5pZmVzdFByb3h5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNQcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uT3duZXIucHJvamVjdGlvbnMucHVzaChuZXcgUHJvamVjdGlvblN5bWJvbChwcm9qZWN0aW9uLCBtYW5pZmVzdFByb3h5KSk7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXUtc2xvdCcpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiByZWZhY3RvciB0byB1c2UgcmVuZGVyIHByaW9yaXR5IHNsb3RzICh0aGlzIGxvZ2ljIHNob3VsZG4ndCBiZSBpbiB0aGUgdGVtcGxhdGUgYmluZGVyKVxuICAgIGVuc3VyZUF0dHJpYnV0ZU9yZGVyKG1hbmlmZXN0KSB7XG4gICAgICAgIC8vIHN3YXAgdGhlIG9yZGVyIG9mIGNoZWNrZWQgYW5kIG1vZGVsL3ZhbHVlIGF0dHJpYnV0ZSwgc28gdGhhdCB0aGUgcmVxdWlyZWQgb2JzZXJ2ZXJzIGFyZSBwcmVwYXJlZCBmb3IgY2hlY2tlZC1vYnNlcnZlclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbWFuaWZlc3QucGxhaW5BdHRyaWJ1dGVzO1xuICAgICAgICBsZXQgbW9kZWxPclZhbHVlSW5kZXggPSB2b2lkIDA7XG4gICAgICAgIGxldCBjaGVja2VkSW5kZXggPSB2b2lkIDA7XG4gICAgICAgIGxldCBmb3VuZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGggJiYgZm91bmQgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXR0cmlidXRlc1tpXS5zeW50YXgudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9kZWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtYXRjaGVyJzpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxPclZhbHVlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZWRJbmRleCAhPT0gdm9pZCAwICYmIG1vZGVsT3JWYWx1ZUluZGV4ICE9PSB2b2lkIDAgJiYgY2hlY2tlZEluZGV4IDwgbW9kZWxPclZhbHVlSW5kZXgpIHtcbiAgICAgICAgICAgIFthdHRyaWJ1dGVzW21vZGVsT3JWYWx1ZUluZGV4XSwgYXR0cmlidXRlc1tjaGVja2VkSW5kZXhdXSA9IFthdHRyaWJ1dGVzW2NoZWNrZWRJbmRleF0sIGF0dHJpYnV0ZXNbbW9kZWxPclZhbHVlSW5kZXhdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kQ2hpbGROb2Rlcyhub2RlLCBzdXJyb2dhdGUsIG1hbmlmZXN0LCBtYW5pZmVzdFJvb3QsIHBhcmVudE1hbmlmZXN0Um9vdCkge1xuICAgICAgICBsZXQgY2hpbGROb2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDaGlsZDtcbiAgICAgICAgd2hpbGUgKGNoaWxkTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChjaGlsZE5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogRWxlbWVudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoaWxkID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRNYW5pZmVzdChcbiAgICAgICAgICAgICAgICAgICAgLyogcGFyZW50TWFuaWZlc3QgICAgICovIG1hbmlmZXN0LCBcbiAgICAgICAgICAgICAgICAgICAgLyogbm9kZSAgICAgICAgICAgICAgICovIGNoaWxkTm9kZSwgXG4gICAgICAgICAgICAgICAgICAgIC8qIHN1cnJvZ2F0ZSAgICAgICAgICAqLyBzdXJyb2dhdGUsIFxuICAgICAgICAgICAgICAgICAgICAvKiBtYW5pZmVzdCAgICAgICAgICAgKi8gbWFuaWZlc3QsIFxuICAgICAgICAgICAgICAgICAgICAvKiBtYW5pZmVzdFJvb3QgICAgICAgKi8gbWFuaWZlc3RSb290LCBcbiAgICAgICAgICAgICAgICAgICAgLyogcGFyZW50TWFuaWZlc3RSb290ICovIHBhcmVudE1hbmlmZXN0Um9vdCk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFRleHQgKi86XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IHRoaXMuYmluZFRleHQoXG4gICAgICAgICAgICAgICAgICAgIC8qIHRleHROb2RlICovIGNoaWxkTm9kZSwgXG4gICAgICAgICAgICAgICAgICAgIC8qIG1hbmlmZXN0ICovIG1hbmlmZXN0KS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIENEQVRBU2VjdGlvbiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDcgLyogUHJvY2Vzc2luZ0luc3RydWN0aW9uICovOlxuICAgICAgICAgICAgICAgIGNhc2UgOCAvKiBDb21tZW50ICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMTAgLyogRG9jdW1lbnRUeXBlICovOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOSAvKiBEb2N1bWVudCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi86XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRUZXh0KHRleHROb2RlLCBtYW5pZmVzdCkge1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gdGhpcy5leHByUGFyc2VyLnBhcnNlKHRleHROb2RlLndob2xlVGV4dCwgMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovKTtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IG5ldyBUZXh0U3ltYm9sKHRoaXMucGxhdGZvcm0sIHRleHROb2RlLCBpbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICAgIG1hbmlmZXN0LmNoaWxkTm9kZXMucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgcHJvY2Vzc0ludGVycG9sYXRpb25UZXh0KHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSB0ZXh0Tm9kZTtcbiAgICAgICAgd2hpbGUgKG5leHQubmV4dFNpYmxpbmcgIT09IG51bGwgJiYgbmV4dC5uZXh0U2libGluZy5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0ICovKSB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgZGVjbGFyZVRlbXBsYXRlQ29udHJvbGxlcihhdHRyU3ludGF4LCBhdHRySW5mbykge1xuICAgICAgICBsZXQgc3ltYm9sO1xuICAgICAgICBjb25zdCBhdHRyUmF3VmFsdWUgPSBhdHRyU3ludGF4LnJhd1ZhbHVlO1xuICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5nZXRCaW5kaW5nQ29tbWFuZChhdHRyU3ludGF4LCBmYWxzZSk7XG4gICAgICAgIC8vIG11bHRpLWJpbmRpbmdzIGxvZ2ljIGhlcmUgaXMgc2ltaWxhciB0byAoYW5kIGV4cGxhaW5lZCBpbikgYmluZEN1c3RvbUF0dHJpYnV0ZVxuICAgICAgICBjb25zdCBpc011bHRpQmluZGluZ3MgPSBhdHRySW5mby5ub011bHRpQmluZGluZ3MgPT09IGZhbHNlICYmIGNvbW1hbmQgPT09IG51bGwgJiYgaGFzSW5saW5lQmluZGluZ3MoYXR0clJhd1ZhbHVlKTtcbiAgICAgICAgaWYgKGlzTXVsdGlCaW5kaW5ncykge1xuICAgICAgICAgICAgc3ltYm9sID0gbmV3IFRlbXBsYXRlQ29udHJvbGxlclN5bWJvbCh0aGlzLnBsYXRmb3JtLCBhdHRyU3ludGF4LCBhdHRySW5mbyk7XG4gICAgICAgICAgICB0aGlzLmJpbmRNdWx0aUF0dHJpYnV0ZShzeW1ib2wsIGF0dHJJbmZvLCBhdHRyUmF3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ltYm9sID0gbmV3IFRlbXBsYXRlQ29udHJvbGxlclN5bWJvbCh0aGlzLnBsYXRmb3JtLCBhdHRyU3ludGF4LCBhdHRySW5mbyk7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nVHlwZSA9IGNvbW1hbmQgPT09IG51bGwgPyAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8gOiBjb21tYW5kLmJpbmRpbmdUeXBlO1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZXhwclBhcnNlci5wYXJzZShhdHRyUmF3VmFsdWUsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgIHN5bWJvbC5iaW5kaW5ncy5wdXNoKG5ldyBCaW5kaW5nU3ltYm9sKGNvbW1hbmQsIGF0dHJJbmZvLmJpbmRhYmxlLCBleHByLCBhdHRyUmF3VmFsdWUsIGF0dHJTeW50YXgudGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9XG4gICAgYmluZEN1c3RvbUF0dHJpYnV0ZShhdHRyU3ludGF4LCBhdHRySW5mbywgY29tbWFuZCwgbWFuaWZlc3QpIHtcbiAgICAgICAgbGV0IHN5bWJvbDtcbiAgICAgICAgY29uc3QgYXR0clJhd1ZhbHVlID0gYXR0clN5bnRheC5yYXdWYWx1ZTtcbiAgICAgICAgLy8gQ3VzdG9tIGF0dHJpYnV0ZXMgYXJlIGFsd2F5cyBpbiBtdWx0aXBsZSBiaW5kaW5nIG1vZGUsXG4gICAgICAgIC8vIGV4Y2VwdCB3aGVuIHRoZXkgY2FuJ3QgYmVcbiAgICAgICAgLy8gV2hlbiB0aGV5IGNhbm5vdCBiZTpcbiAgICAgICAgLy8gICAgICAgICogaGFzIGV4cGxpY2l0IGNvbmZpZ3VyYXRpb24gbm9NdWx0aUJpbmRpbmdzOiBmYWxzZVxuICAgICAgICAvLyAgICAgICAgKiBoYXMgYmluZGluZyBjb21tYW5kLCBpZTogPGRpdiBteS1hdHRyLmJpbmQ9XCIuLi5cIj4uXG4gICAgICAgIC8vICAgICAgICAgIEluIHRoaXMgc2NlbmFyaW8sIHRoZSB2YWx1ZSBvZiB0aGUgY3VzdG9tIGF0dHJpYnV0ZXMgaXMgcmVxdWlyZWQgdG8gYmUgYSB2YWxpZCBleHByZXNzaW9uXG4gICAgICAgIC8vICAgICAgICAqIGhhcyBubyBjb2xvbjogaWU6IDxkaXYgbXktYXR0cj1cImFiY2RcIj5cbiAgICAgICAgLy8gICAgICAgICAgSW4gdGhpcyBzY2VuYXJpbywgaXQncyBzaW1wbHkgaW52YWxpZCBzeW50YXguIENvbnNpZGVyIHN0eWxlIGF0dHJpYnV0ZSBydWxlLXZhbHVlIHBhaXI6IDxkaXYgc3R5bGU9XCJydWxlOiBydWxlVmFsdWVcIj5cbiAgICAgICAgY29uc3QgaXNNdWx0aUJpbmRpbmdzID0gYXR0ckluZm8ubm9NdWx0aUJpbmRpbmdzID09PSBmYWxzZSAmJiBjb21tYW5kID09PSBudWxsICYmIGhhc0lubGluZUJpbmRpbmdzKGF0dHJSYXdWYWx1ZSk7XG4gICAgICAgIGlmIChpc011bHRpQmluZGluZ3MpIHtcbiAgICAgICAgICAgIC8vIGEgbXVsdGlwbGUtYmluZGluZ3MgYXR0cmlidXRlIHVzYWdlIChzZW1pY29sb24gc2VwYXJhdGVkIGJpbmRpbmcpIGlzIG9ubHkgdmFsaWQgd2l0aG91dCBhIGJpbmRpbmcgY29tbWFuZDtcbiAgICAgICAgICAgIC8vIHRoZSBiaW5kaW5nIGNvbW1hbmRzIG11c3QgYmUgZGVjbGFyZWQgaW4gZWFjaCBvZiB0aGUgcHJvcGVydHkgYmluZGluZ3NcbiAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBDdXN0b21BdHRyaWJ1dGVTeW1ib2woYXR0clN5bnRheCwgYXR0ckluZm8pO1xuICAgICAgICAgICAgdGhpcy5iaW5kTXVsdGlBdHRyaWJ1dGUoc3ltYm9sLCBhdHRySW5mbywgYXR0clJhd1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBDdXN0b21BdHRyaWJ1dGVTeW1ib2woYXR0clN5bnRheCwgYXR0ckluZm8pO1xuICAgICAgICAgICAgY29uc3QgYmluZGluZ1R5cGUgPSBjb21tYW5kID09PSBudWxsID8gMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovIDogY29tbWFuZC5iaW5kaW5nVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLmV4cHJQYXJzZXIucGFyc2UoYXR0clJhd1ZhbHVlLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICBzeW1ib2wuYmluZGluZ3MucHVzaChuZXcgQmluZGluZ1N5bWJvbChjb21tYW5kLCBhdHRySW5mby5iaW5kYWJsZSwgZXhwciwgYXR0clJhd1ZhbHVlLCBhdHRyU3ludGF4LnRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICAgIG1hbmlmZXN0LmN1c3RvbUF0dHJpYnV0ZXMucHVzaChzeW1ib2wpO1xuICAgICAgICBtYW5pZmVzdC5pc1RhcmdldCA9IHRydWU7XG4gICAgfVxuICAgIGJpbmRNdWx0aUF0dHJpYnV0ZShzeW1ib2wsIGF0dHJJbmZvLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBiaW5kYWJsZXMgPSBhdHRySW5mby5iaW5kYWJsZXM7XG4gICAgICAgIGNvbnN0IHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBsZXQgYXR0ck5hbWUgPSB2b2lkIDA7XG4gICAgICAgIGxldCBhdHRyVmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBjaCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2ggPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoID09PSA5MiAvKiBCYWNrc2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHdoYXRldmVyIGNvbWVzIG5leHQgYmVjYXVzZSBpdCdzIGVzY2FwZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSA1OCAvKiBDb2xvbiAqLykge1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gdmFsdWUuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBjb2xvblxuICAgICAgICAgICAgICAgIHdoaWxlICh2YWx1ZS5jaGFyQ29kZUF0KCsraSkgPD0gMzIgLyogU3BhY2UgKi8pXG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCB2YWx1ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA5MiAvKiBCYWNrc2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGF0ZXZlciBjb21lcyBuZXh0IGJlY2F1c2UgaXQncyBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDU5IC8qIFNlbWljb2xvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0clZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHNlbWljb2xvbiBmb3VuZCwgc28ganVzdCBncmFiIHRoZSByZXN0IG9mIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBhdHRyVmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJTeW50YXggPSB0aGlzLmF0dHJQYXJzZXIucGFyc2UoYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0clRhcmdldCA9IGNhbWVsQ2FzZShhdHRyU3ludGF4LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuZ2V0QmluZGluZ0NvbW1hbmQoYXR0clN5bnRheCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdUeXBlID0gY29tbWFuZCA9PT0gbnVsbCA/IDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyA6IGNvbW1hbmQuYmluZGluZ1R5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZXhwclBhcnNlci5wYXJzZShhdHRyVmFsdWUsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgYmluZGFibGUgPSBiaW5kYWJsZXNbYXR0clRhcmdldF07XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBpbiBhIG11bHRpLWJpbmRpbmdzIGV4cHJlc3Npb24gbXVzdCBiZSB1c2VkLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBpZiBpdCdzIG5vdCBhIGJpbmRhYmxlIHRoZW4gd2UgY3JlYXRlIG9uZSBvbiB0aGUgc3BvdFxuICAgICAgICAgICAgICAgICAgICBiaW5kYWJsZSA9IGJpbmRhYmxlc1thdHRyVGFyZ2V0XSA9IG5ldyBCaW5kYWJsZUluZm8oYXR0clRhcmdldCwgQmluZGluZ01vZGUudG9WaWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ltYm9sLmJpbmRpbmdzLnB1c2gobmV3IEJpbmRpbmdTeW1ib2woY29tbWFuZCwgYmluZGFibGUsIGV4cHIsIGF0dHJWYWx1ZSwgYXR0clRhcmdldCkpO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBzZW1pY29sb25cbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHZhbHVlTGVuZ3RoICYmIHZhbHVlLmNoYXJDb2RlQXQoKytpKSA8PSAzMiAvKiBTcGFjZSAqLylcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBhdHRyVmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZFBsYWluQXR0cmlidXRlKGF0dHJTeW50YXgsIGF0dHIsIHN1cnJvZ2F0ZSwgbWFuaWZlc3QpIHtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuZ2V0QmluZGluZ0NvbW1hbmQoYXR0clN5bnRheCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBiaW5kaW5nVHlwZSA9IGNvbW1hbmQgPT09IG51bGwgPyAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8gOiBjb21tYW5kLmJpbmRpbmdUeXBlO1xuICAgICAgICBjb25zdCBhdHRyVGFyZ2V0ID0gYXR0clN5bnRheC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGF0dHJSYXdWYWx1ZSA9IGF0dHJTeW50YXgucmF3VmFsdWU7XG4gICAgICAgIGxldCBleHByO1xuICAgICAgICBpZiAoYXR0clJhd1ZhbHVlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgJiYgKGJpbmRpbmdUeXBlICYgNTMgLyogQmluZENvbW1hbmQgKi8gfCA0OSAvKiBPbmVUaW1lQ29tbWFuZCAqLyB8IDUwIC8qIFRvVmlld0NvbW1hbmQgKi8gfCA1MiAvKiBUd29XYXlDb21tYW5kICovKSA+IDApIHtcbiAgICAgICAgICAgIGlmICgoYmluZGluZ1R5cGUgJiA1MyAvKiBCaW5kQ29tbWFuZCAqLyB8IDQ5IC8qIE9uZVRpbWVDb21tYW5kICovIHwgNTAgLyogVG9WaWV3Q29tbWFuZCAqLyB8IDUyIC8qIFR3b1dheUNvbW1hbmQgKi8pID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIGF0dHIgZm9yIGVtcHR5IGJpbmRpbmcgY29tbWFuZHNcbiAgICAgICAgICAgICAgICBleHByID0gdGhpcy5leHByUGFyc2VyLnBhcnNlKGNhbWVsQ2FzZShhdHRyVGFyZ2V0KSwgYmluZGluZ1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IHRoaXMuZXhwclBhcnNlci5wYXJzZShhdHRyUmF3VmFsdWUsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1hbmlmZXN0LmZsYWdzICYgMTYgLyogaXNDdXN0b21FbGVtZW50ICovKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRhYmxlID0gbWFuaWZlc3QuYmluZGFibGVzW2F0dHJUYXJnZXRdO1xuICAgICAgICAgICAgaWYgKGJpbmRhYmxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYXR0cmlidXRlIG5hbWUgbWF0Y2hlcyBhIGJpbmRhYmxlIHByb3BlcnR5IG5hbWUsIGFkZCBpdCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQncyBhIGNvbW1hbmQsIGludGVycG9sYXRpb24sIG9yIGp1c3QgYSBwbGFpbiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRlbXBsYXRlIGNvbXBpbGVyIHdpbGwgdHJhbnNsYXRlIGl0IHRvIHRoZSBjb3JyZWN0IGluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgbWFuaWZlc3QuYmluZGluZ3MucHVzaChuZXcgQmluZGluZ1N5bWJvbChjb21tYW5kLCBiaW5kYWJsZSwgZXhwciwgYXR0clJhd1ZhbHVlLCBhdHRyVGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3QuaXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZG9lcyBub3QgbWFwIHRvIGEgYmluZGFibGUsIG9ubHkgYWRkIGl0IGlmIHdlIHdlcmUgYWJsZSB0byBwYXJzZSBhbiBleHByZXNzaW9uIChlaXRoZXIgYSBjb21tYW5kIG9yIGludGVycG9sYXRpb24pXG4gICAgICAgICAgICAgICAgbWFuaWZlc3QucGxhaW5BdHRyaWJ1dGVzLnB1c2gobmV3IFBsYWluQXR0cmlidXRlU3ltYm9sKGF0dHJTeW50YXgsIGNvbW1hbmQsIGV4cHIpKTtcbiAgICAgICAgICAgICAgICBtYW5pZmVzdC5pc1RhcmdldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwciAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYSBiaW5kaW5nIGNvbW1hbmQsIGFuIGludGVycG9sYXRpb24sIG9yIGEgcmVmXG4gICAgICAgICAgICBtYW5pZmVzdC5wbGFpbkF0dHJpYnV0ZXMucHVzaChuZXcgUGxhaW5BdHRyaWJ1dGVTeW1ib2woYXR0clN5bnRheCwgY29tbWFuZCwgZXhwcikpO1xuICAgICAgICAgICAgbWFuaWZlc3QuaXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hbmlmZXN0ID09PSBzdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIC8vIGFueSBhdHRyaWJ1dGVzLCBldmVuIGlmIHRoZXkgYXJlIHBsYWluIChubyBjb21tYW5kL2ludGVycG9sYXRpb24gZXRjKSwgc2hvdWxkIGJlIGFkZGVkIGlmIHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBvbiB0aGUgc3Vycm9nYXRlIGVsZW1lbnRcbiAgICAgICAgICAgIG1hbmlmZXN0LnBsYWluQXR0cmlidXRlcy5wdXNoKG5ldyBQbGFpbkF0dHJpYnV0ZVN5bWJvbChhdHRyU3ludGF4LCBjb21tYW5kLCBleHByKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQgPT0gbnVsbCAmJiBleHByICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYW4gaW50ZXJwb2xhdGlvbiwgY2xlYXIgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgICAgYXR0ci52YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgYmluZGluZyBjb21tYW5kIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgcGFyc2VkIGBBdHRyU3ludGF4YFxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIGNvbW1hbmQgaWYgaXQgZXhpc3RzLCBvciBgbnVsbGAgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICovXG4gICAgZ2V0QmluZGluZ0NvbW1hbmQoc3ludGF4LCBvcHRpb25hbCkge1xuICAgICAgICBjb25zdCBuYW1lID0gc3ludGF4LmNvbW1hbmQ7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb21tYW5kTG9va3VwW25hbWVdO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbmVyLmNyZWF0ZShCaW5kaW5nQ29tbWFuZCwgbmFtZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYmluZGluZyBjb21tYW5kOiAke25hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRMb29rdXBbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1iaW5kZXIuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBlbXB0eUFycmF5LCBSZWdpc3RyYXRpb24sIG1lcmdlQXJyYXlzLCB0b0FycmF5LCBJTG9nZ2VyLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJRXhwcmVzc2lvblBhcnNlciwgQmluZGluZ01vZGUsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBJQXR0clN5bnRheFRyYW5zZm9ybWVyIH0gZnJvbSAnLi9hdHRyaWJ1dGUtc3ludGF4LXRyYW5zZm9ybWVyLmpzJztcbmltcG9ydCB7IFRlbXBsYXRlQmluZGVyIH0gZnJvbSAnLi90ZW1wbGF0ZS1iaW5kZXIuanMnO1xuaW1wb3J0IHsgSVRlbXBsYXRlRWxlbWVudEZhY3RvcnkgfSBmcm9tICcuL3RlbXBsYXRlLWVsZW1lbnQtZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBIeWRyYXRlQXR0cmlidXRlSW5zdHJ1Y3Rpb24sIEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24sIEh5ZHJhdGVMZXRFbGVtZW50SW5zdHJ1Y3Rpb24sIEh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIsIEludGVycG9sYXRpb25JbnN0cnVjdGlvbiwgTGV0QmluZGluZ0luc3RydWN0aW9uLCBTZXRBdHRyaWJ1dGVJbnN0cnVjdGlvbiwgU2V0Q2xhc3NBdHRyaWJ1dGVJbnN0cnVjdGlvbiwgU2V0UHJvcGVydHlJbnN0cnVjdGlvbiwgU2V0U3R5bGVBdHRyaWJ1dGVJbnN0cnVjdGlvbiwgVGV4dEJpbmRpbmdJbnN0cnVjdGlvbiwgSVRlbXBsYXRlQ29tcGlsZXIsIH0gZnJvbSAnLi9yZW5kZXJlci5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IEJpbmRhYmxlIH0gZnJvbSAnLi9iaW5kYWJsZS5qcyc7XG5pbXBvcnQgeyBJQXR0cmlidXRlUGFyc2VyIH0gZnJvbSAnLi9yZXNvdXJjZXMvYXR0cmlidXRlLXBhdHRlcm4uanMnO1xuaW1wb3J0IHsgQXVTbG90Q29udGVudFR5cGUsIFByb2plY3Rpb25Db250ZXh0LCBTbG90SW5mbyB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9hdS1zbG90LmpzJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQsIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuY2xhc3MgQ3VzdG9tRWxlbWVudENvbXBpbGF0aW9uVW5pdCB7XG4gICAgY29uc3RydWN0b3IocGFydGlhbERlZmluaXRpb24sIHN1cnJvZ2F0ZSwgdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsRGVmaW5pdGlvbiA9IHBhcnRpYWxEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLnN1cnJvZ2F0ZSA9IHN1cnJvZ2F0ZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnN1cnJvZ2F0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uc01hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdG9EZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLnBhcnRpYWxEZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uY3JlYXRlKHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIGluc3RydWN0aW9uczogbWVyZ2VBcnJheXMoZGVmLmluc3RydWN0aW9ucywgdGhpcy5pbnN0cnVjdGlvbnMpLFxuICAgICAgICAgICAgc3Vycm9nYXRlczogbWVyZ2VBcnJheXMoZGVmLnN1cnJvZ2F0ZXMsIHRoaXMuc3Vycm9nYXRlcyksXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgICAgICAgICAgIG5lZWRzQ29tcGlsZTogZmFsc2UsXG4gICAgICAgICAgICBoYXNTbG90czogdGhpcy5zdXJyb2dhdGUuaGFzU2xvdHMsXG4gICAgICAgICAgICBwcm9qZWN0aW9uc01hcDogdGhpcy5wcm9qZWN0aW9uc01hcCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxudmFyIExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXM7XG4oZnVuY3Rpb24gKExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXMpIHtcbiAgICBMb2NhbFRlbXBsYXRlQmluZGFibGVBdHRyaWJ1dGVzW1wicHJvcGVydHlcIl0gPSBcInByb3BlcnR5XCI7XG4gICAgTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlc1tcImF0dHJpYnV0ZVwiXSA9IFwiYXR0cmlidXRlXCI7XG4gICAgTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlc1tcIm1vZGVcIl0gPSBcIm1vZGVcIjtcbn0pKExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXMgfHwgKExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXMgPSB7fSkpO1xuY29uc3QgYWxsb3dlZExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXMgPSBPYmplY3QuZnJlZXplKFtcbiAgICBcInByb3BlcnR5XCIgLyogcHJvcGVydHkgKi8sXG4gICAgXCJhdHRyaWJ1dGVcIiAvKiBhdHRyaWJ1dGUgKi8sXG4gICAgXCJtb2RlXCIgLyogbW9kZSAqL1xuXSk7XG5jb25zdCBsb2NhbFRlbXBsYXRlSWRlbnRpZmllciA9ICdhcy1jdXN0b20tZWxlbWVudCc7XG4vKipcbiAqIERlZmF1bHQgKHJ1bnRpbWUtYWdub3N0aWMpIGltcGxlbWVudGF0aW9uIGZvciBgSVRlbXBsYXRlQ29tcGlsZXJgLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgVGVtcGxhdGVDb21waWxlciA9IGNsYXNzIFRlbXBsYXRlQ29tcGlsZXIge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnksIGF0dHJQYXJzZXIsIGV4cHJQYXJzZXIsIGF0dHJTeW50YXhNb2RpZmllciwgbG9nZ2VyLCBwKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMuYXR0clBhcnNlciA9IGF0dHJQYXJzZXI7XG4gICAgICAgIHRoaXMuZXhwclBhcnNlciA9IGV4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuYXR0clN5bnRheE1vZGlmaWVyID0gYXR0clN5bnRheE1vZGlmaWVyO1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlci5zY29wZVRvKCdUZW1wbGF0ZUNvbXBpbGVyJyk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ2RlZmF1bHQnO1xuICAgIH1cbiAgICBzdGF0aWMgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBSZWdpc3RyYXRpb24uc2luZ2xldG9uKElUZW1wbGF0ZUNvbXBpbGVyLCB0aGlzKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgIH1cbiAgICBjb21waWxlKHBhcnRpYWxEZWZpbml0aW9uLCBjb250ZXh0LCB0YXJnZXRlZFByb2plY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5nZXRPckNyZWF0ZShwYXJ0aWFsRGVmaW5pdGlvbik7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLnRlbXBsYXRlID09PSBudWxsIHx8IGRlZmluaXRpb24udGVtcGxhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhdHRyUGFyc2VyLCBleHByUGFyc2VyLCBhdHRyU3ludGF4TW9kaWZpZXIsIGZhY3RvcnkgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHAgPSBjb250ZXh0LmdldChJUGxhdGZvcm0pO1xuICAgICAgICBjb25zdCBiaW5kZXIgPSBuZXcgVGVtcGxhdGVCaW5kZXIocCwgY29udGV4dCwgYXR0clBhcnNlciwgZXhwclBhcnNlciwgYXR0clN5bnRheE1vZGlmaWVyKTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkZWZpbml0aW9uLmVuaGFuY2UgPT09IHRydWVcbiAgICAgICAgICAgID8gZGVmaW5pdGlvbi50ZW1wbGF0ZVxuICAgICAgICAgICAgOiBmYWN0b3J5LmNyZWF0ZVRlbXBsYXRlKGRlZmluaXRpb24udGVtcGxhdGUpO1xuICAgICAgICBwcm9jZXNzTG9jYWxUZW1wbGF0ZXModGVtcGxhdGUsIGRlZmluaXRpb24sIGNvbnRleHQsIHAsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgY29uc3Qgc3Vycm9nYXRlID0gYmluZGVyLmJpbmQodGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBjb21waWxhdGlvbiA9IHRoaXMuY29tcGlsYXRpb24gPSBuZXcgQ3VzdG9tRWxlbWVudENvbXBpbGF0aW9uVW5pdChkZWZpbml0aW9uLCBzdXJyb2dhdGUsIHRlbXBsYXRlKTtcbiAgICAgICAgY29uc3QgY3VzdG9tQXR0cmlidXRlcyA9IHN1cnJvZ2F0ZS5jdXN0b21BdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBwbGFpbkF0dHJpYnV0ZXMgPSBzdXJyb2dhdGUucGxhaW5BdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBjdXN0b21BdHRyaWJ1dGVMZW5ndGggPSBjdXN0b21BdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGxhaW5BdHRyaWJ1dGVMZW5ndGggPSBwbGFpbkF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICBpZiAoY3VzdG9tQXR0cmlidXRlTGVuZ3RoICsgcGxhaW5BdHRyaWJ1dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBjdXN0b21BdHRyaWJ1dGVMZW5ndGggPiBpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb21waWxhdGlvbi5zdXJyb2dhdGVzW29mZnNldF0gPSB0aGlzLmNvbXBpbGVDdXN0b21BdHRyaWJ1dGUoY3VzdG9tQXR0cmlidXRlc1tpXSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYWluQXR0cmlidXRlTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb21waWxhdGlvbi5zdXJyb2dhdGVzW29mZnNldF0gPSB0aGlzLmNvbXBpbGVQbGFpbkF0dHJpYnV0ZShwbGFpbkF0dHJpYnV0ZXNbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsZUNoaWxkTm9kZXMoc3Vycm9nYXRlLCBjb21waWxhdGlvbi5pbnN0cnVjdGlvbnMsIGNvbXBpbGF0aW9uLnByb2plY3Rpb25zTWFwLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgY29uc3QgY29tcGlsZWREZWZpbml0aW9uID0gY29tcGlsYXRpb24udG9EZWZpbml0aW9uKCk7XG4gICAgICAgIHRoaXMuY29tcGlsYXRpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gY29tcGlsZWREZWZpbml0aW9uO1xuICAgIH1cbiAgICBjb21waWxlQ2hpbGROb2RlcyhwYXJlbnQsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgaWYgKChwYXJlbnQuZmxhZ3MgJiAxNjM4NCAvKiBoYXNDaGlsZE5vZGVzICovKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBwYXJlbnQuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGNvbnN0IGlpID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoKGNoaWxkTm9kZS5mbGFncyAmIDEyOCAvKiBpc1RleHQgKi8pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvblJvd3MucHVzaChbbmV3IFRleHRCaW5kaW5nSW5zdHJ1Y3Rpb24oY2hpbGROb2RlLmludGVycG9sYXRpb24pXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjaGlsZE5vZGUuZmxhZ3MgJiAzMiAvKiBpc0xldEVsZW1lbnQgKi8pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IGNoaWxkTm9kZS5iaW5kaW5ncztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBiaW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqaiA9IGJpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nID0gYmluZGluZ3Nbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnNbal0gPSBuZXcgTGV0QmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgYmluZGluZy50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uUm93cy5wdXNoKFtuZXcgSHlkcmF0ZUxldEVsZW1lbnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbnMsIGNoaWxkTm9kZS50b0JpbmRpbmdDb250ZXh0KV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlUGFyZW50Tm9kZShjaGlsZE5vZGUsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21waWxlQ3VzdG9tRWxlbWVudChzeW1ib2wsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaXNBdVNsb3QgPSAoc3ltYm9sLmZsYWdzICYgNTEyIC8qIGlzQXVTbG90ICovKSA+IDA7XG4gICAgICAgIC8vIG9mZnNldCAxIHRvIGxlYXZlIGEgc3BvdCBmb3IgdGhlIGh5ZHJhdGUgaW5zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgMiBhcnJheXMgd2l0aCBhIHNwcmVhZCBldGNcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25Sb3cgPSB0aGlzLmNvbXBpbGVBdHRyaWJ1dGVzKHN5bWJvbCwgMSk7XG4gICAgICAgIGNvbnN0IHNsb3ROYW1lID0gc3ltYm9sLnNsb3ROYW1lO1xuICAgICAgICBsZXQgc2xvdEluZm8gPSBudWxsO1xuICAgICAgICBpZiAoaXNBdVNsb3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldGVkUHJvamVjdGlvbiA9IHRhcmdldGVkUHJvamVjdGlvbnM/LnByb2plY3Rpb25zPy5bc2xvdE5hbWVdO1xuICAgICAgICAgICAgc2xvdEluZm8gPSB0YXJnZXRlZFByb2plY3Rpb24gIT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gbmV3IFNsb3RJbmZvKHNsb3ROYW1lLCBBdVNsb3RDb250ZW50VHlwZS5Qcm9qZWN0aW9uLCBuZXcgUHJvamVjdGlvbkNvbnRleHQodGFyZ2V0ZWRQcm9qZWN0aW9uLCB0YXJnZXRlZFByb2plY3Rpb25zPy5zY29wZSkpXG4gICAgICAgICAgICAgICAgOiBuZXcgU2xvdEluZm8oc2xvdE5hbWUsIEF1U2xvdENvbnRlbnRUeXBlLkZhbGxiYWNrLCBuZXcgUHJvamVjdGlvbkNvbnRleHQodGhpcy5jb21waWxlUHJvamVjdGlvbkZhbGxiYWNrKHN5bWJvbCwgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvblJvd1swXSA9IG5ldyBIeWRyYXRlRWxlbWVudEluc3RydWN0aW9uKHN5bWJvbC5yZXMsIHN5bWJvbC5pbmZvLmFsaWFzLCB0aGlzLmNvbXBpbGVCaW5kaW5ncyhzeW1ib2wpLCBzbG90SW5mbyk7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVkUHJvamVjdGlvbnMgPSB0aGlzLmNvbXBpbGVQcm9qZWN0aW9ucyhzeW1ib2wsIHByb2plY3Rpb25zLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgaWYgKGNvbXBpbGVkUHJvamVjdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25zLnNldChpbnN0cnVjdGlvbiwgY29tcGlsZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdHJ1Y3Rpb25Sb3dzLnB1c2goaW5zdHJ1Y3Rpb25Sb3cpO1xuICAgICAgICBpZiAoIWlzQXVTbG90KSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVDaGlsZE5vZGVzKHN5bWJvbCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcGlsZVBsYWluRWxlbWVudChzeW1ib2wsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuY29tcGlsZUF0dHJpYnV0ZXMoc3ltYm9sLCAwKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25Sb3dzLnB1c2goYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxlQ2hpbGROb2RlcyhzeW1ib2wsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgIH1cbiAgICBjb21waWxlUGFyZW50Tm9kZShzeW1ib2wsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChzeW1ib2wuZmxhZ3MgJiAxMDIzIC8qIHR5cGUgKi8pIHtcbiAgICAgICAgICAgIGNhc2UgMTYgLyogaXNDdXN0b21FbGVtZW50ICovOlxuICAgICAgICAgICAgY2FzZSA1MTIgLyogaXNBdVNsb3QgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlQ3VzdG9tRWxlbWVudChzeW1ib2wsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2NCAvKiBpc1BsYWluRWxlbWVudCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVQbGFpbkVsZW1lbnQoc3ltYm9sLCBpbnN0cnVjdGlvblJvd3MsIHByb2plY3Rpb25zLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBpc1RlbXBsYXRlQ29udHJvbGxlciAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVUZW1wbGF0ZUNvbnRyb2xsZXIoc3ltYm9sLCBpbnN0cnVjdGlvblJvd3MsIHByb2plY3Rpb25zLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21waWxlVGVtcGxhdGVDb250cm9sbGVyKHN5bWJvbCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucykge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuY29tcGlsZUJpbmRpbmdzKHN5bWJvbCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXJJbnN0cnVjdGlvblJvd3MgPSBbXTtcbiAgICAgICAgdGhpcy5jb21waWxlUGFyZW50Tm9kZShzeW1ib2wudGVtcGxhdGUsIGNvbnRyb2xsZXJJbnN0cnVjdGlvblJvd3MsIHByb2plY3Rpb25zLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgY29uc3QgZGVmID0gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uY3JlYXRlKHtcbiAgICAgICAgICAgIG5hbWU6IHN5bWJvbC5pbmZvLmFsaWFzID8/IHN5bWJvbC5pbmZvLm5hbWUsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogc3ltYm9sLnBoeXNpY2FsTm9kZSxcbiAgICAgICAgICAgIGluc3RydWN0aW9uczogY29udHJvbGxlckluc3RydWN0aW9uUm93cyxcbiAgICAgICAgICAgIG5lZWRzQ29tcGlsZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpbnN0cnVjdGlvblJvd3MucHVzaChbbmV3IEh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIoZGVmLCBzeW1ib2wucmVzLCBzeW1ib2wuaW5mby5hbGlhcywgYmluZGluZ3MpXSk7XG4gICAgfVxuICAgIGNvbXBpbGVCaW5kaW5ncyhzeW1ib2wpIHtcbiAgICAgICAgbGV0IGJpbmRpbmdJbnN0cnVjdGlvbnM7XG4gICAgICAgIGlmICgoc3ltYm9sLmZsYWdzICYgODE5MiAvKiBoYXNCaW5kaW5ncyAqLykgPiAwKSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYSBjdXN0b20gZWxlbWVudCB3aXRoIGJpbmRpbmdzLCBhIGN1c3RvbSBhdHRyaWJ1dGUgLyB0ZW1wbGF0ZSBjb250cm9sbGVyIHdpdGggZHluYW1pYyBvcHRpb25zLFxuICAgICAgICAgICAgLy8gb3IgYSBzaW5nbGUgdmFsdWUgY3VzdG9tIGF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICAgICAgICBjb25zdCB7IGJpbmRpbmdzIH0gPSBzeW1ib2w7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBiaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICBiaW5kaW5nSW5zdHJ1Y3Rpb25zID0gQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nSW5zdHJ1Y3Rpb25zW2ldID0gdGhpcy5jb21waWxlQmluZGluZyhiaW5kaW5nc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiaW5kaW5nSW5zdHJ1Y3Rpb25zID0gZW1wdHlBcnJheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ0luc3RydWN0aW9ucztcbiAgICB9XG4gICAgY29tcGlsZUJpbmRpbmcoc3ltYm9sKSB7XG4gICAgICAgIGlmIChzeW1ib2wuY29tbWFuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGFuIGludGVycG9sYXRpb24gb3IgYSBub3JtYWwgc3RyaW5nIHZhbHVlIGFzc2lnbmVkIHRvIGFuIGVsZW1lbnQgb3IgYXR0cmlidXRlIGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChzeW1ib2wuZXhwcmVzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSB0ZW1wbGF0ZSBiaW5kZXIgYWxyZWFkeSBmaWx0ZXJlZCBvdXQgbm9uLWJpbmRhYmxlcywgc28gd2Uga25vdyB3ZSBuZWVkIGEgc2V0UHJvcGVydHkgaGVyZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0UHJvcGVydHlJbnN0cnVjdGlvbihzeW1ib2wucmF3VmFsdWUsIHN5bWJvbC5iaW5kYWJsZS5wcm9wTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlaXRoZXIgYW4gZWxlbWVudCBiaW5kaW5nIGludGVycG9sYXRpb24gb3IgYSBkeW5hbWljIG9wdGlvbnMgYXR0cmlidXRlIGJpbmRpbmcgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkluc3RydWN0aW9uKHN5bWJvbC5leHByZXNzaW9uLCBzeW1ib2wuYmluZGFibGUucHJvcE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGFuIGVsZW1lbnQgYmluZGluZyBjb21tYW5kLCBkeW5hbWljIG9wdGlvbnMgYXR0cmlidXRlIGJpbmRpbmcgY29tbWFuZCxcbiAgICAgICAgICAgIC8vIG9yIGN1c3RvbSBhdHRyaWJ1dGUgLyB0ZW1wbGF0ZSBjb250cm9sbGVyIChzaW5nbGUgdmFsdWUpIGJpbmRpbmcgY29tbWFuZFxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5jb21tYW5kLmNvbXBpbGUoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21waWxlQXR0cmlidXRlcyhzeW1ib2wsIG9mZnNldCkge1xuICAgICAgICBsZXQgYXR0cmlidXRlSW5zdHJ1Y3Rpb25zO1xuICAgICAgICBpZiAoKHN5bWJvbC5mbGFncyAmIDQwOTYgLyogaGFzQXR0cmlidXRlcyAqLykgPiAwKSB7XG4gICAgICAgICAgICAvLyBhbnkgYXR0cmlidXRlcyBvbiBhIGN1c3RvbSBlbGVtZW50ICh3aGljaCBhcmUgbm90IGJpbmRhYmxlcykgb3IgYSBwbGFpbiBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBjdXN0b21BdHRyaWJ1dGVzID0gc3ltYm9sLmN1c3RvbUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBjb25zdCBwbGFpbkF0dHJpYnV0ZXMgPSBzeW1ib2wucGxhaW5BdHRyaWJ1dGVzO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tQXR0cmlidXRlTGVuZ3RoID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwbGFpbkF0dHJpYnV0ZXNMZW5ndGggPSBwbGFpbkF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgYXR0cmlidXRlSW5zdHJ1Y3Rpb25zID0gQXJyYXkob2Zmc2V0ICsgY3VzdG9tQXR0cmlidXRlTGVuZ3RoICsgcGxhaW5BdHRyaWJ1dGVzTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBjdXN0b21BdHRyaWJ1dGVMZW5ndGggPiBpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnN0cnVjdGlvbnNbb2Zmc2V0XSA9IHRoaXMuY29tcGlsZUN1c3RvbUF0dHJpYnV0ZShjdXN0b21BdHRyaWJ1dGVzW2ldKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBwbGFpbkF0dHJpYnV0ZXNMZW5ndGggPiBpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnN0cnVjdGlvbnNbb2Zmc2V0XSA9IHRoaXMuY29tcGlsZVBsYWluQXR0cmlidXRlKHBsYWluQXR0cmlidXRlc1tpXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZUluc3RydWN0aW9ucyA9IEFycmF5KG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVJbnN0cnVjdGlvbnMgPSBlbXB0eUFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVJbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGNvbXBpbGVDdXN0b21BdHRyaWJ1dGUoc3ltYm9sKSB7XG4gICAgICAgIC8vIGEgbm9ybWFsIGN1c3RvbSBhdHRyaWJ1dGUgKG5vdCB0ZW1wbGF0ZSBjb250cm9sbGVyKVxuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuY29tcGlsZUJpbmRpbmdzKHN5bWJvbCk7XG4gICAgICAgIHJldHVybiBuZXcgSHlkcmF0ZUF0dHJpYnV0ZUluc3RydWN0aW9uKHN5bWJvbC5yZXMsIHN5bWJvbC5pbmZvLmFsaWFzLCBiaW5kaW5ncyk7XG4gICAgfVxuICAgIGNvbXBpbGVQbGFpbkF0dHJpYnV0ZShzeW1ib2wsIGlzT25TdXJyb2dhdGUpIHtcbiAgICAgICAgaWYgKHN5bWJvbC5jb21tYW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzeW50YXggPSBzeW1ib2wuc3ludGF4O1xuICAgICAgICAgICAgaWYgKHN5bWJvbC5leHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0clJhd1ZhbHVlID0gc3ludGF4LnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc09uU3Vycm9nYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ludGF4LnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0Q2xhc3NBdHRyaWJ1dGVJbnN0cnVjdGlvbihhdHRyUmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0U3R5bGVBdHRyaWJ1dGVJbnN0cnVjdGlvbihhdHRyUmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogIGRlZmluZSBob3cgdG8gbWVyZ2Ugb3RoZXIgYXR0cmlidXRlIHBlYWNlZnVsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzIGlzIGFuIGV4aXN0aW5nIGZlYXR1cmUgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGEgcGxhaW4gYXR0cmlidXRlIG9uIGEgc3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRBdHRyaWJ1dGVJbnN0cnVjdGlvbihhdHRyUmF3VmFsdWUsIHN5bnRheC50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYSBwbGFpbiBhdHRyaWJ1dGUgd2l0aCBhbiBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uSW5zdHJ1Y3Rpb24oc3ltYm9sLmV4cHJlc3Npb24sIHN5bnRheC50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYSBwbGFpbiBhdHRyaWJ1dGUgd2l0aCBhIGJpbmRpbmcgY29tbWFuZFxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5jb21tYW5kLmNvbXBpbGUoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwcml2YXRlIGNvbXBpbGVBdHRyaWJ1dGUoc3ltYm9sOiBJQXR0cmlidXRlU3ltYm9sKTogQXR0cmlidXRlSW5zdHJ1Y3Rpb24ge1xuICAgIC8vICAgLy8gYW55IGF0dHJpYnV0ZSBvbiBhIGN1c3RvbSBlbGVtZW50ICh3aGljaCBpcyBub3QgYSBiaW5kYWJsZSkgb3IgYSBwbGFpbiBlbGVtZW50XG4gICAgLy8gICBpZiAoc3ltYm9sLmZsYWdzICYgU3ltYm9sRmxhZ3MuaXNDdXN0b21BdHRyaWJ1dGUpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUN1c3RvbUF0dHJpYnV0ZShzeW1ib2wgYXMgQ3VzdG9tQXR0cmlidXRlU3ltYm9sKTtcbiAgICAvLyAgIH0gZWxzZSB7XG4gICAgLy8gICAgIHJldHVybiB0aGlzLmNvbXBpbGVQbGFpbkF0dHJpYnV0ZShzeW1ib2wgYXMgUGxhaW5BdHRyaWJ1dGVTeW1ib2wpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBjb21waWxlUHJvamVjdGlvbnMoc3ltYm9sLCBwcm9qZWN0aW9uTWFwLCB0YXJnZXRlZFByb2plY3Rpb25zKSB7XG4gICAgICAgIGlmICgoc3ltYm9sLmZsYWdzICYgMzI3NjggLyogaGFzUHJvamVjdGlvbnMgKi8pID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwID0gdGhpcy5wO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0ICRwcm9qZWN0aW9ucyA9IHN5bWJvbC5wcm9qZWN0aW9ucztcbiAgICAgICAgY29uc3QgbGVuID0gJHByb2plY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9ICRwcm9qZWN0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwcm9qZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZVBhcmVudE5vZGUocHJvamVjdGlvbi50ZW1wbGF0ZSwgaW5zdHJ1Y3Rpb25zLCBwcm9qZWN0aW9uTWFwLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBwcm9qZWN0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBwcm9qZWN0aW9uLnRlbXBsYXRlLnBoeXNpY2FsTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGUudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfdGVtcGxhdGUgPSBwLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIF90ZW1wbGF0ZS5jb250ZW50LmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBfdGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2plY3Rpb25zW25hbWVdID0gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uY3JlYXRlKHsgbmFtZSwgdGVtcGxhdGUsIGluc3RydWN0aW9ucywgbmVlZHNDb21waWxlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGlkYXRlIHRoZSBwcm9qZWN0aW9ucyB0byBzYW1lIHNsb3RcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLnRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQocHJvamVjdGlvbi50ZW1wbGF0ZS5waHlzaWNhbE5vZGUpO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uaW5zdHJ1Y3Rpb25zLnB1c2goLi4uaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvamVjdGlvbnM7XG4gICAgfVxuICAgIGNvbXBpbGVQcm9qZWN0aW9uRmFsbGJhY2soc3ltYm9sLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucykge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21waWxlQ2hpbGROb2RlcyhzeW1ib2wsIGluc3RydWN0aW9ucywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMucC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmFwcGVuZCguLi50b0FycmF5KHN5bWJvbC5waHlzaWNhbE5vZGUuY2hpbGROb2RlcykpO1xuICAgICAgICByZXR1cm4gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uY3JlYXRlKHsgbmFtZTogQ3VzdG9tRWxlbWVudC5nZW5lcmF0ZU5hbWUoKSwgdGVtcGxhdGUsIGluc3RydWN0aW9ucywgbmVlZHNDb21waWxlOiBmYWxzZSB9KTtcbiAgICB9XG59O1xuVGVtcGxhdGVDb21waWxlciA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgSVRlbXBsYXRlRWxlbWVudEZhY3RvcnkpLFxuICAgIF9fcGFyYW0oMSwgSUF0dHJpYnV0ZVBhcnNlciksXG4gICAgX19wYXJhbSgyLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgzLCBJQXR0clN5bnRheFRyYW5zZm9ybWVyKSxcbiAgICBfX3BhcmFtKDQsIElMb2dnZXIpLFxuICAgIF9fcGFyYW0oNSwgSVBsYXRmb3JtKVxuXSwgVGVtcGxhdGVDb21waWxlcik7XG5leHBvcnQgeyBUZW1wbGF0ZUNvbXBpbGVyIH07XG5mdW5jdGlvbiBwcm9jZXNzVGVtcGxhdGVOYW1lKGxvY2FsVGVtcGxhdGUsIGxvY2FsVGVtcGxhdGVOYW1lcykge1xuICAgIGNvbnN0IG5hbWUgPSBsb2NhbFRlbXBsYXRlLmdldEF0dHJpYnV0ZShsb2NhbFRlbXBsYXRlSWRlbnRpZmllcik7XG4gICAgaWYgKG5hbWUgPT09IG51bGwgfHwgbmFtZSA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgXCJhcy1jdXN0b20tZWxlbWVudFwiIGF0dHJpYnV0ZSBjYW5ub3QgYmUgZW1wdHkgZm9yIGxvY2FsIHRlbXBsYXRlJyk7XG4gICAgfVxuICAgIGlmIChsb2NhbFRlbXBsYXRlTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGRlZmluaXRpb24gb2YgdGhlIGxvY2FsIHRlbXBsYXRlIG5hbWVkICR7bmFtZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvY2FsVGVtcGxhdGVOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIGxvY2FsVGVtcGxhdGUucmVtb3ZlQXR0cmlidXRlKGxvY2FsVGVtcGxhdGVJZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nTW9kZShiaW5kYWJsZSkge1xuICAgIHN3aXRjaCAoYmluZGFibGUuZ2V0QXR0cmlidXRlKFwibW9kZVwiIC8qIG1vZGUgKi8pKSB7XG4gICAgICAgIGNhc2UgJ29uZVRpbWUnOlxuICAgICAgICAgICAgcmV0dXJuIEJpbmRpbmdNb2RlLm9uZVRpbWU7XG4gICAgICAgIGNhc2UgJ3RvVmlldyc6XG4gICAgICAgICAgICByZXR1cm4gQmluZGluZ01vZGUudG9WaWV3O1xuICAgICAgICBjYXNlICdmcm9tVmlldyc6XG4gICAgICAgICAgICByZXR1cm4gQmluZGluZ01vZGUuZnJvbVZpZXc7XG4gICAgICAgIGNhc2UgJ3R3b1dheSc6XG4gICAgICAgICAgICByZXR1cm4gQmluZGluZ01vZGUudHdvV2F5O1xuICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBCaW5kaW5nTW9kZS5kZWZhdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NMb2NhbFRlbXBsYXRlcyh0ZW1wbGF0ZSwgZGVmaW5pdGlvbiwgY29udGV4dCwgcCwgbG9nZ2VyKSB7XG4gICAgbGV0IHJvb3Q7XG4gICAgaWYgKHRlbXBsYXRlLm5vZGVOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5oYXNBdHRyaWJ1dGUobG9jYWxUZW1wbGF0ZUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByb290IGNhbm5vdCBiZSBhIGxvY2FsIHRlbXBsYXRlIGl0c2VsZi4nKTtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gdGVtcGxhdGUuY29udGVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxUZW1wbGF0ZXMgPSB0b0FycmF5KHJvb3QucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGVbYXMtY3VzdG9tLWVsZW1lbnRdJykpO1xuICAgIGNvbnN0IG51bUxvY2FsVGVtcGxhdGVzID0gbG9jYWxUZW1wbGF0ZXMubGVuZ3RoO1xuICAgIGlmIChudW1Mb2NhbFRlbXBsYXRlcyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChudW1Mb2NhbFRlbXBsYXRlcyA9PT0gcm9vdC5jaGlsZEVsZW1lbnRDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFueSBjb250ZW50IG90aGVyIHRoYW4gbG9jYWwgdGVtcGxhdGUocykuJyk7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsVGVtcGxhdGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGxvY2FsVGVtcGxhdGUgb2YgbG9jYWxUZW1wbGF0ZXMpIHtcbiAgICAgICAgaWYgKGxvY2FsVGVtcGxhdGUucGFyZW50Tm9kZSAhPT0gcm9vdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbCB0ZW1wbGF0ZXMgbmVlZHMgdG8gYmUgZGVmaW5lZCBkaXJlY3RseSB1bmRlciByb290LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwcm9jZXNzVGVtcGxhdGVOYW1lKGxvY2FsVGVtcGxhdGUsIGxvY2FsVGVtcGxhdGVOYW1lcyk7XG4gICAgICAgIGNvbnN0IGxvY2FsVGVtcGxhdGVUeXBlID0gY2xhc3MgTG9jYWxUZW1wbGF0ZSB7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBsb2NhbFRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGJpbmRhYmxlRWxzID0gdG9BcnJheShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2JpbmRhYmxlJykpO1xuICAgICAgICBjb25zdCBiaW5kYWJsZUluc3RydWN0aW9ucyA9IEJpbmRhYmxlLmZvcihsb2NhbFRlbXBsYXRlVHlwZSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgYmluZGFibGVFbCBvZiBiaW5kYWJsZUVscykge1xuICAgICAgICAgICAgaWYgKGJpbmRhYmxlRWwucGFyZW50Tm9kZSAhPT0gY29udGVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmluZGFibGUgcHJvcGVydGllcyBvZiBsb2NhbCB0ZW1wbGF0ZXMgbmVlZHMgdG8gYmUgZGVmaW5lZCBkaXJlY3RseSB1bmRlciByb290LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBiaW5kYWJsZUVsLmdldEF0dHJpYnV0ZShcInByb3BlcnR5XCIgLyogcHJvcGVydHkgKi8pO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYXR0cmlidXRlICdwcm9wZXJ0eScgaXMgbWlzc2luZyBpbiAke2JpbmRhYmxlRWwub3V0ZXJIVE1MfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gYmluZGFibGVFbC5nZXRBdHRyaWJ1dGUoXCJhdHRyaWJ1dGVcIiAvKiBhdHRyaWJ1dGUgKi8pO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICYmIGF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgICB8fCBwcm9wZXJ0aWVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmRhYmxlIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGUgbmVlZHMgdG8gYmUgdW5pcXVlOyBmb3VuZCBwcm9wZXJ0eTogJHtwcm9wZXJ0eX0sIGF0dHJpYnV0ZTogJHthdHRyaWJ1dGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYWRkKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuYWRkKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRhYmxlSW5zdHJ1Y3Rpb25zLmFkZCh7XG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUgPz8gdm9pZCAwLFxuICAgICAgICAgICAgICAgIG1vZGU6IGdldEJpbmRpbmdNb2RlKGJpbmRhYmxlRWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpZ25vcmVkQXR0cmlidXRlcyA9IGJpbmRhYmxlRWwuZ2V0QXR0cmlidXRlTmFtZXMoKS5maWx0ZXIoKGF0dHJOYW1lKSA9PiAhYWxsb3dlZExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0ck5hbWUpKTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVkQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSBhdHRyaWJ1dGUocykgJHtpZ25vcmVkQXR0cmlidXRlcy5qb2luKCcsICcpfSB3aWxsIGJlIGlnbm9yZWQgZm9yICR7YmluZGFibGVFbC5vdXRlckhUTUx9LiBPbmx5ICR7YWxsb3dlZExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXMuam9pbignLCAnKX0gYXJlIHByb2Nlc3NlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnQucmVtb3ZlQ2hpbGQoYmluZGFibGVFbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYWxUZW1wbGF0ZURlZmluaXRpb24gPSBDdXN0b21FbGVtZW50LmRlZmluZSh7IG5hbWUsIHRlbXBsYXRlOiBsb2NhbFRlbXBsYXRlIH0sIGxvY2FsVGVtcGxhdGVUeXBlKTtcbiAgICAgICAgLy8gdGhlIGNhc3RpbmcgaXMgbmVlZGVkIGhlcmUgYXMgdGhlIGRlcGVuZGVuY2llcyBhcmUgdHlwZWQgYXMgcmVhZG9ubHkgYXJyYXlcbiAgICAgICAgZGVmaW5pdGlvbi5kZXBlbmRlbmNpZXMucHVzaChsb2NhbFRlbXBsYXRlRGVmaW5pdGlvbik7XG4gICAgICAgIGNvbnRleHQucmVnaXN0ZXIobG9jYWxUZW1wbGF0ZURlZmluaXRpb24pO1xuICAgICAgICByb290LnJlbW92ZUNoaWxkKGxvY2FsVGVtcGxhdGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWNvbXBpbGVyLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5leHBvcnQgY29uc3QgSVRlbXBsYXRlRWxlbWVudEZhY3RvcnkgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lUZW1wbGF0ZUVsZW1lbnRGYWN0b3J5JywgeCA9PiB4LnNpbmdsZXRvbihUZW1wbGF0ZUVsZW1lbnRGYWN0b3J5KSk7XG5jb25zdCBtYXJrdXBDYWNoZSA9IHt9O1xubGV0IFRlbXBsYXRlRWxlbWVudEZhY3RvcnkgPSBjbGFzcyBUZW1wbGF0ZUVsZW1lbnRGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihwKSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBwLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgfVxuICAgIGNyZWF0ZVRlbXBsYXRlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWFya3VwQ2FjaGVbaW5wdXRdO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbnB1dCBpcyBlaXRoZXIgbm90IHdyYXBwZWQgaW4gYSB0ZW1wbGF0ZSBvciB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG5vZGUsXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSB3aG9sZSB0ZW1wbGF0ZSB0aGF0IHdyYXBzIGl0L3RoZW0gKGFuZCBjcmVhdGUgYSBuZXcgb25lIGZvciB0aGUgbmV4dCBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IG5vZGUubm9kZU5hbWUgIT09ICdURU1QTEFURScgfHwgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5wLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5vZGUgdG8gcmV0dXJuIGlzIGJvdGggYSB0ZW1wbGF0ZSBhbmQgdGhlIG9ubHkgbm9kZSwgc28gcmV0dXJuIGp1c3QgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNsZWFuIHVwIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIG5leHQgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFya3VwQ2FjaGVbaW5wdXRdID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0Lm5vZGVOYW1lICE9PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBnZXQgb25lIG5vZGUgdGhhdCBpcyBub3QgYSB0ZW1wbGF0ZSwgd3JhcCBpdCBpbiBvbmVcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5wLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBnb3QgYSB0ZW1wbGF0ZSBlbGVtZW50LCByZW1vdmUgaXQgZnJvbSB0aGUgRE9NIGlmIGl0J3MgcHJlc2VudCB0aGVyZSBhbmQgZG9uJ3RcbiAgICAgICAgLy8gZG8gYW55IG90aGVyIHByb2Nlc3NpbmdcbiAgICAgICAgaW5wdXQucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaW5wdXQuY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cbn07XG5UZW1wbGF0ZUVsZW1lbnRGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJUGxhdGZvcm0pXG5dLCBUZW1wbGF0ZUVsZW1lbnRGYWN0b3J5KTtcbmV4cG9ydCB7IFRlbXBsYXRlRWxlbWVudEZhY3RvcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWVsZW1lbnQtZmFjdG9yeS5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgQ2hpbGRyZW5PYnNlcnZlcl8xO1xuaW1wb3J0IHsgUHJvdG9jb2wsIE1ldGFkYXRhLCBmaXJzdERlZmluZWQsIGdldFByb3RvdHlwZUNoYWluIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbihjb25maWdPclRhcmdldCwgcHJvcCkge1xuICAgIGxldCBjb25maWc7XG4gICAgZnVuY3Rpb24gZGVjb3JhdG9yKCR0YXJnZXQsICRwcm9wKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gTm9uIGludm9jYXRpb246XG4gICAgICAgICAgICAvLyAtIEBjaGlsZHJlblxuICAgICAgICAgICAgLy8gSW52b2NhdGlvbiB3aXRoIG9yIHcvbyBvcHRzOlxuICAgICAgICAgICAgLy8gLSBAY2hpbGRyZW4oKVxuICAgICAgICAgICAgLy8gLSBAY2hpbGRyZW4oey4uLm9wdHN9KVxuICAgICAgICAgICAgY29uZmlnLnByb3BlcnR5ID0gJHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKENoaWxkcmVuLm5hbWUsIENoaWxkcmVuRGVmaW5pdGlvbi5jcmVhdGUoJHByb3AsIGNvbmZpZyksICR0YXJnZXQuY29uc3RydWN0b3IsICRwcm9wKTtcbiAgICAgICAgUHJvdG9jb2wuYW5ub3RhdGlvbi5hcHBlbmRUbygkdGFyZ2V0LmNvbnN0cnVjdG9yLCBDaGlsZHJlbi5rZXlGcm9tKCRwcm9wKSk7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBOb24gaW52b2NhdGlvbjpcbiAgICAgICAgLy8gLSBAY2hpbGRyZW5cbiAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIGRlY29yYXRvcihjb25maWdPclRhcmdldCwgcHJvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZ09yVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBDbGFzc0RlY29yYXRvclxuICAgICAgICAvLyAtIEBjaGlsZHJlbignYmFyJylcbiAgICAgICAgLy8gRGlyZWN0IGNhbGw6XG4gICAgICAgIC8vIC0gQGNoaWxkcmVuKCdiYXInKShGb28pXG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgIH1cbiAgICAvLyBJbnZvY2F0aW9uIHdpdGggb3Igdy9vIG9wdHM6XG4gICAgLy8gLSBAY2hpbGRyZW4oKVxuICAgIC8vIC0gQGNoaWxkcmVuKHsuLi5vcHRzfSlcbiAgICBjb25maWcgPSBjb25maWdPclRhcmdldCA9PT0gdm9pZCAwID8ge30gOiBjb25maWdPclRhcmdldDtcbiAgICByZXR1cm4gZGVjb3JhdG9yO1xufVxuZnVuY3Rpb24gaXNDaGlsZHJlbk9ic2VydmVyQW5ub3RhdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoQ2hpbGRyZW4ubmFtZSk7XG59XG5leHBvcnQgY29uc3QgQ2hpbGRyZW4gPSB7XG4gICAgbmFtZTogUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IoJ2NoaWxkcmVuLW9ic2VydmVyJyksXG4gICAga2V5RnJvbShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtDaGlsZHJlbi5uYW1lfToke25hbWV9YDtcbiAgICB9LFxuICAgIGZyb20oLi4uY2hpbGRyZW5PYnNlcnZlckxpc3RzKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuT2JzZXJ2ZXJzID0ge307XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgICAgICBmdW5jdGlvbiBhZGROYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuT2JzZXJ2ZXJzW25hbWVdID0gQ2hpbGRyZW5EZWZpbml0aW9uLmNyZWF0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGREZXNjcmlwdGlvbihuYW1lLCBkZWYpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuT2JzZXJ2ZXJzW25hbWVdID0gQ2hpbGRyZW5EZWZpbml0aW9uLmNyZWF0ZShuYW1lLCBkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZExpc3QobWF5YmVMaXN0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShtYXliZUxpc3QpKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVMaXN0LmZvckVhY2goYWRkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXliZUxpc3QgaW5zdGFuY2VvZiBDaGlsZHJlbkRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk9ic2VydmVyc1ttYXliZUxpc3QucHJvcGVydHldID0gbWF5YmVMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF5YmVMaXN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtYXliZUxpc3QpLmZvckVhY2gobmFtZSA9PiBhZGREZXNjcmlwdGlvbihuYW1lLCBtYXliZUxpc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbk9ic2VydmVyTGlzdHMuZm9yRWFjaChhZGRMaXN0KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuT2JzZXJ2ZXJzO1xuICAgIH0sXG4gICAgZ2V0QWxsKFR5cGUpIHtcbiAgICAgICAgY29uc3QgcHJvcFN0YXJ0ID0gQ2hpbGRyZW4ubmFtZS5sZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBkZWZzID0gW107XG4gICAgICAgIGNvbnN0IHByb3RvdHlwZUNoYWluID0gZ2V0UHJvdG90eXBlQ2hhaW4oVHlwZSk7XG4gICAgICAgIGxldCBpUHJvdG8gPSBwcm90b3R5cGVDaGFpbi5sZW5ndGg7XG4gICAgICAgIGxldCBpRGVmcyA9IDA7XG4gICAgICAgIGxldCBrZXlzO1xuICAgICAgICBsZXQga2V5c0xlbjtcbiAgICAgICAgbGV0IENsYXNzO1xuICAgICAgICB3aGlsZSAoLS1pUHJvdG8gPj0gMCkge1xuICAgICAgICAgICAgQ2xhc3MgPSBwcm90b3R5cGVDaGFpbltpUHJvdG9dO1xuICAgICAgICAgICAga2V5cyA9IFByb3RvY29sLmFubm90YXRpb24uZ2V0S2V5cyhDbGFzcykuZmlsdGVyKGlzQ2hpbGRyZW5PYnNlcnZlckFubm90YXRpb24pO1xuICAgICAgICAgICAga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWZzW2lEZWZzKytdID0gTWV0YWRhdGEuZ2V0T3duKENoaWxkcmVuLm5hbWUsIENsYXNzLCBrZXlzW2ldLnNsaWNlKHByb3BTdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZzO1xuICAgIH0sXG59O1xuY29uc3QgY2hpbGRPYnNlcnZlck9wdGlvbnMgPSB7IGNoaWxkTGlzdDogdHJ1ZSB9O1xuZXhwb3J0IGNsYXNzIENoaWxkcmVuRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHByb3BlcnR5LCBvcHRpb25zLCBxdWVyeSwgZmlsdGVyLCBtYXApIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHByb3AsIGRlZiA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5EZWZpbml0aW9uKGZpcnN0RGVmaW5lZChkZWYuY2FsbGJhY2ssIGAke3Byb3B9Q2hhbmdlZGApLCBmaXJzdERlZmluZWQoZGVmLnByb3BlcnR5LCBwcm9wKSwgZGVmLm9wdGlvbnMgPz8gY2hpbGRPYnNlcnZlck9wdGlvbnMsIGRlZi5xdWVyeSwgZGVmLmZpbHRlciwgZGVmLm1hcCk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xubGV0IENoaWxkcmVuT2JzZXJ2ZXIgPSBDaGlsZHJlbk9ic2VydmVyXzEgPSBjbGFzcyBDaGlsZHJlbk9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyLCBvYmosIHByb3BlcnR5S2V5LCBjYk5hbWUsIHF1ZXJ5ID0gZGVmYXVsdENoaWxkUXVlcnksIGZpbHRlciA9IGRlZmF1bHRDaGlsZEZpbHRlciwgbWFwID0gZGVmYXVsdENoaWxkTWFwLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm9ic2VydmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gKHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvYmpbY2JOYW1lXTtcbiAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9iaiwgdGhpcy5wcm9wZXJ0eUtleSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gdGhpcy5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgc2V0OiAoKSA9PiB7IHJldHVybjsgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICB0aGlzLnRyeVN0YXJ0T2JzZXJ2aW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSkgeyB9XG4gICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdGhpcy50cnlTdGFydE9ic2VydmluZygpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpO1xuICAgIH1cbiAgICB0cnlTdGFydE9ic2VydmluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9ic2VydmluZykge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGZpbHRlckNoaWxkcmVuKHRoaXMuY29udHJvbGxlciwgdGhpcy5xdWVyeSwgdGhpcy5maWx0ZXIsIHRoaXMubWFwKTtcbiAgICAgICAgICAgIGNvbnN0IG9icyA9IG5ldyB0aGlzLmNvbnRyb2xsZXIuaG9zdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4geyB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2VkKCk7IH0pO1xuICAgICAgICAgICAgb2JzLm9ic2VydmUodGhpcy5jb250cm9sbGVyLmhvc3QsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaGlsZHJlbkNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBmaWx0ZXJDaGlsZHJlbih0aGlzLmNvbnRyb2xsZXIsIHRoaXMucXVlcnksIHRoaXMuZmlsdGVyLCB0aGlzLm1hcCk7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLm9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzLm5vdGlmeSh0aGlzLmNoaWxkcmVuLCB1bmRlZmluZWQsIDggLyogdXBkYXRlVGFyZ2V0ICovKTtcbiAgICB9XG59O1xuQ2hpbGRyZW5PYnNlcnZlciA9IENoaWxkcmVuT2JzZXJ2ZXJfMSA9IF9fZGVjb3JhdGUoW1xuICAgIHN1YnNjcmliZXJDb2xsZWN0aW9uKClcbl0sIENoaWxkcmVuT2JzZXJ2ZXIpO1xuZXhwb3J0IHsgQ2hpbGRyZW5PYnNlcnZlciB9O1xuZnVuY3Rpb24gZGVmYXVsdENoaWxkUXVlcnkoY29udHJvbGxlcikge1xuICAgIHJldHVybiBjb250cm9sbGVyLmhvc3QuY2hpbGROb2Rlcztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDaGlsZEZpbHRlcihub2RlLCBjb250cm9sbGVyLCB2aWV3TW9kZWwpIHtcbiAgICByZXR1cm4gISF2aWV3TW9kZWw7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2hpbGRNYXAobm9kZSwgY29udHJvbGxlciwgdmlld01vZGVsKSB7XG4gICAgcmV0dXJuIHZpZXdNb2RlbDtcbn1cbmNvbnN0IGZvck9wdHMgPSB7IG9wdGlvbmFsOiB0cnVlIH07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyQ2hpbGRyZW4oY29udHJvbGxlciwgcXVlcnksIGZpbHRlciwgbWFwKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBxdWVyeShjb250cm9sbGVyKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG5vZGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBjb25zdCAkY29udHJvbGxlciA9IEN1c3RvbUVsZW1lbnQuZm9yKG5vZGUsIGZvck9wdHMpO1xuICAgICAgICBjb25zdCB2aWV3TW9kZWwgPSAkY29udHJvbGxlcj8udmlld01vZGVsID8/IG51bGw7XG4gICAgICAgIGlmIChmaWx0ZXIobm9kZSwgJGNvbnRyb2xsZXIsIHZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobWFwKG5vZGUsICRjb250cm9sbGVyLCB2aWV3TW9kZWwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZHJlbi5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb24gKi9cbmltcG9ydCB7IG5leHRJZCwgaXNPYmplY3QsIElMb2dnZXIsIE1ldGFkYXRhLCBESSwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQWNjZXNzU2NvcGVFeHByZXNzaW9uLCBTY29wZSwgSU9ic2VydmVyTG9jYXRvciwgSUV4cHJlc3Npb25QYXJzZXIsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBCaW5kYWJsZU9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24vYmluZGFibGUtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgY29udmVydFRvUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudERlZmluaXRpb24sIEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgZ2V0UmVuZGVyQ29udGV4dCB9IGZyb20gJy4vcmVuZGVyLWNvbnRleHQuanMnO1xuaW1wb3J0IHsgQ2hpbGRyZW5PYnNlcnZlciB9IGZyb20gJy4vY2hpbGRyZW4uanMnO1xuaW1wb3J0IHsgSUFwcFJvb3QgfSBmcm9tICcuLi9hcHAtcm9vdC5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBJU2hhZG93RE9NR2xvYmFsU3R5bGVzLCBJU2hhZG93RE9NU3R5bGVzIH0gZnJvbSAnLi9zdHlsZXMuanMnO1xuaW1wb3J0IHsgQ29tcHV0ZWRXYXRjaGVyLCBFeHByZXNzaW9uV2F0Y2hlciB9IGZyb20gJy4vd2F0Y2hlcnMuanMnO1xuZnVuY3Rpb24gY2FsbERpc3Bvc2UoZGlzcG9zYWJsZSkge1xuICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xufVxuZXhwb3J0IHZhciBNb3VudFRhcmdldDtcbihmdW5jdGlvbiAoTW91bnRUYXJnZXQpIHtcbiAgICBNb3VudFRhcmdldFtNb3VudFRhcmdldFtcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgIE1vdW50VGFyZ2V0W01vdW50VGFyZ2V0W1wiaG9zdFwiXSA9IDFdID0gXCJob3N0XCI7XG4gICAgTW91bnRUYXJnZXRbTW91bnRUYXJnZXRbXCJzaGFkb3dSb290XCJdID0gMl0gPSBcInNoYWRvd1Jvb3RcIjtcbiAgICBNb3VudFRhcmdldFtNb3VudFRhcmdldFtcImxvY2F0aW9uXCJdID0gM10gPSBcImxvY2F0aW9uXCI7XG59KShNb3VudFRhcmdldCB8fCAoTW91bnRUYXJnZXQgPSB7fSkpO1xuY29uc3Qgb3B0aW9uYWwgPSB7IG9wdGlvbmFsOiB0cnVlIH07XG5jb25zdCBjb250cm9sbGVyTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBjb250YWluZXIsIHZtS2luZCwgZmxhZ3MsIGRlZmluaXRpb24sIFxuICAgIC8qKlxuICAgICAqIFRoZSB2aWV3RmFjdG9yeS4gT25seSBwcmVzZW50IGZvciBzeW50aGV0aWMgdmlld3MuXG4gICAgICovXG4gICAgdmlld0ZhY3RvcnksIFxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNraW5nIHZpZXdNb2RlbC4gT25seSBwcmVzZW50IGZvciBjdXN0b20gYXR0cmlidXRlcyBhbmQgZWxlbWVudHMuXG4gICAgICovXG4gICAgdmlld01vZGVsLCBcbiAgICAvKipcbiAgICAgKiBUaGUgcGh5c2ljYWwgaG9zdCBkb20gbm9kZS5cbiAgICAgKlxuICAgICAqIEZvciBjb250YWluZXJsZXNzIGVsZW1lbnRzLCB0aGlzIG5vZGUgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIERPTSBhbmQgcmVwbGFjZWQgYnkgYSBjb21tZW50LCB3aGljaCBpcyBhc3NpZ25lZCB0byB0aGUgYGxvY2F0aW9uYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEZvciBTaGFkb3dET00gZWxlbWVudHMsIHRoaXMgd2lsbCBiZSB0aGUgb3JpZ2luYWwgZGVjbGFyaW5nIGVsZW1lbnQsIE5PVCB0aGUgc2hhZG93IHJvb3QgKHRoZSBzaGFkb3cgcm9vdCBpcyBzdG9yZWQgb24gdGhlIGBzaGFkb3dSb290YCBwcm9wZXJ0eSlcbiAgICAgKi9cbiAgICBob3N0KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnZtS2luZCA9IHZtS2luZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICB0aGlzLnZpZXdGYWN0b3J5ID0gdmlld0ZhY3Rvcnk7XG4gICAgICAgIHRoaXMudmlld01vZGVsID0gdmlld01vZGVsO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzTG9ja2VkU2NvcGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0cmljdEJpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaG9zdFNjb3BlID0gbnVsbDtcbiAgICAgICAgLy8gSWYgYSBob3N0IGZyb20gYW5vdGhlciBjdXN0b20gZWxlbWVudCB3YXMgcGFzc2VkIGluLCB0aGVuIHRoaXMgd2lsbCBiZSB0aGUgY29udHJvbGxlciBmb3IgdGhhdCBjdXN0b20gZWxlbWVudCAoY291bGQgYmUgYGF1LXZpZXdwb3J0YCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhpcyBjb250cm9sbGVyIHdpbGwgY3JlYXRlIGEgbmV3IGhvc3Qgbm9kZSAod2l0aCB0aGUgZGVmaW5pdGlvbidzIG5hbWUpIGFuZCB1c2UgdGhhdCBhcyB0aGUgdGFyZ2V0IGhvc3QgZm9yIHRoZSBub2RlcyBpbnN0ZWFkLlxuICAgICAgICAvLyBUaGF0IGhvc3Qgbm9kZSBpcyBzZXBhcmF0ZWx5IG1vdW50ZWQgdG8gdGhlIGhvc3QgY29udHJvbGxlcidzIG9yaWdpbmFsIGhvc3Qgbm9kZS5cbiAgICAgICAgdGhpcy5ob3N0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRUYXJnZXQgPSAwIC8qIG5vbmUgKi87XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogbm9uZSAqLztcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRlYnVnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnVsbHlOYW1lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRpbml0aWF0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLiRmbGFncyA9IDAgLyogbm9uZSAqLztcbiAgICAgICAgdGhpcy4kcmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy4kcmVqZWN0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmFjdGl2YXRpbmdTdGFjayA9IDA7XG4gICAgICAgIHRoaXMuZGV0YWNoaW5nU3RhY2sgPSAwO1xuICAgICAgICB0aGlzLnVuYmluZGluZ1N0YWNrID0gMDtcbiAgICAgICAgaWYgKHJvb3QgPT09IG51bGwgJiYgY29udGFpbmVyLmhhcyhJQXBwUm9vdCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGNvbnRhaW5lci5nZXQoSUFwcFJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBjb250YWluZXIuZ2V0KElQbGF0Zm9ybSk7XG4gICAgICAgIHN3aXRjaCAodm1LaW5kKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogY3VzdG9tQXR0cmlidXRlICovOlxuICAgICAgICAgICAgY2FzZSAwIC8qIGN1c3RvbUVsZW1lbnQgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBIb29rc0RlZmluaXRpb24odmlld01vZGVsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBzeW50aGV0aWMgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcyA9IEhvb2tzRGVmaW5pdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlICYgKDEgLyogYWN0aXZhdGluZyAqLyB8IDIgLyogYWN0aXZhdGVkICovKSkgPiAwICYmICh0aGlzLnN0YXRlICYgNCAvKiBkZWFjdGl2YXRpbmcgKi8pID09PSAwO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudm1LaW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIGN1c3RvbUF0dHJpYnV0ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBbJHt0aGlzLmRlZmluaXRpb24ubmFtZX1dYDtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogY3VzdG9tRWxlbWVudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbi5uYW1lO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBzeW50aGV0aWMgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdGYWN0b3J5Lm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnZtS2luZCkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIGN1c3RvbUF0dHJpYnV0ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wYXJlbnQubmFtZX0+WyR7dGhpcy5kZWZpbml0aW9uLm5hbWV9XWA7XG4gICAgICAgICAgICBjYXNlIDAgLyogY3VzdG9tRWxlbWVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wYXJlbnQubmFtZX0+JHt0aGlzLmRlZmluaXRpb24ubmFtZX1gO1xuICAgICAgICAgICAgY2FzZSAyIC8qIHN5bnRoZXRpYyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RmFjdG9yeS5uYW1lID09PSB0aGlzLnBhcmVudC5kZWZpbml0aW9uPy5uYW1lXG4gICAgICAgICAgICAgICAgICAgID8gYCR7dGhpcy5wYXJlbnQubmFtZX1bdmlld11gXG4gICAgICAgICAgICAgICAgICAgIDogYCR7dGhpcy5wYXJlbnQubmFtZX1bdmlldzoke3RoaXMudmlld0ZhY3RvcnkubmFtZX1dYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2FjaGVkKHZpZXdNb2RlbCkge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlckxvb2t1cC5nZXQodmlld01vZGVsKTtcbiAgICB9XG4gICAgc3RhdGljIGdldENhY2hlZE9yVGhyb3codmlld01vZGVsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBDb250cm9sbGVyLmdldENhY2hlZCh2aWV3TW9kZWwpO1xuICAgICAgICBpZiAoY29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIGNhY2hlZCBjb250cm9sbGVyIGZvciB0aGUgcHJvdmlkZWQgVmlld01vZGVsOiAke1N0cmluZyh2aWV3TW9kZWwpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yQ3VzdG9tRWxlbWVudChyb290LCBjb250YWluZXIsIHZpZXdNb2RlbCwgaG9zdCwgXG4gICAgLy8gcHJvamVjdGlvbnMgKnRhcmdldGVkKiBmb3IgdGhpcyBjdXN0b20gZWxlbWVudC4gdGhlc2UgYXJlIG5vdCB0aGUgcHJvamVjdGlvbnMgKnByb3ZpZGVkKiBieSB0aGlzIGN1c3RvbSBlbGVtZW50LlxuICAgIHRhcmdldGVkUHJvamVjdGlvbnMsIGZsYWdzID0gMCAvKiBub25lICovLCBoeWRyYXRlID0gdHJ1ZSwgXG4gICAgLy8gVXNlIHRoaXMgd2hlbiBgaW5zdGFuY2UuY29uc3RydWN0b3JgIGlzIG5vdCBhIGN1c3RvbSBlbGVtZW50IHR5cGUgdG8gcGFzcyBvbiB0aGUgQ3VzdG9tRWxlbWVudCBkZWZpbml0aW9uXG4gICAgZGVmaW5pdGlvbiA9IHZvaWQgMCkge1xuICAgICAgICBpZiAoY29udHJvbGxlckxvb2t1cC5oYXModmlld01vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJMb29rdXAuZ2V0KHZpZXdNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24gPz8gQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKHZpZXdNb2RlbC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcihcbiAgICAgICAgLyogcm9vdCAgICAgICAgICAgKi8gcm9vdCwgXG4gICAgICAgIC8qIGNvbnRhaW5lciAgICAgICovIGNvbnRhaW5lciwgMCAvKiBjdXN0b21FbGVtZW50ICovLCBcbiAgICAgICAgLyogZmxhZ3MgICAgICAgICAgKi8gZmxhZ3MsIFxuICAgICAgICAvKiBkZWZpbml0aW9uICAgICAqLyBkZWZpbml0aW9uLCBcbiAgICAgICAgLyogdmlld0ZhY3RvcnkgICAgKi8gbnVsbCwgXG4gICAgICAgIC8qIHZpZXdNb2RlbCAgICAgICovIHZpZXdNb2RlbCwgXG4gICAgICAgIC8qIGhvc3QgICAgICAgICAgICovIGhvc3QpO1xuICAgICAgICBjb250cm9sbGVyTG9va3VwLnNldCh2aWV3TW9kZWwsIGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoaHlkcmF0ZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5oeWRyYXRlQ3VzdG9tRWxlbWVudChjb250YWluZXIsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yQ3VzdG9tQXR0cmlidXRlKHJvb3QsIGNvbnRhaW5lciwgdmlld01vZGVsLCBob3N0LCBmbGFncyA9IDAgLyogbm9uZSAqLykge1xuICAgICAgICBpZiAoY29udHJvbGxlckxvb2t1cC5oYXModmlld01vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJMb29rdXAuZ2V0KHZpZXdNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEN1c3RvbUF0dHJpYnV0ZS5nZXREZWZpbml0aW9uKHZpZXdNb2RlbC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcihcbiAgICAgICAgLyogcm9vdCAgICAgICAgICAgKi8gcm9vdCwgXG4gICAgICAgIC8qIGNvbnRhaW5lciAgICAgICovIGNvbnRhaW5lciwgMSAvKiBjdXN0b21BdHRyaWJ1dGUgKi8sIFxuICAgICAgICAvKiBmbGFncyAgICAgICAgICAqLyBmbGFncywgXG4gICAgICAgIC8qIGRlZmluaXRpb24gICAgICovIGRlZmluaXRpb24sIFxuICAgICAgICAvKiB2aWV3RmFjdG9yeSAgICAqLyBudWxsLCBcbiAgICAgICAgLyogdmlld01vZGVsICAgICAgKi8gdmlld01vZGVsLCBcbiAgICAgICAgLyogaG9zdCAgICAgICAgICAgKi8gaG9zdCk7XG4gICAgICAgIGNvbnRyb2xsZXJMb29rdXAuc2V0KHZpZXdNb2RlbCwgY29udHJvbGxlcik7XG4gICAgICAgIGNvbnRyb2xsZXIuaHlkcmF0ZUN1c3RvbUF0dHJpYnV0ZSgpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gICAgc3RhdGljIGZvclN5bnRoZXRpY1ZpZXcocm9vdCwgY29udGV4dCwgdmlld0ZhY3RvcnksIGZsYWdzID0gMCAvKiBub25lICovLCBwYXJlbnRDb250cm9sbGVyID0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcihcbiAgICAgICAgLyogcm9vdCAgICAgICAgICAgKi8gcm9vdCwgXG4gICAgICAgIC8qIGNvbnRhaW5lciAgICAgICovIGNvbnRleHQsIDIgLyogc3ludGhldGljICovLCBcbiAgICAgICAgLyogZmxhZ3MgICAgICAgICAgKi8gZmxhZ3MsIFxuICAgICAgICAvKiBkZWZpbml0aW9uICAgICAqLyBudWxsLCBcbiAgICAgICAgLyogdmlld0ZhY3RvcnkgICAgKi8gdmlld0ZhY3RvcnksIFxuICAgICAgICAvKiB2aWV3TW9kZWwgICAgICAqLyBudWxsLCBcbiAgICAgICAgLyogaG9zdCAgICAgICAgICAgKi8gbnVsbCk7XG4gICAgICAgIGNvbnRyb2xsZXIucGFyZW50ID0gcGFyZW50Q29udHJvbGxlciA/PyBudWxsO1xuICAgICAgICBjb250cm9sbGVyLmh5ZHJhdGVTeW50aGV0aWMoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaHlkcmF0ZUN1c3RvbUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0YXJnZXRlZFByb2plY3Rpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gcGFyZW50Q29udGFpbmVyLmdldChJTG9nZ2VyKS5yb290O1xuICAgICAgICB0aGlzLmRlYnVnID0gdGhpcy5sb2dnZXIuY29uZmlnLmxldmVsIDw9IDEgLyogZGVidWcgKi87XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHRoaXMubG9nZ2VyLnNjb3BlVG8odGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmaW5pdGlvbiA9IHRoaXMuZGVmaW5pdGlvbjtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSB0aGlzLmZsYWdzO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMudmlld01vZGVsO1xuICAgICAgICB0aGlzLnNjb3BlID0gU2NvcGUuY3JlYXRlKGluc3RhbmNlLCBudWxsLCB0cnVlKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ud2F0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVycyh0aGlzLCB0aGlzLmNvbnRhaW5lciwgZGVmaW5pdGlvbiwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZU9ic2VydmVycyh0aGlzLCBkZWZpbml0aW9uLCBmbGFncywgaW5zdGFuY2UpO1xuICAgICAgICBjcmVhdGVDaGlsZHJlbk9ic2VydmVycyh0aGlzLCBkZWZpbml0aW9uLCBmbGFncywgaW5zdGFuY2UpO1xuICAgICAgICBpZiAodGhpcy5ob29rcy5oYXNEZWZpbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGludm9raW5nIGRlZmluZSgpIGhvb2tgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGluc3RhbmNlLmRlZmluZShcbiAgICAgICAgICAgIC8qIGNvbnRyb2xsZXIgICAgICAqLyB0aGlzLCBcbiAgICAgICAgICAgIC8qIHBhcmVudENvbnRhaW5lciAqLyBwYXJlbnRDb250YWluZXIsIFxuICAgICAgICAgICAgLyogZGVmaW5pdGlvbiAgICAgICovIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwICYmIHJlc3VsdCAhPT0gZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5nZXRPckNyZWF0ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQgPSBnZXRSZW5kZXJDb250ZXh0KGRlZmluaXRpb24sIHBhcmVudENvbnRhaW5lciwgdGFyZ2V0ZWRQcm9qZWN0aW9ucz8ucHJvamVjdGlvbnMpO1xuICAgICAgICAvLyBTdXBwb3J0IFJlY3Vyc2l2ZSBDb21wb25lbnRzIGJ5IGFkZGluZyBzZWxmIHRvIG93biBjb250ZXh0XG4gICAgICAgIGRlZmluaXRpb24ucmVnaXN0ZXIoY29udGV4dCk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmluamVjdGFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIHJlZ2lzdGVyZWQgYXMgaW5qZWN0YWJsZSwgc3VwcG9ydCBpbmplY3RpbmcgdGhlIGluc3RhbmNlIGludG8gY2hpbGRyZW5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5DaGlsZENvbXBvbmVudE9wZXJhdGlvbihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBjb250cm9sbGVyLCB0aGVuIHRoZSBBcHBSb290IHdpbGwgaW52b2tlIHRoaW5ncyBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICAgICAgICAvLyAtIENvbnRyb2xsZXIuaHlkcmF0ZUN1c3RvbUVsZW1lbnRcbiAgICAgICAgLy8gLSBydW5BcHBUYXNrcygnaHlkcmF0aW5nJykgLy8gbWF5IHJldHVybiBhIHByb21pc2VcbiAgICAgICAgLy8gLSBDb250cm9sbGVyLmNvbXBpbGVcbiAgICAgICAgLy8gLSBydW5BcHBUYXNrcygnaHlkcmF0ZWQnKSAvLyBtYXkgcmV0dXJuIGEgcHJvbWlzZVxuICAgICAgICAvLyAtIENvbnRyb2xsZXIuY29tcGlsZUNoaWxkcmVuXG4gICAgICAgIC8vIFRoaXMga2VlcHMgaHlkcmF0aW9uIHN5bmNocm9ub3VzIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSBjb21wb3NpdGlvbiByb290IGNvbXBpbGUgaG9va3MgdG8gZG8gYXN5bmMgd29yay5cbiAgICAgICAgaWYgKHRoaXMucm9vdD8uY29udHJvbGxlciAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5oeWRyYXRlKHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5oeWRyYXRlQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaHlkcmF0ZSh0YXJnZXRlZFByb2plY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgaW52b2tpbmcgaGFzSHlkcmF0aW5nKCkgaG9va2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaHlkcmF0aW5nKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBpbGVkQ29udGV4dCA9IHRoaXMuY29udGV4dC5jb21waWxlKHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb25zTWFwLCBzaGFkb3dPcHRpb25zLCBpc1N0cmljdEJpbmRpbmcsIGhhc1Nsb3RzLCBjb250YWluZXJsZXNzIH0gPSBjb21waWxlZENvbnRleHQuY29tcGlsZWREZWZpbml0aW9uO1xuICAgICAgICBjb21waWxlZENvbnRleHQucmVnaXN0ZXJQcm9qZWN0aW9ucyhwcm9qZWN0aW9uc01hcCwgdGhpcy5zY29wZSk7XG4gICAgICAgIC8vIG9uY2UgdGhlIHByb2plY3Rpb25zIGFyZSByZWdpc3RlcmVkLCB3ZSBjYW4gY2xlYW51cCB0aGUgcHJvamVjdGlvbiBtYXAgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXG4gICAgICAgIHByb2plY3Rpb25zTWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaXNTdHJpY3RCaW5kaW5nID0gaXNTdHJpY3RCaW5kaW5nO1xuICAgICAgICBpZiAoKHRoaXMuaG9zdENvbnRyb2xsZXIgPSBDdXN0b21FbGVtZW50LmZvcih0aGlzLmhvc3QsIG9wdGlvbmFsKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IHRoaXMucGxhdGZvcm0uZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmNvbnRleHQuZGVmaW5pdGlvbi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ3VzdG9tRWxlbWVudC5uYW1lLCB0aGlzLCB0aGlzLmhvc3QpO1xuICAgICAgICBpZiAoc2hhZG93T3B0aW9ucyAhPT0gbnVsbCB8fCBoYXNTbG90cykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcmxlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgY29tYmluZSB0aGUgY29udGFpbmVybGVzcyBjdXN0b20gZWxlbWVudCBvcHRpb24gd2l0aCBTaGFkb3cgRE9NLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUVsZW1lbnQubmFtZSwgdGhpcywgdGhpcy5zaGFkb3dSb290ID0gdGhpcy5ob3N0LmF0dGFjaFNoYWRvdyhzaGFkb3dPcHRpb25zID8/IGRlZmF1bHRTaGFkb3dPcHRpb25zKSk7XG4gICAgICAgICAgICB0aGlzLm1vdW50VGFyZ2V0ID0gMiAvKiBzaGFkb3dSb290ICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5lcmxlc3MpIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShDdXN0b21FbGVtZW50Lm5hbWUsIHRoaXMsIHRoaXMubG9jYXRpb24gPSBjb252ZXJ0VG9SZW5kZXJMb2NhdGlvbih0aGlzLmhvc3QpKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRUYXJnZXQgPSAzIC8qIGxvY2F0aW9uICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3VudFRhcmdldCA9IDEgLyogaG9zdCAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdNb2RlbC4kY29udHJvbGxlciA9IHRoaXM7XG4gICAgICAgIHRoaXMubm9kZXMgPSBjb21waWxlZENvbnRleHQuY3JlYXRlTm9kZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuaG9va3MuaGFzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGludm9raW5nIGhhc0h5ZHJhdGVkKCkgaG9va2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaHlkcmF0ZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGh5ZHJhdGVDaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0cyA9IHRoaXMubm9kZXMuZmluZFRhcmdldHMoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbmRlcihcbiAgICAgICAgLyogZmxhZ3MgICAgICAqLyB0aGlzLmZsYWdzLCBcbiAgICAgICAgLyogY29udHJvbGxlciAqLyB0aGlzLCBcbiAgICAgICAgLyogdGFyZ2V0cyAgICAqLyB0YXJnZXRzLCBcbiAgICAgICAgLyogZGVmaW5pdGlvbiAqLyB0aGlzLmNvbnRleHQuY29tcGlsZWREZWZpbml0aW9uLCBcbiAgICAgICAgLyogaG9zdCAgICAgICAqLyB0aGlzLmhvc3QpO1xuICAgICAgICBpZiAodGhpcy5ob29rcy5oYXNDcmVhdGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBpbnZva2luZyBjcmVhdGVkKCkgaG9va2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY3JlYXRlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoeWRyYXRlQ3VzdG9tQXR0cmlidXRlKCkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5kZWZpbml0aW9uO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMudmlld01vZGVsO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi53YXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXJzKHRoaXMsIHRoaXMuY29udGFpbmVyLCBkZWZpbml0aW9uLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlT2JzZXJ2ZXJzKHRoaXMsIGRlZmluaXRpb24sIHRoaXMuZmxhZ3MsIGluc3RhbmNlKTtcbiAgICAgICAgaW5zdGFuY2UuJGNvbnRyb2xsZXIgPSB0aGlzO1xuICAgIH1cbiAgICBoeWRyYXRlU3ludGhldGljKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgY29uc3QgY29tcGlsZWRDb250ZXh0ID0gY29udGV4dC5jb21waWxlKG51bGwpO1xuICAgICAgICBjb25zdCBjb21waWxlZERlZmluaXRpb24gPSBjb21waWxlZENvbnRleHQuY29tcGlsZWREZWZpbml0aW9uO1xuICAgICAgICB0aGlzLmlzU3RyaWN0QmluZGluZyA9IGNvbXBpbGVkRGVmaW5pdGlvbi5pc1N0cmljdEJpbmRpbmc7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5ub2RlcyA9IGNvbXBpbGVkQ29udGV4dC5jcmVhdGVOb2RlcygpO1xuICAgICAgICBjb25zdCB0YXJnZXRzID0gbm9kZXMuZmluZFRhcmdldHMoKTtcbiAgICAgICAgY29tcGlsZWRDb250ZXh0LnJlbmRlcihcbiAgICAgICAgLyogZmxhZ3MgICAgICAqLyB0aGlzLmZsYWdzLCBcbiAgICAgICAgLyogY29udHJvbGxlciAqLyB0aGlzLCBcbiAgICAgICAgLyogdGFyZ2V0cyAgICAqLyB0YXJnZXRzLCBcbiAgICAgICAgLyogZGVmaW5pdGlvbiAqLyBjb21waWxlZERlZmluaXRpb24sIFxuICAgICAgICAvKiBob3N0ICAgICAgICovIHZvaWQgMCk7XG4gICAgfVxuICAgIGFjdGl2YXRlKGluaXRpYXRvciwgcGFyZW50LCBmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBub25lICovOlxuICAgICAgICAgICAgY2FzZSA4IC8qIGRlYWN0aXZhdGVkICovOlxuICAgICAgICAgICAgICAgIGlmICghKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQuaXNBY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSByb290LCBhbmQgdGhlIHBhcmVudCBpcyBlaXRoZXI6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIE5vdCBhY3RpdmF0ZWQsIG9yIGFjdGl2YXRpbmcgY2hpbGRyZW4gT1JcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gRGVhY3RpdmF0aW5nIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAvLyBhYm9ydC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHByb2NlZWQgbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgLy8gJ2RlYWN0aXZhdGVkJyBhbmQgJ25vbmUnIGFyZSB0cmVhdGVkIHRoZSBzYW1lIGJlY2F1c2UsIGZyb20gYW4gYWN0aXZhdGlvbiBwZXJzcGVjdGl2ZSwgdGhleSBtZWFuIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIGFjdGl2YXRpbmcgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogYWN0aXZhdGVkICovOlxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgYWN0aXZhdGVkLCBubyBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgMzIgLyogZGlzcG9zZWQgKi86XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX0gdHJ5aW5nIHRvIGFjdGl2YXRlIGEgY29udHJvbGxlciB0aGF0IGlzIGRpc3Bvc2VkLmApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfSB1bmV4cGVjdGVkIHN0YXRlOiAke3N0cmluZ2lmeVN0YXRlKHRoaXMuc3RhdGUpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcgJiYgIXRoaXMuZnVsbHlOYW1lZCkge1xuICAgICAgICAgICAgdGhpcy5mdWxseU5hbWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gdGhpcy5jb250ZXh0LmdldChJTG9nZ2VyKS5yb290LnNjb3BlVG8odGhpcy5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBhY3RpdmF0ZSgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0U2NvcGUgPSBob3N0U2NvcGUgPz8gbnVsbDtcbiAgICAgICAgZmxhZ3MgfD0gMzIgLyogZnJvbUJpbmQgKi87XG4gICAgICAgIHN3aXRjaCAodGhpcy52bUtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBjdXN0b21FbGVtZW50ICovOlxuICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBlbGVtZW50IHNjb3BlIGlzIGNyZWF0ZWQgYW5kIGFzc2lnbmVkIGR1cmluZyBoeWRyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLnBhcmVudFNjb3BlID0gc2NvcGUgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBjdXN0b21BdHRyaWJ1dGUgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlID8/IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogc3ludGhldGljICovOlxuICAgICAgICAgICAgICAgIGlmIChzY29wZSA9PT0gdm9pZCAwIHx8IHNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NvcGUgaXMgbnVsbCBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0xvY2tlZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTdHJpY3RCaW5kaW5nKSB7XG4gICAgICAgICAgICBmbGFncyB8PSA0IC8qIGlzU3RyaWN0QmluZGluZ1N0cmF0ZWd5ICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGluaXRpYXRvciA9IGluaXRpYXRvcjtcbiAgICAgICAgdGhpcy4kZmxhZ3MgPSBmbGFncztcbiAgICAgICAgLy8gb3Bwb3NpbmcgbGVhdmUgaXMgY2FsbGVkIGluIGF0dGFjaCgpICh3aGljaCB3aWxsIHRyaWdnZXIgYXR0YWNoZWQoKSlcbiAgICAgICAgdGhpcy5lbnRlckFjdGl2YXRpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuaG9va3MuaGFzQmluZGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgYmluZGluZygpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLnZpZXdNb2RlbC5iaW5kaW5nKHRoaXMuJGluaXRpYXRvciwgdGhpcy5wYXJlbnQsIHRoaXMuJGZsYWdzKTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy4kcHJvbWlzZTtcbiAgICB9XG4gICAgYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBiaW5kKClgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iaW5kaW5ncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tpXS4kYmluZCh0aGlzLiRmbGFncywgdGhpcy5zY29wZSwgdGhpcy5ob3N0U2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBib3VuZCgpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLnZpZXdNb2RlbC5ib3VuZCh0aGlzLiRpbml0aWF0b3IsIHRoaXMucGFyZW50LCB0aGlzLiRmbGFncyk7XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJldC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dGFjaCgpO1xuICAgIH1cbiAgICBhcHBlbmQoLi4ubm9kZXMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vdW50VGFyZ2V0KSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogaG9zdCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3QuYXBwZW5kKC4uLm5vZGVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBzaGFkb3dSb290ICovOlxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmQoLi4ubm9kZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIGxvY2F0aW9uICovOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2Rlc1tpXSwgdGhpcy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBhdHRhY2goKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvc3RDb250cm9sbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMubW91bnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogaG9zdCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogc2hhZG93Um9vdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0Q29udHJvbGxlci5hcHBlbmQodGhpcy5ob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIGxvY2F0aW9uICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RDb250cm9sbGVyLmFwcGVuZCh0aGlzLmxvY2F0aW9uLiRzdGFydCwgdGhpcy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb3VudFRhcmdldCkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIGhvc3QgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5hcHBlbmRUbyh0aGlzLmhvc3QsIHRoaXMuZGVmaW5pdGlvbj8uZW5oYW5jZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogc2hhZG93Um9vdCAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHRoaXMuY29udGV4dC5oYXMoSVNoYWRvd0RPTVN0eWxlcywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5jb250ZXh0LmdldChJU2hhZG93RE9NU3R5bGVzKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY29udGV4dC5nZXQoSVNoYWRvd0RPTUdsb2JhbFN0eWxlcyk7XG4gICAgICAgICAgICAgICAgc3R5bGVzLmFwcGx5VG8odGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmFwcGVuZFRvKHRoaXMuc2hhZG93Um9vdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDMgLyogbG9jYXRpb24gKi86XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5pbnNlcnRCZWZvcmUodGhpcy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9va3MuaGFzQXR0YWNoaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBhdHRhY2hpbmcoKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy52aWV3TW9kZWwuYXR0YWNoaW5nKHRoaXMuJGluaXRpYXRvciwgdGhpcy5wYXJlbnQsIHRoaXMuJGZsYWdzKTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlckFjdGl2YXRpbmcoKTtcbiAgICAgICAgICAgICAgICByZXQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmVBY3RpdmF0aW5nKCk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2hpbmcoKSBhbmQgY2hpbGQgYWN0aXZhdGlvbiBydW4gaW4gcGFyYWxsZWwsIGFuZCBhdHRhY2hlZCgpIGlzIGNhbGxlZCB3aGVuIGJvdGggYXJlIGZpbmlzaGVkXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBBbnkgcHJvbWlzZXMgcmV0dXJuZWQgZnJvbSBjaGlsZCBhY3RpdmF0aW9uIGFyZSBjdW11bGF0aXZlbHkgYXdhaXRlZCBiZWZvcmUgdGhpcy4kcHJvbWlzZSByZXNvbHZlc1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5jaGlsZHJlbltpXS5hY3RpdmF0ZSh0aGlzLiRpbml0aWF0b3IsIHRoaXMsIHRoaXMuJGZsYWdzLCB0aGlzLnNjb3BlLCB0aGlzLmhvc3RTY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXR0YWNoZWQoKSBpcyBpbnZva2VkIGJ5IENvbnRyb2xsZXIjbGVhdmVBY3RpdmF0aW5nIHdoZW4gYGFjdGl2YXRpbmdTdGFja2AgcmVhY2hlcyAwXG4gICAgICAgIHRoaXMubGVhdmVBY3RpdmF0aW5nKCk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHN3aXRjaCAoKHRoaXMuc3RhdGUgJiB+MTYgLyogcmVsZWFzZWQgKi8pKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogYWN0aXZhdGVkICovOlxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGZ1bGx5IGFjdGl2YXRlZCwgc28gcHJvY2VlZCB3aXRoIG5vcm1hbCBkZWFjdGl2YXRpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQgLyogZGVhY3RpdmF0aW5nICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwIC8qIG5vbmUgKi86XG4gICAgICAgICAgICBjYXNlIDggLyogZGVhY3RpdmF0ZWQgKi86XG4gICAgICAgICAgICBjYXNlIDMyIC8qIGRpc3Bvc2VkICovOlxuICAgICAgICAgICAgY2FzZSA4IC8qIGRlYWN0aXZhdGVkICovIHwgMzIgLyogZGlzcG9zZWQgKi86XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgYWxyZWFkeSBkZWFjdGl2YXRlZCAob3IgZXZlbiBkaXNwb3NlZCksIG9yIG5ldmVyIGFjdGl2YXRlZCBpbiB0aGUgZmlyc3QgcGxhY2UsIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfSB1bmV4cGVjdGVkIHN0YXRlOiAke3N0cmluZ2lmeVN0YXRlKHRoaXMuc3RhdGUpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGRlYWN0aXZhdGUoKWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGluaXRpYXRvciA9IGluaXRpYXRvcjtcbiAgICAgICAgdGhpcy4kZmxhZ3MgPSBmbGFncztcbiAgICAgICAgaWYgKGluaXRpYXRvciA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5lbnRlckRldGFjaGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGlsZCBwcm9taXNlIHJlc3VsdHMgYXJlIHRyYWNrZWQgYnkgZW50ZXIvbGVhdmUgY29tYm8nc1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5jaGlsZHJlbltpXS5kZWFjdGl2YXRlKGluaXRpYXRvciwgdGhpcywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0RldGFjaGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgZGV0YWNoaW5nKClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMudmlld01vZGVsLmRldGFjaGluZyh0aGlzLiRpbml0aWF0b3IsIHRoaXMucGFyZW50LCB0aGlzLiRmbGFncyk7XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIGluaXRpYXRvci5lbnRlckRldGFjaGluZygpO1xuICAgICAgICAgICAgICAgIHJldC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhdG9yLmxlYXZlRGV0YWNoaW5nKCk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhdG9yLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGlmIGEgM3JkIHBhcnR5IHBsdWdpbiBoYXBwZW5zIHRvIGRvIGFueSBhc3luYyBzdHVmZiBpbiBhIHRlbXBsYXRlIGNvbnRyb2xsZXIgYmVmb3JlIGNhbGxpbmcgZGVhY3RpdmF0ZSBvbiBpdHMgdmlldyxcbiAgICAgICAgLy8gdGhlbiB0aGUgbGlua2luZyB3aWxsIGJlY29tZSBvdXQgb2Ygb3JkZXIuXG4gICAgICAgIC8vIEZvciBmcmFtZXdvcmsgY29tcG9uZW50cywgdGhpcyBzaG91bGRuJ3QgY2F1c2UgaXNzdWVzLlxuICAgICAgICAvLyBXZSBjYW4gb25seSBwcmV2ZW50IHRoYXQgYnkgbGlua2luZyB1cCBhZnRlciBhd2FpdGluZyB0aGUgZGV0YWNoaW5nIHByb21pc2UsIHdoaWNoIHdvdWxkIGFkZCBhbiBleHRyYSB0aWNrICsgYSBmYWlyIGJpdCBvZlxuICAgICAgICAvLyBvdmVyaGVhZCBvbiB0aGlzIGhvdCBwYXRoLCBzbyBpdCdzIChmb3Igbm93KSBhIGRlbGliZXJhdGUgY2hvaWNlIHRvIG5vdCBhY2NvdW50IGZvciBzdWNoIHNpdHVhdGlvbi5cbiAgICAgICAgLy8gSnVzdCBsZWF2aW5nIHRoZSBub3RlIGhlcmUgc28gdGhhdCB3ZSBrbm93IHRvIGxvb2sgaGVyZSBpZiBhIHdlaXJkIGRldGFjaGluZy1yZWxhdGVkIHRpbWluZyBpc3N1ZSBpcyBldmVyIHJlcG9ydGVkLlxuICAgICAgICBpZiAoaW5pdGlhdG9yLmhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGluaXRpYXRvci5oZWFkID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluaXRpYXRvci50YWlsLm5leHQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYXRvci50YWlsID0gdGhpcztcbiAgICAgICAgaWYgKGluaXRpYXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgLy8gT25seSBkZXRhY2hpbmcgaXMgY2FsbGVkICsgdGhlIGxpbmtlZCBsaXN0IGlzIGJ1aWx0IHdoZW4gYW55IGNvbnRyb2xsZXIgdGhhdCBpcyBub3QgdGhlIGluaXRpYXRvciwgaXMgZGVhY3RpdmF0ZWQuXG4gICAgICAgICAgICAvLyBUaGUgcmVzdCBpcyBoYW5kbGVkIGJ5IHRoZSBpbml0aWF0b3IuXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgZGVzY2VuZGFudCBjb250cm9sbGVycyBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhd2FpdCB0aGUgaW5pdGlhdG9yJ3MgcHJvbWlzZSBiZWZvcmUgZG9pbmcgYW55IHN1YnNlcXVlbnRcbiAgICAgICAgICAgIC8vIGNvbnRyb2xsZXIgYXBpIGNhbGxzLCBvciByYWNlIGNvbmRpdGlvbnMgbWlnaHQgb2NjdXIuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWF2ZURldGFjaGluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy4kcHJvbWlzZTtcbiAgICB9XG4gICAgcmVtb3ZlTm9kZXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy52bUtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBjdXN0b21FbGVtZW50ICovOlxuICAgICAgICAgICAgY2FzZSAyIC8qIHN5bnRoZXRpYyAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMudW5saW5rKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9zdENvbnRyb2xsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tb3VudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBob3N0ICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBzaGFkb3dSb290ICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3QucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBsb2NhdGlvbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi4kc3RhcnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGB1bmJpbmQoKWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gdGhpcy4kZmxhZ3MgfCA2NCAvKiBmcm9tVW5iaW5kICovO1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5ncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tpXS4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAodGhpcy52bUtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBjdXN0b21BdHRyaWJ1dGUgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogc3ludGhldGljICovOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNMb2NrZWRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnN0YXRlICYgMTYgLyogcmVsZWFzZWQgKi8pID09PSAxNiAvKiByZWxlYXNlZCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy52aWV3RmFjdG9yeS50cnlSZXR1cm5Ub0NhY2hlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMCAvKiBjdXN0b21FbGVtZW50ICovOlxuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUucGFyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZmxhZ3MgJiA1MTIgLyogZGlzcG9zZSAqLykgPT09IDUxMiAvKiBkaXNwb3NlICovKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gKHRoaXMuc3RhdGUgJiAzMiAvKiBkaXNwb3NlZCAqLykgfCA4IC8qIGRlYWN0aXZhdGVkICovO1xuICAgICAgICB0aGlzLiRpbml0aWF0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5zdXJlUHJvbWlzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy4kcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRpbml0aWF0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5lbnN1cmVQcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHByb21pc2UgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9IHRoaXMuJHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLiRyZXNvbHZlID0gdGhpcy4kcmVqZWN0ID0gdGhpcy4kcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWplY3QoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLiRwcm9taXNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdCA9IHRoaXMuJHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMuJHJlc29sdmUgPSB0aGlzLiRyZWplY3QgPSB0aGlzLiRwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGluaXRpYXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW50ZXJBY3RpdmF0aW5nKCkge1xuICAgICAgICArK3RoaXMuYWN0aXZhdGluZ1N0YWNrO1xuICAgICAgICBpZiAodGhpcy4kaW5pdGlhdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5lbnRlckFjdGl2YXRpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZWF2ZUFjdGl2YXRpbmcoKSB7XG4gICAgICAgIGlmICgtLXRoaXMuYWN0aXZhdGluZ1N0YWNrID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ob29rcy5oYXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBhdHRhY2hlZCgpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMudmlld01vZGVsLmF0dGFjaGVkKHRoaXMuJGluaXRpYXRvciwgdGhpcy4kZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBhY3RpdmF0ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoaXMuJHByb21pc2UsIHNpZ25hbGluZyB0aGF0IGFjdGl2YXRpb24gaXMgZG9uZSAocGF0aCAxIG9mIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRpbml0aWF0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZUFjdGl2YXRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogYWN0aXZhdGVkICovO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGlzLiRwcm9taXNlIChpZiBwcmVzZW50KSwgc2lnbmFsaW5nIHRoYXQgYWN0aXZhdGlvbiBpcyBkb25lIChwYXRoIDIgb2YgMilcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRpbml0aWF0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlQWN0aXZhdGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVudGVyRGV0YWNoaW5nKCkge1xuICAgICAgICArK3RoaXMuZGV0YWNoaW5nU3RhY2s7XG4gICAgfVxuICAgIGxlYXZlRGV0YWNoaW5nKCkge1xuICAgICAgICBpZiAoLS10aGlzLmRldGFjaGluZ1N0YWNrID09PSAwKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGlzIGNvbnRyb2xsZXIgaXMgdGhlIGluaXRpYXRvciAoZGV0YWNoIGlzIG9ubHkgZXZlciBjYWxsZWQgb24gdGhlIGluaXRpYXRvcilcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGRldGFjaCgpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVudGVyVW5iaW5kaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVzKCk7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy4kaW5pdGlhdG9yLmhlYWQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIubG9nZ2VyLnRyYWNlKGBkZXRhY2goKWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ci5yZW1vdmVOb2RlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VyLmhvb2tzLmhhc1VuYmluZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIubG9nZ2VyLnRyYWNlKCd1bmJpbmRpbmcoKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGN1ci52aWV3TW9kZWwudW5iaW5kaW5nKGN1ci4kaW5pdGlhdG9yLCBjdXIucGFyZW50LCBjdXIuJGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRlclVuYmluZGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmVVbmJpbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZWF2ZVVuYmluZGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVudGVyVW5iaW5kaW5nKCkge1xuICAgICAgICArK3RoaXMudW5iaW5kaW5nU3RhY2s7XG4gICAgfVxuICAgIGxlYXZlVW5iaW5kaW5nKCkge1xuICAgICAgICBpZiAoLS10aGlzLnVuYmluZGluZ1N0YWNrID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGB1bmJpbmQoKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuJGluaXRpYXRvci5oZWFkO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGN1ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gY3VyLm5leHQ7XG4gICAgICAgICAgICAgICAgY3VyLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRCaW5kaW5nKGJpbmRpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MgPSBbYmluZGluZ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3RoaXMuYmluZGluZ3MubGVuZ3RoXSA9IGJpbmRpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW2NvbnRyb2xsZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aF0gPSBjb250cm9sbGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZtS2luZCkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIGN1c3RvbUF0dHJpYnV0ZSAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IEN1c3RvbUF0dHJpYnV0ZS5nZXREZWZpbml0aW9uKHRoaXMudmlld01vZGVsLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLm5hbWUgPT09IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDAgLyogY3VzdG9tRWxlbWVudCAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IEN1c3RvbUVsZW1lbnQuZ2V0RGVmaW5pdGlvbih0aGlzLnZpZXdNb2RlbC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi5uYW1lID09PSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyIC8qIHN5bnRoZXRpYyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RmFjdG9yeS5uYW1lID09PSBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2tTY29wZShzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuaGFzTG9ja2VkU2NvcGUgPSB0cnVlO1xuICAgIH1cbiAgICBzZXRIb3N0KGhvc3QpIHtcbiAgICAgICAgaWYgKHRoaXMudm1LaW5kID09PSAwIC8qIGN1c3RvbUVsZW1lbnQgKi8pIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShDdXN0b21FbGVtZW50Lm5hbWUsIHRoaXMsIGhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMubW91bnRUYXJnZXQgPSAxIC8qIGhvc3QgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRTaGFkb3dSb290KHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMudm1LaW5kID09PSAwIC8qIGN1c3RvbUVsZW1lbnQgKi8pIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShDdXN0b21FbGVtZW50Lm5hbWUsIHRoaXMsIHNoYWRvd1Jvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IHNoYWRvd1Jvb3Q7XG4gICAgICAgIHRoaXMubW91bnRUYXJnZXQgPSAyIC8qIHNoYWRvd1Jvb3QgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgICBpZiAodGhpcy52bUtpbmQgPT09IDAgLyogY3VzdG9tRWxlbWVudCAqLykge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUVsZW1lbnQubmFtZSwgdGhpcywgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5tb3VudFRhcmdldCA9IDMgLyogbG9jYXRpb24gKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWxlYXNlKCkge1xuICAgICAgICB0aGlzLnN0YXRlIHw9IDE2IC8qIHJlbGVhc2VkICovO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGRpc3Bvc2UoKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5zdGF0ZSAmIDMyIC8qIGRpc3Bvc2VkICovKSA9PT0gMzIgLyogZGlzcG9zZWQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlIHw9IDMyIC8qIGRpc3Bvc2VkICovO1xuICAgICAgICBpZiAodGhpcy5ob29rcy5oYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjYWxsRGlzcG9zZSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvc3RDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3RmFjdG9yeSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnZpZXdNb2RlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlckxvb2t1cC5kZWxldGUodGhpcy52aWV3TW9kZWwpO1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld01vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaGFkb3dSb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0FjY2VwdCAmJiB0aGlzLnZpZXdNb2RlbC5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFRhcmdldEFjY2Vzc29yKHByb3BlcnR5TmFtZSkge1xuICAgICAgICBjb25zdCB7IGJpbmRpbmdzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYmluZGluZ3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5ncy5maW5kKGIgPT4gYi50YXJnZXRQcm9wZXJ0eSA9PT0gcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZGluZy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldExvb2t1cChpbnN0YW5jZSkge1xuICAgIGxldCBsb29rdXAgPSBpbnN0YW5jZS4kb2JzZXJ2ZXJzO1xuICAgIGlmIChsb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCAnJG9ic2VydmVycycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGxvb2t1cCA9IHt9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxvb2t1cDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVycyhjb250cm9sbGVyLCBkZWZpbml0aW9uLCBcbi8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG5fZmxhZ3MsIGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmluZGFibGVzID0gZGVmaW5pdGlvbi5iaW5kYWJsZXM7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYmluZGFibGVzKTtcbiAgICBjb25zdCBsZW5ndGggPSBvYnNlcnZhYmxlTmFtZXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBsZXQgYmluZGFibGU7XG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IGdldExvb2t1cChpbnN0YW5jZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWUgPSBvYnNlcnZhYmxlTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJzW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBiaW5kYWJsZSA9IGJpbmRhYmxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnNbbmFtZV0gPSBuZXcgQmluZGFibGVPYnNlcnZlcihpbnN0YW5jZSwgbmFtZSwgYmluZGFibGUuY2FsbGJhY2ssIGJpbmRhYmxlLnNldCwgY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbk9ic2VydmVycyhjb250cm9sbGVyLCBkZWZpbml0aW9uLCBcbi8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG5fZmxhZ3MsIGluc3RhbmNlKSB7XG4gICAgY29uc3QgY2hpbGRyZW5PYnNlcnZlcnMgPSBkZWZpbml0aW9uLmNoaWxkcmVuT2JzZXJ2ZXJzO1xuICAgIGNvbnN0IGNoaWxkT2JzZXJ2ZXJOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoaWxkcmVuT2JzZXJ2ZXJzKTtcbiAgICBjb25zdCBsZW5ndGggPSBjaGlsZE9ic2VydmVyTmFtZXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IGdldExvb2t1cChpbnN0YW5jZSk7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gY2hpbGRPYnNlcnZlck5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyc1tuYW1lXSA9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbkRlc2NyaXB0aW9uID0gY2hpbGRyZW5PYnNlcnZlcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzW25hbWVdID0gbmV3IENoaWxkcmVuT2JzZXJ2ZXIoY29udHJvbGxlciwgaW5zdGFuY2UsIG5hbWUsIGNoaWxkcmVuRGVzY3JpcHRpb24uY2FsbGJhY2ssIGNoaWxkcmVuRGVzY3JpcHRpb24ucXVlcnksIGNoaWxkcmVuRGVzY3JpcHRpb24uZmlsdGVyLCBjaGlsZHJlbkRlc2NyaXB0aW9uLm1hcCwgY2hpbGRyZW5EZXNjcmlwdGlvbi5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEFjY2Vzc1Njb3BlQXN0ID0ge1xuICAgIG1hcDogbmV3IE1hcCgpLFxuICAgIGZvcihrZXkpIHtcbiAgICAgICAgbGV0IGFzdCA9IEFjY2Vzc1Njb3BlQXN0Lm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGFzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhc3QgPSBuZXcgQWNjZXNzU2NvcGVFeHByZXNzaW9uKGtleSwgMCk7XG4gICAgICAgICAgICBBY2Nlc3NTY29wZUFzdC5tYXAuc2V0KGtleSwgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcnMoY29udHJvbGxlciwgY29udGV4dCwgZGVmaW5pdGlvbiwgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBvYnNlcnZlckxvY2F0b3IgPSBjb250ZXh0LmdldChJT2JzZXJ2ZXJMb2NhdG9yKTtcbiAgICBjb25zdCBleHByZXNzaW9uUGFyc2VyID0gY29udGV4dC5nZXQoSUV4cHJlc3Npb25QYXJzZXIpO1xuICAgIGNvbnN0IHdhdGNoZXMgPSBkZWZpbml0aW9uLndhdGNoZXM7XG4gICAgbGV0IGV4cHJlc3Npb247XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHdhdGNoZXMubGVuZ3RoOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAoeyBleHByZXNzaW9uLCBjYWxsYmFjayB9ID0gd2F0Y2hlc1tpXSk7XG4gICAgICAgIGNhbGxiYWNrID0gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNhbGxiYWNrXG4gICAgICAgICAgICA6IFJlZmxlY3QuZ2V0KGluc3RhbmNlLCBjYWxsYmFjayk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjYWxsYmFjayBmb3IgQHdhdGNoIGRlY29yYXRvcjogJHtTdHJpbmcoY2FsbGJhY2spfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKG5ldyBDb21wdXRlZFdhdGNoZXIoaW5zdGFuY2UsIG9ic2VydmVyTG9jYXRvciwgZXhwcmVzc2lvbiwgY2FsbGJhY2ssIFxuICAgICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZmxhZyB0byBwdXJwb3NlbHkgZGlzYWJsZSBwcm94eVxuICAgICAgICAgICAgLy8gQU9UOiBub3QgdHJ1ZSBmb3IgSUUxMVxuICAgICAgICAgICAgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXN0ID0gdHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBleHByZXNzaW9uUGFyc2VyLnBhcnNlKGV4cHJlc3Npb24sIDUzIC8qIEJpbmRDb21tYW5kICovKVxuICAgICAgICAgICAgICAgIDogQWNjZXNzU2NvcGVBc3QuZm9yKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKG5ldyBFeHByZXNzaW9uV2F0Y2hlcihjb250cm9sbGVyLnNjb3BlLCBjb250ZXh0LCBvYnNlcnZlckxvY2F0b3IsIGFzdCwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnRDb250cm9sbGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ29udHJvbGxlciAmJiB2YWx1ZS52bUtpbmQgPT09IDAgLyogY3VzdG9tRWxlbWVudCAqLztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnRWaWV3TW9kZWwodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIEN1c3RvbUVsZW1lbnQuaXNUeXBlKHZhbHVlLmNvbnN0cnVjdG9yKTtcbn1cbmV4cG9ydCBjbGFzcyBIb29rc0RlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICB0aGlzLmhhc0RlZmluZSA9ICdkZWZpbmUnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNIeWRyYXRpbmcgPSAnaHlkcmF0aW5nJyBpbiB0YXJnZXQ7XG4gICAgICAgIHRoaXMuaGFzSHlkcmF0ZWQgPSAnaHlkcmF0ZWQnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNDcmVhdGVkID0gJ2NyZWF0ZWQnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNCaW5kaW5nID0gJ2JpbmRpbmcnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNCb3VuZCA9ICdib3VuZCcgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc0F0dGFjaGluZyA9ICdhdHRhY2hpbmcnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNBdHRhY2hlZCA9ICdhdHRhY2hlZCcgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc0RldGFjaGluZyA9ICdkZXRhY2hpbmcnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNVbmJpbmRpbmcgPSAndW5iaW5kaW5nJyBpbiB0YXJnZXQ7XG4gICAgICAgIHRoaXMuaGFzRGlzcG9zZSA9ICdkaXNwb3NlJyBpbiB0YXJnZXQ7XG4gICAgICAgIHRoaXMuaGFzQWNjZXB0ID0gJ2FjY2VwdCcgaW4gdGFyZ2V0O1xuICAgIH1cbn1cbkhvb2tzRGVmaW5pdGlvbi5ub25lID0gbmV3IEhvb2tzRGVmaW5pdGlvbih7fSk7XG5jb25zdCBkZWZhdWx0U2hhZG93T3B0aW9ucyA9IHtcbiAgICBtb2RlOiAnb3Blbidcbn07XG5leHBvcnQgdmFyIFZpZXdNb2RlbEtpbmQ7XG4oZnVuY3Rpb24gKFZpZXdNb2RlbEtpbmQpIHtcbiAgICBWaWV3TW9kZWxLaW5kW1ZpZXdNb2RlbEtpbmRbXCJjdXN0b21FbGVtZW50XCJdID0gMF0gPSBcImN1c3RvbUVsZW1lbnRcIjtcbiAgICBWaWV3TW9kZWxLaW5kW1ZpZXdNb2RlbEtpbmRbXCJjdXN0b21BdHRyaWJ1dGVcIl0gPSAxXSA9IFwiY3VzdG9tQXR0cmlidXRlXCI7XG4gICAgVmlld01vZGVsS2luZFtWaWV3TW9kZWxLaW5kW1wic3ludGhldGljXCJdID0gMl0gPSBcInN5bnRoZXRpY1wiO1xufSkoVmlld01vZGVsS2luZCB8fCAoVmlld01vZGVsS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIFN0YXRlO1xuKGZ1bmN0aW9uIChTdGF0ZSkge1xuICAgIFN0YXRlW1N0YXRlW1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJhY3RpdmF0aW5nXCJdID0gMV0gPSBcImFjdGl2YXRpbmdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcImFjdGl2YXRlZFwiXSA9IDJdID0gXCJhY3RpdmF0ZWRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcImRlYWN0aXZhdGluZ1wiXSA9IDRdID0gXCJkZWFjdGl2YXRpbmdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcImRlYWN0aXZhdGVkXCJdID0gOF0gPSBcImRlYWN0aXZhdGVkXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJyZWxlYXNlZFwiXSA9IDE2XSA9IFwicmVsZWFzZWRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcImRpc3Bvc2VkXCJdID0gMzJdID0gXCJkaXNwb3NlZFwiO1xufSkoU3RhdGUgfHwgKFN0YXRlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgaWYgKChzdGF0ZSAmIDEgLyogYWN0aXZhdGluZyAqLykgPT09IDEgLyogYWN0aXZhdGluZyAqLykge1xuICAgICAgICBuYW1lcy5wdXNoKCdhY3RpdmF0aW5nJyk7XG4gICAgfVxuICAgIGlmICgoc3RhdGUgJiAyIC8qIGFjdGl2YXRlZCAqLykgPT09IDIgLyogYWN0aXZhdGVkICovKSB7XG4gICAgICAgIG5hbWVzLnB1c2goJ2FjdGl2YXRlZCcpO1xuICAgIH1cbiAgICBpZiAoKHN0YXRlICYgNCAvKiBkZWFjdGl2YXRpbmcgKi8pID09PSA0IC8qIGRlYWN0aXZhdGluZyAqLykge1xuICAgICAgICBuYW1lcy5wdXNoKCdkZWFjdGl2YXRpbmcnKTtcbiAgICB9XG4gICAgaWYgKChzdGF0ZSAmIDggLyogZGVhY3RpdmF0ZWQgKi8pID09PSA4IC8qIGRlYWN0aXZhdGVkICovKSB7XG4gICAgICAgIG5hbWVzLnB1c2goJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIGlmICgoc3RhdGUgJiAxNiAvKiByZWxlYXNlZCAqLykgPT09IDE2IC8qIHJlbGVhc2VkICovKSB7XG4gICAgICAgIG5hbWVzLnB1c2goJ3JlbGVhc2VkJyk7XG4gICAgfVxuICAgIGlmICgoc3RhdGUgJiAzMiAvKiBkaXNwb3NlZCAqLykgPT09IDMyIC8qIGRpc3Bvc2VkICovKSB7XG4gICAgICAgIG5hbWVzLnB1c2goJ2Rpc3Bvc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBuYW1lcy5qb2luKCd8Jyk7XG59XG5leHBvcnQgY29uc3QgSUNvbnRyb2xsZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lDb250cm9sbGVyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sbGVyLmpzLm1hcCIsImltcG9ydCB7IEluc3RhbmNlUHJvdmlkZXIsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEZyYWdtZW50Tm9kZVNlcXVlbmNlLCBJTm9kZSwgSVJlbmRlckxvY2F0aW9uIH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7IElSZW5kZXJlciwgSVRlbXBsYXRlQ29tcGlsZXIsIElJbnN0cnVjdGlvbiB9IGZyb20gJy4uL3JlbmRlcmVyLmpzJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50LmpzJztcbmltcG9ydCB7IElWaWV3RmFjdG9yeSwgVmlld0ZhY3RvcnkgfSBmcm9tICcuL3ZpZXcuanMnO1xuaW1wb3J0IHsgSVByb2plY3Rpb25Qcm92aWRlciB9IGZyb20gJy4uL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudHMvYXUtc2xvdC5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBJQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci5qcyc7XG5jb25zdCBkZWZpbml0aW9uQ29udGFpbmVyTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGRlZmluaXRpb25Db250YWluZXJQcm9qZWN0aW9uc0xvb2t1cCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBmcmFnbWVudENhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1JlbmRlckNvbnRleHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZW5kZXJDb250ZXh0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlckNvbnRleHQocGFydGlhbERlZmluaXRpb24sIHBhcmVudENvbnRhaW5lciwgcHJvamVjdGlvbnMpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uZ2V0T3JDcmVhdGUocGFydGlhbERlZmluaXRpb24pO1xuICAgIC8vIGluamVjdGFibGUgY29tcGxldGVseSBwcmV2ZW50cyBjYWNoaW5nLCBlbnN1cmluZyB0aGF0IGVhY2ggaW5zdGFuY2UgZ2V0cyBhIG5ldyBjb250ZXh0IGNvbnRleHRcbiAgICBpZiAoZGVmaW5pdGlvbi5pbmplY3RhYmxlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyQ29udGV4dChkZWZpbml0aW9uLCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cbiAgICBpZiAocHJvamVjdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBsZXQgY29udGFpbmVyTG9va3VwID0gZGVmaW5pdGlvbkNvbnRhaW5lckxvb2t1cC5nZXQoZGVmaW5pdGlvbik7XG4gICAgICAgIGlmIChjb250YWluZXJMb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbkNvbnRhaW5lckxvb2t1cC5zZXQoZGVmaW5pdGlvbiwgY29udGFpbmVyTG9va3VwID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRleHQgPSBjb250YWluZXJMb29rdXAuZ2V0KHBhcmVudENvbnRhaW5lcik7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckxvb2t1cC5zZXQocGFyZW50Q29udGFpbmVyLCBjb250ZXh0ID0gbmV3IFJlbmRlckNvbnRleHQoZGVmaW5pdGlvbiwgcGFyZW50Q29udGFpbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGxldCBjb250YWluZXJQcm9qZWN0aW9uc0xvb2t1cCA9IGRlZmluaXRpb25Db250YWluZXJQcm9qZWN0aW9uc0xvb2t1cC5nZXQoZGVmaW5pdGlvbik7XG4gICAgaWYgKGNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVmaW5pdGlvbkNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwLnNldChkZWZpbml0aW9uLCBjb250YWluZXJQcm9qZWN0aW9uc0xvb2t1cCA9IG5ldyBXZWFrTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgcHJvamVjdGlvbnNMb29rdXAgPSBjb250YWluZXJQcm9qZWN0aW9uc0xvb2t1cC5nZXQocGFyZW50Q29udGFpbmVyKTtcbiAgICBpZiAocHJvamVjdGlvbnNMb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250YWluZXJQcm9qZWN0aW9uc0xvb2t1cC5zZXQocGFyZW50Q29udGFpbmVyLCBwcm9qZWN0aW9uc0xvb2t1cCA9IG5ldyBXZWFrTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgY29udGV4dCA9IHByb2plY3Rpb25zTG9va3VwLmdldChwcm9qZWN0aW9ucyk7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm9qZWN0aW9uc0xvb2t1cC5zZXQocHJvamVjdGlvbnMsIGNvbnRleHQgPSBuZXcgUmVuZGVyQ29udGV4dChkZWZpbml0aW9uLCBwYXJlbnRDb250YWluZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5jb25zdCBlbXB0eU5vZGVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgY2xhc3MgUmVuZGVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoZGVmaW5pdGlvbiwgcGFyZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgIHRoaXMucGFyZW50Q29udGFpbmVyID0gcGFyZW50Q29udGFpbmVyO1xuICAgICAgICB0aGlzLnZpZXdNb2RlbFByb3ZpZGVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmNvbXBpbGVkRGVmaW5pdGlvbiA9ICh2b2lkIDApO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciA9IHBhcmVudENvbnRhaW5lci5jcmVhdGVDaGlsZCgpO1xuICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogZ2V0IGNvbnRleHR1YWwgKyByb290IHJlbmRlcmVyc1xuICAgICAgICBjb25zdCByZW5kZXJlcnMgPSBjb250YWluZXIuZ2V0QWxsKElSZW5kZXJlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHJlbmRlcmVyc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW3JlbmRlcmVyLmluc3RydWN0aW9uVHlwZV0gPSByZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2plY3Rpb25Qcm92aWRlciA9IGNvbnRhaW5lci5nZXQoSVByb2plY3Rpb25Qcm92aWRlcik7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBsYXRmb3JtID0gY29udGFpbmVyLmdldChJUGxhdGZvcm0pO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihJVmlld0ZhY3RvcnksIHRoaXMuZmFjdG9yeVByb3ZpZGVyID0gbmV3IFZpZXdGYWN0b3J5UHJvdmlkZXIoKSwgdHJ1ZSk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKElDb250cm9sbGVyLCB0aGlzLnBhcmVudENvbnRyb2xsZXJQcm92aWRlciA9IG5ldyBJbnN0YW5jZVByb3ZpZGVyKCdJQ29udHJvbGxlcicpLCB0cnVlKTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoSUluc3RydWN0aW9uLCB0aGlzLmluc3RydWN0aW9uUHJvdmlkZXIgPSBuZXcgSW5zdGFuY2VQcm92aWRlcignSUluc3RydWN0aW9uJyksIHRydWUpO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihJUmVuZGVyTG9jYXRpb24sIHRoaXMucmVuZGVyTG9jYXRpb25Qcm92aWRlciA9IG5ldyBJbnN0YW5jZVByb3ZpZGVyKCdJUmVuZGVyTG9jYXRpb24nKSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5lbGVtZW50UHJvdmlkZXIgPSBuZXcgSW5zdGFuY2VQcm92aWRlcignRWxlbWVudFJlc29sdmVyJyk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKElOb2RlLCBlcCk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKHAuTm9kZSwgZXApO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihwLkVsZW1lbnQsIGVwKTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIocC5IVE1MRWxlbWVudCwgZXApO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoLi4uZGVmaW5pdGlvbi5kZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICAvLyAjcmVnaW9uIElTZXJ2aWNlTG9jYXRvciBhcGlcbiAgICBoYXMoa2V5LCBzZWFyY2hBbmNlc3RvcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmhhcyhrZXksIHNlYXJjaEFuY2VzdG9ycyk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmdldChrZXkpO1xuICAgIH1cbiAgICBnZXRBbGwoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5nZXRBbGwoa2V5KTtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gSUNvbnRhaW5lciBhcGlcbiAgICByZWdpc3RlciguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnJlZ2lzdGVyKC4uLnBhcmFtcyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVzb2x2ZXIoa2V5LCByZXNvbHZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihrZXksIHJlc29sdmVyKTtcbiAgICB9XG4gICAgLy8gcHVibGljIGRlcmVnaXN0ZXJSZXNvbHZlckZvcjxLIGV4dGVuZHMgS2V5LCBUID0gSz4oa2V5OiBLKTogdm9pZCB7XG4gICAgLy8gICB0aGlzLmNvbnRhaW5lci5kZXJlZ2lzdGVyUmVzb2x2ZXJGb3Ioa2V5KTtcbiAgICAvLyB9XG4gICAgcmVnaXN0ZXJUcmFuc2Zvcm1lcihrZXksIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5yZWdpc3RlclRyYW5zZm9ybWVyKGtleSwgdHJhbnNmb3JtZXIpO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlcihrZXksIGF1dG9SZWdpc3Rlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuZ2V0UmVzb2x2ZXIoa2V5LCBhdXRvUmVnaXN0ZXIpO1xuICAgIH1cbiAgICBnZXRGYWN0b3J5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuZ2V0RmFjdG9yeShrZXkpO1xuICAgIH1cbiAgICByZWdpc3RlckZhY3Rvcnkoa2V5LCBmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlZ2lzdGVyRmFjdG9yeShrZXksIGZhY3RvcnkpO1xuICAgIH1cbiAgICBjcmVhdGVDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmNyZWF0ZUNoaWxkKCk7XG4gICAgfVxuICAgIGZpbmQoa2luZCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuZmluZChraW5kLCBuYW1lKTtcbiAgICB9XG4gICAgY3JlYXRlKGtpbmQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmNyZWF0ZShraW5kLCBuYW1lKTtcbiAgICB9XG4gICAgZGlzcG9zZVJlc29sdmVycygpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuZGlzcG9zZVJlc29sdmVycygpO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBJUmVuZGVyQ29udGV4dCBhcGlcbiAgICBjb21waWxlKHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgbGV0IGNvbXBpbGVkRGVmaW5pdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaXNDb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuZGVmaW5pdGlvbjtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ubmVlZHNDb21waWxlKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVyID0gY29udGFpbmVyLmdldChJVGVtcGxhdGVDb21waWxlcik7XG4gICAgICAgICAgICBjb21waWxlZERlZmluaXRpb24gPSB0aGlzLmNvbXBpbGVkRGVmaW5pdGlvbiA9IGNvbXBpbGVyLmNvbXBpbGUoZGVmaW5pdGlvbiwgY29udGFpbmVyLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBpbGVkRGVmaW5pdGlvbiA9IHRoaXMuY29tcGlsZWREZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdXBwb3J0IFJlY3Vyc2l2ZSBDb21wb25lbnRzIGJ5IGFkZGluZyBzZWxmIHRvIG93biBjb250ZXh0XG4gICAgICAgIGNvbXBpbGVkRGVmaW5pdGlvbi5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgaWYgKGZyYWdtZW50Q2FjaGUuaGFzKGNvbXBpbGVkRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudENhY2hlLmdldChjb21waWxlZERlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gdGhpcy5wbGF0Zm9ybS5kb2N1bWVudDtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gY29tcGlsZWREZWZpbml0aW9uLnRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlID09PSBudWxsIHx8IHRoaXMuZGVmaW5pdGlvbi5lbmhhbmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIHRoaXMucGxhdGZvcm0uTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gZG9jLmFkb3B0Tm9kZSh0ZW1wbGF0ZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmZyYWdtZW50ID0gZG9jLmFkb3B0Tm9kZShkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKSkuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRwbCA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgICAgIGRvYy5hZG9wdE5vZGUodHBsLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRwbC5pbm5lckhUTUwgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRwbC5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhZ21lbnRDYWNoZS5zZXQoY29tcGlsZWREZWZpbml0aW9uLCB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0Vmlld0ZhY3RvcnkobmFtZSwgY29udGVudFR5cGUsIHByb2plY3Rpb25TY29wZSkge1xuICAgICAgICBsZXQgZmFjdG9yeSA9IHRoaXMuZmFjdG9yeTtcbiAgICAgICAgaWYgKGZhY3RvcnkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmRlZmluaXRpb24ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhY3RvcnkgPSB0aGlzLmZhY3RvcnkgPSBuZXcgVmlld0ZhY3RvcnkobmFtZSwgdGhpcywgY29udGVudFR5cGUsIHByb2plY3Rpb25TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgfVxuICAgIGJlZ2luQ2hpbGRDb21wb25lbnRPcGVyYXRpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuZGVmaW5pdGlvbjtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uaW5qZWN0YWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld01vZGVsUHJvdmlkZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoZGVmaW5pdGlvbi5pbmplY3RhYmxlLCB0aGlzLnZpZXdNb2RlbFByb3ZpZGVyID0gbmV3IEluc3RhbmNlUHJvdmlkZXIoJ2RlZmluaXRpb24uaW5qZWN0YWJsZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsUHJvdmlkZXIucHJlcGFyZShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIElDb21waWxlZFJlbmRlckNvbnRleHQgYXBpXG4gICAgY3JlYXRlTm9kZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBpbGVkRGVmaW5pdGlvbi5lbmhhbmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50Tm9kZVNlcXVlbmNlKHRoaXMucGxhdGZvcm0sIHRoaXMuY29tcGlsZWREZWZpbml0aW9uLnRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGVtcHR5Tm9kZXMgPSBlbXB0eU5vZGVDYWNoZS5nZXQodGhpcy5wbGF0Zm9ybSk7XG4gICAgICAgICAgICBpZiAoZW1wdHlOb2RlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZW1wdHlOb2RlQ2FjaGUuc2V0KHRoaXMucGxhdGZvcm0sIGVtcHR5Tm9kZXMgPSBuZXcgRnJhZ21lbnROb2RlU2VxdWVuY2UodGhpcy5wbGF0Zm9ybSwgdGhpcy5wbGF0Zm9ybS5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbXB0eU5vZGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnROb2RlU2VxdWVuY2UodGhpcy5wbGF0Zm9ybSwgdGhpcy5mcmFnbWVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBzcGxpdCB1cCBpbnRvIDIgbWV0aG9kcz8gZ2V0Q29tcG9uZW50RmFjdG9yeSArIGdldFN5bnRoZXRpY0ZhY3Rvcnkgb3Igc29tZXRoaW5nXG4gICAgZ2V0Q29tcG9uZW50RmFjdG9yeShwYXJlbnRDb250cm9sbGVyLCBob3N0LCBpbnN0cnVjdGlvbiwgdmlld0ZhY3RvcnksIGxvY2F0aW9uKSB7XG4gICAgICAgIGlmIChwYXJlbnRDb250cm9sbGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Q29udHJvbGxlclByb3ZpZGVyLnByZXBhcmUocGFyZW50Q29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgLy8gVE9ETzogZml4IHByb3ZpZGVyIGlucHV0IHR5cGUsIEtleSBpcyBwcm9iYWJseSBub3QgYSBnb29kIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFByb3ZpZGVyLnByZXBhcmUoaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RydWN0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25Qcm92aWRlci5wcmVwYXJlKGluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJMb2NhdGlvblByb3ZpZGVyLnByZXBhcmUobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3RmFjdG9yeSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcnlQcm92aWRlci5wcmVwYXJlKHZpZXdGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gSUNvbXBvbmVudEZhY3RvcnkgYXBpXG4gICAgY3JlYXRlQ29tcG9uZW50KHJlc291cmNlS2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5nZXQocmVzb3VyY2VLZXkpO1xuICAgIH1cbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRyb2xsZXIsIHRhcmdldHMsIGRlZmluaXRpb24sIGhvc3QpIHtcbiAgICAgICAgaWYgKHRhcmdldHMubGVuZ3RoICE9PSBkZWZpbml0aW9uLmluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNvbXBpbGVkIHRlbXBsYXRlIGlzIG5vdCBhbGlnbmVkIHdpdGggdGhlIHJlbmRlciBpbnN0cnVjdGlvbnMuIFRoZXJlIGFyZSAke3RhcmdldHMubGVuZ3RofSB0YXJnZXRzIGFuZCAke2RlZmluaXRpb24uaW5zdHJ1Y3Rpb25zLmxlbmd0aH0gaW5zdHJ1Y3Rpb25zLmApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihcbiAgICAgICAgICAgIC8qIGZsYWdzICAgICAgICAqLyBmbGFncywgXG4gICAgICAgICAgICAvKiBpbnN0cnVjdGlvbnMgKi8gZGVmaW5pdGlvbi5pbnN0cnVjdGlvbnNbaV0sIFxuICAgICAgICAgICAgLyogY29udHJvbGxlciAgICovIGNvbnRyb2xsZXIsIFxuICAgICAgICAgICAgLyogdGFyZ2V0ICAgICAgICovIHRhcmdldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0ICE9PSB2b2lkIDAgJiYgaG9zdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihcbiAgICAgICAgICAgIC8qIGZsYWdzICAgICAgICAqLyBmbGFncywgXG4gICAgICAgICAgICAvKiBpbnN0cnVjdGlvbnMgKi8gZGVmaW5pdGlvbi5zdXJyb2dhdGVzLCBcbiAgICAgICAgICAgIC8qIGNvbnRyb2xsZXIgICAqLyBjb250cm9sbGVyLCBcbiAgICAgICAgICAgIC8qIHRhcmdldCAgICAgICAqLyBob3N0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihmbGFncywgaW5zdHJ1Y3Rpb25zLCBjb250cm9sbGVyLCB0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyc1tjdXJyZW50LnR5cGVdLnJlbmRlcihmbGFncywgdGhpcywgY29udHJvbGxlciwgdGFyZ2V0LCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRQcm92aWRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIElQcm9qZWN0aW9uUHJvdmlkZXIgYXBpXG4gICAgcmVnaXN0ZXJQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uUHJvdmlkZXIucmVnaXN0ZXJQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucywgc2NvcGUpO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0aW9uRm9yKGluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb25Qcm92aWRlci5nZXRQcm9qZWN0aW9uRm9yKGluc3RydWN0aW9uKTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgVmlld0ZhY3RvcnlQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IG51bGw7XG4gICAgfVxuICAgIHByZXBhcmUoZmFjdG9yeSkge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIH1cbiAgICBnZXQgJGlzUmVzb2x2ZXIoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmVzb2x2ZShfaGFuZGxlciwgX3JlcXVlc3Rvcikge1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5mYWN0b3J5O1xuICAgICAgICBpZiAoZmFjdG9yeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBWaWV3RmFjdG9yeSBiZWZvcmUgdGhlIHByb3ZpZGVyIHdhcyBwcmVwYXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkubmFtZSAhPT0gJ3N0cmluZycgfHwgZmFjdG9yeS5uYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBWaWV3RmFjdG9yeSB3aXRob3V0IGEgKHZhbGlkKSBuYW1lLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBudWxsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci1jb250ZXh0LmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgSUNvbnRhaW5lciwgUmVnaXN0cmF0aW9uLCBESSwgbm9vcCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBBcHBUYXNrIH0gZnJvbSAnLi4vYXBwLXRhc2suanMnO1xuaW1wb3J0IHsgSU5vZGUgfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHsgZ2V0Q2xhc3Nlc1RvQWRkIH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24vY2xhc3MtYXR0cmlidXRlLWFjY2Vzc29yLmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IEN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJy4uL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjc3NNb2R1bGVzKC4uLm1vZHVsZXMpIHtcbiAgICByZXR1cm4gbmV3IENTU01vZHVsZXNQcm9jZXNzb3JSZWdpc3RyeShtb2R1bGVzKTtcbn1cbmV4cG9ydCBjbGFzcyBDU1NNb2R1bGVzUHJvY2Vzc29yUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKG1vZHVsZXMpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gbW9kdWxlcztcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2xhc3NMb29rdXAgPSBPYmplY3QuYXNzaWduKHt9LCAuLi50aGlzLm1vZHVsZXMpO1xuICAgICAgICBjb25zdCBDbGFzc0N1c3RvbUF0dHJpYnV0ZSA9IEN1c3RvbUF0dHJpYnV0ZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogJ2NsYXNzJyxcbiAgICAgICAgICAgIGJpbmRhYmxlczogWyd2YWx1ZSddLFxuICAgICAgICB9LCAoX2EgPSBjbGFzcyBDdXN0b21BdHRyaWJ1dGVDbGFzcyB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5kaW5nKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZUNoYW5nZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBnZXRDbGFzc2VzVG9BZGQodGhpcy52YWx1ZSkubWFwKHggPT4gY2xhc3NMb29rdXBbeF0gfHwgeCkuam9pbignICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYS5pbmplY3QgPSBbSU5vZGVdLFxuICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKENsYXNzQ3VzdG9tQXR0cmlidXRlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhZG93Q1NTKC4uLmNzcykge1xuICAgIHJldHVybiBuZXcgU2hhZG93RE9NUmVnaXN0cnkoY3NzKTtcbn1cbmV4cG9ydCBjb25zdCBJU2hhZG93RE9NU3R5bGVGYWN0b3J5ID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJU2hhZG93RE9NU3R5bGVGYWN0b3J5JywgeCA9PiB4LmNhY2hlZENhbGxiYWNrKGhhbmRsZXIgPT4ge1xuICAgIGlmIChBZG9wdGVkU3R5bGVTaGVldHNTdHlsZXMuc3VwcG9ydGVkKGhhbmRsZXIuZ2V0KElQbGF0Zm9ybSkpKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLmdldChBZG9wdGVkU3R5bGVTaGVldHNTdHlsZXNGYWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIuZ2V0KFN0eWxlRWxlbWVudFN0eWxlc0ZhY3RvcnkpO1xufSkpO1xuZXhwb3J0IGNsYXNzIFNoYWRvd0RPTVJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcihjc3MpIHtcbiAgICAgICAgdGhpcy5jc3MgPSBjc3M7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBzaGFyZWRTdHlsZXMgPSBjb250YWluZXIuZ2V0KElTaGFkb3dET01HbG9iYWxTdHlsZXMpO1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gY29udGFpbmVyLmdldChJU2hhZG93RE9NU3R5bGVGYWN0b3J5KTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShJU2hhZG93RE9NU3R5bGVzLCBmYWN0b3J5LmNyZWF0ZVN0eWxlcyh0aGlzLmNzcywgc2hhcmVkU3R5bGVzKSkpO1xuICAgIH1cbn1cbmxldCBBZG9wdGVkU3R5bGVTaGVldHNTdHlsZXNGYWN0b3J5ID0gY2xhc3MgQWRvcHRlZFN0eWxlU2hlZXRzU3R5bGVzRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IocCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBjcmVhdGVTdHlsZXMobG9jYWxTdHlsZXMsIHNoYXJlZFN0eWxlcykge1xuICAgICAgICByZXR1cm4gbmV3IEFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlcyh0aGlzLnAsIGxvY2FsU3R5bGVzLCB0aGlzLmNhY2hlLCBzaGFyZWRTdHlsZXMpO1xuICAgIH1cbn07XG5BZG9wdGVkU3R5bGVTaGVldHNTdHlsZXNGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJUGxhdGZvcm0pXG5dLCBBZG9wdGVkU3R5bGVTaGVldHNTdHlsZXNGYWN0b3J5KTtcbmxldCBTdHlsZUVsZW1lbnRTdHlsZXNGYWN0b3J5ID0gY2xhc3MgU3R5bGVFbGVtZW50U3R5bGVzRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IocCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgIH1cbiAgICBjcmVhdGVTdHlsZXMobG9jYWxTdHlsZXMsIHNoYXJlZFN0eWxlcykge1xuICAgICAgICByZXR1cm4gbmV3IFN0eWxlRWxlbWVudFN0eWxlcyh0aGlzLnAsIGxvY2FsU3R5bGVzLCBzaGFyZWRTdHlsZXMpO1xuICAgIH1cbn07XG5TdHlsZUVsZW1lbnRTdHlsZXNGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJUGxhdGZvcm0pXG5dLCBTdHlsZUVsZW1lbnRTdHlsZXNGYWN0b3J5KTtcbmV4cG9ydCBjb25zdCBJU2hhZG93RE9NU3R5bGVzID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJU2hhZG93RE9NU3R5bGVzJyk7XG5leHBvcnQgY29uc3QgSVNoYWRvd0RPTUdsb2JhbFN0eWxlcyA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVNoYWRvd0RPTUdsb2JhbFN0eWxlcycsIHggPT4geC5pbnN0YW5jZSh7IGFwcGx5VG86IG5vb3AgfSkpO1xuZXhwb3J0IGNsYXNzIEFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlcyB7XG4gICAgY29uc3RydWN0b3IocCwgbG9jYWxTdHlsZXMsIHN0eWxlU2hlZXRDYWNoZSwgc2hhcmVkU3R5bGVzID0gbnVsbCkge1xuICAgICAgICB0aGlzLnNoYXJlZFN0eWxlcyA9IHNoYXJlZFN0eWxlcztcbiAgICAgICAgdGhpcy5zdHlsZVNoZWV0cyA9IGxvY2FsU3R5bGVzLm1hcCh4ID0+IHtcbiAgICAgICAgICAgIGxldCBzaGVldDtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgcC5DU1NTdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgc2hlZXQgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hlZXQgPSBzdHlsZVNoZWV0Q2FjaGUuZ2V0KHgpO1xuICAgICAgICAgICAgICAgIGlmIChzaGVldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoZWV0ID0gbmV3IHAuQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgICAgICAgICBzaGVldC5yZXBsYWNlU3luYyh4KTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldENhY2hlLnNldCh4LCBzaGVldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoZWV0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHN1cHBvcnRlZChwKSB7XG4gICAgICAgIHJldHVybiAnYWRvcHRlZFN0eWxlU2hlZXRzJyBpbiBwLlNoYWRvd1Jvb3QucHJvdG90eXBlO1xuICAgIH1cbiAgICBhcHBseVRvKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hhcmVkU3R5bGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZFN0eWxlcy5hcHBseVRvKHNoYWRvd1Jvb3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29uc3RydWN0LXN0eWxlc2hlZXRzL1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE5LzAyL2NvbnN0cnVjdGFibGUtc3R5bGVzaGVldHNcbiAgICAgICAgc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbXG4gICAgICAgICAgICAuLi5zaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIC4uLnRoaXMuc3R5bGVTaGVldHNcbiAgICAgICAgXTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3R5bGVFbGVtZW50U3R5bGVzIHtcbiAgICBjb25zdHJ1Y3RvcihwLCBsb2NhbFN0eWxlcywgc2hhcmVkU3R5bGVzID0gbnVsbCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLmxvY2FsU3R5bGVzID0gbG9jYWxTdHlsZXM7XG4gICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzID0gc2hhcmVkU3R5bGVzO1xuICAgIH1cbiAgICBhcHBseVRvKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5sb2NhbFN0eWxlcztcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0eWxlcy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gc3R5bGVzW2ldO1xuICAgICAgICAgICAgc2hhZG93Um9vdC5wcmVwZW5kKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNoYXJlZFN0eWxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXMuYXBwbHlUbyhzaGFkb3dSb290KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBTdHlsZUNvbmZpZ3VyYXRpb24gPSB7XG4gICAgc2hhZG93RE9NKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gQXBwVGFzay53aXRoKElDb250YWluZXIpLmJlZm9yZUNyZWF0ZSgpLmNhbGwoY29udGFpbmVyID0+IHtcbiAgICAgICAgICAgIGlmIChjb25maWcuc2hhcmVkU3R5bGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gY29udGFpbmVyLmdldChJU2hhZG93RE9NU3R5bGVGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKElTaGFkb3dET01HbG9iYWxTdHlsZXMsIGZhY3RvcnkuY3JlYXRlU3R5bGVzKGNvbmZpZy5zaGFyZWRTdHlsZXMsIG51bGwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZXMuanMubWFwIiwiaW1wb3J0IHsgREksIE1ldGFkYXRhLCBQcm90b2NvbCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBTY29wZSB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudERlZmluaXRpb24gfSBmcm9tICcuLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci5qcyc7XG5leHBvcnQgY29uc3QgSVZpZXdGYWN0b3J5ID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJVmlld0ZhY3RvcnknKTtcbmV4cG9ydCBjbGFzcyBWaWV3RmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGV4dCwgY29udGVudFR5cGUsIHByb2plY3Rpb25TY29wZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25TY29wZSA9IHByb2plY3Rpb25TY29wZTtcbiAgICAgICAgdGhpcy5pc0NhY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplID0gLTE7XG4gICAgfVxuICAgIHNldENhY2hlU2l6ZShzaXplLCBkb05vdE92ZXJyaWRlSWZBbHJlYWR5U2V0KSB7XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IFZpZXdGYWN0b3J5Lm1heENhY2hlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZVNpemUgPT09IC0xIHx8ICFkb05vdE92ZXJyaWRlSWZBbHJlYWR5U2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhY2hlU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYWNoaW5nID0gdGhpcy5jYWNoZVNpemUgPiAwO1xuICAgIH1cbiAgICBjYW5SZXR1cm5Ub0NhY2hlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUgIT0gbnVsbCAmJiB0aGlzLmNhY2hlLmxlbmd0aCA8IHRoaXMuY2FjaGVTaXplO1xuICAgIH1cbiAgICB0cnlSZXR1cm5Ub0NhY2hlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUmV0dXJuVG9DYWNoZShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5wdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjcmVhdGUoZmxhZ3MsIHBhcmVudENvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICBsZXQgY29udHJvbGxlcjtcbiAgICAgICAgaWYgKGNhY2hlICE9IG51bGwgJiYgY2FjaGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlciA9IGNhY2hlLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlciA9IENvbnRyb2xsZXIuZm9yU3ludGhldGljVmlldyhudWxsLCB0aGlzLmNvbnRleHQsIHRoaXMsIGZsYWdzLCBwYXJlbnRDb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxufVxuVmlld0ZhY3RvcnkubWF4Q2FjaGVTaXplID0gMHhGRkZGO1xuY29uc3Qgc2VlblZpZXdzID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIG5vdFlldFNlZW4oJHZpZXcpIHtcbiAgICByZXR1cm4gIXNlZW5WaWV3cy5oYXMoJHZpZXcpO1xufVxuZnVuY3Rpb24gdG9DdXN0b21FbGVtZW50RGVmaW5pdGlvbigkdmlldykge1xuICAgIHNlZW5WaWV3cy5hZGQoJHZpZXcpO1xuICAgIHJldHVybiBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5jcmVhdGUoJHZpZXcpO1xufVxuZXhwb3J0IGNvbnN0IFZpZXdzID0ge1xuICAgIG5hbWU6IFByb3RvY29sLnJlc291cmNlLmtleUZvcigndmlld3MnKSxcbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAoTWV0YWRhdGEuaGFzT3duKFZpZXdzLm5hbWUsIHZhbHVlKSB8fCAnJHZpZXdzJyBpbiB2YWx1ZSk7XG4gICAgfSxcbiAgICBnZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAnJHZpZXdzJyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogYSBgZ2V0YCBvcGVyYXRpb24gd2l0aCBzaWRlIGVmZmVjdHMgaXMgbm90IGEgZ29vZCB0aGluZy4gU2hvdWxkIHJlZmFjdG9yIHRoaXMgdG8gYSBwcm9wZXIgcmVzb3VyY2Uga2luZC5cbiAgICAgICAgICAgIGNvbnN0ICR2aWV3cyA9IHZhbHVlLiR2aWV3cztcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gJHZpZXdzLmZpbHRlcihub3RZZXRTZWVuKS5tYXAodG9DdXN0b21FbGVtZW50RGVmaW5pdGlvbik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgIFZpZXdzLmFkZCh2YWx1ZSwgZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3MgPSBNZXRhZGF0YS5nZXRPd24oVmlld3MubmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAodmlld3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKFZpZXdzLm5hbWUsIHZpZXdzID0gW10sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3M7XG4gICAgfSxcbiAgICBhZGQoVHlwZSwgcGFydGlhbERlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLmNyZWF0ZShwYXJ0aWFsRGVmaW5pdGlvbik7XG4gICAgICAgIGxldCB2aWV3cyA9IE1ldGFkYXRhLmdldE93bihWaWV3cy5uYW1lLCBUeXBlKTtcbiAgICAgICAgaWYgKHZpZXdzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShWaWV3cy5uYW1lLCB2aWV3cyA9IFtkZWZpbml0aW9uXSwgVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3cy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cztcbiAgICB9LFxufTtcbmV4cG9ydCBmdW5jdGlvbiB2aWV3KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBWaWV3cy5hZGQodGFyZ2V0LCB2KTtcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IElWaWV3TG9jYXRvciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVZpZXdMb2NhdG9yJywgeCA9PiB4LnNpbmdsZXRvbihWaWV3TG9jYXRvcikpO1xuZXhwb3J0IGNsYXNzIFZpZXdMb2NhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tb2RlbEluc3RhbmNlVG9Cb3VuZENvbXBvbmVudCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMubW9kZWxUeXBlVG9VbmJvdW5kQ29tcG9uZW50ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRWaWV3Q29tcG9uZW50Rm9yT2JqZWN0KG9iamVjdCwgdmlld05hbWVPclNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZVZpZXdzID0gVmlld3MuaGFzKG9iamVjdC5jb25zdHJ1Y3RvcikgPyBWaWV3cy5nZXQob2JqZWN0LmNvbnN0cnVjdG9yKSA6IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRWaWV3TmFtZSA9IHR5cGVvZiB2aWV3TmFtZU9yU2VsZWN0b3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHZpZXdOYW1lT3JTZWxlY3RvcihvYmplY3QsIGF2YWlsYWJsZVZpZXdzKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRWaWV3TmFtZShhdmFpbGFibGVWaWV3cywgdmlld05hbWVPclNlbGVjdG9yKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9yQ3JlYXRlQm91bmRDb21wb25lbnQob2JqZWN0LCBhdmFpbGFibGVWaWV3cywgcmVzb2x2ZWRWaWV3TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldE9yQ3JlYXRlQm91bmRDb21wb25lbnQob2JqZWN0LCBhdmFpbGFibGVWaWV3cywgcmVzb2x2ZWRWaWV3TmFtZSkge1xuICAgICAgICBsZXQgbG9va3VwID0gdGhpcy5tb2RlbEluc3RhbmNlVG9Cb3VuZENvbXBvbmVudC5nZXQob2JqZWN0KTtcbiAgICAgICAgbGV0IEJvdW5kQ29tcG9uZW50O1xuICAgICAgICBpZiAobG9va3VwID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxvb2t1cCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5tb2RlbEluc3RhbmNlVG9Cb3VuZENvbXBvbmVudC5zZXQob2JqZWN0LCBsb29rdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgQm91bmRDb21wb25lbnQgPSBsb29rdXBbcmVzb2x2ZWRWaWV3TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJvdW5kQ29tcG9uZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IFVuYm91bmRDb21wb25lbnQgPSB0aGlzLmdldE9yQ3JlYXRlVW5ib3VuZENvbXBvbmVudChvYmplY3QsIGF2YWlsYWJsZVZpZXdzLCByZXNvbHZlZFZpZXdOYW1lKTtcbiAgICAgICAgICAgIEJvdW5kQ29tcG9uZW50ID0gQ3VzdG9tRWxlbWVudC5kZWZpbmUoQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKFVuYm91bmRDb21wb25lbnQpLCBjbGFzcyBleHRlbmRzIFVuYm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcihvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9va3VwW3Jlc29sdmVkVmlld05hbWVdID0gQm91bmRDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJvdW5kQ29tcG9uZW50O1xuICAgIH1cbiAgICBnZXRPckNyZWF0ZVVuYm91bmRDb21wb25lbnQob2JqZWN0LCBhdmFpbGFibGVWaWV3cywgcmVzb2x2ZWRWaWV3TmFtZSkge1xuICAgICAgICBsZXQgbG9va3VwID0gdGhpcy5tb2RlbFR5cGVUb1VuYm91bmRDb21wb25lbnQuZ2V0KG9iamVjdC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGxldCBVbmJvdW5kQ29tcG9uZW50O1xuICAgICAgICBpZiAobG9va3VwID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxvb2t1cCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5tb2RlbFR5cGVUb1VuYm91bmRDb21wb25lbnQuc2V0KG9iamVjdC5jb25zdHJ1Y3RvciwgbG9va3VwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFVuYm91bmRDb21wb25lbnQgPSBsb29rdXBbcmVzb2x2ZWRWaWV3TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFVuYm91bmRDb21wb25lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgVW5ib3VuZENvbXBvbmVudCA9IEN1c3RvbUVsZW1lbnQuZGVmaW5lKHRoaXMuZ2V0VmlldyhhdmFpbGFibGVWaWV3cywgcmVzb2x2ZWRWaWV3TmFtZSksIGNsYXNzIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB2aWV3TW9kZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmluZShjb250cm9sbGVyLCBwYXJlbnRDb250YWluZXIsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdm0gPSB0aGlzLnZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5zY29wZSA9IFNjb3BlLmZyb21QYXJlbnQoY29udHJvbGxlci5zY29wZSwgdm0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodm0uZGVmaW5lICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2bS5kZWZpbmUoY29udHJvbGxlciwgcGFyZW50Q29udGFpbmVyLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBVbmJvdW5kQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGlmICgnaHlkcmF0aW5nJyBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm90by5oeWRyYXRpbmcgPSBmdW5jdGlvbiBoeWRyYXRpbmcoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oeWRyYXRpbmcoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnaHlkcmF0ZWQnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLmh5ZHJhdGVkID0gZnVuY3Rpb24gaHlkcmF0ZWQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oeWRyYXRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjcmVhdGVkJyBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm90by5jcmVhdGVkID0gZnVuY3Rpb24gY3JlYXRlZChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmNyZWF0ZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnYmluZGluZycgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uYmluZGluZyA9IGZ1bmN0aW9uIGJpbmRpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdNb2RlbC5iaW5kaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnYm91bmQnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLmJvdW5kID0gZnVuY3Rpb24gYm91bmQoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdNb2RlbC5ib3VuZChpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2F0dGFjaGluZycgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uYXR0YWNoaW5nID0gZnVuY3Rpb24gYXR0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3TW9kZWwuYXR0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnYXR0YWNoZWQnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLmF0dGFjaGVkID0gZnVuY3Rpb24gYXR0YWNoZWQoaW5pdGlhdG9yLCBmbGFncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3TW9kZWwuYXR0YWNoZWQoaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnZGV0YWNoaW5nJyBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm90by5kZXRhY2hpbmcgPSBmdW5jdGlvbiBkZXRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdNb2RlbC5kZXRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd1bmJpbmRpbmcnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLnVuYmluZGluZyA9IGZ1bmN0aW9uIHVuYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld01vZGVsLnVuYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2Rpc3Bvc2UnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvb2t1cFtyZXNvbHZlZFZpZXdOYW1lXSA9IFVuYm91bmRDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVuYm91bmRDb21wb25lbnQ7XG4gICAgfVxuICAgIGdldFZpZXdOYW1lKHZpZXdzLCByZXF1ZXN0ZWROYW1lKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld3NbMF0ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RlZmF1bHQtdmlldyc7XG4gICAgfVxuICAgIGdldFZpZXcodmlld3MsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgdiA9IHZpZXdzLmZpbmQoeCA9PiB4Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICBpZiAodiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHZpZXc6ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3LmpzLm1hcCIsImltcG9ydCB7IGNvbm5lY3RhYmxlLCBDb25uZWN0YWJsZVN3aXRjaGVyLCBQcm94eU9ic2VydmFibGUsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5jb25zdCB7IGVudGVyLCBleGl0IH0gPSBDb25uZWN0YWJsZVN3aXRjaGVyO1xuY29uc3QgeyB3cmFwLCB1bndyYXAgfSA9IFByb3h5T2JzZXJ2YWJsZTtcbmV4cG9ydCBjbGFzcyBDb21wdXRlZFdhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgb2JzZXJ2ZXJMb2NhdG9yLCBnZXQsIGNiLCB1c2VQcm94eSkge1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMuZ2V0ID0gZ2V0O1xuICAgICAgICB0aGlzLmNiID0gY2I7XG4gICAgICAgIHRoaXMudXNlUHJveHkgPSB1c2VQcm94eTtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvciA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICAvLyB0b2RvOiBtYXliZSB1c2UgYSBjb3VudGVyIGFsbG93IHJlY3Vyc2l2ZSBjYWxsIHRvIGEgY2VydGFpbiBsZXZlbFxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgY29ubmVjdGFibGUuYXNzaWduSWRUbyh0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgIH1cbiAgICAkYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIH1cbiAgICAkdW5iaW5kKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9icy5jbGVhcih0cnVlKTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCB8fCB0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLm9iajtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICBpZiAoIU9iamVjdC5pcyhuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgb3B0aW9uYWxseSBxdWV1ZVxuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKG9iaiwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGUoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzLnZlcnNpb24rKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVudGVyKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPSB1bndyYXAodGhpcy5nZXQuY2FsbCh2b2lkIDAsIHRoaXMudXNlUHJveHkgPyB3cmFwKHRoaXMub2JqKSA6IHRoaXMub2JqLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLm9icy5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGV4aXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRXhwcmVzc2lvbldhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlLCBsb2NhdG9yLCBvYnNlcnZlckxvY2F0b3IsIGV4cHJlc3Npb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvciA9IHRoaXM7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9iaiA9IHNjb3BlLmJpbmRpbmdDb250ZXh0O1xuICAgICAgICBjb25uZWN0YWJsZS5hc3NpZ25JZFRvKHRoaXMpO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5vYmo7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3QgY2FuT3B0aW1pemUgPSBleHByLiRraW5kID09PSAxMDA4MiAvKiBBY2Nlc3NTY29wZSAqLyAmJiB0aGlzLm9icy5jb3VudCA9PT0gMTtcbiAgICAgICAgaWYgKCFjYW5PcHRpbWl6ZSkge1xuICAgICAgICAgICAgdGhpcy5vYnMudmVyc2lvbisrO1xuICAgICAgICAgICAgdmFsdWUgPSBleHByLmV2YWx1YXRlKDAsIHRoaXMuc2NvcGUsIG51bGwsIHRoaXMubG9jYXRvciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9icy5jbGVhcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gc2hvdWxkIG9wdGlvbmFsbHkgcXVldWUgZm9yIGJhdGNoIHN5bmNocm9ub3VzXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrLmNhbGwob2JqLCB2YWx1ZSwgb2xkVmFsdWUsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgJGJpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9icy52ZXJzaW9uKys7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoMCAvKiBub25lICovLCB0aGlzLnNjb3BlLCBudWxsLCB0aGlzLmxvY2F0b3IsIHRoaXMpO1xuICAgICAgICB0aGlzLm9icy5jbGVhcihmYWxzZSk7XG4gICAgfVxuICAgICR1bmJpbmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzLmNsZWFyKHRydWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIH1cbn1cbmNvbm5lY3RhYmxlKENvbXB1dGVkV2F0Y2hlcik7XG5jb25uZWN0YWJsZShFeHByZXNzaW9uV2F0Y2hlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXRjaGVycy5qcy5tYXAiLCJpbXBvcnQgeyBQcm90b2NvbCwgTWV0YWRhdGEsIGVtcHR5QXJyYXkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoKGV4cHJlc3Npb25PclByb3BlcnR5QWNjZXNzRm4sIGNoYW5nZUhhbmRsZXJPckNhbGxiYWNrKSB7XG4gICAgaWYgKCFleHByZXNzaW9uT3JQcm9wZXJ0eUFjY2Vzc0ZuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB3YXRjaCBjb25maWcuIEV4cGVjdGVkIGFuIGV4cHJlc3Npb24gb3IgYSBmbicpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IGlzQ2xhc3NEZWNvcmF0b3IgPSBrZXkgPT0gbnVsbDtcbiAgICAgICAgY29uc3QgVHlwZSA9IGlzQ2xhc3NEZWNvcmF0b3IgPyB0YXJnZXQgOiB0YXJnZXQuY29uc3RydWN0b3I7XG4gICAgICAgIC8vIGJhc2ljIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKGlzQ2xhc3NEZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlSGFuZGxlck9yQ2FsbGJhY2sgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAmJiAoY2hhbmdlSGFuZGxlck9yQ2FsbGJhY2sgPT0gbnVsbCB8fCAhKGNoYW5nZUhhbmRsZXJPckNhbGxiYWNrIGluIFR5cGUucHJvdG90eXBlKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhbmdlIGhhbmRsZXIgY29uZmlnLiBNZXRob2QgXCIke1N0cmluZyhjaGFuZ2VIYW5kbGVyT3JDYWxsYmFjayl9XCIgbm90IGZvdW5kIGluIGNsYXNzICR7VHlwZS5uYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZXNjcmlwdG9yPy52YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkZWNvcmF0ZWQgdGFyZ2V0ICR7U3RyaW5nKGtleSl9IGlzIG5vdCBhIGNsYXNzIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBXYXRjaC5hZGQoVHlwZSwgbmV3IFdhdGNoRGVmaW5pdGlvbihleHByZXNzaW9uT3JQcm9wZXJ0eUFjY2Vzc0ZuLCBpc0NsYXNzRGVjb3JhdG9yID8gY2hhbmdlSGFuZGxlck9yQ2FsbGJhY2sgOiBkZXNjcmlwdG9yLnZhbHVlKSk7XG4gICAgfTtcbn1cbmNsYXNzIFdhdGNoRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZXhwcmVzc2lvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbn1cbmNvbnN0IG5vRGVmaW5pdGlvbnMgPSBlbXB0eUFycmF5O1xuZXhwb3J0IGNvbnN0IFdhdGNoID0ge1xuICAgIG5hbWU6IFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKCd3YXRjaCcpLFxuICAgIGFkZChUeXBlLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGxldCB3YXRjaERlZmluaXRpb25zID0gTWV0YWRhdGEuZ2V0T3duKFdhdGNoLm5hbWUsIFR5cGUpO1xuICAgICAgICBpZiAod2F0Y2hEZWZpbml0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoV2F0Y2gubmFtZSwgd2F0Y2hEZWZpbml0aW9ucyA9IFtdLCBUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB3YXRjaERlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XG4gICAgfSxcbiAgICBnZXRBbm5vdGF0aW9uKFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLmdldE93bihXYXRjaC5uYW1lLCBUeXBlKSA/PyBub0RlZmluaXRpb25zO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F0Y2guanMubWFwIiwiaW1wb3J0IHsgUHJvdG9jb2wsIE1ldGFkYXRhLCBSZWdpc3RyYXRpb24gfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWFzKC4uLmFsaWFzZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBjb25zdCBrZXkgPSBQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcignYWxpYXNlcycpO1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IE1ldGFkYXRhLmdldE93bihrZXksIHRhcmdldCk7XG4gICAgICAgIGlmIChleGlzdGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoa2V5LCBhbGlhc2VzLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhpc3RpbmcucHVzaCguLi5hbGlhc2VzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJBbGlhc2VzKGFsaWFzZXMsIHJlc291cmNlLCBrZXksIGNvbnRhaW5lcikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGFsaWFzZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBSZWdpc3RyYXRpb24uYWxpYXNUbyhrZXksIHJlc291cmNlLmtleUZyb20oYWxpYXNlc1tpXSkpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxpYXMuanMubWFwIiwiaW1wb3J0IHsgUmVnaXN0cmF0aW9uLCBNZXRhZGF0YSwgUHJvdG9jb2wsIG1lcmdlQXJyYXlzLCBmaXJzdERlZmluZWQsIERJLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgcmVnaXN0ZXJBbGlhc2VzIH0gZnJvbSAnLi9hbGlhcy5qcyc7XG5leHBvcnQgdmFyIEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChCaW5kaW5nQmVoYXZpb3JTdHJhdGVneSkge1xuICAgIEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5W0JpbmRpbmdCZWhhdmlvclN0cmF0ZWd5W1wic2luZ2xldG9uXCJdID0gMV0gPSBcInNpbmdsZXRvblwiO1xuICAgIEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5W0JpbmRpbmdCZWhhdmlvclN0cmF0ZWd5W1wiaW50ZXJjZXB0b3JcIl0gPSAyXSA9IFwiaW50ZXJjZXB0b3JcIjtcbn0pKEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5IHx8IChCaW5kaW5nQmVoYXZpb3JTdHJhdGVneSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gYmluZGluZ0JlaGF2aW9yKG5hbWVPckRlZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBCaW5kaW5nQmVoYXZpb3IuZGVmaW5lKG5hbWVPckRlZiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIEJpbmRpbmdCZWhhdmlvckRlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFR5cGUsIG5hbWUsIGFsaWFzZXMsIGtleSwgc3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5UeXBlID0gVHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gYWxpYXNlcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShuYW1lT3JEZWYsIFR5cGUpIHtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGxldCBkZWY7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yRGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVPckRlZjtcbiAgICAgICAgICAgIGRlZiA9IHsgbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVPckRlZi5uYW1lO1xuICAgICAgICAgICAgZGVmID0gbmFtZU9yRGVmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaGVyaXRzRnJvbUludGVyY2VwdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGUpID09PSBCaW5kaW5nSW50ZXJjZXB0b3I7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ0JlaGF2aW9yRGVmaW5pdGlvbihUeXBlLCBmaXJzdERlZmluZWQoQmluZGluZ0JlaGF2aW9yLmdldEFubm90YXRpb24oVHlwZSwgJ25hbWUnKSwgbmFtZSksIG1lcmdlQXJyYXlzKEJpbmRpbmdCZWhhdmlvci5nZXRBbm5vdGF0aW9uKFR5cGUsICdhbGlhc2VzJyksIGRlZi5hbGlhc2VzLCBUeXBlLmFsaWFzZXMpLCBCaW5kaW5nQmVoYXZpb3Iua2V5RnJvbShuYW1lKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ3N0cmF0ZWd5JywgZGVmLCBUeXBlLCAoKSA9PiBpbmhlcml0c0Zyb21JbnRlcmNlcHRvciA/IDIgLyogaW50ZXJjZXB0b3IgKi8gOiAxIC8qIHNpbmdsZXRvbiAqLykpO1xuICAgIH1cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgeyBUeXBlLCBrZXksIGFsaWFzZXMsIHN0cmF0ZWd5IH0gPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogc2luZ2xldG9uICovOlxuICAgICAgICAgICAgICAgIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oa2V5LCBUeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIGludGVyY2VwdG9yICovOlxuICAgICAgICAgICAgICAgIFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShrZXksIG5ldyBCaW5kaW5nQmVoYXZpb3JGYWN0b3J5KGNvbnRhaW5lciwgVHlwZSkpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgUmVnaXN0cmF0aW9uLmFsaWFzVG8oa2V5LCBUeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICByZWdpc3RlckFsaWFzZXMoYWxpYXNlcywgQmluZGluZ0JlaGF2aW9yLCBrZXksIGNvbnRhaW5lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmRpbmdCZWhhdmlvckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgVHlwZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5UeXBlID0gVHlwZTtcbiAgICAgICAgdGhpcy5kZXBzID0gREkuZ2V0RGVwZW5kZW5jaWVzKFR5cGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3QoYmluZGluZywgZXhwcikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZGVwcyA9IHRoaXMuZGVwcztcbiAgICAgICAgc3dpdGNoIChkZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oZmtsZXV2ZXIpOiBmaXggdGhpcyBjYXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlR5cGUoYmluZGluZywgZXhwcik7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlR5cGUoY29udGFpbmVyLmdldChkZXBzWzBdKSwgYmluZGluZywgZXhwcik7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlR5cGUoY29udGFpbmVyLmdldChkZXBzWzBdKSwgY29udGFpbmVyLmdldChkZXBzWzFdKSwgYmluZGluZywgZXhwcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5UeXBlKC4uLmRlcHMubWFwKGQgPT4gY29udGFpbmVyLmdldChkKSksIGJpbmRpbmcsIGV4cHIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmRpbmdJbnRlcmNlcHRvciB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZywgZXhwcikge1xuICAgICAgICB0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgbGV0IGludGVyY2VwdG9yO1xuICAgICAgICB3aGlsZSAoYmluZGluZy5pbnRlcmNlcHRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgaW50ZXJjZXB0b3IgPSBiaW5kaW5nLmludGVyY2VwdG9yO1xuICAgICAgICAgICAgYmluZGluZy5pbnRlcmNlcHRvciA9IHRoaXM7XG4gICAgICAgICAgICBiaW5kaW5nID0gaW50ZXJjZXB0b3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nLmlkO1xuICAgIH1cbiAgICBnZXQgb2JzZXJ2ZXJMb2NhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nLm9ic2VydmVyTG9jYXRvcjtcbiAgICB9XG4gICAgZ2V0IGxvY2F0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcubG9jYXRvcjtcbiAgICB9XG4gICAgZ2V0ICRzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZy4kc2NvcGU7XG4gICAgfVxuICAgIGdldCAkaG9zdFNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nLiRob3N0U2NvcGU7XG4gICAgfVxuICAgIGdldCBpc0JvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nLmlzQm91bmQ7XG4gICAgfVxuICAgIGdldCBvYnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcub2JzO1xuICAgIH1cbiAgICB1cGRhdGVUYXJnZXQodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZy51cGRhdGVUYXJnZXQodmFsdWUsIGZsYWdzKTtcbiAgICB9XG4gICAgdXBkYXRlU291cmNlKHZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmJpbmRpbmcudXBkYXRlU291cmNlKHZhbHVlLCBmbGFncyk7XG4gICAgfVxuICAgIGNhbGxTb3VyY2UoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nLmNhbGxTb3VyY2UoYXJncyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nLmhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpO1xuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncykge1xuICAgICAgICB0aGlzLmJpbmRpbmcuaGFuZGxlQ29sbGVjdGlvbkNoYW5nZShpbmRleE1hcCwgZmxhZ3MpO1xuICAgIH1cbiAgICBvYnNlcnZlUHJvcGVydHkob2JqLCBrZXkpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nLm9ic2VydmVQcm9wZXJ0eShvYmosIGtleSk7XG4gICAgfVxuICAgIG9ic2VydmVDb2xsZWN0aW9uKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuYmluZGluZy5vYnNlcnZlQ29sbGVjdGlvbihvYnNlcnZlcik7XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIHRoaXMuYmluZGluZy4kYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nLiR1bmJpbmQoZmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBCaW5kaW5nQmVoYXZpb3IgPSB7XG4gICAgbmFtZTogUHJvdG9jb2wucmVzb3VyY2Uua2V5Rm9yKCdiaW5kaW5nLWJlaGF2aW9yJyksXG4gICAga2V5RnJvbShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtCaW5kaW5nQmVoYXZpb3IubmFtZX06JHtuYW1lfWA7XG4gICAgfSxcbiAgICBpc1R5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBNZXRhZGF0YS5oYXNPd24oQmluZGluZ0JlaGF2aW9yLm5hbWUsIHZhbHVlKTtcbiAgICB9LFxuICAgIGRlZmluZShuYW1lT3JEZWYsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEJpbmRpbmdCZWhhdmlvckRlZmluaXRpb24uY3JlYXRlKG5hbWVPckRlZiwgVHlwZSk7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShCaW5kaW5nQmVoYXZpb3IubmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbi5UeXBlKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEJpbmRpbmdCZWhhdmlvci5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uKTtcbiAgICAgICAgUHJvdG9jb2wucmVzb3VyY2UuYXBwZW5kVG8oVHlwZSwgQmluZGluZ0JlaGF2aW9yLm5hbWUpO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5UeXBlO1xuICAgIH0sXG4gICAgZ2V0RGVmaW5pdGlvbihUeXBlKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IE1ldGFkYXRhLmdldE93bihCaW5kaW5nQmVoYXZpb3IubmFtZSwgVHlwZSk7XG4gICAgICAgIGlmIChkZWYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZWZpbml0aW9uIGZvdW5kIGZvciB0eXBlICR7VHlwZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfSxcbiAgICBhbm5vdGF0ZShUeXBlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIHZhbHVlLCBUeXBlKTtcbiAgICB9LFxuICAgIGdldEFubm90YXRpb24oVHlwZSwgcHJvcCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKHByb3ApLCBUeXBlKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmctYmVoYXZpb3IuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMgKi9cbmltcG9ydCB7IGVtcHR5QXJyYXksIGlzTnVtYmVyT3JCaWdJbnQsIGlzU3RyaW5nT3JEYXRlIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdDb250ZXh0IH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24vYmluZGluZy1jb250ZXh0LmpzJztcbmltcG9ydCB7IElTaWduYWxlciB9IGZyb20gJy4uL29ic2VydmF0aW9uL3NpZ25hbGVyLmpzJztcbmltcG9ydCB7IEJpbmRpbmdCZWhhdmlvciwgQmluZGluZ0JlaGF2aW9yRmFjdG9yeSB9IGZyb20gJy4uL2JpbmRpbmctYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgVmFsdWVDb252ZXJ0ZXIgfSBmcm9tICcuLi92YWx1ZS1jb252ZXJ0ZXIuanMnO1xuZXhwb3J0IHZhciBFeHByZXNzaW9uS2luZDtcbihmdW5jdGlvbiAoRXhwcmVzc2lvbktpbmQpIHtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkNvbm5lY3RzXCJdID0gMzJdID0gXCJDb25uZWN0c1wiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiT2JzZXJ2ZXNcIl0gPSA2NF0gPSBcIk9ic2VydmVzXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJDYWxsc0Z1bmN0aW9uXCJdID0gMTI4XSA9IFwiQ2FsbHNGdW5jdGlvblwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiSGFzQW5jZXN0b3JcIl0gPSAyNTZdID0gXCJIYXNBbmNlc3RvclwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiSXNQcmltYXJ5XCJdID0gNTEyXSA9IFwiSXNQcmltYXJ5XCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJJc0xlZnRIYW5kU2lkZVwiXSA9IDEwMjRdID0gXCJJc0xlZnRIYW5kU2lkZVwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiSGFzQmluZFwiXSA9IDIwNDhdID0gXCJIYXNCaW5kXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJIYXNVbmJpbmRcIl0gPSA0MDk2XSA9IFwiSGFzVW5iaW5kXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJJc0Fzc2lnbmFibGVcIl0gPSA4MTkyXSA9IFwiSXNBc3NpZ25hYmxlXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJJc0xpdGVyYWxcIl0gPSAxNjM4NF0gPSBcIklzTGl0ZXJhbFwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiSXNSZXNvdXJjZVwiXSA9IDMyNzY4XSA9IFwiSXNSZXNvdXJjZVwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiSXNGb3JEZWNsYXJhdGlvblwiXSA9IDY1NTM2XSA9IFwiSXNGb3JEZWNsYXJhdGlvblwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiVHlwZVwiXSA9IDMxXSA9IFwiVHlwZVwiO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQWNjZXNzVGhpc1wiXSA9IDE3OTNdID0gXCJBY2Nlc3NUaGlzXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJBY2Nlc3NTY29wZVwiXSA9IDEwMDgyXSA9IFwiQWNjZXNzU2NvcGVcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkFycmF5TGl0ZXJhbFwiXSA9IDE3OTU1XSA9IFwiQXJyYXlMaXRlcmFsXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJPYmplY3RMaXRlcmFsXCJdID0gMTc5NTZdID0gXCJPYmplY3RMaXRlcmFsXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJQcmltaXRpdmVMaXRlcmFsXCJdID0gMTc5MjVdID0gXCJQcmltaXRpdmVMaXRlcmFsXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJUZW1wbGF0ZVwiXSA9IDE3OTU4XSA9IFwiVGVtcGxhdGVcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIlVuYXJ5XCJdID0gMzldID0gXCJVbmFyeVwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQ2FsbFNjb3BlXCJdID0gMTQ0OF0gPSBcIkNhbGxTY29wZVwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQ2FsbE1lbWJlclwiXSA9IDExNjFdID0gXCJDYWxsTWVtYmVyXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJDYWxsRnVuY3Rpb25cIl0gPSAxMTYyXSA9IFwiQ2FsbEZ1bmN0aW9uXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJBY2Nlc3NNZW1iZXJcIl0gPSA5MzIzXSA9IFwiQWNjZXNzTWVtYmVyXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJBY2Nlc3NLZXllZFwiXSA9IDkzMjRdID0gXCJBY2Nlc3NLZXllZFwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiVGFnZ2VkVGVtcGxhdGVcIl0gPSAxMTk3XSA9IFwiVGFnZ2VkVGVtcGxhdGVcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkJpbmFyeVwiXSA9IDQ2XSA9IFwiQmluYXJ5XCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJDb25kaXRpb25hbFwiXSA9IDYzXSA9IFwiQ29uZGl0aW9uYWxcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkFzc2lnblwiXSA9IDgyMDhdID0gXCJBc3NpZ25cIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIlZhbHVlQ29udmVydGVyXCJdID0gMzY5MTNdID0gXCJWYWx1ZUNvbnZlcnRlclwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQmluZGluZ0JlaGF2aW9yXCJdID0gMzg5NjJdID0gXCJCaW5kaW5nQmVoYXZpb3JcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkh0bWxMaXRlcmFsXCJdID0gNTFdID0gXCJIdG1sTGl0ZXJhbFwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQXJyYXlCaW5kaW5nUGF0dGVyblwiXSA9IDY1NTU2XSA9IFwiQXJyYXlCaW5kaW5nUGF0dGVyblwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiT2JqZWN0QmluZGluZ1BhdHRlcm5cIl0gPSA2NTU1N10gPSBcIk9iamVjdEJpbmRpbmdQYXR0ZXJuXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJCaW5kaW5nSWRlbnRpZmllclwiXSA9IDY1NTU4XSA9IFwiQmluZGluZ0lkZW50aWZpZXJcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkZvck9mU3RhdGVtZW50XCJdID0gNjE5OV0gPSBcIkZvck9mU3RhdGVtZW50XCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJJbnRlcnBvbGF0aW9uXCJdID0gMjRdID0gXCJJbnRlcnBvbGF0aW9uXCI7IC8vXG59KShFeHByZXNzaW9uS2luZCB8fCAoRXhwcmVzc2lvbktpbmQgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIFVucGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gJyc7XG4gICAgfVxuICAgIHN0YXRpYyB1bnBhcnNlKGV4cHIpIHtcbiAgICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBVbnBhcnNlcigpO1xuICAgICAgICBleHByLmFjY2VwdCh2aXNpdG9yKTtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudGV4dDtcbiAgICB9XG4gICAgdmlzaXRBY2Nlc3NNZW1iZXIoZXhwcikge1xuICAgICAgICBleHByLm9iamVjdC5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSBgLiR7ZXhwci5uYW1lfWA7XG4gICAgfVxuICAgIHZpc2l0QWNjZXNzS2V5ZWQoZXhwcikge1xuICAgICAgICBleHByLm9iamVjdC5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnWyc7XG4gICAgICAgIGV4cHIua2V5LmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICddJztcbiAgICB9XG4gICAgdmlzaXRBY2Nlc3NUaGlzKGV4cHIpIHtcbiAgICAgICAgaWYgKGV4cHIuYW5jZXN0b3IgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSAnJHRoaXMnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSAnJHBhcmVudCc7XG4gICAgICAgIGxldCBpID0gZXhwci5hbmNlc3RvciAtIDE7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSAnLiRwYXJlbnQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QWNjZXNzU2NvcGUoZXhwcikge1xuICAgICAgICBsZXQgaSA9IGV4cHIuYW5jZXN0b3I7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSAnJHBhcmVudC4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSBleHByLm5hbWU7XG4gICAgfVxuICAgIHZpc2l0QXJyYXlMaXRlcmFsKGV4cHIpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBleHByLmVsZW1lbnRzO1xuICAgICAgICB0aGlzLnRleHQgKz0gJ1snO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzW2ldLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gJ10nO1xuICAgIH1cbiAgICB2aXNpdE9iamVjdExpdGVyYWwoZXhwcikge1xuICAgICAgICBjb25zdCBrZXlzID0gZXhwci5rZXlzO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBleHByLnZhbHVlcztcbiAgICAgICAgdGhpcy50ZXh0ICs9ICd7JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBgJyR7a2V5c1tpXX0nOmA7XG4gICAgICAgICAgICB2YWx1ZXNbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSAnfSc7XG4gICAgfVxuICAgIHZpc2l0UHJpbWl0aXZlTGl0ZXJhbChleHByKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKCc7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWQgPSBleHByLnZhbHVlLnJlcGxhY2UoLycvZywgJ1xcXFxcXCcnKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBgJyR7ZXNjYXBlZH0nYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBgJHtleHByLnZhbHVlfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ICs9ICcpJztcbiAgICB9XG4gICAgdmlzaXRDYWxsRnVuY3Rpb24oZXhwcikge1xuICAgICAgICB0aGlzLnRleHQgKz0gJygnO1xuICAgICAgICBleHByLmZ1bmMuYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLndyaXRlQXJncyhleHByLmFyZ3MpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbiAgICB2aXNpdENhbGxNZW1iZXIoZXhwcikge1xuICAgICAgICB0aGlzLnRleHQgKz0gJygnO1xuICAgICAgICBleHByLm9iamVjdC5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSBgLiR7ZXhwci5uYW1lfWA7XG4gICAgICAgIHRoaXMud3JpdGVBcmdzKGV4cHIuYXJncyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKSc7XG4gICAgfVxuICAgIHZpc2l0Q2FsbFNjb3BlKGV4cHIpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICcoJztcbiAgICAgICAgbGV0IGkgPSBleHByLmFuY2VzdG9yO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gJyRwYXJlbnQuJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gZXhwci5uYW1lO1xuICAgICAgICB0aGlzLndyaXRlQXJncyhleHByLmFyZ3MpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKGV4cHIpIHtcbiAgICAgICAgY29uc3QgeyBjb29rZWQsIGV4cHJlc3Npb25zIH0gPSBleHByO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMudGV4dCArPSAnYCc7XG4gICAgICAgIHRoaXMudGV4dCArPSBjb29rZWRbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zW2ldLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBjb29rZWRbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSAnYCc7XG4gICAgfVxuICAgIHZpc2l0VGFnZ2VkVGVtcGxhdGUoZXhwcikge1xuICAgICAgICBjb25zdCB7IGNvb2tlZCwgZXhwcmVzc2lvbnMgfSA9IGV4cHI7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICAgICAgZXhwci5mdW5jLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICdgJztcbiAgICAgICAgdGhpcy50ZXh0ICs9IGNvb2tlZFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnNbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGNvb2tlZFtpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ICs9ICdgJztcbiAgICB9XG4gICAgdmlzaXRVbmFyeShleHByKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBgKCR7ZXhwci5vcGVyYXRpb259YDtcbiAgICAgICAgaWYgKGV4cHIub3BlcmF0aW9uLmNoYXJDb2RlQXQoMCkgPj0gLyogYSAqLyA5Nykge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBleHByLmV4cHJlc3Npb24uYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbiAgICB2aXNpdEJpbmFyeShleHByKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKCc7XG4gICAgICAgIGV4cHIubGVmdC5hY2NlcHQodGhpcyk7XG4gICAgICAgIGlmIChleHByLm9wZXJhdGlvbi5jaGFyQ29kZUF0KDApID09PSAvKiBpICovIDEwNSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGAgJHtleHByLm9wZXJhdGlvbn0gYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBleHByLm9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBleHByLnJpZ2h0LmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICcpJztcbiAgICB9XG4gICAgdmlzaXRDb25kaXRpb25hbChleHByKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKCc7XG4gICAgICAgIGV4cHIuY29uZGl0aW9uLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICc/JztcbiAgICAgICAgZXhwci55ZXMuYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJzonO1xuICAgICAgICBleHByLm5vLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICcpJztcbiAgICB9XG4gICAgdmlzaXRBc3NpZ24oZXhwcikge1xuICAgICAgICB0aGlzLnRleHQgKz0gJygnO1xuICAgICAgICBleHByLnRhcmdldC5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnPSc7XG4gICAgICAgIGV4cHIudmFsdWUuYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbiAgICB2aXNpdFZhbHVlQ29udmVydGVyKGV4cHIpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGV4cHIuYXJncztcbiAgICAgICAgZXhwci5leHByZXNzaW9uLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9IGB8JHtleHByLm5hbWV9YDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSAnOic7XG4gICAgICAgICAgICBhcmdzW2ldLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEJpbmRpbmdCZWhhdmlvcihleHByKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBleHByLmFyZ3M7XG4gICAgICAgIGV4cHIuZXhwcmVzc2lvbi5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSBgJiR7ZXhwci5uYW1lfWA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gJzonO1xuICAgICAgICAgICAgYXJnc1tpXS5hY2NlcHQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRBcnJheUJpbmRpbmdQYXR0ZXJuKGV4cHIpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBleHByLmVsZW1lbnRzO1xuICAgICAgICB0aGlzLnRleHQgKz0gJ1snO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzW2ldLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gJ10nO1xuICAgIH1cbiAgICB2aXNpdE9iamVjdEJpbmRpbmdQYXR0ZXJuKGV4cHIpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGV4cHIua2V5cztcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZXhwci52YWx1ZXM7XG4gICAgICAgIHRoaXMudGV4dCArPSAneyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gYCcke2tleXNbaV19JzpgO1xuICAgICAgICAgICAgdmFsdWVzW2ldLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gJ30nO1xuICAgIH1cbiAgICB2aXNpdEJpbmRpbmdJZGVudGlmaWVyKGV4cHIpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IGV4cHIubmFtZTtcbiAgICB9XG4gICAgdmlzaXRIdG1sTGl0ZXJhbChleHByKSB7IHRocm93IG5ldyBFcnJvcigndmlzaXRIdG1sTGl0ZXJhbCcpOyB9XG4gICAgdmlzaXRGb3JPZlN0YXRlbWVudChleHByKSB7XG4gICAgICAgIGV4cHIuZGVjbGFyYXRpb24uYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyBvZiAnO1xuICAgICAgICBleHByLml0ZXJhYmxlLmFjY2VwdCh0aGlzKTtcbiAgICB9XG4gICAgdmlzaXRJbnRlcnBvbGF0aW9uKGV4cHIpIHtcbiAgICAgICAgY29uc3QgeyBwYXJ0cywgZXhwcmVzc2lvbnMgfSA9IGV4cHI7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICckeyc7XG4gICAgICAgIHRoaXMudGV4dCArPSBwYXJ0c1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnNbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gJ30nO1xuICAgIH1cbiAgICB3cml0ZUFyZ3MoYXJncykge1xuICAgICAgICB0aGlzLnRleHQgKz0gJygnO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnc1tpXS5hY2NlcHQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ICs9ICcpJztcbiAgICB9XG59XG5mdW5jdGlvbiBjaG9vc2VTY29wZShhY2Nlc3NIb3N0U2NvcGUsIHMsIGhzKSB7XG4gICAgaWYgKGFjY2Vzc0hvc3RTY29wZSkge1xuICAgICAgICBpZiAoaHMgPT09IG51bGwgfHwgaHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb3N0IHNjb3BlIGlzIG1pc3NpbmcuIEFyZSB5b3UgdXNpbmcgYCRob3N0YCBvdXRzaWRlIHRoZSBgYXUtc2xvdGA/IE9yIG1pc3NpbmcgdGhlIGBhdS1zbG90YCBhdHRyaWJ1dGU/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhzO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmV4cG9ydCBjbGFzcyBDdXN0b21FeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGV2YWx1YXRlKF9mLCBfcywgX2hzLCBfbCwgX2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmRpbmdCZWhhdmlvckV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24sIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5iZWhhdmlvcktleSA9IEJpbmRpbmdCZWhhdmlvci5rZXlGcm9tKG5hbWUpO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAzODk2MiAvKiBCaW5kaW5nQmVoYXZpb3IgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgIH1cbiAgICBhc3NpZ24oZiwgcywgaHMsIGwsIHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmFzc2lnbihmLCBzLCBocywgbCwgdmFsKTtcbiAgICB9XG4gICAgYmluZChmLCBzLCBocywgYikge1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uLmhhc0JpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5iaW5kKGYsIHMsIGhzLCBiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiZWhhdmlvciA9IGIubG9jYXRvci5nZXQodGhpcy5iZWhhdmlvcktleSk7XG4gICAgICAgIGlmIChiZWhhdmlvciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmRpbmdCZWhhdmlvciBuYW1lZCAnJHt0aGlzLm5hbWV9JyBjb3VsZCBub3QgYmUgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIHJlZ2lzdGVyIGl0IGFzIGEgZGVwZW5kZW5jeT9gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShiZWhhdmlvciBpbnN0YW5jZW9mIEJpbmRpbmdCZWhhdmlvckZhY3RvcnkpKSB7XG4gICAgICAgICAgICBpZiAoYlt0aGlzLmJlaGF2aW9yS2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYlt0aGlzLmJlaGF2aW9yS2V5XSA9IGJlaGF2aW9yO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLmJpbmQuY2FsbChiZWhhdmlvciwgZiwgcywgaHMsIGIsIC4uLnRoaXMuYXJncy5tYXAoYSA9PiBhLmV2YWx1YXRlKGYsIHMsIGhzLCBiLmxvY2F0b3IsIG51bGwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmRpbmdCZWhhdmlvciBuYW1lZCAnJHt0aGlzLm5hbWV9JyBhbHJlYWR5IGFwcGxpZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5iaW5kKGYsIHMsIGhzLCBiKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuYmVoYXZpb3JLZXk7XG4gICAgICAgIGNvbnN0ICRiID0gYjtcbiAgICAgICAgaWYgKCRiW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAkYltrZXldLnVuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICRiW2tleV0udW5iaW5kKGYsIHMsIGhzLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRiW2tleV0gPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbi5oYXNVbmJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi51bmJpbmQoZiwgcywgaHMsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluZGluZ0JlaGF2aW9yKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZhbHVlQ29udmVydGVyRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZXhwcmVzc2lvbiwgbmFtZSwgYXJncykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmNvbnZlcnRlcktleSA9IFZhbHVlQ29udmVydGVyLmtleUZyb20obmFtZSk7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDM2OTEzIC8qIFZhbHVlQ29udmVydGVyICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgY29uc3QgdmMgPSBsLmdldCh0aGlzLmNvbnZlcnRlcktleSk7XG4gICAgICAgIGlmICh2YyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlQ29udmVydGVyIG5hbWVkICcke3RoaXMubmFtZX0nIGNvdWxkIG5vdCBiZSBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gcmVnaXN0ZXIgaXQgYXMgYSBkZXBlbmRlbmN5P2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGU6IHRoZSBjYXN0IGlzIGV4cGVjdGVkLiBUbyBjb25uZWN0LCBpdCBqdXN0IG5lZWRzIHRvIGJlIGEgSUNvbm5lY3RhYmxlXG4gICAgICAgIC8vIHRob3VnaCB0byB3b3JrIHdpdGggc2lnbmFsLCBpdCBuZWVkcyB0byBoYXZlIGBoYW5kbGVDaGFuZ2VgXG4gICAgICAgIC8vIHNvIGhhdmluZyBgaGFuZGxlQ2hhbmdlYCBhcyBhIGd1YXJkIGluIHRoZSBjb25uZWN0YWJsZSBhcyBhIHNhZmUgbWVhc3VyZSBpcyBuZWVkZWRcbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHNpZ25hbGVyIHdvcmtzXG4gICAgICAgIGlmIChjICE9PSBudWxsICYmICgnaGFuZGxlQ2hhbmdlJyBpbiBjKSkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFscyA9IHZjLnNpZ25hbHM7XG4gICAgICAgICAgICBpZiAoc2lnbmFscyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsZXIgPSBsLmdldChJU2lnbmFsZXIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNpZ25hbHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWxlci5hZGRTaWduYWxMaXN0ZW5lcihzaWduYWxzW2ldLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCd0b1ZpZXcnIGluIHZjKSB7XG4gICAgICAgICAgICByZXR1cm4gdmMudG9WaWV3KHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyksIC4uLnRoaXMuYXJncy5tYXAoYSA9PiBhLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgIH1cbiAgICBhc3NpZ24oZiwgcywgaHMsIGwsIHZhbCkge1xuICAgICAgICBjb25zdCB2YyA9IGwuZ2V0KHRoaXMuY29udmVydGVyS2V5KTtcbiAgICAgICAgaWYgKHZjID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWVDb252ZXJ0ZXIgbmFtZWQgJyR7dGhpcy5uYW1lfScgY291bGQgbm90IGJlIGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byByZWdpc3RlciBpdCBhcyBhIGRlcGVuZGVuY3k/YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdmcm9tVmlldycgaW4gdmMpIHtcbiAgICAgICAgICAgIHZhbCA9IHZjLmZyb21WaWV3KHZhbCwgLi4udGhpcy5hcmdzLm1hcChhID0+IGEuZXZhbHVhdGUoZiwgcywgaHMsIGwsIG51bGwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5hc3NpZ24oZiwgcywgaHMsIGwsIHZhbCk7XG4gICAgfVxuICAgIHVuYmluZChfZiwgX3MsIF9ocywgYikge1xuICAgICAgICBjb25zdCB2YyA9IGIubG9jYXRvci5nZXQodGhpcy5jb252ZXJ0ZXJLZXkpO1xuICAgICAgICBpZiAodmMuc2lnbmFscyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmFsZXIgPSBiLmxvY2F0b3IuZ2V0KElTaWduYWxlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmMuc2lnbmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gdGhlIGNhc3QgaXMgY29ycmVjdCwgYXMgdGhlIHZhbHVlIGNvbnZlcnRlciBleHByZXNzaW9uIHdvdWxkIG9ubHkgYWRkXG4gICAgICAgICAgICAvLyBhIElDb25uZWN0YWJsZSB0aGF0IGFsc28gaW1wbGVtZW50cyBgSVN1YnNjcmliZXJgIGludGVyZmFjZSB0byB0aGUgc2lnbmFsZXJcbiAgICAgICAgICAgIHNpZ25hbGVyLnJlbW92ZVNpZ25hbExpc3RlbmVyKHZjLnNpZ25hbHNbaV0sIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFsdWVDb252ZXJ0ZXIodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXNzaWduRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA4MjA4IC8qIEFzc2lnbiAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQuYXNzaWduKGYsIHMsIGhzLCBsLCB0aGlzLnZhbHVlLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSk7XG4gICAgfVxuICAgIGFzc2lnbihmLCBzLCBocywgbCwgdmFsKSB7XG4gICAgICAgIHRoaXMudmFsdWUuYXNzaWduKGYsIHMsIGhzLCBsLCB2YWwpO1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQuYXNzaWduKGYsIHMsIGhzLCBsLCB2YWwpO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2lnbih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb25kaXRpb25hbEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbmRpdGlvbiwgeWVzLCBubykge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy55ZXMgPSB5ZXM7XG4gICAgICAgIHRoaXMubm8gPSBubztcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gNjMgLyogQ29uZGl0aW9uYWwgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSA/IHRoaXMueWVzLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSA6IHRoaXMubm8uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWNjZXNzVGhpc0V4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGFuY2VzdG9yID0gMCkge1xuICAgICAgICB0aGlzLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDE3OTMgLyogQWNjZXNzVGhpcyAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShfZiwgcywgaHMsIF9sLCBfYykge1xuICAgICAgICBpZiAodGhpcyA9PT0gQWNjZXNzVGhpc0V4cHJlc3Npb24uJGhvc3QpIHtcbiAgICAgICAgICAgIHMgPSBjaG9vc2VTY29wZSh0cnVlLCBzLCBocyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9jID0gcy5vdmVycmlkZUNvbnRleHQ7XG4gICAgICAgIGxldCBjdXJyZW50U2NvcGUgPSBzO1xuICAgICAgICBsZXQgaSA9IHRoaXMuYW5jZXN0b3I7XG4gICAgICAgIHdoaWxlIChpLS0gJiYgb2MpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IGN1cnJlbnRTY29wZS5wYXJlbnRTY29wZTtcbiAgICAgICAgICAgIG9jID0gY3VycmVudFNjb3BlPy5vdmVycmlkZUNvbnRleHQgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaSA8IDEgJiYgb2MgPyBvYy5iaW5kaW5nQ29udGV4dCA6IHZvaWQgMDtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFjY2Vzc1RoaXModGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5BY2Nlc3NUaGlzRXhwcmVzc2lvbi4kdGhpcyA9IG5ldyBBY2Nlc3NUaGlzRXhwcmVzc2lvbigwKTtcbi8vICRob3N0IGFuZCAkdGhpcyBhcmUgbG9vc2VseSB0aGUgc2FtZSB0aGluZy4gJGhvc3QgaXMgdXNlZCBpbiB0aGUgY29udGV4dCBvZiBgYXUtc2xvdGAgd2l0aCB0aGUgcHJpbWFyeSBvYmplY3RpdmUgb2YgZGV0ZXJtaW5pbmcgdGhlIHMuXG5BY2Nlc3NUaGlzRXhwcmVzc2lvbi4kaG9zdCA9IG5ldyBBY2Nlc3NUaGlzRXhwcmVzc2lvbigwKTtcbkFjY2Vzc1RoaXNFeHByZXNzaW9uLiRwYXJlbnQgPSBuZXcgQWNjZXNzVGhpc0V4cHJlc3Npb24oMSk7XG5leHBvcnQgY2xhc3MgQWNjZXNzU2NvcGVFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhbmNlc3RvciA9IDAsIGFjY2Vzc0hvc3RTY29wZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICAgICAgdGhpcy5hY2Nlc3NIb3N0U2NvcGUgPSBhY2Nlc3NIb3N0U2NvcGU7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDEwMDgyIC8qIEFjY2Vzc1Njb3BlICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBfbCwgYykge1xuICAgICAgICBjb25zdCBvYmogPSBCaW5kaW5nQ29udGV4dC5nZXQoY2hvb3NlU2NvcGUodGhpcy5hY2Nlc3NIb3N0U2NvcGUsIHMsIGhzKSwgdGhpcy5uYW1lLCB0aGlzLmFuY2VzdG9yLCBmLCBocyk7XG4gICAgICAgIGlmIChjICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjLm9ic2VydmVQcm9wZXJ0eShvYmosIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZhbHVhdGVkVmFsdWUgPSBvYmpbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKGYgJiA0IC8qIGlzU3RyaWN0QmluZGluZ1N0cmF0ZWd5ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZFZhbHVlID09IG51bGwgPyAnJyA6IGV2YWx1YXRlZFZhbHVlO1xuICAgIH1cbiAgICBhc3NpZ24oZiwgcywgaHMsIF9sLCB2YWwpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gQmluZGluZ0NvbnRleHQuZ2V0KGNob29zZVNjb3BlKHRoaXMuYWNjZXNzSG9zdFNjb3BlLCBzLCBocyksIHRoaXMubmFtZSwgdGhpcy5hbmNlc3RvciwgZiwgaHMpO1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqLiRvYnNlcnZlcnM/Llt0aGlzLm5hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvYmouJG9ic2VydmVyc1t0aGlzLm5hbWVdLnNldFZhbHVlKHZhbCwgZik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpbdGhpcy5uYW1lXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFjY2Vzc1Njb3BlKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFjY2Vzc01lbWJlckV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG9iamVjdCwgbmFtZSkge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gOTMyMyAvKiBBY2Nlc3NNZW1iZXIgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLm9iamVjdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgKGYgJiAyMDQ4IC8qIG9ic2VydmVMZWFmUHJvcGVydGllc09ubHkgKi8pID4gMCA/IG51bGwgOiBjKTtcbiAgICAgICAgaWYgKGYgJiA0IC8qIGlzU3RyaWN0QmluZGluZ1N0cmF0ZWd5ICovKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYy5vYnNlcnZlUHJvcGVydHkoaW5zdGFuY2UsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbdGhpcy5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyAhPT0gbnVsbCAmJiBpbnN0YW5jZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgYy5vYnNlcnZlUHJvcGVydHkoaW5zdGFuY2UsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlID8gaW5zdGFuY2VbdGhpcy5uYW1lXSA6ICcnO1xuICAgIH1cbiAgICBhc3NpZ24oZiwgcywgaHMsIGwsIHZhbCkge1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLm9iamVjdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgbnVsbCk7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmouJG9ic2VydmVycyAhPT0gdm9pZCAwICYmIG9iai4kb2JzZXJ2ZXJzW3RoaXMubmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9iai4kb2JzZXJ2ZXJzW3RoaXMubmFtZV0uc2V0VmFsdWUodmFsLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialt0aGlzLm5hbWVdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYmplY3QuYXNzaWduKGYsIHMsIGhzLCBsLCB7IFt0aGlzLm5hbWVdOiB2YWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBY2Nlc3NNZW1iZXIodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWNjZXNzS2V5ZWRFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvYmplY3QsIGtleSkge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDkzMjQgLyogQWNjZXNzS2V5ZWQgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLm9iamVjdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgKGYgJiAyMDQ4IC8qIG9ic2VydmVMZWFmUHJvcGVydGllc09ubHkgKi8pID4gMCA/IG51bGwgOiBjKTtcbiAgICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleS5ldmFsdWF0ZShmLCBzLCBocywgbCwgKGYgJiAyMDQ4IC8qIG9ic2VydmVMZWFmUHJvcGVydGllc09ubHkgKi8pID4gMCA/IG51bGwgOiBjKTtcbiAgICAgICAgICAgIGlmIChjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYy5vYnNlcnZlUHJvcGVydHkoaW5zdGFuY2UsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhc3NpZ24oZiwgcywgaHMsIGwsIHZhbCkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBudWxsKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkuZXZhbHVhdGUoZiwgcywgaHMsIGwsIG51bGwpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Vba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBY2Nlc3NLZXllZCh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsU2NvcGVFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhbmNlc3RvciA9IDAsIGFjY2Vzc0hvc3RTY29wZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICAgICAgdGhpcy5hY2Nlc3NIb3N0U2NvcGUgPSBhY2Nlc3NIb3N0U2NvcGU7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDE0NDggLyogQ2FsbFNjb3BlICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIHMgPSBjaG9vc2VTY29wZSh0aGlzLmFjY2Vzc0hvc3RTY29wZSwgcywgaHMpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdzLm1hcChhID0+IGEuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IEJpbmRpbmdDb250ZXh0LmdldChzLCB0aGlzLm5hbWUsIHRoaXMuYW5jZXN0b3IsIGYsIGhzKTtcbiAgICAgICAgLy8gaWRlYWxseSwgc2hvdWxkIG9ic2VydmUgcHJvcGVydHkgcmVwcmVzZW50cyBieSB0aGlzLm5hbWUgYXMgd2VsbFxuICAgICAgICAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gdG9kbzogZGlkIGl0IGV2ZXIgc3VycHJpc2UgYW55b25lP1xuICAgICAgICBjb25zdCBmdW5jID0gZ2V0RnVuY3Rpb24oZiwgY29udGV4dCwgdGhpcy5uYW1lKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYWxsU2NvcGUodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2FsbE1lbWJlckV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gMTE2MSAvKiBDYWxsTWVtYmVyICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5vYmplY3QuZXZhbHVhdGUoZiwgcywgaHMsIGwsIChmICYgMjA0OCAvKiBvYnNlcnZlTGVhZlByb3BlcnRpZXNPbmx5ICovKSA+IDAgPyBudWxsIDogYyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3MubWFwKGEgPT4gYS5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykpO1xuICAgICAgICBjb25zdCBmdW5jID0gZ2V0RnVuY3Rpb24oZiwgaW5zdGFuY2UsIHRoaXMubmFtZSk7XG4gICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpbnN0YW5jZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhbGxNZW1iZXIodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2FsbEZ1bmN0aW9uRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZnVuYywgYXJncykge1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAxMTYyIC8qIENhbGxGdW5jdGlvbiAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5mdW5jLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyguLi50aGlzLmFyZ3MubWFwKGEgPT4gYS5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmICYgMTI4IC8qIG11c3RFdmFsdWF0ZSAqLykgJiYgKGZ1bmMgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHByZXNzaW9uIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2FsbEZ1bmN0aW9uKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmFyeUV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wZXJhdGlvbiwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gNDYgLyogQmluYXJ5ICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgJiYgdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHx8IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpID09IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSA9PT0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgIT0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpICE9PSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJpZ2h0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIGluIHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3RlOiBhdXRvQ29udmVydEFkZCAoYW5kIHRoZSBudWxsIGNoZWNrKSBpcyByZW1vdmVkIGJlY2F1c2UgdGhlIGRlZmF1bHQgc3BlYyBiZWhhdmlvciBpcyBhbHJlYWR5IGxhcmdlbHkgc2ltaWxhclxuICAgICAgICAgICAgLy8gYW5kIHdoZXJlIGl0IGlzbid0LCB5b3Uga2luZCBvZiB3YW50IGl0IHRvIGJlaGF2ZSBsaWtlIHRoZSBzcGVjIGFueXdheSAoZS5nLiByZXR1cm4gTmFOIHdoZW4gYWRkaW5nIGEgbnVtYmVyIHRvIHVuZGVmaW5lZClcbiAgICAgICAgICAgIC8vIHRoaXMgbWFrZXMgYnVncyBpbiB1c2VyIGNvZGUgZWFzaWVyIHRvIHRyYWNrIGRvd24gZm9yIGVuZCB1c2Vyc1xuICAgICAgICAgICAgLy8gYWxzbywgc2tpcHBpbmcgdGhlc2UgY2hlY2tzIGFuZCBsZWF2aW5nIGl0IHRvIHRoZSBydW50aW1lIGlzIGEgbmljZSBsaXR0bGUgcGVyZiBib29zdCBhbmQgc2ltcGxpZmllcyBvdXIgY29kZVxuICAgICAgICAgICAgY2FzZSAnKyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgICAgIGlmICgoZiAmIDQgLyogaXNTdHJpY3RCaW5kaW5nU3RyYXRlZ3kgKi8pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgaWYgKCFsZWZ0IHx8ICFyaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXJPckJpZ0ludChsZWZ0KSB8fCBpc051bWJlck9yQmlnSW50KHJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsZWZ0IHx8IDApICsgKHJpZ2h0IHx8IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZ09yRGF0ZShsZWZ0KSB8fCBpc1N0cmluZ09yRGF0ZShyaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobGVmdCB8fCAnJykgKyAocmlnaHQgfHwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSAtIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgKiB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIC8gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSAlIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgPCB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpID4gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgPD0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgPj0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBiaW5hcnkgb3BlcmF0b3I6ICcke3RoaXMub3BlcmF0aW9ufSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5KHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVuYXJ5RXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0aW9uLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAzOSAvKiBVbmFyeSAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd2b2lkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAndHlwZW9mJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmIHwgNCAvKiBpc1N0cmljdEJpbmRpbmdTdHJhdGVneSAqLywgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC10aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICt0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdW5hcnkgb3BlcmF0b3I6ICcke3RoaXMub3BlcmF0aW9ufSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VW5hcnkodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gMTc5MjUgLyogUHJpbWl0aXZlTGl0ZXJhbCAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShfZiwgX3MsIF9ocywgX2wsIF9jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJpbWl0aXZlTGl0ZXJhbCh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cblByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uLiR1bmRlZmluZWQgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24odm9pZCAwKTtcblByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uLiRudWxsID0gbmV3IFByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uKG51bGwpO1xuUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJHRydWUgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24odHJ1ZSk7XG5QcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbi4kZmFsc2UgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24oZmFsc2UpO1xuUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJGVtcHR5ID0gbmV3IFByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uKCcnKTtcbmV4cG9ydCBjbGFzcyBIdG1sTGl0ZXJhbEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHBhcnRzKSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gNTEgLyogSHRtbExpdGVyYWwgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLnBhcnRzW2ldLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmosIF9wcm9qZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SHRtbExpdGVyYWwodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXJyYXlMaXRlcmFsRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAxNzk1NSAvKiBBcnJheUxpdGVyYWwgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubWFwKGUgPT4gZS5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykpO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlMaXRlcmFsKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuQXJyYXlMaXRlcmFsRXhwcmVzc2lvbi4kZW1wdHkgPSBuZXcgQXJyYXlMaXRlcmFsRXhwcmVzc2lvbihlbXB0eUFycmF5KTtcbmV4cG9ydCBjbGFzcyBPYmplY3RMaXRlcmFsRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAxNzk1NiAvKiBPYmplY3RMaXRlcmFsICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVt0aGlzLmtleXNbaV1dID0gdGhpcy52YWx1ZXNbaV0uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE9iamVjdExpdGVyYWwodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5PYmplY3RMaXRlcmFsRXhwcmVzc2lvbi4kZW1wdHkgPSBuZXcgT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24oZW1wdHlBcnJheSwgZW1wdHlBcnJheSk7XG5leHBvcnQgY2xhc3MgVGVtcGxhdGVFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb29rZWQsIGV4cHJlc3Npb25zID0gZW1wdHlBcnJheSkge1xuICAgICAgICB0aGlzLmNvb2tlZCA9IGNvb2tlZDtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAxNzk1OCAvKiBUZW1wbGF0ZSAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb29rZWRbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5leHByZXNzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZyh0aGlzLmV4cHJlc3Npb25zW2ldLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jb29rZWRbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZW1wbGF0ZSh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cblRlbXBsYXRlRXhwcmVzc2lvbi4kZW1wdHkgPSBuZXcgVGVtcGxhdGVFeHByZXNzaW9uKFsnJ10pO1xuZXhwb3J0IGNsYXNzIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29va2VkLCByYXcsIGZ1bmMsIGV4cHJlc3Npb25zID0gZW1wdHlBcnJheSkge1xuICAgICAgICB0aGlzLmNvb2tlZCA9IGNvb2tlZDtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICBjb29rZWQucmF3ID0gcmF3O1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAxMTk3IC8qIFRhZ2dlZFRlbXBsYXRlICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLmV4cHJlc3Npb25zLm1hcChlID0+IGUuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpKTtcbiAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuZnVuYy5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZWZ0LWhhbmQgc2lkZSBvZiB0YWdnZWQgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyh0aGlzLmNvb2tlZCwgLi4ucmVzdWx0cyk7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdnZWRUZW1wbGF0ZSh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJheUJpbmRpbmdQYXR0ZXJuIHtcbiAgICAvLyBXZSdsbCBlaXRoZXIgaGF2ZSBlbGVtZW50cywgb3Iga2V5cyt2YWx1ZXMsIGJ1dCBuZXZlciBhbGwgM1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gNjU1NTYgLyogQXJyYXlCaW5kaW5nUGF0dGVybiAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShfZiwgX3MsIF9ocywgX2wsIF9jKSB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGNvbWUgYWZ0ZXIgYmF0Y2hcbiAgICAgICAgLy8gYXMgYSBkZXN0cnVjdHVyaW5nIGV4cHJlc3Npb24gbGlrZSBbeCwgeV0gPSB2YWx1ZVxuICAgICAgICAvL1xuICAgICAgICAvLyBzaG91bGQgb25seSB0cmlnZ2VyIGNoYW5nZSBvbmx5IG9uY2U6XG4gICAgICAgIC8vIGJhdGNoKCgpID0+IHtcbiAgICAgICAgLy8gICBvYmplY3QueCA9IHZhbHVlWzBdXG4gICAgICAgIC8vICAgb2JqZWN0LnkgPSB2YWx1ZVsxXVxuICAgICAgICAvLyB9KVxuICAgICAgICAvL1xuICAgICAgICAvLyBpbnN0ZWFkIG9mIHR3aWNlOlxuICAgICAgICAvLyBvYmplY3QueCA9IHZhbHVlWzBdXG4gICAgICAgIC8vIG9iamVjdC55ID0gdmFsdWVbMV1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlCaW5kaW5nUGF0dGVybih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPYmplY3RCaW5kaW5nUGF0dGVybiB7XG4gICAgLy8gV2UnbGwgZWl0aGVyIGhhdmUgZWxlbWVudHMsIG9yIGtleXMrdmFsdWVzLCBidXQgbmV2ZXIgYWxsIDNcbiAgICBjb25zdHJ1Y3RvcihrZXlzLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDY1NTU3IC8qIE9iamVjdEJpbmRpbmdQYXR0ZXJuICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKF9mLCBfcywgX2hzLCBfbCwgX2MpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBzaW1pbGFyIHRvIGFycmF5IGJpbmRpbmcgYXN0LCB0aGlzIHNob3VsZCBvbmx5IGNvbWUgYWZ0ZXIgYmF0Y2hcbiAgICAgICAgLy8gZm9yIGEgc2luZ2xlIG5vdGlmaWNhdGlvbiBwZXIgZGVzdHJ1Y3RpbmcsXG4gICAgICAgIC8vIHJlZ2FyZGxlc3MgbnVtYmVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9uIHRoZSBzY29wZSBiaW5kaW5nIGNvbnRleHRcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0T2JqZWN0QmluZGluZ1BhdHRlcm4odGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmluZGluZ0lkZW50aWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gNjU1NTggLyogQmluZGluZ0lkZW50aWZpZXIgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoX2YsIF9zLCBfaHMsIF9sLCBfYykge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmRpbmdJZGVudGlmaWVyKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuY29uc3QgdG9TdHJpbmdUYWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0aW9uLXN0YXRlbWVudHNcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZvci1pbi1hbmQtZm9yLW9mLXN0YXRlbWVudHNcbmV4cG9ydCBjbGFzcyBGb3JPZlN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZGVjbGFyYXRpb24sIGl0ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA2MTk5IC8qIEZvck9mU3RhdGVtZW50ICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhYmxlLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb3VudChfZiwgcmVzdWx0KSB7XG4gICAgICAgIHN3aXRjaCAodG9TdHJpbmdUYWcuY2FsbChyZXN1bHQpKSB7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBNYXBdJzogcmV0dXJuIHJlc3VsdC5zaXplO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBTZXRdJzogcmV0dXJuIHJlc3VsdC5zaXplO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzogcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOiByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgVW5kZWZpbmVkXSc6IHJldHVybiAwO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY291bnQgJHt0b1N0cmluZ1RhZy5jYWxsKHJlc3VsdCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpdGVyYXRlKGYsIHJlc3VsdCwgZnVuYykge1xuICAgICAgICBzd2l0Y2ggKHRvU3RyaW5nVGFnLmNhbGwocmVzdWx0KSkge1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJGFycmF5KHJlc3VsdCwgZnVuYyk7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE1hcF0nOiByZXR1cm4gJG1hcChyZXN1bHQsIGZ1bmMpO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBTZXRdJzogcmV0dXJuICRzZXQocmVzdWx0LCBmdW5jKTtcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6IHJldHVybiAkbnVtYmVyKHJlc3VsdCwgZnVuYyk7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE51bGxdJzogcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBVbmRlZmluZWRdJzogcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaXRlcmF0ZSBvdmVyICR7dG9TdHJpbmdUYWcuY2FsbChyZXN1bHQpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmQoZiwgcywgaHMsIGIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlcmFibGUuaGFzQmluZCkge1xuICAgICAgICAgICAgdGhpcy5pdGVyYWJsZS5iaW5kKGYsIHMsIGhzLCBiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmJpbmQoZiwgcywgaHMsIGIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlcmFibGUuaGFzVW5iaW5kKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJhYmxlLnVuYmluZChmLCBzLCBocywgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGb3JPZlN0YXRlbWVudCh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbi8qXG4qIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gaXMgZmFyIHNpbXBsZXIgdGhhbiB0aGUgb25lIGluIHZDdXJyZW50IGFuZCBtaWdodCBiZSBtaXNzaW5nIGltcG9ydGFudCBzdHVmZiAobm90IHN1cmUgeWV0KVxuKiBzbyB3aGlsZSB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGlkZW50aWNhbCB0byBUZW1wbGF0ZSBhbmQgd2UgY291bGQgcmV1c2UgdGhhdCBvbmUsIHdlIGRvbid0IHdhbnQgdG8gbG9jayBvdXRzZWx2ZXMgaW4gdG8gcG90ZW50aWFsbHkgdGhlIHdyb25nIGFic3RyYWN0aW9uXG4qIGJ1dCB0aGlzIGNsYXNzIG1pZ2h0IGJlIGEgY2FuZGlkYXRlIGZvciByZW1vdmFsIGlmIGl0IHR1cm5zIG91dCBpdCBkb2VzIHByb3ZpZGUgYWxsIHdlIG5lZWRcbiovXG5leHBvcnQgY2xhc3MgSW50ZXJwb2xhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFydHMsIGV4cHJlc3Npb25zID0gZW1wdHlBcnJheSkge1xuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5pc011bHRpID0gZXhwcmVzc2lvbnMubGVuZ3RoID4gMTtcbiAgICAgICAgdGhpcy5maXJzdEV4cHJlc3Npb24gPSBleHByZXNzaW9uc1swXTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gMjQgLyogSW50ZXJwb2xhdGlvbiAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBpZiAodGhpcy5pc011bHRpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJ0c1swXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5leHByZXNzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcodGhpcy5leHByZXNzaW9uc1tpXS5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wYXJ0c1swXX0ke3RoaXMuZmlyc3RFeHByZXNzaW9uLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKX0ke3RoaXMucGFydHNbMV19YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW50ZXJwb2xhdGlvbih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uKGYsIG9iaiwgbmFtZSkge1xuICAgIGNvbnN0IGZ1bmMgPSBvYmogPT0gbnVsbCA/IG51bGwgOiBvYmpbbmFtZV07XG4gICAgaWYgKHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICBpZiAoIShmICYgMTI4IC8qIG11c3RFdmFsdWF0ZSAqLykgJiYgZnVuYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICcke25hbWV9JyB0byBiZSBhIGZ1bmN0aW9uYCk7XG59XG5mdW5jdGlvbiAkYXJyYXkocmVzdWx0LCBmdW5jKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgZnVuYyhyZXN1bHQsIGksIHJlc3VsdFtpXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gJG1hcChyZXN1bHQsIGZ1bmMpIHtcbiAgICBjb25zdCBhcnIgPSBBcnJheShyZXN1bHQuc2l6ZSk7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJlc3VsdC5lbnRyaWVzKCkpIHtcbiAgICAgICAgYXJyWysraV0gPSBlbnRyeTtcbiAgICB9XG4gICAgJGFycmF5KGFyciwgZnVuYyk7XG59XG5mdW5jdGlvbiAkc2V0KHJlc3VsdCwgZnVuYykge1xuICAgIGNvbnN0IGFyciA9IEFycmF5KHJlc3VsdC5zaXplKTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHJlc3VsdC5rZXlzKCkpIHtcbiAgICAgICAgYXJyWysraV0gPSBrZXk7XG4gICAgfVxuICAgICRhcnJheShhcnIsIGZ1bmMpO1xufVxuZnVuY3Rpb24gJG51bWJlcihyZXN1bHQsIGZ1bmMpIHtcbiAgICBjb25zdCBhcnIgPSBBcnJheShyZXN1bHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0OyArK2kpIHtcbiAgICAgICAgYXJyW2ldID0gaTtcbiAgICB9XG4gICAgJGFycmF5KGFyciwgZnVuYyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QuanMubWFwIiwiaW1wb3J0IHsgZGVmLCBkZWZpbmVIaWRkZW5Qcm9wLCBlbnN1cmVQcm90byB9IGZyb20gJy4uL3V0aWxpdGllcy1vYmplY3RzLmpzJztcbmltcG9ydCB7IGdldEFycmF5T2JzZXJ2ZXIgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi9hcnJheS1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBnZXRTZXRPYnNlcnZlciB9IGZyb20gJy4uL29ic2VydmF0aW9uL3NldC1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBnZXRNYXBPYnNlcnZlciB9IGZyb20gJy4uL29ic2VydmF0aW9uL21hcC1vYnNlcnZlci5qcyc7XG4vLyBUT0RPOiBhZGQgY29ubmVjdC1xdWV1ZSAob3Igc29tZXRoaW5nIHNpbWlsYXIpIGJhY2sgaW4gd2hlbiBldmVyeXRoaW5nIGVsc2UgaXMgd29ya2luZywgdG8gaW1wcm92ZSBzdGFydHVwIHRpbWVcbmNvbnN0IHNsb3ROYW1lcyA9IFtdO1xuY29uc3QgdmVyc2lvblNsb3ROYW1lcyA9IFtdO1xubGV0IGxhc3RTbG90ID0gLTE7XG5mdW5jdGlvbiBlbnN1cmVFbm91Z2hTbG90TmFtZXMoY3VycmVudFNsb3QpIHtcbiAgICBpZiAoY3VycmVudFNsb3QgPT09IGxhc3RTbG90KSB7XG4gICAgICAgIGxhc3RTbG90ICs9IDU7XG4gICAgICAgIGNvbnN0IGlpID0gc2xvdE5hbWVzLmxlbmd0aCA9IHZlcnNpb25TbG90TmFtZXMubGVuZ3RoID0gbGFzdFNsb3QgKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gY3VycmVudFNsb3QgKyAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgc2xvdE5hbWVzW2ldID0gYF9vJHtpfWA7XG4gICAgICAgICAgICB2ZXJzaW9uU2xvdE5hbWVzW2ldID0gYF92JHtpfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5lbnN1cmVFbm91Z2hTbG90TmFtZXMoLTEpO1xuZnVuY3Rpb24gb2JzZXJ2ZVByb3BlcnR5KG9iaiwga2V5KSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyTG9jYXRvci5nZXRPYnNlcnZlcihvYmosIGtleSk7XG4gICAgLyogTm90ZTogd2UgbmVlZCB0byBjYXN0IGhlcmUgYmVjYXVzZSB3ZSBjYW4gaW5kZWVkIGdldCBhbiBhY2Nlc3NvciBpbnN0ZWFkIG9mIGFuIG9ic2VydmVyLFxuICAgICAqICBpbiB3aGljaCBjYXNlIHRoZSBjYWxsIHRvIG9ic2VydmVyLnN1YnNjcmliZSB3aWxsIHRocm93LiBJdCdzIG5vdCB2ZXJ5IGNsZWFuIGFuZCB3ZSBjYW4gc29sdmUgdGhpcyBpbiAyIHdheXM6XG4gICAgICogIDEuIEZhaWwgZWFybGllcjogb25seSBsZXQgdGhlIGxvY2F0b3IgcmVzb2x2ZSBvYnNlcnZlcnMgZnJvbSAuZ2V0T2JzZXJ2ZXIsIGFuZCB0aHJvdyBpZiBubyBicmFuY2hlcyBhcmUgbGVmdCAoZS5nLiBpdCB3b3VsZCBvdGhlcndpc2UgcmV0dXJuIGFuIGFjY2Vzc29yKVxuICAgICAqICAyLiBGYWlsIHNpbGVudGx5ICh3aXRob3V0IHRocm93aW5nKTogZ2l2ZSBhbGwgYWNjZXNzb3JzIGEgbm8tb3Agc3Vic2NyaWJlIG1ldGhvZFxuICAgICAqXG4gICAgICogV2UnbGwgcHJvYmFibHkgd2FudCB0byBpbXBsZW1lbnQgc29tZSBnbG9iYWwgY29uZmlndXJhdGlvbiAobGlrZSBhIFwic3RyaWN0XCIgdG9nZ2xlKSBzbyB1c2VycyBjYW4gcGljayBiZXR3ZWVuIGVuZm9yY2VkIGNvcnJlY3RuZXNzIHZzLiBlYXNlLW9mLXVzZVxuICAgICAqL1xuICAgIHRoaXMub2JzLmFkZChvYnNlcnZlcik7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlclJlY29yZCgpIHtcbiAgICBjb25zdCByZWNvcmQgPSBuZXcgQmluZGluZ09ic2VydmVyUmVjb3JkKHRoaXMpO1xuICAgIGRlZmluZUhpZGRlblByb3AodGhpcywgJ29icycsIHJlY29yZCk7XG4gICAgcmV0dXJuIHJlY29yZDtcbn1cbmZ1bmN0aW9uIG9ic2VydmVDb2xsZWN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgb2JzO1xuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgb2JzID0gZ2V0QXJyYXlPYnNlcnZlcihjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBvYnMgPSBnZXRTZXRPYnNlcnZlcihjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYnMgPSBnZXRNYXBPYnNlcnZlcihjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pc2VkIGNvbGxlY3Rpb24gdHlwZS4nKTtcbiAgICB9XG4gICAgdGhpcy5vYnMuYWRkKG9icyk7XG59XG5mdW5jdGlvbiBub29wSGFuZGxlQ2hhbmdlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIFwiaGFuZGxlQ2hhbmdlXCIgbm90IGltcGxlbWVudGVkJyk7XG59XG5mdW5jdGlvbiBub29wSGFuZGxlQ29sbGVjdGlvbkNoYW5nZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBcImhhbmRsZUNvbGxlY3Rpb25DaGFuZ2VcIiBub3QgaW1wbGVtZW50ZWQnKTtcbn1cbmV4cG9ydCBjbGFzcyBCaW5kaW5nT2JzZXJ2ZXJSZWNvcmQge1xuICAgIGNvbnN0cnVjdG9yKGJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nID0gYmluZGluZztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIGNvbm5lY3RhYmxlLmFzc2lnbklkVG8odGhpcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh2YWx1ZSwgb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcuaW50ZXJjZXB0b3IuaGFuZGxlQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSwgZmxhZ3MpO1xuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncykge1xuICAgICAgICB0aGlzLmJpbmRpbmcuaW50ZXJjZXB0b3IuaGFuZGxlQ29sbGVjdGlvbkNoYW5nZShpbmRleE1hcCwgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQsIGFuZCBzdWJzY3JpYmUgdG8gYSBnaXZlbiBvYnNlcnZlclxuICAgICAqL1xuICAgIGFkZChvYnNlcnZlcikge1xuICAgICAgICAvLyBmaW5kIHRoZSBvYnNlcnZlci5cbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJTbG90cyA9IHRoaXMuY291bnQgPT0gbnVsbCA/IDAgOiB0aGlzLmNvdW50O1xuICAgICAgICBsZXQgaSA9IG9ic2VydmVyU2xvdHM7XG4gICAgICAgIHdoaWxlIChpLS0gJiYgdGhpc1tzbG90TmFtZXNbaV1dICE9PSBvYnNlcnZlcilcbiAgICAgICAgICAgIDtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBhbHJlYWR5IG9ic2VydmluZywgcHV0IHRoZSBvYnNlcnZlciBpbiBhbiBvcGVuIHNsb3QgYW5kIHN1YnNjcmliZS5cbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzW3Nsb3ROYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW3Nsb3ROYW1lc1tpXV0gPSBvYnNlcnZlcjtcbiAgICAgICAgICAgIG9ic2VydmVyLnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgIG9ic2VydmVyW3RoaXMuaWRdIHw9IDggLyogdXBkYXRlVGFyZ2V0ICovO1xuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBzbG90IGNvdW50LlxuICAgICAgICAgICAgaWYgKGkgPT09IG9ic2VydmVyU2xvdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1t2ZXJzaW9uU2xvdE5hbWVzW2ldXSA9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgZW5zdXJlRW5vdWdoU2xvdE5hbWVzKGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSB0aGUgb2JzZXJ2ZXJzIHRoYXQgYXJlIG5vdCB1cCB0byBkYXRlIHdpdGggdGhlIHJlY29yZCB2ZXJzaW9uXG4gICAgICovXG4gICAgY2xlYXIoYWxsKSB7XG4gICAgICAgIGNvbnN0IHNsb3RDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGxldCBzbG90TmFtZTtcbiAgICAgICAgbGV0IG9ic2VydmVyO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGlmIChhbGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgc2xvdENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICBzbG90TmFtZSA9IHNsb3ROYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlciA9IHRoaXNbc2xvdE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc2xvdE5hbWVdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci51bnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJbdGhpcy5pZF0gJj0gfjggLyogdXBkYXRlVGFyZ2V0ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBzbG90Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW3ZlcnNpb25TbG90TmFtZXNbaV1dICE9PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBzbG90TmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyID0gdGhpc1tzbG90TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Nsb3ROYW1lXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJbdGhpcy5pZF0gJj0gfjggLyogdXBkYXRlVGFyZ2V0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29ubmVjdGFibGVEZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgY29uc3QgcHJvdG8gPSB0YXJnZXQucHJvdG90eXBlO1xuICAgIGVuc3VyZVByb3RvKHByb3RvLCAnb2JzZXJ2ZVByb3BlcnR5Jywgb2JzZXJ2ZVByb3BlcnR5LCB0cnVlKTtcbiAgICBlbnN1cmVQcm90byhwcm90bywgJ29ic2VydmVDb2xsZWN0aW9uJywgb2JzZXJ2ZUNvbGxlY3Rpb24sIHRydWUpO1xuICAgIGRlZihwcm90bywgJ29icycsIHsgZ2V0OiBnZXRPYnNlcnZlclJlY29yZCB9KTtcbiAgICAvLyBvcHRpb25hbGx5IGFkZCB0aGVzZSB0d28gbWV0aG9kcyB0byBub3JtYWxpemUgYSBjb25uZWN0YWJsZSBpbXBsXG4gICAgZW5zdXJlUHJvdG8ocHJvdG8sICdoYW5kbGVDaGFuZ2UnLCBub29wSGFuZGxlQ2hhbmdlKTtcbiAgICBlbnN1cmVQcm90byhwcm90bywgJ2hhbmRsZUNvbGxlY3Rpb25DaGFuZ2UnLCBub29wSGFuZGxlQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25uZWN0YWJsZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ID09IG51bGwgPyBjb25uZWN0YWJsZURlY29yYXRvciA6IGNvbm5lY3RhYmxlRGVjb3JhdG9yKHRhcmdldCk7XG59XG5sZXQgaWRWYWx1ZSA9IDA7XG5jb25uZWN0YWJsZS5hc3NpZ25JZFRvID0gKGluc3RhbmNlKSA9PiB7XG4gICAgaW5zdGFuY2UuaWQgPSArK2lkVmFsdWU7XG59O1xuLy8gQGNvbm5lY3RhYmxlXG5leHBvcnQgY2xhc3MgQmluZGluZ01lZGlhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGJpbmRpbmcsIG9ic2VydmVyTG9jYXRvciwgbG9jYXRvcikge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5iaW5kaW5nID0gYmluZGluZztcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICBjb25uZWN0YWJsZS5hc3NpZ25JZFRvKHRoaXMpO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgcHJvamVjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1t0aGlzLmtleV0obmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKTtcbiAgICB9XG59XG5jb25uZWN0YWJsZURlY29yYXRvcihCaW5kaW5nTWVkaWF0b3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGFibGUuanMubWFwIiwiaW1wb3J0IHsgREksIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEFjY2Vzc0tleWVkRXhwcmVzc2lvbiwgQWNjZXNzTWVtYmVyRXhwcmVzc2lvbiwgQWNjZXNzU2NvcGVFeHByZXNzaW9uLCBBY2Nlc3NUaGlzRXhwcmVzc2lvbiwgQXJyYXlCaW5kaW5nUGF0dGVybiwgQXJyYXlMaXRlcmFsRXhwcmVzc2lvbiwgQXNzaWduRXhwcmVzc2lvbiwgQmluYXJ5RXhwcmVzc2lvbiwgQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbiwgQmluZGluZ0lkZW50aWZpZXIsIENhbGxGdW5jdGlvbkV4cHJlc3Npb24sIENhbGxNZW1iZXJFeHByZXNzaW9uLCBDYWxsU2NvcGVFeHByZXNzaW9uLCBDb25kaXRpb25hbEV4cHJlc3Npb24sIEN1c3RvbUV4cHJlc3Npb24sIEZvck9mU3RhdGVtZW50LCBJbnRlcnBvbGF0aW9uLCBPYmplY3RCaW5kaW5nUGF0dGVybiwgT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24sIFByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uLCBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24sIFRlbXBsYXRlRXhwcmVzc2lvbiwgVW5hcnlFeHByZXNzaW9uLCBWYWx1ZUNvbnZlcnRlckV4cHJlc3Npb24sIH0gZnJvbSAnLi9hc3QuanMnO1xuZXhwb3J0IGNvbnN0IElFeHByZXNzaW9uUGFyc2VyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJRXhwcmVzc2lvblBhcnNlcicsIHggPT4geC5zaW5nbGV0b24oRXhwcmVzc2lvblBhcnNlcikpO1xuZXhwb3J0IGNsYXNzIEV4cHJlc3Npb25QYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25Mb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmZvck9mTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgcGFyc2UoZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUpIHtcbiAgICAgICAgc3dpdGNoIChiaW5kaW5nVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAyMDQ4IC8qIEludGVycG9sYXRpb24gKi86IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmludGVycG9sYXRpb25Mb29rdXBbZXhwcmVzc2lvbl07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmludGVycG9sYXRpb25Mb29rdXBbZXhwcmVzc2lvbl0gPSB0aGlzLiRwYXJzZShleHByZXNzaW9uLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNTM5IC8qIEZvckNvbW1hbmQgKi86IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZvck9mTG9va3VwW2V4cHJlc3Npb25dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5mb3JPZkxvb2t1cFtleHByZXNzaW9uXSA9IHRoaXMuJHBhcnNlKGV4cHJlc3Npb24sIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IGVtcHR5IHN0cmluZ3MgZm9yIG5vcm1hbCBiaW5kaW5ncyBhbmQgdGhvc2UgdGhhdCBhcmUgZW1wdHkgYnkgZGVmYXVsdCAoc3VjaCBhcyBhIGN1c3RvbSBhdHRyaWJ1dGUgd2l0aG91dCBhbiBlcXVhbHMgc2lnbilcbiAgICAgICAgICAgICAgICAvLyBCdXQgZG9uJ3QgY2FjaGUgaXQsIGJlY2F1c2UgZW1wdHkgc3RyaW5ncyBhcmUgYWx3YXlzIGludmFsaWQgZm9yIGFueSBvdGhlciB0eXBlIG9mIGJpbmRpbmdcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDAgJiYgKGJpbmRpbmdUeXBlICYgKDUzIC8qIEJpbmRDb21tYW5kICovIHwgNDkgLyogT25lVGltZUNvbW1hbmQgKi8gfCA1MCAvKiBUb1ZpZXdDb21tYW5kICovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uLiRlbXB0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5leHByZXNzaW9uTG9va3VwW2V4cHJlc3Npb25dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5leHByZXNzaW9uTG9va3VwW2V4cHJlc3Npb25dID0gdGhpcy4kcGFyc2UoZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgJHBhcnNlKGV4cHJlc3Npb24sIGJpbmRpbmdUeXBlKSB7XG4gICAgICAgICRzdGF0ZS5pbnB1dCA9IGV4cHJlc3Npb247XG4gICAgICAgICRzdGF0ZS5sZW5ndGggPSBleHByZXNzaW9uLmxlbmd0aDtcbiAgICAgICAgJHN0YXRlLmluZGV4ID0gMDtcbiAgICAgICAgJHN0YXRlLmN1cnJlbnRDaGFyID0gZXhwcmVzc2lvbi5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gcGFyc2UoJHN0YXRlLCAwIC8qIFJlc2V0ICovLCA2MSAvKiBWYXJpYWRpYyAqLywgYmluZGluZ1R5cGUgPT09IHZvaWQgMCA/IDUzIC8qIEJpbmRDb21tYW5kICovIDogYmluZGluZ1R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgQ2hhcjtcbihmdW5jdGlvbiAoQ2hhcikge1xuICAgIENoYXJbQ2hhcltcIk51bGxcIl0gPSAwXSA9IFwiTnVsbFwiO1xuICAgIENoYXJbQ2hhcltcIkJhY2tzcGFjZVwiXSA9IDhdID0gXCJCYWNrc3BhY2VcIjtcbiAgICBDaGFyW0NoYXJbXCJUYWJcIl0gPSA5XSA9IFwiVGFiXCI7XG4gICAgQ2hhcltDaGFyW1wiTGluZUZlZWRcIl0gPSAxMF0gPSBcIkxpbmVGZWVkXCI7XG4gICAgQ2hhcltDaGFyW1wiVmVydGljYWxUYWJcIl0gPSAxMV0gPSBcIlZlcnRpY2FsVGFiXCI7XG4gICAgQ2hhcltDaGFyW1wiRm9ybUZlZWRcIl0gPSAxMl0gPSBcIkZvcm1GZWVkXCI7XG4gICAgQ2hhcltDaGFyW1wiQ2FycmlhZ2VSZXR1cm5cIl0gPSAxM10gPSBcIkNhcnJpYWdlUmV0dXJuXCI7XG4gICAgQ2hhcltDaGFyW1wiU3BhY2VcIl0gPSAzMl0gPSBcIlNwYWNlXCI7XG4gICAgQ2hhcltDaGFyW1wiRXhjbGFtYXRpb25cIl0gPSAzM10gPSBcIkV4Y2xhbWF0aW9uXCI7XG4gICAgQ2hhcltDaGFyW1wiRG91YmxlUXVvdGVcIl0gPSAzNF0gPSBcIkRvdWJsZVF1b3RlXCI7XG4gICAgQ2hhcltDaGFyW1wiRG9sbGFyXCJdID0gMzZdID0gXCJEb2xsYXJcIjtcbiAgICBDaGFyW0NoYXJbXCJQZXJjZW50XCJdID0gMzddID0gXCJQZXJjZW50XCI7XG4gICAgQ2hhcltDaGFyW1wiQW1wZXJzYW5kXCJdID0gMzhdID0gXCJBbXBlcnNhbmRcIjtcbiAgICBDaGFyW0NoYXJbXCJTaW5nbGVRdW90ZVwiXSA9IDM5XSA9IFwiU2luZ2xlUXVvdGVcIjtcbiAgICBDaGFyW0NoYXJbXCJPcGVuUGFyZW5cIl0gPSA0MF0gPSBcIk9wZW5QYXJlblwiO1xuICAgIENoYXJbQ2hhcltcIkNsb3NlUGFyZW5cIl0gPSA0MV0gPSBcIkNsb3NlUGFyZW5cIjtcbiAgICBDaGFyW0NoYXJbXCJBc3Rlcmlza1wiXSA9IDQyXSA9IFwiQXN0ZXJpc2tcIjtcbiAgICBDaGFyW0NoYXJbXCJQbHVzXCJdID0gNDNdID0gXCJQbHVzXCI7XG4gICAgQ2hhcltDaGFyW1wiQ29tbWFcIl0gPSA0NF0gPSBcIkNvbW1hXCI7XG4gICAgQ2hhcltDaGFyW1wiTWludXNcIl0gPSA0NV0gPSBcIk1pbnVzXCI7XG4gICAgQ2hhcltDaGFyW1wiRG90XCJdID0gNDZdID0gXCJEb3RcIjtcbiAgICBDaGFyW0NoYXJbXCJTbGFzaFwiXSA9IDQ3XSA9IFwiU2xhc2hcIjtcbiAgICBDaGFyW0NoYXJbXCJTZW1pY29sb25cIl0gPSA1OV0gPSBcIlNlbWljb2xvblwiO1xuICAgIENoYXJbQ2hhcltcIkJhY2t0aWNrXCJdID0gOTZdID0gXCJCYWNrdGlja1wiO1xuICAgIENoYXJbQ2hhcltcIk9wZW5CcmFja2V0XCJdID0gOTFdID0gXCJPcGVuQnJhY2tldFwiO1xuICAgIENoYXJbQ2hhcltcIkJhY2tzbGFzaFwiXSA9IDkyXSA9IFwiQmFja3NsYXNoXCI7XG4gICAgQ2hhcltDaGFyW1wiQ2xvc2VCcmFja2V0XCJdID0gOTNdID0gXCJDbG9zZUJyYWNrZXRcIjtcbiAgICBDaGFyW0NoYXJbXCJDYXJldFwiXSA9IDk0XSA9IFwiQ2FyZXRcIjtcbiAgICBDaGFyW0NoYXJbXCJVbmRlcnNjb3JlXCJdID0gOTVdID0gXCJVbmRlcnNjb3JlXCI7XG4gICAgQ2hhcltDaGFyW1wiT3BlbkJyYWNlXCJdID0gMTIzXSA9IFwiT3BlbkJyYWNlXCI7XG4gICAgQ2hhcltDaGFyW1wiQmFyXCJdID0gMTI0XSA9IFwiQmFyXCI7XG4gICAgQ2hhcltDaGFyW1wiQ2xvc2VCcmFjZVwiXSA9IDEyNV0gPSBcIkNsb3NlQnJhY2VcIjtcbiAgICBDaGFyW0NoYXJbXCJDb2xvblwiXSA9IDU4XSA9IFwiQ29sb25cIjtcbiAgICBDaGFyW0NoYXJbXCJMZXNzVGhhblwiXSA9IDYwXSA9IFwiTGVzc1RoYW5cIjtcbiAgICBDaGFyW0NoYXJbXCJFcXVhbHNcIl0gPSA2MV0gPSBcIkVxdWFsc1wiO1xuICAgIENoYXJbQ2hhcltcIkdyZWF0ZXJUaGFuXCJdID0gNjJdID0gXCJHcmVhdGVyVGhhblwiO1xuICAgIENoYXJbQ2hhcltcIlF1ZXN0aW9uXCJdID0gNjNdID0gXCJRdWVzdGlvblwiO1xuICAgIENoYXJbQ2hhcltcIlplcm9cIl0gPSA0OF0gPSBcIlplcm9cIjtcbiAgICBDaGFyW0NoYXJbXCJPbmVcIl0gPSA0OV0gPSBcIk9uZVwiO1xuICAgIENoYXJbQ2hhcltcIlR3b1wiXSA9IDUwXSA9IFwiVHdvXCI7XG4gICAgQ2hhcltDaGFyW1wiVGhyZWVcIl0gPSA1MV0gPSBcIlRocmVlXCI7XG4gICAgQ2hhcltDaGFyW1wiRm91clwiXSA9IDUyXSA9IFwiRm91clwiO1xuICAgIENoYXJbQ2hhcltcIkZpdmVcIl0gPSA1M10gPSBcIkZpdmVcIjtcbiAgICBDaGFyW0NoYXJbXCJTaXhcIl0gPSA1NF0gPSBcIlNpeFwiO1xuICAgIENoYXJbQ2hhcltcIlNldmVuXCJdID0gNTVdID0gXCJTZXZlblwiO1xuICAgIENoYXJbQ2hhcltcIkVpZ2h0XCJdID0gNTZdID0gXCJFaWdodFwiO1xuICAgIENoYXJbQ2hhcltcIk5pbmVcIl0gPSA1N10gPSBcIk5pbmVcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlckFcIl0gPSA2NV0gPSBcIlVwcGVyQVwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyQlwiXSA9IDY2XSA9IFwiVXBwZXJCXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJDXCJdID0gNjddID0gXCJVcHBlckNcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlckRcIl0gPSA2OF0gPSBcIlVwcGVyRFwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyRVwiXSA9IDY5XSA9IFwiVXBwZXJFXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJGXCJdID0gNzBdID0gXCJVcHBlckZcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlckdcIl0gPSA3MV0gPSBcIlVwcGVyR1wiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVySFwiXSA9IDcyXSA9IFwiVXBwZXJIXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJJXCJdID0gNzNdID0gXCJVcHBlcklcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlckpcIl0gPSA3NF0gPSBcIlVwcGVySlwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyS1wiXSA9IDc1XSA9IFwiVXBwZXJLXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJMXCJdID0gNzZdID0gXCJVcHBlckxcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlck1cIl0gPSA3N10gPSBcIlVwcGVyTVwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyTlwiXSA9IDc4XSA9IFwiVXBwZXJOXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJPXCJdID0gNzldID0gXCJVcHBlck9cIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlclBcIl0gPSA4MF0gPSBcIlVwcGVyUFwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyUVwiXSA9IDgxXSA9IFwiVXBwZXJRXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJSXCJdID0gODJdID0gXCJVcHBlclJcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlclNcIl0gPSA4M10gPSBcIlVwcGVyU1wiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyVFwiXSA9IDg0XSA9IFwiVXBwZXJUXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJVXCJdID0gODVdID0gXCJVcHBlclVcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlclZcIl0gPSA4Nl0gPSBcIlVwcGVyVlwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyV1wiXSA9IDg3XSA9IFwiVXBwZXJXXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJYXCJdID0gODhdID0gXCJVcHBlclhcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlcllcIl0gPSA4OV0gPSBcIlVwcGVyWVwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyWlwiXSA9IDkwXSA9IFwiVXBwZXJaXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJBXCJdID0gOTddID0gXCJMb3dlckFcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckJcIl0gPSA5OF0gPSBcIkxvd2VyQlwiO1xuICAgIENoYXJbQ2hhcltcIkxvd2VyQ1wiXSA9IDk5XSA9IFwiTG93ZXJDXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJEXCJdID0gMTAwXSA9IFwiTG93ZXJEXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJFXCJdID0gMTAxXSA9IFwiTG93ZXJFXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJGXCJdID0gMTAyXSA9IFwiTG93ZXJGXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJHXCJdID0gMTAzXSA9IFwiTG93ZXJHXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJIXCJdID0gMTA0XSA9IFwiTG93ZXJIXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJJXCJdID0gMTA1XSA9IFwiTG93ZXJJXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJKXCJdID0gMTA2XSA9IFwiTG93ZXJKXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJLXCJdID0gMTA3XSA9IFwiTG93ZXJLXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJMXCJdID0gMTA4XSA9IFwiTG93ZXJMXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJNXCJdID0gMTA5XSA9IFwiTG93ZXJNXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJOXCJdID0gMTEwXSA9IFwiTG93ZXJOXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJPXCJdID0gMTExXSA9IFwiTG93ZXJPXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJQXCJdID0gMTEyXSA9IFwiTG93ZXJQXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJRXCJdID0gMTEzXSA9IFwiTG93ZXJRXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJSXCJdID0gMTE0XSA9IFwiTG93ZXJSXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJTXCJdID0gMTE1XSA9IFwiTG93ZXJTXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJUXCJdID0gMTE2XSA9IFwiTG93ZXJUXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJVXCJdID0gMTE3XSA9IFwiTG93ZXJVXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJWXCJdID0gMTE4XSA9IFwiTG93ZXJWXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJXXCJdID0gMTE5XSA9IFwiTG93ZXJXXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJYXCJdID0gMTIwXSA9IFwiTG93ZXJYXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJZXCJdID0gMTIxXSA9IFwiTG93ZXJZXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJaXCJdID0gMTIyXSA9IFwiTG93ZXJaXCI7XG59KShDaGFyIHx8IChDaGFyID0ge30pKTtcbmZ1bmN0aW9uIHVuZXNjYXBlQ29kZShjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgOTggLyogTG93ZXJCICovOiByZXR1cm4gOCAvKiBCYWNrc3BhY2UgKi87XG4gICAgICAgIGNhc2UgMTE2IC8qIExvd2VyVCAqLzogcmV0dXJuIDkgLyogVGFiICovO1xuICAgICAgICBjYXNlIDExMCAvKiBMb3dlck4gKi86IHJldHVybiAxMCAvKiBMaW5lRmVlZCAqLztcbiAgICAgICAgY2FzZSAxMTggLyogTG93ZXJWICovOiByZXR1cm4gMTEgLyogVmVydGljYWxUYWIgKi87XG4gICAgICAgIGNhc2UgMTAyIC8qIExvd2VyRiAqLzogcmV0dXJuIDEyIC8qIEZvcm1GZWVkICovO1xuICAgICAgICBjYXNlIDExNCAvKiBMb3dlclIgKi86IHJldHVybiAxMyAvKiBDYXJyaWFnZVJldHVybiAqLztcbiAgICAgICAgY2FzZSAzNCAvKiBEb3VibGVRdW90ZSAqLzogcmV0dXJuIDM0IC8qIERvdWJsZVF1b3RlICovO1xuICAgICAgICBjYXNlIDM5IC8qIFNpbmdsZVF1b3RlICovOiByZXR1cm4gMzkgLyogU2luZ2xlUXVvdGUgKi87XG4gICAgICAgIGNhc2UgOTIgLyogQmFja3NsYXNoICovOiByZXR1cm4gOTIgLyogQmFja3NsYXNoICovO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gY29kZTtcbiAgICB9XG59XG5leHBvcnQgdmFyIEFjY2VzcztcbihmdW5jdGlvbiAoQWNjZXNzKSB7XG4gICAgQWNjZXNzW0FjY2Vzc1tcIlJlc2V0XCJdID0gMF0gPSBcIlJlc2V0XCI7XG4gICAgQWNjZXNzW0FjY2Vzc1tcIkFuY2VzdG9yXCJdID0gNTExXSA9IFwiQW5jZXN0b3JcIjtcbiAgICBBY2Nlc3NbQWNjZXNzW1wiVGhpc1wiXSA9IDUxMl0gPSBcIlRoaXNcIjtcbiAgICBBY2Nlc3NbQWNjZXNzW1wiU2NvcGVcIl0gPSAxMDI0XSA9IFwiU2NvcGVcIjtcbiAgICBBY2Nlc3NbQWNjZXNzW1wiTWVtYmVyXCJdID0gMjA0OF0gPSBcIk1lbWJlclwiO1xuICAgIEFjY2Vzc1tBY2Nlc3NbXCJLZXllZFwiXSA9IDQwOTZdID0gXCJLZXllZFwiO1xufSkoQWNjZXNzIHx8IChBY2Nlc3MgPSB7fSkpO1xuZXhwb3J0IHZhciBQcmVjZWRlbmNlO1xuKGZ1bmN0aW9uIChQcmVjZWRlbmNlKSB7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiVmFyaWFkaWNcIl0gPSA2MV0gPSBcIlZhcmlhZGljXCI7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiQXNzaWduXCJdID0gNjJdID0gXCJBc3NpZ25cIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJDb25kaXRpb25hbFwiXSA9IDYzXSA9IFwiQ29uZGl0aW9uYWxcIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJMb2dpY2FsT1JcIl0gPSA2NF0gPSBcIkxvZ2ljYWxPUlwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIkxvZ2ljYWxBTkRcIl0gPSAxMjhdID0gXCJMb2dpY2FsQU5EXCI7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiRXF1YWxpdHlcIl0gPSAxOTJdID0gXCJFcXVhbGl0eVwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIlJlbGF0aW9uYWxcIl0gPSAyNTZdID0gXCJSZWxhdGlvbmFsXCI7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiQWRkaXRpdmVcIl0gPSAzMjBdID0gXCJBZGRpdGl2ZVwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIk11bHRpcGxpY2F0aXZlXCJdID0gMzg0XSA9IFwiTXVsdGlwbGljYXRpdmVcIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJCaW5hcnlcIl0gPSA0NDhdID0gXCJCaW5hcnlcIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJMZWZ0SGFuZFNpZGVcIl0gPSA0NDldID0gXCJMZWZ0SGFuZFNpZGVcIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJQcmltYXJ5XCJdID0gNDUwXSA9IFwiUHJpbWFyeVwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIlVuYXJ5XCJdID0gNDUxXSA9IFwiVW5hcnlcIjtcbn0pKFByZWNlZGVuY2UgfHwgKFByZWNlZGVuY2UgPSB7fSkpO1xudmFyIFRva2VuO1xuKGZ1bmN0aW9uIChUb2tlbikge1xuICAgIFRva2VuW1Rva2VuW1wiRU9GXCJdID0gMTU3Mjg2NF0gPSBcIkVPRlwiO1xuICAgIFRva2VuW1Rva2VuW1wiRXhwcmVzc2lvblRlcm1pbmFsXCJdID0gMTA0ODU3Nl0gPSBcIkV4cHJlc3Npb25UZXJtaW5hbFwiO1xuICAgIFRva2VuW1Rva2VuW1wiQWNjZXNzU2NvcGVUZXJtaW5hbFwiXSA9IDUyNDI4OF0gPSBcIkFjY2Vzc1Njb3BlVGVybWluYWxcIjtcbiAgICBUb2tlbltUb2tlbltcIkNsb3NpbmdUb2tlblwiXSA9IDI2MjE0NF0gPSBcIkNsb3NpbmdUb2tlblwiO1xuICAgIFRva2VuW1Rva2VuW1wiT3BlbmluZ1Rva2VuXCJdID0gMTMxMDcyXSA9IFwiT3BlbmluZ1Rva2VuXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJCaW5hcnlPcFwiXSA9IDY1NTM2XSA9IFwiQmluYXJ5T3BcIjtcbiAgICBUb2tlbltUb2tlbltcIlVuYXJ5T3BcIl0gPSAzMjc2OF0gPSBcIlVuYXJ5T3BcIjtcbiAgICBUb2tlbltUb2tlbltcIkxlZnRIYW5kU2lkZVwiXSA9IDE2Mzg0XSA9IFwiTGVmdEhhbmRTaWRlXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJTdHJpbmdPck51bWVyaWNMaXRlcmFsXCJdID0gMTIyODhdID0gXCJTdHJpbmdPck51bWVyaWNMaXRlcmFsXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJOdW1lcmljTGl0ZXJhbFwiXSA9IDgxOTJdID0gXCJOdW1lcmljTGl0ZXJhbFwiO1xuICAgIFRva2VuW1Rva2VuW1wiU3RyaW5nTGl0ZXJhbFwiXSA9IDQwOTZdID0gXCJTdHJpbmdMaXRlcmFsXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJJZGVudGlmaWVyTmFtZVwiXSA9IDMwNzJdID0gXCJJZGVudGlmaWVyTmFtZVwiO1xuICAgIFRva2VuW1Rva2VuW1wiS2V5d29yZFwiXSA9IDIwNDhdID0gXCJLZXl3b3JkXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJJZGVudGlmaWVyXCJdID0gMTAyNF0gPSBcIklkZW50aWZpZXJcIjtcbiAgICBUb2tlbltUb2tlbltcIkNvbnRleHR1YWxcIl0gPSA1MTJdID0gXCJDb250ZXh0dWFsXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJQcmVjZWRlbmNlXCJdID0gNDQ4XSA9IFwiUHJlY2VkZW5jZVwiO1xuICAgIFRva2VuW1Rva2VuW1wiVHlwZVwiXSA9IDYzXSA9IFwiVHlwZVwiO1xuICAgIFRva2VuW1Rva2VuW1wiRmFsc2VLZXl3b3JkXCJdID0gMjA0OF0gPSBcIkZhbHNlS2V5d29yZFwiO1xuICAgIFRva2VuW1Rva2VuW1wiVHJ1ZUtleXdvcmRcIl0gPSAyMDQ5XSA9IFwiVHJ1ZUtleXdvcmRcIjtcbiAgICBUb2tlbltUb2tlbltcIk51bGxLZXl3b3JkXCJdID0gMjA1MF0gPSBcIk51bGxLZXl3b3JkXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJVbmRlZmluZWRLZXl3b3JkXCJdID0gMjA1MV0gPSBcIlVuZGVmaW5lZEtleXdvcmRcIjtcbiAgICBUb2tlbltUb2tlbltcIlRoaXNTY29wZVwiXSA9IDMwNzZdID0gXCJUaGlzU2NvcGVcIjtcbiAgICBUb2tlbltUb2tlbltcIkhvc3RTY29wZVwiXSA9IDMwNzddID0gXCJIb3N0U2NvcGVcIjtcbiAgICBUb2tlbltUb2tlbltcIlBhcmVudFNjb3BlXCJdID0gMzA3OF0gPSBcIlBhcmVudFNjb3BlXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJPcGVuUGFyZW5cIl0gPSA2NzE3NTFdID0gXCJPcGVuUGFyZW5cIjtcbiAgICBUb2tlbltUb2tlbltcIk9wZW5CcmFjZVwiXSA9IDEzMTA4MF0gPSBcIk9wZW5CcmFjZVwiO1xuICAgIFRva2VuW1Rva2VuW1wiRG90XCJdID0gMTYzOTNdID0gXCJEb3RcIjtcbiAgICBUb2tlbltUb2tlbltcIkNsb3NlQnJhY2VcIl0gPSAxODM1MDE4XSA9IFwiQ2xvc2VCcmFjZVwiO1xuICAgIFRva2VuW1Rva2VuW1wiQ2xvc2VQYXJlblwiXSA9IDE4MzUwMTldID0gXCJDbG9zZVBhcmVuXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJDb21tYVwiXSA9IDE1NzI4NzZdID0gXCJDb21tYVwiO1xuICAgIFRva2VuW1Rva2VuW1wiT3BlbkJyYWNrZXRcIl0gPSA2NzE3NTddID0gXCJPcGVuQnJhY2tldFwiO1xuICAgIFRva2VuW1Rva2VuW1wiQ2xvc2VCcmFja2V0XCJdID0gMTgzNTAyMl0gPSBcIkNsb3NlQnJhY2tldFwiO1xuICAgIFRva2VuW1Rva2VuW1wiQ29sb25cIl0gPSAxNTcyODc5XSA9IFwiQ29sb25cIjtcbiAgICBUb2tlbltUb2tlbltcIlF1ZXN0aW9uXCJdID0gMTU3Mjg4MF0gPSBcIlF1ZXN0aW9uXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJBbXBlcnNhbmRcIl0gPSAxNTcyODgzXSA9IFwiQW1wZXJzYW5kXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJCYXJcIl0gPSAxNTcyODg0XSA9IFwiQmFyXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJCYXJCYXJcIl0gPSAxNjM4NTQ5XSA9IFwiQmFyQmFyXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJBbXBlcnNhbmRBbXBlcnNhbmRcIl0gPSAxNjM4NjE0XSA9IFwiQW1wZXJzYW5kQW1wZXJzYW5kXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJFcXVhbHNFcXVhbHNcIl0gPSAxNjM4Njc5XSA9IFwiRXF1YWxzRXF1YWxzXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJFeGNsYW1hdGlvbkVxdWFsc1wiXSA9IDE2Mzg2ODBdID0gXCJFeGNsYW1hdGlvbkVxdWFsc1wiO1xuICAgIFRva2VuW1Rva2VuW1wiRXF1YWxzRXF1YWxzRXF1YWxzXCJdID0gMTYzODY4MV0gPSBcIkVxdWFsc0VxdWFsc0VxdWFsc1wiO1xuICAgIFRva2VuW1Rva2VuW1wiRXhjbGFtYXRpb25FcXVhbHNFcXVhbHNcIl0gPSAxNjM4NjgyXSA9IFwiRXhjbGFtYXRpb25FcXVhbHNFcXVhbHNcIjtcbiAgICBUb2tlbltUb2tlbltcIkxlc3NUaGFuXCJdID0gMTYzODc0N10gPSBcIkxlc3NUaGFuXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJHcmVhdGVyVGhhblwiXSA9IDE2Mzg3NDhdID0gXCJHcmVhdGVyVGhhblwiO1xuICAgIFRva2VuW1Rva2VuW1wiTGVzc1RoYW5FcXVhbHNcIl0gPSAxNjM4NzQ5XSA9IFwiTGVzc1RoYW5FcXVhbHNcIjtcbiAgICBUb2tlbltUb2tlbltcIkdyZWF0ZXJUaGFuRXF1YWxzXCJdID0gMTYzODc1MF0gPSBcIkdyZWF0ZXJUaGFuRXF1YWxzXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJJbktleXdvcmRcIl0gPSAxNjQwNzk5XSA9IFwiSW5LZXl3b3JkXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJJbnN0YW5jZU9mS2V5d29yZFwiXSA9IDE2NDA4MDBdID0gXCJJbnN0YW5jZU9mS2V5d29yZFwiO1xuICAgIFRva2VuW1Rva2VuW1wiUGx1c1wiXSA9IDYyMzAwOV0gPSBcIlBsdXNcIjtcbiAgICBUb2tlbltUb2tlbltcIk1pbnVzXCJdID0gNjIzMDEwXSA9IFwiTWludXNcIjtcbiAgICBUb2tlbltUb2tlbltcIlR5cGVvZktleXdvcmRcIl0gPSAzNDg1MV0gPSBcIlR5cGVvZktleXdvcmRcIjtcbiAgICBUb2tlbltUb2tlbltcIlZvaWRLZXl3b3JkXCJdID0gMzQ4NTJdID0gXCJWb2lkS2V5d29yZFwiO1xuICAgIFRva2VuW1Rva2VuW1wiQXN0ZXJpc2tcIl0gPSAxNjM4ODg1XSA9IFwiQXN0ZXJpc2tcIjtcbiAgICBUb2tlbltUb2tlbltcIlBlcmNlbnRcIl0gPSAxNjM4ODg2XSA9IFwiUGVyY2VudFwiO1xuICAgIFRva2VuW1Rva2VuW1wiU2xhc2hcIl0gPSAxNjM4ODg3XSA9IFwiU2xhc2hcIjtcbiAgICBUb2tlbltUb2tlbltcIkVxdWFsc1wiXSA9IDEwNDg2MTZdID0gXCJFcXVhbHNcIjtcbiAgICBUb2tlbltUb2tlbltcIkV4Y2xhbWF0aW9uXCJdID0gMzI4MDldID0gXCJFeGNsYW1hdGlvblwiO1xuICAgIFRva2VuW1Rva2VuW1wiVGVtcGxhdGVUYWlsXCJdID0gNTQwNzE0XSA9IFwiVGVtcGxhdGVUYWlsXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJUZW1wbGF0ZUNvbnRpbnVhdGlvblwiXSA9IDU0MDcxNV0gPSBcIlRlbXBsYXRlQ29udGludWF0aW9uXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJPZktleXdvcmRcIl0gPSAxMDUxMTgwXSA9IFwiT2ZLZXl3b3JkXCI7XG59KShUb2tlbiB8fCAoVG9rZW4gPSB7fSkpO1xuY29uc3QgJGZhbHNlID0gUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJGZhbHNlO1xuY29uc3QgJHRydWUgPSBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbi4kdHJ1ZTtcbmNvbnN0ICRudWxsID0gUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJG51bGw7XG5jb25zdCAkdW5kZWZpbmVkID0gUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJHVuZGVmaW5lZDtcbmNvbnN0ICR0aGlzID0gQWNjZXNzVGhpc0V4cHJlc3Npb24uJHRoaXM7XG5jb25zdCAkaG9zdCA9IEFjY2Vzc1RoaXNFeHByZXNzaW9uLiRob3N0O1xuY29uc3QgJHBhcmVudCA9IEFjY2Vzc1RoaXNFeHByZXNzaW9uLiRwYXJlbnQ7XG5leHBvcnQgdmFyIEJpbmRpbmdUeXBlO1xuKGZ1bmN0aW9uIChCaW5kaW5nVHlwZSkge1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJZ25vcmVDdXN0b21BdHRyXCJdID0gNDA5Nl0gPSBcIklnbm9yZUN1c3RvbUF0dHJcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIkludGVycG9sYXRpb25cIl0gPSAyMDQ4XSA9IFwiSW50ZXJwb2xhdGlvblwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSXNSZWZcIl0gPSA1Mzc2XSA9IFwiSXNSZWZcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIklzSXRlcmF0b3JcIl0gPSA1MTJdID0gXCJJc0l0ZXJhdG9yXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJc0N1c3RvbVwiXSA9IDI1Nl0gPSBcIklzQ3VzdG9tXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJc0Z1bmN0aW9uXCJdID0gMTI4XSA9IFwiSXNGdW5jdGlvblwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSXNFdmVudFwiXSA9IDY0XSA9IFwiSXNFdmVudFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSXNQcm9wZXJ0eVwiXSA9IDMyXSA9IFwiSXNQcm9wZXJ0eVwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSXNDb21tYW5kXCJdID0gMTZdID0gXCJJc0NvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIklzUHJvcGVydHlDb21tYW5kXCJdID0gNDhdID0gXCJJc1Byb3BlcnR5Q29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSXNFdmVudENvbW1hbmRcIl0gPSA4MF0gPSBcIklzRXZlbnRDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJEZWxlZ2F0aW9uU3RyYXRlZ3lEZWx0YVwiXSA9IDZdID0gXCJEZWxlZ2F0aW9uU3RyYXRlZ3lEZWx0YVwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiQ29tbWFuZFwiXSA9IDE1XSA9IFwiQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiT25lVGltZUNvbW1hbmRcIl0gPSA0OV0gPSBcIk9uZVRpbWVDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJUb1ZpZXdDb21tYW5kXCJdID0gNTBdID0gXCJUb1ZpZXdDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJGcm9tVmlld0NvbW1hbmRcIl0gPSA1MV0gPSBcIkZyb21WaWV3Q29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiVHdvV2F5Q29tbWFuZFwiXSA9IDUyXSA9IFwiVHdvV2F5Q29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiQmluZENvbW1hbmRcIl0gPSA1M10gPSBcIkJpbmRDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJUcmlnZ2VyQ29tbWFuZFwiXSA9IDQxODJdID0gXCJUcmlnZ2VyQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiQ2FwdHVyZUNvbW1hbmRcIl0gPSA0MTgzXSA9IFwiQ2FwdHVyZUNvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIkRlbGVnYXRlQ29tbWFuZFwiXSA9IDQxODRdID0gXCJEZWxlZ2F0ZUNvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIkNhbGxDb21tYW5kXCJdID0gMTUzXSA9IFwiQ2FsbENvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIk9wdGlvbnNDb21tYW5kXCJdID0gMjZdID0gXCJPcHRpb25zQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiRm9yQ29tbWFuZFwiXSA9IDUzOV0gPSBcIkZvckNvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIkN1c3RvbUNvbW1hbmRcIl0gPSAyODRdID0gXCJDdXN0b21Db21tYW5kXCI7XG59KShCaW5kaW5nVHlwZSB8fCAoQmluZGluZ1R5cGUgPSB7fSkpO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvaW5kZW50ICovXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgUGFyc2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4gPSAxNTcyODY0IC8qIEVPRiAqLztcbiAgICAgICAgdGhpcy50b2tlblZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuYXNzaWduYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGFyID0gaW5wdXQuY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgZ2V0IHRva2VuUmF3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0SW5kZXgsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cbmNvbnN0ICRzdGF0ZSA9IG5ldyBQYXJzZXJTdGF0ZSgnJyk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGlucHV0LCBiaW5kaW5nVHlwZSkge1xuICAgICRzdGF0ZS5pbnB1dCA9IGlucHV0O1xuICAgICRzdGF0ZS5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgJHN0YXRlLmluZGV4ID0gMDtcbiAgICAkc3RhdGUuY3VycmVudENoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBwYXJzZSgkc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYxIC8qIFZhcmlhZGljICovLCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwID8gNTMgLyogQmluZENvbW1hbmQgKi8gOiBiaW5kaW5nVHlwZSk7XG59XG4vKiogQGludGVybmFsICovXG4vLyBUaGlzIGlzIHBlcmZvcm1hbmNlLWNyaXRpY2FsIGNvZGUgd2hpY2ggZm9sbG93cyBhIHN1YnNldCBvZiB0aGUgd2VsbC1rbm93biBFUyBzcGVjLlxuLy8gS25vd2luZyB0aGUgc3BlYywgb3IgcGFyc2VycyBpbiBnZW5lcmFsLCB3aWxsIGhlbHAgd2l0aCB1bmRlcnN0YW5kaW5nIHRoaXMgY29kZSBhbmQgaXQgaXMgdGhlcmVmb3JlIG5vdCB0aGVcbi8vIHNpbmdsZSBzb3VyY2Ugb2YgaW5mb3JtYXRpb24gZm9yIGJlaW5nIGFibGUgdG8gZmlndXJlIGl0IG91dC5cbi8vIEl0IGdlbmVyYWxseSBkb2VzIG5vdCBuZWVkIHRvIGNoYW5nZSB1bmxlc3MgdGhlIHNwZWMgY2hhbmdlcyBvciBzcGVjIHZpb2xhdGlvbnMgYXJlIGZvdW5kLCBvciBvcHRpbWl6YXRpb25cbi8vIG9wcG9ydHVuaXRpZXMgYXJlIGZvdW5kICh3aGljaCB3b3VsZCBsaWtlbHkgbm90IGZpeCB0aGVzZSB3YXJuaW5ncyBpbiBhbnkgY2FzZSkuXG4vLyBJdCdzIHRoZXJlZm9yZSBub3QgY29uc2lkZXJlZCB0byBoYXZlIGFueSB0YW5naWJsZSBpbXBhY3Qgb24gdGhlIG1haW50YWluYWJpbGl0eSBvZiB0aGUgY29kZSBiYXNlLlxuLy8gRm9yIHJlZmVyZW5jZSwgbW9zdCBvZiB0aGUgcGFyc2luZyBsb2dpYyBpcyBiYXNlZCBvbjogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS1leHByZXNzaW9uc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShzdGF0ZSwgYWNjZXNzLCBtaW5QcmVjZWRlbmNlLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gMjg0IC8qIEN1c3RvbUNvbW1hbmQgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FeHByZXNzaW9uKHN0YXRlLmlucHV0KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmluZGV4ID09PSAwKSB7XG4gICAgICAgIGlmIChiaW5kaW5nVHlwZSAmIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludGVycG9sYXRpb24oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gJiAxMDQ4NTc2IC8qIEV4cHJlc3Npb25UZXJtaW5hbCAqLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXJ0IG9mIGV4cHJlc3Npb246ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5hc3NpZ25hYmxlID0gNDQ4IC8qIEJpbmFyeSAqLyA+IG1pblByZWNlZGVuY2U7XG4gICAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuICYgMzI3NjggLyogVW5hcnlPcCAqLykge1xuICAgICAgICAvKiogcGFyc2VVbmFyeUV4cHJlc3Npb25cbiAgICAgICAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdW5hcnktb3BlcmF0b3JzXG4gICAgICAgICAqXG4gICAgICAgICAqIFVuYXJ5RXhwcmVzc2lvbiA6XG4gICAgICAgICAqIDEuIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cbiAgICAgICAgICogMi4gdm9pZCBVbmFyeUV4cHJlc3Npb25cbiAgICAgICAgICogMy4gdHlwZW9mIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKiA0LiArIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKiA1LiAtIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKiA2LiAhIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKlxuICAgICAgICAgKiBJc1ZhbGlkQXNzaWdubWVudFRhcmdldFxuICAgICAgICAgKiAyLDMsNCw1LDYgPSBmYWxzZVxuICAgICAgICAgKiAxID0gc2VlIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiB0ZWNobmljYWxseSB3ZSBzaG91bGQgdGhyb3cgb24gKysgLyAtLSAvICsrKyAvIC0tLSwgYnV0IHRoZXJlJ3Mgbm90aGluZyB0byBnYWluIGZyb20gdGhhdFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgb3AgPSBUb2tlblZhbHVlc1tzdGF0ZS5jdXJyZW50VG9rZW4gJiA2MyAvKiBUeXBlICovXTtcbiAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVuYXJ5RXhwcmVzc2lvbihvcCwgcGFyc2Uoc3RhdGUsIGFjY2VzcywgNDQ5IC8qIExlZnRIYW5kU2lkZSAqLywgYmluZGluZ1R5cGUpKTtcbiAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyoqIHBhcnNlUHJpbWFyeUV4cHJlc3Npb25cbiAgICAgICAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJpbWFyeS1leHByZXNzaW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFByaW1hcnlFeHByZXNzaW9uIDpcbiAgICAgICAgICogMS4gdGhpc1xuICAgICAgICAgKiAyLiBJZGVudGlmaWVyTmFtZVxuICAgICAgICAgKiAzLiBMaXRlcmFsXG4gICAgICAgICAqIDQuIEFycmF5TGl0ZXJhbEV4cHJlc3Npb25cbiAgICAgICAgICogNS4gT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb25cbiAgICAgICAgICogNi4gVGVtcGxhdGVMaXRlcmFsXG4gICAgICAgICAqIDcuIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIExpdGVyYWwgOlxuICAgICAgICAgKiBOdWxsTGl0ZXJhbFxuICAgICAgICAgKiBCb29sZWFuTGl0ZXJhbFxuICAgICAgICAgKiBOdW1lcmljTGl0ZXJhbFxuICAgICAgICAgKiBTdHJpbmdMaXRlcmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIDpcbiAgICAgICAgICogKCBBc3NpZ25tZW50RXhwcmVzc2lvbiApXG4gICAgICAgICAqXG4gICAgICAgICAqIElzVmFsaWRBc3NpZ25tZW50VGFyZ2V0XG4gICAgICAgICAqIDEsMyw0LDUsNiw3ID0gZmFsc2VcbiAgICAgICAgICogMiA9IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHByaW1hcnk6IHN3aXRjaCAoc3RhdGUuY3VycmVudFRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIDMwNzggLyogUGFyZW50U2NvcGUgKi86IC8vICRwYXJlbnRcbiAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3MrKzsgLy8gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVPcHQoc3RhdGUsIDE2MzkzIC8qIERvdCAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IDE2MzkzIC8qIERvdCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRG91YmxlIGRvdCBhbmQgc3ByZWFkIG9wZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZDogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxNTcyODY0IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllcjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDUyNDI4OCAvKiBBY2Nlc3NTY29wZVRlcm1pbmFsICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvciA9IGFjY2VzcyAmIDUxMSAvKiBBbmNlc3RvciAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFuY2VzdG9yID09PSAwID8gJHRoaXMgOiBhbmNlc3RvciA9PT0gMSA/ICRwYXJlbnQgOiBuZXcgQWNjZXNzVGhpc0V4cHJlc3Npb24oYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gNTEyIC8qIFRoaXMgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBwcmltYXJ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lbWJlciBleHByZXNzaW9uOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IDMwNzggLyogUGFyZW50U2NvcGUgKi8pO1xuICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAxMDI0IC8qIElkZW50aWZpZXIgKi86IC8vIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZ1R5cGUgJiA1MTIgLyogSXNJdGVyYXRvciAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ0lkZW50aWZpZXIoc3RhdGUudG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQWNjZXNzU2NvcGVFeHByZXNzaW9uKHN0YXRlLnRva2VuVmFsdWUsIGFjY2VzcyAmIDUxMSAvKiBBbmNlc3RvciAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VzcyA9IDEwMjQgLyogU2NvcGUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMwNzYgLyogVGhpc1Njb3BlICovOiAvLyAkdGhpc1xuICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICR0aGlzO1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDUxMiAvKiBUaGlzICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMDc3IC8qIEhvc3RTY29wZSAqLzogLy8gJGhvc3RcbiAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAkaG9zdDtcbiAgICAgICAgICAgICAgICBhY2Nlc3MgPSA1MTIgLyogVGhpcyAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjcxNzUxIC8qIE9wZW5QYXJlbiAqLzogLy8gcGFyZW50aGVzaXplZCBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3VtZShzdGF0ZSwgMTgzNTAxOSAvKiBDbG9zZVBhcmVuICovKTtcbiAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2NzE3NTcgLyogT3BlbkJyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VBcnJheUxpdGVyYWxFeHByZXNzaW9uKHN0YXRlLCBhY2Nlc3MsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMzEwODAgLyogT3BlbkJyYWNlICovOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24oc3RhdGUsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1NDA3MTQgLyogVGVtcGxhdGVUYWlsICovOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUZW1wbGF0ZUV4cHJlc3Npb24oW3N0YXRlLnRva2VuVmFsdWVdKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1NDA3MTUgLyogVGVtcGxhdGVDb250aW51YXRpb24gKi86XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VUZW1wbGF0ZShzdGF0ZSwgYWNjZXNzLCBiaW5kaW5nVHlwZSwgcmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYWNjZXNzID0gMCAvKiBSZXNldCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDA5NiAvKiBTdHJpbmdMaXRlcmFsICovOlxuICAgICAgICAgICAgY2FzZSA4MTkyIC8qIE51bWVyaWNMaXRlcmFsICovOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbihzdGF0ZS50b2tlblZhbHVlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMDUwIC8qIE51bGxLZXl3b3JkICovOlxuICAgICAgICAgICAgY2FzZSAyMDUxIC8qIFVuZGVmaW5lZEtleXdvcmQgKi86XG4gICAgICAgICAgICBjYXNlIDIwNDkgLyogVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICBjYXNlIDIwNDggLyogRmFsc2VLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFRva2VuVmFsdWVzW3N0YXRlLmN1cnJlbnRUb2tlbiAmIDYzIC8qIFR5cGUgKi9dO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pbmRleCA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuY29uc3VtZWQgdG9rZW46ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlICYgNTEyIC8qIElzSXRlcmF0b3IgKi8pIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGb3JPZlN0YXRlbWVudChzdGF0ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoNDQ5IC8qIExlZnRIYW5kU2lkZSAqLyA8IG1pblByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBwYXJzZU1lbWJlckV4cHJlc3Npb24gKFRva2VuLkRvdCwgVG9rZW4uT3BlbkJyYWNrZXQsIFRva2VuLlRlbXBsYXRlQ29udGludWF0aW9uKVxuICAgICAgICAgKiBNZW1iZXJFeHByZXNzaW9uIDpcbiAgICAgICAgICogMS4gUHJpbWFyeUV4cHJlc3Npb25cbiAgICAgICAgICogMi4gTWVtYmVyRXhwcmVzc2lvbiBbIEFzc2lnbm1lbnRFeHByZXNzaW9uIF1cbiAgICAgICAgICogMy4gTWVtYmVyRXhwcmVzc2lvbiAuIElkZW50aWZpZXJOYW1lXG4gICAgICAgICAqIDQuIE1lbWJlckV4cHJlc3Npb24gVGVtcGxhdGVMaXRlcmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIElzVmFsaWRBc3NpZ25tZW50VGFyZ2V0XG4gICAgICAgICAqIDEsNCA9IGZhbHNlXG4gICAgICAgICAqIDIsMyA9IHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogcGFyc2VDYWxsRXhwcmVzc2lvbiAoVG9rZW4uT3BlblBhcmVuKVxuICAgICAgICAgKiBDYWxsRXhwcmVzc2lvbiA6XG4gICAgICAgICAqIDEuIE1lbWJlckV4cHJlc3Npb24gQXJndW1lbnRzXG4gICAgICAgICAqIDIuIENhbGxFeHByZXNzaW9uIEFyZ3VtZW50c1xuICAgICAgICAgKiAzLiBDYWxsRXhwcmVzc2lvbiBbIEFzc2lnbm1lbnRFeHByZXNzaW9uIF1cbiAgICAgICAgICogNC4gQ2FsbEV4cHJlc3Npb24gLiBJZGVudGlmaWVyTmFtZVxuICAgICAgICAgKiA1LiBDYWxsRXhwcmVzc2lvbiBUZW1wbGF0ZUxpdGVyYWxcbiAgICAgICAgICpcbiAgICAgICAgICogSXNWYWxpZEFzc2lnbm1lbnRUYXJnZXRcbiAgICAgICAgICogMSwyLDUgPSBmYWxzZVxuICAgICAgICAgKiAzLDQgPSB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbmFtZSA9IHN0YXRlLnRva2VuVmFsdWU7XG4gICAgICAgIHdoaWxlICgoc3RhdGUuY3VycmVudFRva2VuICYgMTYzODQgLyogTGVmdEhhbmRTaWRlICovKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBzdHJpbmdzO1xuICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5jdXJyZW50VG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE2MzkzIC8qIERvdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuY3VycmVudFRva2VuICYgMzA3MiAvKiBJZGVudGlmaWVyTmFtZSAqLykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllcjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBzdGF0ZS50b2tlblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgJFRoaXMgdG8gJFNjb3BlLCBjaGFuZ2UgJFNjb3BlIHRvICRNZW1iZXIsIGtlZXAgJE1lbWJlciBhcy1pcywgY2hhbmdlICRLZXllZCB0byAkTWVtYmVyLCBkaXNyZWdhcmQgb3RoZXIgZmxhZ3NcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gKChhY2Nlc3MgJiAoNTEyIC8qIFRoaXMgKi8gfCAxMDI0IC8qIFNjb3BlICovKSkgPDwgMSkgfCAoYWNjZXNzICYgMjA0OCAvKiBNZW1iZXIgKi8pIHwgKChhY2Nlc3MgJiA0MDk2IC8qIEtleWVkICovKSA+PiAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiA9PT0gNjcxNzUxIC8qIE9wZW5QYXJlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2VzcyA9PT0gMCAvKiBSZXNldCAqLykgeyAvLyBpZiB0aGUgbGVmdCBoYW5kIHNpZGUgaXMgYSBsaXRlcmFsLCBtYWtlIHN1cmUgd2UgcGFyc2UgYSBDYWxsTWVtYmVyRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VzcyA9IDIwNDggLyogTWVtYmVyICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2VzcyAmIDEwMjQgLyogU2NvcGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBY2Nlc3NTY29wZUV4cHJlc3Npb24obmFtZSwgcmVzdWx0LmFuY2VzdG9yLCByZXN1bHQgPT09ICRob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gaWYgaXQncyBub3QgJFNjb3BlLCBpdCdzICRNZW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBY2Nlc3NNZW1iZXJFeHByZXNzaW9uKHJlc3VsdCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA2NzE3NTcgLyogT3BlbkJyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3MgPSA0MDk2IC8qIEtleWVkICovO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQWNjZXNzS2V5ZWRFeHByZXNzaW9uKHJlc3VsdCwgcGFyc2Uoc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZShzdGF0ZSwgMTgzNTAyMiAvKiBDbG9zZUJyYWNrZXQgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY3MTc1MSAvKiBPcGVuUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmN1cnJlbnRUb2tlbiAhPT0gMTgzNTAxOSAvKiBDbG9zZVBhcmVuICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gocGFyc2Uoc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uc3VtZU9wdChzdGF0ZSwgMTU3Mjg3NiAvKiBDb21tYSAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxODM1MDE5IC8qIENsb3NlUGFyZW4gKi8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjZXNzICYgMTAyNCAvKiBTY29wZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENhbGxTY29wZUV4cHJlc3Npb24obmFtZSwgYXJncywgcmVzdWx0LmFuY2VzdG9yLCByZXN1bHQgPT09ICRob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhY2Nlc3MgJiAyMDQ4IC8qIE1lbWJlciAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENhbGxNZW1iZXJFeHByZXNzaW9uKHJlc3VsdCwgbmFtZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ2FsbEZ1bmN0aW9uRXhwcmVzc2lvbihyZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjY2VzcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTQwNzE0IC8qIFRlbXBsYXRlVGFpbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdzID0gW3N0YXRlLnRva2VuVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKHN0cmluZ3MsIHN0cmluZ3MsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTQwNzE1IC8qIFRlbXBsYXRlQ29udGludWF0aW9uICovOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZVRlbXBsYXRlKHN0YXRlLCBhY2Nlc3MsIGJpbmRpbmdUeXBlLCByZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKDQ0OCAvKiBCaW5hcnkgKi8gPCBtaW5QcmVjZWRlbmNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKiBwYXJzZUJpbmFyeUV4cHJlc3Npb25cbiAgICAgKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tdWx0aXBsaWNhdGl2ZS1vcGVyYXRvcnNcbiAgICAgKlxuICAgICAqIE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbiA6IChsb2NhbCBwcmVjZWRlbmNlIDYpXG4gICAgICogVW5hcnlFeHByZXNzaW9uXG4gICAgICogTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uICogLyAlIFVuYXJ5RXhwcmVzc2lvblxuICAgICAqXG4gICAgICogQWRkaXRpdmVFeHByZXNzaW9uIDogKGxvY2FsIHByZWNlZGVuY2UgNSlcbiAgICAgKiBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25cbiAgICAgKiBBZGRpdGl2ZUV4cHJlc3Npb24gKyAtIE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvblxuICAgICAqXG4gICAgICogUmVsYXRpb25hbEV4cHJlc3Npb24gOiAobG9jYWwgcHJlY2VkZW5jZSA0KVxuICAgICAqIEFkZGl0aXZlRXhwcmVzc2lvblxuICAgICAqIFJlbGF0aW9uYWxFeHByZXNzaW9uIDwgPiA8PSA+PSBpbnN0YW5jZW9mIGluIEFkZGl0aXZlRXhwcmVzc2lvblxuICAgICAqXG4gICAgICogRXF1YWxpdHlFeHByZXNzaW9uIDogKGxvY2FsIHByZWNlZGVuY2UgMylcbiAgICAgKiBSZWxhdGlvbmFsRXhwcmVzc2lvblxuICAgICAqIEVxdWFsaXR5RXhwcmVzc2lvbiA9PSAhPSA9PT0gIT09IFJlbGF0aW9uYWxFeHByZXNzaW9uXG4gICAgICpcbiAgICAgKiBMb2dpY2FsQU5ERXhwcmVzc2lvbiA6IChsb2NhbCBwcmVjZWRlbmNlIDIpXG4gICAgICogRXF1YWxpdHlFeHByZXNzaW9uXG4gICAgICogTG9naWNhbEFOREV4cHJlc3Npb24gJiYgRXF1YWxpdHlFeHByZXNzaW9uXG4gICAgICpcbiAgICAgKiBMb2dpY2FsT1JFeHByZXNzaW9uIDogKGxvY2FsIHByZWNlZGVuY2UgMSlcbiAgICAgKiBMb2dpY2FsQU5ERXhwcmVzc2lvblxuICAgICAqIExvZ2ljYWxPUkV4cHJlc3Npb24gfHwgTG9naWNhbEFOREV4cHJlc3Npb25cbiAgICAgKi9cbiAgICB3aGlsZSAoKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDY1NTM2IC8qIEJpbmFyeU9wICovKSA+IDApIHtcbiAgICAgICAgY29uc3Qgb3BUb2tlbiA9IHN0YXRlLmN1cnJlbnRUb2tlbjtcbiAgICAgICAgaWYgKChvcFRva2VuICYgNDQ4IC8qIFByZWNlZGVuY2UgKi8pIDw9IG1pblByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnlFeHByZXNzaW9uKFRva2VuVmFsdWVzW29wVG9rZW4gJiA2MyAvKiBUeXBlICovXSwgcmVzdWx0LCBwYXJzZShzdGF0ZSwgYWNjZXNzLCBvcFRva2VuICYgNDQ4IC8qIFByZWNlZGVuY2UgKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKDYzIC8qIENvbmRpdGlvbmFsICovIDwgbWluUHJlY2VkZW5jZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvblxuICAgICAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jcHJvZC1Db25kaXRpb25hbEV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIENvbmRpdGlvbmFsRXhwcmVzc2lvbiA6XG4gICAgICogMS4gQmluYXJ5RXhwcmVzc2lvblxuICAgICAqIDIuIEJpbmFyeUV4cHJlc3Npb24gPyBBc3NpZ25tZW50RXhwcmVzc2lvbiA6IEFzc2lnbm1lbnRFeHByZXNzaW9uXG4gICAgICpcbiAgICAgKiBJc1ZhbGlkQXNzaWdubWVudFRhcmdldFxuICAgICAqIDEsMiA9IGZhbHNlXG4gICAgICovXG4gICAgaWYgKGNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4ODAgLyogUXVlc3Rpb24gKi8pKSB7XG4gICAgICAgIGNvbnN0IHllcyA9IHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpO1xuICAgICAgICBjb25zdW1lKHN0YXRlLCAxNTcyODc5IC8qIENvbG9uICovKTtcbiAgICAgICAgcmVzdWx0ID0gbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbihyZXN1bHQsIHllcywgcGFyc2Uoc3RhdGUsIGFjY2VzcywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICg2MiAvKiBBc3NpZ24gKi8gPCBtaW5QcmVjZWRlbmNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXG4gICAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNwcm9kLUFzc2lnbm1lbnRFeHByZXNzaW9uXG4gICAgICogTm90ZTogQXNzaWdubWVudEV4cHJlc3Npb24gaGVyZSBpcyBlcXVpdmFsZW50IHRvIEVTIEV4cHJlc3Npb24gYmVjYXVzZSB3ZSBkb24ndCBwYXJzZSB0aGUgY29tbWEgb3BlcmF0b3JcbiAgICAgKlxuICAgICAqIEFzc2lnbm1lbnRFeHByZXNzaW9uIDpcbiAgICAgKiAxLiBDb25kaXRpb25hbEV4cHJlc3Npb25cbiAgICAgKiAyLiBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIElzVmFsaWRBc3NpZ25tZW50VGFyZ2V0XG4gICAgICogMSwyID0gZmFsc2VcbiAgICAgKi9cbiAgICBpZiAoY29uc3VtZU9wdChzdGF0ZSwgMTA0ODYxNiAvKiBFcXVhbHMgKi8pKSB7XG4gICAgICAgIGlmICghc3RhdGUuYXNzaWduYWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZWZ0IGhhbmQgc2lkZSBvZiBleHByZXNzaW9uIGlzIG5vdCBhc3NpZ25hYmxlOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IEFzc2lnbkV4cHJlc3Npb24ocmVzdWx0LCBwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgfVxuICAgIGlmICg2MSAvKiBWYXJpYWRpYyAqLyA8IG1pblByZWNlZGVuY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIHBhcnNlVmFsdWVDb252ZXJ0ZXJcbiAgICAgKi9cbiAgICB3aGlsZSAoY29uc3VtZU9wdChzdGF0ZSwgMTU3Mjg4NCAvKiBCYXIgKi8pKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IDE1NzI4NjQgLyogRU9GICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGlkZW50aWZpZXIgdG8gY29tZSBhZnRlciBWYWx1ZUNvbnZlcnRlciBvcGVyYXRvcjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS50b2tlblZhbHVlO1xuICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHdoaWxlIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc5IC8qIENvbG9uICovKSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBuZXcgVmFsdWVDb252ZXJ0ZXJFeHByZXNzaW9uKHJlc3VsdCwgbmFtZSwgYXJncyk7XG4gICAgfVxuICAgIC8qKiBwYXJzZUJpbmRpbmdCZWhhdmlvclxuICAgICAqL1xuICAgIHdoaWxlIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODgzIC8qIEFtcGVyc2FuZCAqLykpIHtcbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiA9PT0gMTU3Mjg2NCAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllciB0byBjb21lIGFmdGVyIEJpbmRpbmdCZWhhdmlvciBvcGVyYXRvcjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS50b2tlblZhbHVlO1xuICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHdoaWxlIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc5IC8qIENvbG9uICovKSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbihyZXN1bHQsIG5hbWUsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxNTcyODY0IC8qIEVPRiAqLykge1xuICAgICAgICBpZiAoYmluZGluZ1R5cGUgJiAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS50b2tlblJhdyA9PT0gJ29mJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGtleXdvcmQgXCJvZlwiOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmNvbnN1bWVkIHRva2VuOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogcGFyc2VBcnJheUxpdGVyYWxFeHByZXNzaW9uXG4gKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3Byb2QtQXJyYXlMaXRlcmFsRXhwcmVzc2lvblxuICpcbiAqIEFycmF5TGl0ZXJhbEV4cHJlc3Npb24gOlxuICogWyBFbGlzaW9uKG9wdCkgXVxuICogWyBFbGVtZW50TGlzdCBdXG4gKiBbIEVsZW1lbnRMaXN0LCBFbGlzaW9uKG9wdCkgXVxuICpcbiAqIEVsZW1lbnRMaXN0IDpcbiAqIEVsaXNpb24ob3B0KSBBc3NpZ25tZW50RXhwcmVzc2lvblxuICogRWxlbWVudExpc3QsIEVsaXNpb24ob3B0KSBBc3NpZ25tZW50RXhwcmVzc2lvblxuICpcbiAqIEVsaXNpb24gOlxuICogLFxuICogRWxpc2lvbiAsXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJyYXlMaXRlcmFsRXhwcmVzc2lvbihzdGF0ZSwgYWNjZXNzLCBiaW5kaW5nVHlwZSkge1xuICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgQXJyYXkoKTtcbiAgICB3aGlsZSAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxODM1MDIyIC8qIENsb3NlQnJhY2tldCAqLykge1xuICAgICAgICBpZiAoY29uc3VtZU9wdChzdGF0ZSwgMTU3Mjg3NiAvKiBDb21tYSAqLykpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goJHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxODM1MDIyIC8qIENsb3NlQnJhY2tldCAqLykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlICYgfjUxMiAvKiBJc0l0ZXJhdG9yICovKSk7XG4gICAgICAgICAgICBpZiAoY29uc3VtZU9wdChzdGF0ZSwgMTU3Mjg3NiAvKiBDb21tYSAqLykpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxODM1MDIyIC8qIENsb3NlQnJhY2tldCAqLykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdW1lKHN0YXRlLCAxODM1MDIyIC8qIENsb3NlQnJhY2tldCAqLyk7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgNTEyIC8qIElzSXRlcmF0b3IgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJpbmRpbmdQYXR0ZXJuKGVsZW1lbnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUxpdGVyYWxFeHByZXNzaW9uKGVsZW1lbnRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUZvck9mU3RhdGVtZW50KHN0YXRlLCByZXN1bHQpIHtcbiAgICBpZiAoKHJlc3VsdC4ka2luZCAmIDY1NTM2IC8qIElzRm9yRGVjbGFyYXRpb24gKi8pID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBCaW5kaW5nSWRlbnRpZmllciBhdCBsZWZ0IGhhbmQgc2lkZSBvZiBcIm9mXCI6ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAhPT0gMTA1MTE4MCAvKiBPZktleXdvcmQgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpbmRpbmdJZGVudGlmaWVyIGF0IGxlZnQgaGFuZCBzaWRlIG9mIFwib2ZcIjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgIH1cbiAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gcmVzdWx0O1xuICAgIGNvbnN0IHN0YXRlbWVudCA9IHBhcnNlKHN0YXRlLCAwIC8qIFJlc2V0ICovLCA2MSAvKiBWYXJpYWRpYyAqLywgMCAvKiBOb25lICovKTtcbiAgICByZXR1cm4gbmV3IEZvck9mU3RhdGVtZW50KGRlY2xhcmF0aW9uLCBzdGF0ZW1lbnQpO1xufVxuLyoqXG4gKiBwYXJzZU9iamVjdExpdGVyYWxFeHByZXNzaW9uXG4gKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3Byb2QtTGl0ZXJhbFxuICpcbiAqIE9iamVjdExpdGVyYWxFeHByZXNzaW9uIDpcbiAqIHsgfVxuICogeyBQcm9wZXJ0eURlZmluaXRpb25MaXN0IH1cbiAqXG4gKiBQcm9wZXJ0eURlZmluaXRpb25MaXN0IDpcbiAqIFByb3BlcnR5RGVmaW5pdGlvblxuICogUHJvcGVydHlEZWZpbml0aW9uTGlzdCwgUHJvcGVydHlEZWZpbml0aW9uXG4gKlxuICogUHJvcGVydHlEZWZpbml0aW9uIDpcbiAqIElkZW50aWZpZXJOYW1lXG4gKiBQcm9wZXJ0eU5hbWUgOiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICpcbiAqIFByb3BlcnR5TmFtZSA6XG4gKiBJZGVudGlmaWVyTmFtZVxuICogU3RyaW5nTGl0ZXJhbFxuICogTnVtZXJpY0xpdGVyYWxcbiAqL1xuZnVuY3Rpb24gcGFyc2VPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihzdGF0ZSwgYmluZGluZ1R5cGUpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KCk7XG4gICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICB3aGlsZSAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxODM1MDE4IC8qIENsb3NlQnJhY2UgKi8pIHtcbiAgICAgICAga2V5cy5wdXNoKHN0YXRlLnRva2VuVmFsdWUpO1xuICAgICAgICAvLyBMaXRlcmFsID0gbWFuZGF0b3J5IGNvbG9uXG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gJiAxMjI4OCAvKiBTdHJpbmdPck51bWVyaWNMaXRlcmFsICovKSB7XG4gICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgY29uc3VtZShzdGF0ZSwgMTU3Mjg3OSAvKiBDb2xvbiAqLyk7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSAmIH41MTIgLyogSXNJdGVyYXRvciAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDMwNzIgLyogSWRlbnRpZmllck5hbWUgKi8pIHtcbiAgICAgICAgICAgIC8vIElkZW50aWZpZXJOYW1lID0gb3B0aW9uYWwgY29sb25cbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudENoYXIsIGN1cnJlbnRUb2tlbiwgaW5kZXggfSA9IHN0YXRlO1xuICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc5IC8qIENvbG9uICovKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlKHN0YXRlLCAwIC8qIFJlc2V0ICovLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlICYgfjUxMiAvKiBJc0l0ZXJhdG9yICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGhhbmRcbiAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Q2hhciA9IGN1cnJlbnRDaGFyO1xuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRUb2tlbiA9IGN1cnJlbnRUb2tlbjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlKHN0YXRlLCAwIC8qIFJlc2V0ICovLCA0NTAgLyogUHJpbWFyeSAqLywgYmluZGluZ1R5cGUgJiB+NTEyIC8qIElzSXRlcmF0b3IgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvciB1bnN1cHBvcnRlZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluIG9iamVjdCBsaXRlcmFsOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAhPT0gMTgzNTAxOCAvKiBDbG9zZUJyYWNlICovKSB7XG4gICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxNTcyODc2IC8qIENvbW1hICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdW1lKHN0YXRlLCAxODM1MDE4IC8qIENsb3NlQnJhY2UgKi8pO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDUxMiAvKiBJc0l0ZXJhdG9yICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0QmluZGluZ1BhdHRlcm4oa2V5cywgdmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihrZXlzLCB2YWx1ZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50ZXJwb2xhdGlvbihzdGF0ZSkge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIHdoaWxlIChzdGF0ZS5pbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBzd2l0Y2ggKHN0YXRlLmN1cnJlbnRDaGFyKSB7XG4gICAgICAgICAgICBjYXNlIDM2IC8qIERvbGxhciAqLzpcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5pbmRleCArIDEpID09PSAxMjMgLyogT3BlbkJyYWNlICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRDaGFyID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjEgLyogVmFyaWFkaWMgKi8sIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICckJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkyIC8qIEJhY2tzbGFzaCAqLzpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZUNvZGUobmV4dENoYXIoc3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXRlLmN1cnJlbnRDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24ocGFydHMsIGV4cHJlc3Npb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIHBhcnNlVGVtcGxhdGVMaXRlcmFsRXhwcmVzc2lvblxuICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNwcm9kLUxpdGVyYWxcbiAqXG4gKiBUZW1wbGF0ZUV4cHJlc3Npb24gOlxuICogTm9TdWJzdGl0dXRpb25UZW1wbGF0ZVxuICogVGVtcGxhdGVIZWFkXG4gKlxuICogTm9TdWJzdGl0dXRpb25UZW1wbGF0ZSA6XG4gKiBgIFRlbXBsYXRlQ2hhcmFjdGVycyhvcHQpIGBcbiAqXG4gKiBUZW1wbGF0ZUhlYWQgOlxuICogYCBUZW1wbGF0ZUNoYXJhY3RlcnMob3B0KSAke1xuICpcbiAqIFRlbXBsYXRlU3Vic3RpdHV0aW9uVGFpbCA6XG4gKiBUZW1wbGF0ZU1pZGRsZVxuICogVGVtcGxhdGVUYWlsXG4gKlxuICogVGVtcGxhdGVNaWRkbGUgOlxuICogfSBUZW1wbGF0ZUNoYXJhY3RlcnMob3B0KSAke1xuICpcbiAqIFRlbXBsYXRlVGFpbCA6XG4gKiB9IFRlbXBsYXRlQ2hhcmFjdGVycyhvcHQpIGBcbiAqXG4gKiBUZW1wbGF0ZUNoYXJhY3RlcnMgOlxuICogVGVtcGxhdGVDaGFyYWN0ZXIgVGVtcGxhdGVDaGFyYWN0ZXJzKG9wdClcbiAqXG4gKiBUZW1wbGF0ZUNoYXJhY3RlciA6XG4gKiAkIFtsb29rYWhlYWQg4omgIHtdXG4gKiBcXCBFc2NhcGVTZXF1ZW5jZVxuICogU291cmNlQ2hhcmFjdGVyIChidXQgbm90IG9uZSBvZiBgIG9yIFxcIG9yICQpXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUoc3RhdGUsIGFjY2VzcywgYmluZGluZ1R5cGUsIHJlc3VsdCwgdGFnZ2VkKSB7XG4gICAgY29uc3QgY29va2VkID0gW3N0YXRlLnRva2VuVmFsdWVdO1xuICAgIC8vIFRPRE86IHByb3Blcmx5IGltcGxlbWVudCByYXcgcGFydHMgLyBkZWNpZGUgd2hldGhlciB3ZSB3YW50IHRoaXNcbiAgICBjb25zdW1lKHN0YXRlLCA1NDA3MTUgLyogVGVtcGxhdGVDb250aW51YXRpb24gKi8pO1xuICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW3BhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpXTtcbiAgICB3aGlsZSAoKHN0YXRlLmN1cnJlbnRUb2tlbiA9IHNjYW5UZW1wbGF0ZVRhaWwoc3RhdGUpKSAhPT0gNTQwNzE0IC8qIFRlbXBsYXRlVGFpbCAqLykge1xuICAgICAgICBjb29rZWQucHVzaChzdGF0ZS50b2tlblZhbHVlKTtcbiAgICAgICAgY29uc3VtZShzdGF0ZSwgNTQwNzE1IC8qIFRlbXBsYXRlQ29udGludWF0aW9uICovKTtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgfVxuICAgIGNvb2tlZC5wdXNoKHN0YXRlLnRva2VuVmFsdWUpO1xuICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICBpZiAodGFnZ2VkKSB7XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGNvb2tlZCwgY29va2VkLCByZXN1bHQsIGV4cHJlc3Npb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVFeHByZXNzaW9uKGNvb2tlZCwgZXhwcmVzc2lvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5leHRUb2tlbihzdGF0ZSkge1xuICAgIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZS5zdGFydEluZGV4ID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIGlmICgoc3RhdGUuY3VycmVudFRva2VuID0gKENoYXJTY2FubmVyc1tzdGF0ZS5jdXJyZW50Q2hhcl0oc3RhdGUpKSkgIT0gbnVsbCkgeyAvLyBhIG51bGwgdG9rZW4gbWVhbnMgdGhlIGNoYXJhY3RlciBtdXN0IGJlIHNraXBwZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5jdXJyZW50VG9rZW4gPSAxNTcyODY0IC8qIEVPRiAqLztcbn1cbmZ1bmN0aW9uIG5leHRDaGFyKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmN1cnJlbnRDaGFyID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLmluZGV4KTtcbn1cbmZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKHN0YXRlKSB7XG4gICAgLy8gcnVuIHRvIHRoZSBuZXh0IG5vbi1pZFBhcnRcbiAgICB3aGlsZSAoSWRQYXJ0c1tuZXh0Q2hhcihzdGF0ZSldKVxuICAgICAgICA7XG4gICAgY29uc3QgdG9rZW4gPSBLZXl3b3JkTG9va3VwW3N0YXRlLnRva2VuVmFsdWUgPSBzdGF0ZS50b2tlblJhd107XG4gICAgcmV0dXJuIHRva2VuID09PSB1bmRlZmluZWQgPyAxMDI0IC8qIElkZW50aWZpZXIgKi8gOiB0b2tlbjtcbn1cbmZ1bmN0aW9uIHNjYW5OdW1iZXIoc3RhdGUsIGlzRmxvYXQpIHtcbiAgICBsZXQgY2hhciA9IHN0YXRlLmN1cnJlbnRDaGFyO1xuICAgIGlmIChpc0Zsb2F0ID09PSBmYWxzZSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjaGFyID0gbmV4dENoYXIoc3RhdGUpO1xuICAgICAgICB9IHdoaWxlIChjaGFyIDw9IDU3IC8qIE5pbmUgKi8gJiYgY2hhciA+PSA0OCAvKiBaZXJvICovKTtcbiAgICAgICAgaWYgKGNoYXIgIT09IDQ2IC8qIERvdCAqLykge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5WYWx1ZSA9IHBhcnNlSW50KHN0YXRlLnRva2VuUmF3LCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gODE5MiAvKiBOdW1lcmljTGl0ZXJhbCAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXN0IHRoaXMgcG9pbnQgaXQncyBhbHdheXMgYSBmbG9hdFxuICAgICAgICBjaGFyID0gbmV4dENoYXIoc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuaW5kZXggPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB1bmxlc3MgdGhlIG51bWJlciBlbmRzIHdpdGggYSBkb3QgLSB0aGF0IGJlaGF2ZXMgYSBsaXR0bGUgZGlmZmVyZW50IGluIG5hdGl2ZSBFUyBleHByZXNzaW9uc1xuICAgICAgICAgICAgLy8gYnV0IGluIG91ciBBU1QgdGhhdCBiZWhhdmlvciBoYXMgbm8gZWZmZWN0IGJlY2F1c2UgbnVtYmVycyBhcmUgYWx3YXlzIHN0b3JlZCBpbiB2YXJpYWJsZXNcbiAgICAgICAgICAgIHN0YXRlLnRva2VuVmFsdWUgPSBwYXJzZUludChzdGF0ZS50b2tlblJhdy5zbGljZSgwLCAtMSksIDEwKTtcbiAgICAgICAgICAgIHJldHVybiA4MTkyIC8qIE51bWVyaWNMaXRlcmFsICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFyIDw9IDU3IC8qIE5pbmUgKi8gJiYgY2hhciA+PSA0OCAvKiBaZXJvICovKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoYXIgPSBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICAgIH0gd2hpbGUgKGNoYXIgPD0gNTcgLyogTmluZSAqLyAmJiBjaGFyID49IDQ4IC8qIFplcm8gKi8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUuY3VycmVudENoYXIgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KC0tc3RhdGUuaW5kZXgpO1xuICAgIH1cbiAgICBzdGF0ZS50b2tlblZhbHVlID0gcGFyc2VGbG9hdChzdGF0ZS50b2tlblJhdyk7XG4gICAgcmV0dXJuIDgxOTIgLyogTnVtZXJpY0xpdGVyYWwgKi87XG59XG5mdW5jdGlvbiBzY2FuU3RyaW5nKHN0YXRlKSB7XG4gICAgY29uc3QgcXVvdGUgPSBzdGF0ZS5jdXJyZW50Q2hhcjtcbiAgICBuZXh0Q2hhcihzdGF0ZSk7IC8vIFNraXAgaW5pdGlhbCBxdW90ZS5cbiAgICBsZXQgdW5lc2NhcGVkID0gMDtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoKTtcbiAgICBsZXQgbWFya2VyID0gc3RhdGUuaW5kZXg7XG4gICAgd2hpbGUgKHN0YXRlLmN1cnJlbnRDaGFyICE9PSBxdW90ZSkge1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudENoYXIgPT09IDkyIC8qIEJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goc3RhdGUuaW5wdXQuc2xpY2UobWFya2VyLCBzdGF0ZS5pbmRleCkpO1xuICAgICAgICAgICAgbmV4dENoYXIoc3RhdGUpO1xuICAgICAgICAgICAgdW5lc2NhcGVkID0gdW5lc2NhcGVDb2RlKHN0YXRlLmN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIG5leHRDaGFyKHN0YXRlKTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodW5lc2NhcGVkKSk7XG4gICAgICAgICAgICBtYXJrZXIgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5pbmRleCA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW50ZXJtaW5hdGVkIHF1b3RlIGluIHN0cmluZyBsaXRlcmFsOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHN0YXRlLmlucHV0LnNsaWNlKG1hcmtlciwgc3RhdGUuaW5kZXgpO1xuICAgIG5leHRDaGFyKHN0YXRlKTsgLy8gU2tpcCB0ZXJtaW5hdGluZyBxdW90ZS5cbiAgICAvLyBDb21wdXRlIHRoZSB1bmVzY2FwZWQgc3RyaW5nIHZhbHVlLlxuICAgIGJ1ZmZlci5wdXNoKGxhc3QpO1xuICAgIGNvbnN0IHVuZXNjYXBlZFN0ciA9IGJ1ZmZlci5qb2luKCcnKTtcbiAgICBzdGF0ZS50b2tlblZhbHVlID0gdW5lc2NhcGVkU3RyO1xuICAgIHJldHVybiA0MDk2IC8qIFN0cmluZ0xpdGVyYWwgKi87XG59XG5mdW5jdGlvbiBzY2FuVGVtcGxhdGUoc3RhdGUpIHtcbiAgICBsZXQgdGFpbCA9IHRydWU7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIHdoaWxlIChuZXh0Q2hhcihzdGF0ZSkgIT09IDk2IC8qIEJhY2t0aWNrICovKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50Q2hhciA9PT0gMzYgLyogRG9sbGFyICovKSB7XG4gICAgICAgICAgICBpZiAoKHN0YXRlLmluZGV4ICsgMSkgPCBzdGF0ZS5sZW5ndGggJiYgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5pbmRleCArIDEpID09PSAxMjMgLyogT3BlbkJyYWNlICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICAgICAgICAgICAgICB0YWlsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmN1cnJlbnRDaGFyID09PSA5MiAvKiBCYWNrc2xhc2ggKi8pIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlQ29kZShuZXh0Q2hhcihzdGF0ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbmRleCA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVudGVybWluYXRlZCB0ZW1wbGF0ZSBzdHJpbmc6ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXRlLmN1cnJlbnRDaGFyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgc3RhdGUudG9rZW5WYWx1ZSA9IHJlc3VsdDtcbiAgICBpZiAodGFpbCkge1xuICAgICAgICByZXR1cm4gNTQwNzE0IC8qIFRlbXBsYXRlVGFpbCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDU0MDcxNSAvKiBUZW1wbGF0ZUNvbnRpbnVhdGlvbiAqLztcbn1cbmZ1bmN0aW9uIHNjYW5UZW1wbGF0ZVRhaWwoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuaW5kZXggPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW50ZXJtaW5hdGVkIHRlbXBsYXRlIHN0cmluZzogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgIH1cbiAgICBzdGF0ZS5pbmRleC0tO1xuICAgIHJldHVybiBzY2FuVGVtcGxhdGUoc3RhdGUpO1xufVxuZnVuY3Rpb24gY29uc3VtZU9wdChzdGF0ZSwgdG9rZW4pIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSB0b2tlbikge1xuICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29uc3VtZShzdGF0ZSwgdG9rZW4pIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSB0b2tlbikge1xuICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGV4cGVjdGVkIHRva2VuOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgfVxufVxuLyoqXG4gKiBBcnJheSBmb3IgbWFwcGluZyB0b2tlbnMgdG8gdG9rZW4gdmFsdWVzLiBUaGUgaW5kaWNlcyBvZiB0aGUgdmFsdWVzXG4gKiBjb3JyZXNwb25kIHRvIHRoZSB0b2tlbiBiaXRzIDAtMzguXG4gKiBGb3IgdGhpcyB0byB3b3JrIHByb3Blcmx5LCB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBtdXN0IGJlIGtlcHQgaW5cbiAqIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB0b2tlbiBiaXRzLlxuICogVXNhZ2U6IFRva2VuVmFsdWVzW3Rva2VuICYgVG9rZW4uVHlwZV1cbiAqL1xuY29uc3QgVG9rZW5WYWx1ZXMgPSBbXG4gICAgJGZhbHNlLCAkdHJ1ZSwgJG51bGwsICR1bmRlZmluZWQsICckdGhpcycsICckaG9zdCcsICckcGFyZW50JyxcbiAgICAnKCcsICd7JywgJy4nLCAnfScsICcpJywgJywnLCAnWycsICddJywgJzonLCAnPycsICdcXCcnLCAnXCInLFxuICAgICcmJywgJ3wnLCAnfHwnLCAnJiYnLCAnPT0nLCAnIT0nLCAnPT09JywgJyE9PScsICc8JywgJz4nLFxuICAgICc8PScsICc+PScsICdpbicsICdpbnN0YW5jZW9mJywgJysnLCAnLScsICd0eXBlb2YnLCAndm9pZCcsICcqJywgJyUnLCAnLycsICc9JywgJyEnLFxuICAgIDU0MDcxNCAvKiBUZW1wbGF0ZVRhaWwgKi8sIDU0MDcxNSAvKiBUZW1wbGF0ZUNvbnRpbnVhdGlvbiAqLyxcbiAgICAnb2YnXG5dO1xuY29uc3QgS2V5d29yZExvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5LZXl3b3JkTG9va3VwLnRydWUgPSAyMDQ5IC8qIFRydWVLZXl3b3JkICovO1xuS2V5d29yZExvb2t1cC5udWxsID0gMjA1MCAvKiBOdWxsS2V5d29yZCAqLztcbktleXdvcmRMb29rdXAuZmFsc2UgPSAyMDQ4IC8qIEZhbHNlS2V5d29yZCAqLztcbktleXdvcmRMb29rdXAudW5kZWZpbmVkID0gMjA1MSAvKiBVbmRlZmluZWRLZXl3b3JkICovO1xuS2V5d29yZExvb2t1cC4kdGhpcyA9IDMwNzYgLyogVGhpc1Njb3BlICovO1xuS2V5d29yZExvb2t1cC4kaG9zdCA9IDMwNzcgLyogSG9zdFNjb3BlICovO1xuS2V5d29yZExvb2t1cC4kcGFyZW50ID0gMzA3OCAvKiBQYXJlbnRTY29wZSAqLztcbktleXdvcmRMb29rdXAuaW4gPSAxNjQwNzk5IC8qIEluS2V5d29yZCAqLztcbktleXdvcmRMb29rdXAuaW5zdGFuY2VvZiA9IDE2NDA4MDAgLyogSW5zdGFuY2VPZktleXdvcmQgKi87XG5LZXl3b3JkTG9va3VwLnR5cGVvZiA9IDM0ODUxIC8qIFR5cGVvZktleXdvcmQgKi87XG5LZXl3b3JkTG9va3VwLnZvaWQgPSAzNDg1MiAvKiBWb2lkS2V5d29yZCAqLztcbktleXdvcmRMb29rdXAub2YgPSAxMDUxMTgwIC8qIE9mS2V5d29yZCAqLztcbi8qKlxuICogUmFuZ2VzIG9mIGNvZGUgcG9pbnRzIGluIHBhaXJzIG9mIDIgKGVnIDB4NDEtMHg1QiwgMHg2MS0weDdCLCAuLi4pIHdoZXJlIHRoZSBzZWNvbmQgdmFsdWUgaXMgbm90IGluY2x1c2l2ZSAoNS03IG1lYW5zIDUgYW5kIDYpXG4gKiBTaW5nbGUgdmFsdWVzIGFyZSBkZW5vdGVkIGJ5IHRoZSBzZWNvbmQgdmFsdWUgYmVpbmcgYSAwXG4gKlxuICogQ29waWVkIGZyb20gb3V0cHV0IGdlbmVyYXRlZCB3aXRoIFwibm9kZSBidWlsZC9nZW5lcmF0ZS11bmljb2RlLmpzXCJcbiAqXG4gKiBTZWUgYWxzbzogaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvVW5pY29kZS9DaGFyYWN0ZXJfcmVmZXJlbmNlLzAwMDAtMEZGRlxuICovXG5jb25zdCBjb2RlcyA9IHtcbiAgICAvKiBbJDAtOUEtWmFfYS16XSAqL1xuICAgIEFzY2lpSWRQYXJ0OiBbMHgyNCwgMCwgMHgzMCwgMHgzQSwgMHg0MSwgMHg1QiwgMHg1RiwgMCwgMHg2MSwgMHg3Ql0sXG4gICAgSWRTdGFydDogLyogSWRlbnRpZmllclN0YXJ0ICovIFsweDI0LCAwLCAweDQxLCAweDVCLCAweDVGLCAwLCAweDYxLCAweDdCLCAweEFBLCAwLCAweEJBLCAwLCAweEMwLCAweEQ3LCAweEQ4LCAweEY3LCAweEY4LCAweDJCOSwgMHgyRTAsIDB4MkU1LCAweDFEMDAsIDB4MUQyNiwgMHgxRDJDLCAweDFENUQsIDB4MUQ2MiwgMHgxRDY2LCAweDFENkIsIDB4MUQ3OCwgMHgxRDc5LCAweDFEQkYsIDB4MUUwMCwgMHgxRjAwLCAweDIwNzEsIDAsIDB4MjA3RiwgMCwgMHgyMDkwLCAweDIwOUQsIDB4MjEyQSwgMHgyMTJDLCAweDIxMzIsIDAsIDB4MjE0RSwgMCwgMHgyMTYwLCAweDIxODksIDB4MkM2MCwgMHgyQzgwLCAweEE3MjIsIDB4QTc4OCwgMHhBNzhCLCAweEE3QUYsIDB4QTdCMCwgMHhBN0I4LCAweEE3RjcsIDB4QTgwMCwgMHhBQjMwLCAweEFCNUIsIDB4QUI1QywgMHhBQjY1LCAweEZCMDAsIDB4RkIwNywgMHhGRjIxLCAweEZGM0IsIDB4RkY0MSwgMHhGRjVCXSxcbiAgICBEaWdpdDogLyogRGVjaW1hbE51bWJlciAqLyBbMHgzMCwgMHgzQV0sXG4gICAgU2tpcDogLyogU2tpcHBhYmxlICovIFswLCAweDIxLCAweDdGLCAweEExXVxufTtcbi8qKlxuICogRGVjb21wcmVzcyB0aGUgcmFuZ2VzIGludG8gYW4gYXJyYXkgb2YgbnVtYmVycyBzbyB0aGF0IHRoZSBjaGFyIGNvZGVcbiAqIGNhbiBiZSB1c2VkIGFzIGFuIGluZGV4IHRvIHRoZSBsb29rdXBcbiAqL1xuZnVuY3Rpb24gZGVjb21wcmVzcyhsb29rdXAsICRzZXQsIGNvbXByZXNzZWQsIHZhbHVlKSB7XG4gICAgY29uc3QgcmFuZ2VDb3VudCA9IGNvbXByZXNzZWQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VDb3VudDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gY29tcHJlc3NlZFtpXTtcbiAgICAgICAgbGV0IGVuZCA9IGNvbXByZXNzZWRbaSArIDFdO1xuICAgICAgICBlbmQgPSBlbmQgPiAwID8gZW5kIDogc3RhcnQgKyAxO1xuICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICBsb29rdXAuZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRzZXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoID0gc3RhcnQ7IGNoIDwgZW5kOyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgJHNldC5hZGQoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gQ2hhckZ1bmNMb29rdXAgZnVuY3Rpb25zXG5mdW5jdGlvbiByZXR1cm5Ub2tlbih0b2tlbikge1xuICAgIHJldHVybiBzID0+IHtcbiAgICAgICAgbmV4dENoYXIocyk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xufVxuY29uc3QgdW5leHBlY3RlZENoYXJhY3RlciA9IHMgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICcke3MuaW5wdXR9J2ApO1xufTtcbnVuZXhwZWN0ZWRDaGFyYWN0ZXIubm90TWFwcGVkID0gdHJ1ZTtcbi8vIEFTQ0lJIElkZW50aWZpZXJQYXJ0IGxvb2t1cFxuY29uc3QgQXNjaWlJZFBhcnRzID0gbmV3IFNldCgpO1xuZGVjb21wcmVzcyhudWxsLCBBc2NpaUlkUGFydHMsIGNvZGVzLkFzY2lpSWRQYXJ0LCB0cnVlKTtcbi8vIElkZW50aWZpZXJQYXJ0IGxvb2t1cFxuY29uc3QgSWRQYXJ0cyA9IG5ldyBVaW50OEFycmF5KDB4RkZGRik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZGVjb21wcmVzcyhJZFBhcnRzLCBudWxsLCBjb2Rlcy5JZFN0YXJ0LCAxKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5kZWNvbXByZXNzKElkUGFydHMsIG51bGwsIGNvZGVzLkRpZ2l0LCAxKTtcbi8vIENoYXJhY3RlciBzY2FubmluZyBmdW5jdGlvbiBsb29rdXBcbmNvbnN0IENoYXJTY2FubmVycyA9IG5ldyBBcnJheSgweEZGRkYpO1xuQ2hhclNjYW5uZXJzLmZpbGwodW5leHBlY3RlZENoYXJhY3RlciwgMCwgMHhGRkZGKTtcbmRlY29tcHJlc3MoQ2hhclNjYW5uZXJzLCBudWxsLCBjb2Rlcy5Ta2lwLCBzID0+IHtcbiAgICBuZXh0Q2hhcihzKTtcbiAgICByZXR1cm4gbnVsbDtcbn0pO1xuZGVjb21wcmVzcyhDaGFyU2Nhbm5lcnMsIG51bGwsIGNvZGVzLklkU3RhcnQsIHNjYW5JZGVudGlmaWVyKTtcbmRlY29tcHJlc3MoQ2hhclNjYW5uZXJzLCBudWxsLCBjb2Rlcy5EaWdpdCwgcyA9PiBzY2FuTnVtYmVyKHMsIGZhbHNlKSk7XG5DaGFyU2Nhbm5lcnNbMzQgLyogRG91YmxlUXVvdGUgKi9dID1cbiAgICBDaGFyU2Nhbm5lcnNbMzkgLyogU2luZ2xlUXVvdGUgKi9dID0gcyA9PiB7XG4gICAgICAgIHJldHVybiBzY2FuU3RyaW5nKHMpO1xuICAgIH07XG5DaGFyU2Nhbm5lcnNbOTYgLyogQmFja3RpY2sgKi9dID0gcyA9PiB7XG4gICAgcmV0dXJuIHNjYW5UZW1wbGF0ZShzKTtcbn07XG4vLyAhLCAhPSwgIT09XG5DaGFyU2Nhbm5lcnNbMzMgLyogRXhjbGFtYXRpb24gKi9dID0gcyA9PiB7XG4gICAgaWYgKG5leHRDaGFyKHMpICE9PSA2MSAvKiBFcXVhbHMgKi8pIHtcbiAgICAgICAgcmV0dXJuIDMyODA5IC8qIEV4Y2xhbWF0aW9uICovO1xuICAgIH1cbiAgICBpZiAobmV4dENoYXIocykgIT09IDYxIC8qIEVxdWFscyAqLykge1xuICAgICAgICByZXR1cm4gMTYzODY4MCAvKiBFeGNsYW1hdGlvbkVxdWFscyAqLztcbiAgICB9XG4gICAgbmV4dENoYXIocyk7XG4gICAgcmV0dXJuIDE2Mzg2ODIgLyogRXhjbGFtYXRpb25FcXVhbHNFcXVhbHMgKi87XG59O1xuLy8gPSwgPT0sID09PVxuQ2hhclNjYW5uZXJzWzYxIC8qIEVxdWFscyAqL10gPSBzID0+IHtcbiAgICBpZiAobmV4dENoYXIocykgIT09IDYxIC8qIEVxdWFscyAqLykge1xuICAgICAgICByZXR1cm4gMTA0ODYxNiAvKiBFcXVhbHMgKi87XG4gICAgfVxuICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgIHJldHVybiAxNjM4Njc5IC8qIEVxdWFsc0VxdWFscyAqLztcbiAgICB9XG4gICAgbmV4dENoYXIocyk7XG4gICAgcmV0dXJuIDE2Mzg2ODEgLyogRXF1YWxzRXF1YWxzRXF1YWxzICovO1xufTtcbi8vICYsICYmXG5DaGFyU2Nhbm5lcnNbMzggLyogQW1wZXJzYW5kICovXSA9IHMgPT4ge1xuICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gMzggLyogQW1wZXJzYW5kICovKSB7XG4gICAgICAgIHJldHVybiAxNTcyODgzIC8qIEFtcGVyc2FuZCAqLztcbiAgICB9XG4gICAgbmV4dENoYXIocyk7XG4gICAgcmV0dXJuIDE2Mzg2MTQgLyogQW1wZXJzYW5kQW1wZXJzYW5kICovO1xufTtcbi8vIHwsIHx8XG5DaGFyU2Nhbm5lcnNbMTI0IC8qIEJhciAqL10gPSBzID0+IHtcbiAgICBpZiAobmV4dENoYXIocykgIT09IDEyNCAvKiBCYXIgKi8pIHtcbiAgICAgICAgcmV0dXJuIDE1NzI4ODQgLyogQmFyICovO1xuICAgIH1cbiAgICBuZXh0Q2hhcihzKTtcbiAgICByZXR1cm4gMTYzODU0OSAvKiBCYXJCYXIgKi87XG59O1xuLy8gLlxuQ2hhclNjYW5uZXJzWzQ2IC8qIERvdCAqL10gPSBzID0+IHtcbiAgICBpZiAobmV4dENoYXIocykgPD0gNTcgLyogTmluZSAqLyAmJiBzLmN1cnJlbnRDaGFyID49IDQ4IC8qIFplcm8gKi8pIHtcbiAgICAgICAgcmV0dXJuIHNjYW5OdW1iZXIocywgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiAxNjM5MyAvKiBEb3QgKi87XG59O1xuLy8gPCwgPD1cbkNoYXJTY2FubmVyc1s2MCAvKiBMZXNzVGhhbiAqL10gPSBzID0+IHtcbiAgICBpZiAobmV4dENoYXIocykgIT09IDYxIC8qIEVxdWFscyAqLykge1xuICAgICAgICByZXR1cm4gMTYzODc0NyAvKiBMZXNzVGhhbiAqLztcbiAgICB9XG4gICAgbmV4dENoYXIocyk7XG4gICAgcmV0dXJuIDE2Mzg3NDkgLyogTGVzc1RoYW5FcXVhbHMgKi87XG59O1xuLy8gPiwgPj1cbkNoYXJTY2FubmVyc1s2MiAvKiBHcmVhdGVyVGhhbiAqL10gPSBzID0+IHtcbiAgICBpZiAobmV4dENoYXIocykgIT09IDYxIC8qIEVxdWFscyAqLykge1xuICAgICAgICByZXR1cm4gMTYzODc0OCAvKiBHcmVhdGVyVGhhbiAqLztcbiAgICB9XG4gICAgbmV4dENoYXIocyk7XG4gICAgcmV0dXJuIDE2Mzg3NTAgLyogR3JlYXRlclRoYW5FcXVhbHMgKi87XG59O1xuQ2hhclNjYW5uZXJzWzM3IC8qIFBlcmNlbnQgKi9dID0gcmV0dXJuVG9rZW4oMTYzODg4NiAvKiBQZXJjZW50ICovKTtcbkNoYXJTY2FubmVyc1s0MCAvKiBPcGVuUGFyZW4gKi9dID0gcmV0dXJuVG9rZW4oNjcxNzUxIC8qIE9wZW5QYXJlbiAqLyk7XG5DaGFyU2Nhbm5lcnNbNDEgLyogQ2xvc2VQYXJlbiAqL10gPSByZXR1cm5Ub2tlbigxODM1MDE5IC8qIENsb3NlUGFyZW4gKi8pO1xuQ2hhclNjYW5uZXJzWzQyIC8qIEFzdGVyaXNrICovXSA9IHJldHVyblRva2VuKDE2Mzg4ODUgLyogQXN0ZXJpc2sgKi8pO1xuQ2hhclNjYW5uZXJzWzQzIC8qIFBsdXMgKi9dID0gcmV0dXJuVG9rZW4oNjIzMDA5IC8qIFBsdXMgKi8pO1xuQ2hhclNjYW5uZXJzWzQ0IC8qIENvbW1hICovXSA9IHJldHVyblRva2VuKDE1NzI4NzYgLyogQ29tbWEgKi8pO1xuQ2hhclNjYW5uZXJzWzQ1IC8qIE1pbnVzICovXSA9IHJldHVyblRva2VuKDYyMzAxMCAvKiBNaW51cyAqLyk7XG5DaGFyU2Nhbm5lcnNbNDcgLyogU2xhc2ggKi9dID0gcmV0dXJuVG9rZW4oMTYzODg4NyAvKiBTbGFzaCAqLyk7XG5DaGFyU2Nhbm5lcnNbNTggLyogQ29sb24gKi9dID0gcmV0dXJuVG9rZW4oMTU3Mjg3OSAvKiBDb2xvbiAqLyk7XG5DaGFyU2Nhbm5lcnNbNjMgLyogUXVlc3Rpb24gKi9dID0gcmV0dXJuVG9rZW4oMTU3Mjg4MCAvKiBRdWVzdGlvbiAqLyk7XG5DaGFyU2Nhbm5lcnNbOTEgLyogT3BlbkJyYWNrZXQgKi9dID0gcmV0dXJuVG9rZW4oNjcxNzU3IC8qIE9wZW5CcmFja2V0ICovKTtcbkNoYXJTY2FubmVyc1s5MyAvKiBDbG9zZUJyYWNrZXQgKi9dID0gcmV0dXJuVG9rZW4oMTgzNTAyMiAvKiBDbG9zZUJyYWNrZXQgKi8pO1xuQ2hhclNjYW5uZXJzWzEyMyAvKiBPcGVuQnJhY2UgKi9dID0gcmV0dXJuVG9rZW4oMTMxMDgwIC8qIE9wZW5CcmFjZSAqLyk7XG5DaGFyU2Nhbm5lcnNbMTI1IC8qIENsb3NlQnJhY2UgKi9dID0gcmV0dXJuVG9rZW4oMTgzNTAxOCAvKiBDbG9zZUJyYWNlICovKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cHJlc3Npb24tcGFyc2VyLmpzLm1hcCIsImV4cG9ydCB7IElQbGF0Zm9ybSwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IHsgUGxhdGZvcm0sIFRhc2tRdWV1ZSwgVGFzaywgVGFza0Fib3J0RXJyb3IsIFRhc2tRdWV1ZVByaW9yaXR5LCBUYXNrU3RhdHVzLCB9IGZyb20gJ0BhdXJlbGlhL3BsYXRmb3JtJztcbmV4cG9ydCB7IGFsaWFzLCByZWdpc3RlckFsaWFzZXMsIH0gZnJvbSAnLi9hbGlhcy5qcyc7XG5leHBvcnQgeyBFeHByZXNzaW9uS2luZCwgQ2FsbEZ1bmN0aW9uRXhwcmVzc2lvbiwgQ3VzdG9tRXhwcmVzc2lvbiwgQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbiwgVmFsdWVDb252ZXJ0ZXJFeHByZXNzaW9uLCBBc3NpZ25FeHByZXNzaW9uLCBDb25kaXRpb25hbEV4cHJlc3Npb24sIEFjY2Vzc1RoaXNFeHByZXNzaW9uLCBBY2Nlc3NTY29wZUV4cHJlc3Npb24sIEFjY2Vzc01lbWJlckV4cHJlc3Npb24sIEFjY2Vzc0tleWVkRXhwcmVzc2lvbiwgQ2FsbFNjb3BlRXhwcmVzc2lvbiwgQ2FsbE1lbWJlckV4cHJlc3Npb24sIEJpbmFyeUV4cHJlc3Npb24sIFVuYXJ5RXhwcmVzc2lvbiwgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24sIEh0bWxMaXRlcmFsRXhwcmVzc2lvbiwgQXJyYXlMaXRlcmFsRXhwcmVzc2lvbiwgT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24sIFRlbXBsYXRlRXhwcmVzc2lvbiwgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLCBBcnJheUJpbmRpbmdQYXR0ZXJuLCBPYmplY3RCaW5kaW5nUGF0dGVybiwgQmluZGluZ0lkZW50aWZpZXIsIEZvck9mU3RhdGVtZW50LCBJbnRlcnBvbGF0aW9uLCB9IGZyb20gJy4vYmluZGluZy9hc3QuanMnO1xuZXhwb3J0IHsgY29ubmVjdGFibGUsIEJpbmRpbmdNZWRpYXRvciwgQmluZGluZ09ic2VydmVyUmVjb3JkLCB9IGZyb20gJy4vYmluZGluZy9jb25uZWN0YWJsZS5qcyc7XG5leHBvcnQgeyBJRXhwcmVzc2lvblBhcnNlciwgQmluZGluZ1R5cGUsIHBhcnNlRXhwcmVzc2lvbiwgQ2hhciwgQWNjZXNzLCBQcmVjZWRlbmNlLCBwYXJzZSwgUGFyc2VyU3RhdGUsIH0gZnJvbSAnLi9iaW5kaW5nL2V4cHJlc3Npb24tcGFyc2VyLmpzJztcbmV4cG9ydCB7IEFycmF5T2JzZXJ2ZXIsIEFycmF5SW5kZXhPYnNlcnZlciwgZW5hYmxlQXJyYXlPYnNlcnZhdGlvbiwgZGlzYWJsZUFycmF5T2JzZXJ2YXRpb24sIGFwcGx5TXV0YXRpb25zVG9JbmRpY2VzLCBzeW5jaHJvbml6ZUluZGljZXMsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9hcnJheS1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBNYXBPYnNlcnZlciwgZW5hYmxlTWFwT2JzZXJ2YXRpb24sIGRpc2FibGVNYXBPYnNlcnZhdGlvbiwgfSBmcm9tICcuL29ic2VydmF0aW9uL21hcC1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBTZXRPYnNlcnZlciwgZW5hYmxlU2V0T2JzZXJ2YXRpb24sIGRpc2FibGVTZXRPYnNlcnZhdGlvbiB9IGZyb20gJy4vb2JzZXJ2YXRpb24vc2V0LW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IEJpbmRpbmdDb250ZXh0LCBTY29wZSwgT3ZlcnJpZGVDb250ZXh0LCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vYmluZGluZy1jb250ZXh0LmpzJztcbmV4cG9ydCB7IENvbGxlY3Rpb25MZW5ndGhPYnNlcnZlciwgQ29sbGVjdGlvblNpemVPYnNlcnZlciwgfSBmcm9tICcuL29ic2VydmF0aW9uL2NvbGxlY3Rpb24tbGVuZ3RoLW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IENvbXB1dGVkT2JzZXJ2ZXIsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9jb21wdXRlZC1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBJRGlydHlDaGVja2VyLCBEaXJ0eUNoZWNrUHJvcGVydHksIERpcnR5Q2hlY2tTZXR0aW5ncywgfSBmcm9tICcuL29ic2VydmF0aW9uL2RpcnR5LWNoZWNrZXIuanMnO1xuZXhwb3J0IHsgb2JzZXJ2YWJsZSwgfSBmcm9tICcuL29ic2VydmF0aW9uL29ic2VydmFibGUuanMnO1xuZXhwb3J0IHsgSU9ic2VydmVyTG9jYXRvciwgSU5vZGVPYnNlcnZlckxvY2F0b3IsIGdldENvbGxlY3Rpb25PYnNlcnZlciwgT2JzZXJ2ZXJMb2NhdG9yLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vb2JzZXJ2ZXItbG9jYXRvci5qcyc7XG5leHBvcnQgeyBQcmltaXRpdmVPYnNlcnZlciwgfSBmcm9tICcuL29ic2VydmF0aW9uL3ByaW1pdGl2ZS1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBQcm9wZXJ0eUFjY2Vzc29yLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vcHJvcGVydHktYWNjZXNzb3IuanMnO1xuZXhwb3J0IHsgUHJveHlPYnNlcnZhYmxlLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vcHJveHktb2JzZXJ2YXRpb24uanMnO1xuZXhwb3J0IHsgU2V0dGVyT2JzZXJ2ZXIsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9zZXR0ZXItb2JzZXJ2ZXIuanMnO1xuZXhwb3J0IHsgSVNpZ25hbGVyLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vc2lnbmFsZXIuanMnO1xuZXhwb3J0IHsgU3Vic2NyaWJlclJlY29yZCwgc3Vic2NyaWJlckNvbGxlY3Rpb24sIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9zdWJzY3JpYmVyLWNvbGxlY3Rpb24uanMnO1xuZXhwb3J0IHsgQ29ubmVjdGFibGVTd2l0Y2hlciwgfSBmcm9tICcuL29ic2VydmF0aW9uL2Nvbm5lY3RhYmxlLXN3aXRjaGVyLmpzJztcbmV4cG9ydCB7IGJpbmRpbmdCZWhhdmlvciwgQmluZGluZ0JlaGF2aW9yLCBCaW5kaW5nQmVoYXZpb3JEZWZpbml0aW9uLCBCaW5kaW5nSW50ZXJjZXB0b3IsIEJpbmRpbmdCZWhhdmlvckZhY3RvcnksIEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5LCB9IGZyb20gJy4vYmluZGluZy1iZWhhdmlvci5qcyc7XG5leHBvcnQgeyBWYWx1ZUNvbnZlcnRlciwgVmFsdWVDb252ZXJ0ZXJEZWZpbml0aW9uLCB2YWx1ZUNvbnZlcnRlciwgfSBmcm9tICcuL3ZhbHVlLWNvbnZlcnRlci5qcyc7XG5leHBvcnQgeyBCaW5kaW5nTW9kZSwgTGlmZWN5Y2xlRmxhZ3MsIEFjY2Vzc29yVHlwZSwgQ29sbGVjdGlvbktpbmQsIERlbGVnYXRpb25TdHJhdGVneSwgaXNJbmRleE1hcCwgY29weUluZGV4TWFwLCBjbG9uZUluZGV4TWFwLCBjcmVhdGVJbmRleE1hcCwgfSBmcm9tICcuL29ic2VydmF0aW9uLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qXG4qIE5vdGU6IHRoZSBvbmVUaW1lIGJpbmRpbmcgbm93IGhhcyBhIG5vbi16ZXJvIHZhbHVlIGZvciAyIHJlYXNvbnM6XG4qICAtIHBsYXlzIG5pY2VyIHdpdGggYml0d2lzZSBvcGVyYXRpb25zIChtb3JlIGNvbnNpc3RlbnQgY29kZSwgbW9yZSBleHBsaWNpdCBzZXR0aW5ncylcbiogIC0gYWxsb3dzIGZvciBwb3RlbnRpYWxseSBoYXZpbmcgc29tZXRoaW5nIGxpa2UgQmluZGluZ01vZGUub25lVGltZSB8IEJpbmRpbmdNb2RlLmZyb21WaWV3LCB3aGVyZSBhbiBpbml0aWFsIHZhbHVlIGlzIHNldCBvbmNlIHRvIHRoZSB2aWV3IGJ1dCB1cGRhdGVzIGZyb20gdGhlIHZpZXcgYWxzbyBwcm9wYWdhdGUgYmFjayB0byB0aGUgdmlldyBtb2RlbFxuKlxuKiBGdXJ0aGVybW9yZSwgdGhlIFwiZGVmYXVsdFwiIG1vZGUgd291bGQgYmUgZm9yIHNpbXBsZSBcIi5iaW5kXCIgZXhwcmVzc2lvbnMgdG8gbWFrZSBpdCBleHBsaWNpdCBmb3Igb3VyIGxvZ2ljIHRoYXQgdGhlIGRlZmF1bHQgaXMgYmVpbmcgdXNlZC5cbiogVGhpcyBlc3NlbnRpYWxseSBhZGRzIGV4dHJhIGluZm9ybWF0aW9uIHdoaWNoIGJpbmRpbmcgY291bGQgdXNlIHRvIGRvIHNtYXJ0ZXIgdGhpbmdzIGFuZCBhbGxvd3MgYmluZGluZ0JlaGF2aW9ycyB0aGF0IGFkZCBhIG1vZGUgaW5zdGVhZCBvZiBzaW1wbHkgb3ZlcndyaXRpbmcgaXRcbiovXG5leHBvcnQgdmFyIEJpbmRpbmdNb2RlO1xuKGZ1bmN0aW9uIChCaW5kaW5nTW9kZSkge1xuICAgIEJpbmRpbmdNb2RlW0JpbmRpbmdNb2RlW1wib25lVGltZVwiXSA9IDFdID0gXCJvbmVUaW1lXCI7XG4gICAgQmluZGluZ01vZGVbQmluZGluZ01vZGVbXCJ0b1ZpZXdcIl0gPSAyXSA9IFwidG9WaWV3XCI7XG4gICAgQmluZGluZ01vZGVbQmluZGluZ01vZGVbXCJmcm9tVmlld1wiXSA9IDRdID0gXCJmcm9tVmlld1wiO1xuICAgIEJpbmRpbmdNb2RlW0JpbmRpbmdNb2RlW1widHdvV2F5XCJdID0gNl0gPSBcInR3b1dheVwiO1xuICAgIEJpbmRpbmdNb2RlW0JpbmRpbmdNb2RlW1wiZGVmYXVsdFwiXSA9IDhdID0gXCJkZWZhdWx0XCI7XG59KShCaW5kaW5nTW9kZSB8fCAoQmluZGluZ01vZGUgPSB7fSkpO1xuZXhwb3J0IHZhciBMaWZlY3ljbGVGbGFncztcbihmdW5jdGlvbiAoTGlmZWN5Y2xlRmxhZ3MpIHtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgIC8vIEJpdG1hc2sgZm9yIGZsYWdzIHRoYXQgbmVlZCB0byBiZSBzdG9yZWQgb24gYSBiaW5kaW5nIGR1cmluZyAkYmluZCBmb3IgbXV0YXRpb25cbiAgICAvLyBjYWxsYmFja3Mgb3V0c2lkZSBvZiAkYmluZFxuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wicGVyc2lzdGVudEJpbmRpbmdGbGFnc1wiXSA9IDE1MzY3XSA9IFwicGVyc2lzdGVudEJpbmRpbmdGbGFnc1wiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiYWxsb3dQYXJlbnRTY29wZVRyYXZlcnNhbFwiXSA9IDEwMjRdID0gXCJhbGxvd1BhcmVudFNjb3BlVHJhdmVyc2FsXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJvYnNlcnZlTGVhZlByb3BlcnRpZXNPbmx5XCJdID0gMjA0OF0gPSBcIm9ic2VydmVMZWFmUHJvcGVydGllc09ubHlcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcInRhcmdldE9ic2VydmVyRmxhZ3NcIl0gPSAxMjI5NV0gPSBcInRhcmdldE9ic2VydmVyRmxhZ3NcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcIm5vRmx1c2hcIl0gPSA0MDk2XSA9IFwibm9GbHVzaFwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wicGVyc2lzdGVudFRhcmdldE9ic2VydmVyUXVldWVcIl0gPSA4MTkyXSA9IFwicGVyc2lzdGVudFRhcmdldE9ic2VydmVyUXVldWVcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImJpbmRpbmdTdHJhdGVneVwiXSA9IDddID0gXCJiaW5kaW5nU3RyYXRlZ3lcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImdldHRlclNldHRlclN0cmF0ZWd5XCJdID0gMV0gPSBcImdldHRlclNldHRlclN0cmF0ZWd5XCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJwcm94eVN0cmF0ZWd5XCJdID0gMl0gPSBcInByb3h5U3RyYXRlZ3lcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImlzU3RyaWN0QmluZGluZ1N0cmF0ZWd5XCJdID0gNF0gPSBcImlzU3RyaWN0QmluZGluZ1N0cmF0ZWd5XCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJ1cGRhdGVcIl0gPSAyNF0gPSBcInVwZGF0ZVwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1widXBkYXRlVGFyZ2V0XCJdID0gOF0gPSBcInVwZGF0ZVRhcmdldFwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1widXBkYXRlU291cmNlXCJdID0gMTZdID0gXCJ1cGRhdGVTb3VyY2VcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21cIl0gPSA5Nl0gPSBcImZyb21cIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21CaW5kXCJdID0gMzJdID0gXCJmcm9tQmluZFwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbVVuYmluZFwiXSA9IDY0XSA9IFwiZnJvbVVuYmluZFwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wibXVzdEV2YWx1YXRlXCJdID0gMTI4XSA9IFwibXVzdEV2YWx1YXRlXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJpc1RyYXZlcnNpbmdQYXJlbnRTY29wZVwiXSA9IDI1Nl0gPSBcImlzVHJhdmVyc2luZ1BhcmVudFNjb3BlXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJkaXNwb3NlXCJdID0gNTEyXSA9IFwiZGlzcG9zZVwiO1xufSkoTGlmZWN5Y2xlRmxhZ3MgfHwgKExpZmVjeWNsZUZsYWdzID0ge30pKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB2YXIgU3Vic2NyaWJlckZsYWdzO1xuKGZ1bmN0aW9uIChTdWJzY3JpYmVyRmxhZ3MpIHtcbiAgICBTdWJzY3JpYmVyRmxhZ3NbU3Vic2NyaWJlckZsYWdzW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgU3Vic2NyaWJlckZsYWdzW1N1YnNjcmliZXJGbGFnc1tcIlN1YnNjcmliZXIwXCJdID0gMV0gPSBcIlN1YnNjcmliZXIwXCI7XG4gICAgU3Vic2NyaWJlckZsYWdzW1N1YnNjcmliZXJGbGFnc1tcIlN1YnNjcmliZXIxXCJdID0gMl0gPSBcIlN1YnNjcmliZXIxXCI7XG4gICAgU3Vic2NyaWJlckZsYWdzW1N1YnNjcmliZXJGbGFnc1tcIlN1YnNjcmliZXIyXCJdID0gNF0gPSBcIlN1YnNjcmliZXIyXCI7XG4gICAgU3Vic2NyaWJlckZsYWdzW1N1YnNjcmliZXJGbGFnc1tcIlN1YnNjcmliZXJzUmVzdFwiXSA9IDhdID0gXCJTdWJzY3JpYmVyc1Jlc3RcIjtcbiAgICBTdWJzY3JpYmVyRmxhZ3NbU3Vic2NyaWJlckZsYWdzW1wiQW55XCJdID0gMTVdID0gXCJBbnlcIjtcbn0pKFN1YnNjcmliZXJGbGFncyB8fCAoU3Vic2NyaWJlckZsYWdzID0ge30pKTtcbmV4cG9ydCB2YXIgRGVsZWdhdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChEZWxlZ2F0aW9uU3RyYXRlZ3kpIHtcbiAgICBEZWxlZ2F0aW9uU3RyYXRlZ3lbRGVsZWdhdGlvblN0cmF0ZWd5W1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgRGVsZWdhdGlvblN0cmF0ZWd5W0RlbGVnYXRpb25TdHJhdGVneVtcImNhcHR1cmluZ1wiXSA9IDFdID0gXCJjYXB0dXJpbmdcIjtcbiAgICBEZWxlZ2F0aW9uU3RyYXRlZ3lbRGVsZWdhdGlvblN0cmF0ZWd5W1wiYnViYmxpbmdcIl0gPSAyXSA9IFwiYnViYmxpbmdcIjtcbn0pKERlbGVnYXRpb25TdHJhdGVneSB8fCAoRGVsZWdhdGlvblN0cmF0ZWd5ID0ge30pKTtcbmV4cG9ydCB2YXIgQ29sbGVjdGlvbktpbmQ7XG4oZnVuY3Rpb24gKENvbGxlY3Rpb25LaW5kKSB7XG4gICAgQ29sbGVjdGlvbktpbmRbQ29sbGVjdGlvbktpbmRbXCJpbmRleGVkXCJdID0gOF0gPSBcImluZGV4ZWRcIjtcbiAgICBDb2xsZWN0aW9uS2luZFtDb2xsZWN0aW9uS2luZFtcImtleWVkXCJdID0gNF0gPSBcImtleWVkXCI7XG4gICAgQ29sbGVjdGlvbktpbmRbQ29sbGVjdGlvbktpbmRbXCJhcnJheVwiXSA9IDldID0gXCJhcnJheVwiO1xuICAgIENvbGxlY3Rpb25LaW5kW0NvbGxlY3Rpb25LaW5kW1wibWFwXCJdID0gNl0gPSBcIm1hcFwiO1xuICAgIENvbGxlY3Rpb25LaW5kW0NvbGxlY3Rpb25LaW5kW1wic2V0XCJdID0gN10gPSBcInNldFwiO1xufSkoQ29sbGVjdGlvbktpbmQgfHwgKENvbGxlY3Rpb25LaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgQWNjZXNzb3JUeXBlO1xuKGZ1bmN0aW9uIChBY2Nlc3NvclR5cGUpIHtcbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgQWNjZXNzb3JUeXBlW0FjY2Vzc29yVHlwZVtcIk9ic2VydmVyXCJdID0gMV0gPSBcIk9ic2VydmVyXCI7XG4gICAgQWNjZXNzb3JUeXBlW0FjY2Vzc29yVHlwZVtcIk5vZGVcIl0gPSAyXSA9IFwiTm9kZVwiO1xuICAgIC8vIG1pc2MgY2hhcmFjdGVyaXN0aWMgb2YgYWNjZXNzb3JzL29ic2VydmVycyB3aGVuIHVwZGF0ZVxuICAgIC8vXG4gICAgLy8gYnkgZGVmYXVsdCwgZXZlcnl0aGluZyBpcyBzeW5jaHJvbm91c1xuICAgIC8vIGV4Y2VwdCBjaGFuZ2VzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIGNhdXNlIHJlZmxvdy9oZWF2eSBjb21wdXRhdGlvblxuICAgIC8vIGFuIG9ic2VydmVyIGNhbiB1c2UgdGhpcyBmbGFnIHRvIHNpZ25hbCBiaW5kaW5nIHRoYXQgZG9uJ3QgY2FyZWxlc3NseSB0ZWxsIGl0IHRvIHVwZGF0ZVxuICAgIC8vIHF1ZXVlIGl0IGluc3RlYWRcbiAgICAvLyB0b2RvOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNWQ1MmZiMDgxYjM1NzBjODFlM2FcbiAgICAvLyB0b2RvOiBodHRwczovL2Nzc3RyaWdnZXJzLmNvbS9cbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiTGF5b3V0XCJdID0gNF0gPSBcIkxheW91dFwiO1xuICAgIC8vIGJ5IGRlZmF1bHQsIGV2ZXJ5dGhpbmcgaXMgYW4gb2JqZWN0XG4gICAgLy8gZWc6IGEgcHJvcGVydHkgaXMgYWNjZXNzZWQgb24gYW4gb2JqZWN0XG4gICAgLy8gdW5sZXNzIGV4cGxpY2l0bHkgbm90IHNvXG4gICAgQWNjZXNzb3JUeXBlW0FjY2Vzc29yVHlwZVtcIlByaW10aXZlXCJdID0gOF0gPSBcIlByaW10aXZlXCI7XG4gICAgQWNjZXNzb3JUeXBlW0FjY2Vzc29yVHlwZVtcIkFycmF5XCJdID0gMThdID0gXCJBcnJheVwiO1xuICAgIEFjY2Vzc29yVHlwZVtBY2Nlc3NvclR5cGVbXCJTZXRcIl0gPSAzNF0gPSBcIlNldFwiO1xuICAgIEFjY2Vzc29yVHlwZVtBY2Nlc3NvclR5cGVbXCJNYXBcIl0gPSA2Nl0gPSBcIk1hcFwiO1xufSkoQWNjZXNzb3JUeXBlIHx8IChBY2Nlc3NvclR5cGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlJbmRleE1hcChleGlzdGluZywgZGVsZXRlZEl0ZW1zKSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGV4aXN0aW5nO1xuICAgIGNvbnN0IGFyciA9IEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycltpXSA9IGV4aXN0aW5nW2ldO1xuICAgICAgICArK2k7XG4gICAgfVxuICAgIGlmIChkZWxldGVkSXRlbXMgIT09IHZvaWQgMCkge1xuICAgICAgICBhcnIuZGVsZXRlZEl0ZW1zID0gZGVsZXRlZEl0ZW1zLnNsaWNlKDApO1xuICAgIH1cbiAgICBlbHNlIGlmIChleGlzdGluZy5kZWxldGVkSXRlbXMgIT09IHZvaWQgMCkge1xuICAgICAgICBhcnIuZGVsZXRlZEl0ZW1zID0gZXhpc3RpbmcuZGVsZXRlZEl0ZW1zLnNsaWNlKDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJyLmRlbGV0ZWRJdGVtcyA9IFtdO1xuICAgIH1cbiAgICBhcnIuaXNJbmRleE1hcCA9IHRydWU7XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbmRleE1hcChsZW5ndGggPSAwKSB7XG4gICAgY29uc3QgYXJyID0gQXJyYXkobGVuZ3RoKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyW2ldID0gaSsrO1xuICAgIH1cbiAgICBhcnIuZGVsZXRlZEl0ZW1zID0gW107XG4gICAgYXJyLmlzSW5kZXhNYXAgPSB0cnVlO1xuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xvbmVJbmRleE1hcChpbmRleE1hcCkge1xuICAgIGNvbnN0IGNsb25lID0gaW5kZXhNYXAuc2xpY2UoKTtcbiAgICBjbG9uZS5kZWxldGVkSXRlbXMgPSBpbmRleE1hcC5kZWxldGVkSXRlbXMuc2xpY2UoKTtcbiAgICBjbG9uZS5pc0luZGV4TWFwID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xvbmU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNJbmRleE1hcCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmlzSW5kZXhNYXAgPT09IHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVJbmRleE1hcCwgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi5qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uTGVuZ3RoT2JzZXJ2ZXIsIH0gZnJvbSAnLi9jb2xsZWN0aW9uLWxlbmd0aC1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiwgfSBmcm9tICcuL3N1YnNjcmliZXItY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBkZWYsIGRlZmluZUhpZGRlblByb3AgfSBmcm9tICcuLi91dGlsaXRpZXMtb2JqZWN0cy5qcyc7XG5jb25zdCBvYnNlcnZlckxvb2t1cCA9IG5ldyBXZWFrTWFwKCk7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zb3J0Y29tcGFyZVxuZnVuY3Rpb24gc29ydENvbXBhcmUoeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB4ID0geCA9PT0gbnVsbCA/ICdudWxsJyA6IHgudG9TdHJpbmcoKTtcbiAgICB5ID0geSA9PT0gbnVsbCA/ICdudWxsJyA6IHkudG9TdHJpbmcoKTtcbiAgICByZXR1cm4geCA8IHkgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBwcmVTb3J0Q29tcGFyZSh4LCB5KSB7XG4gICAgaWYgKHggPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh5ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGluc2VydGlvblNvcnQoYXJyLCBpbmRleE1hcCwgZnJvbSwgdG8sIGNvbXBhcmVGbikge1xuICAgIGxldCB2ZWxlbWVudCwgaWVsZW1lbnQsIHZ0bXAsIGl0bXAsIG9yZGVyO1xuICAgIGxldCBpLCBqO1xuICAgIGZvciAoaSA9IGZyb20gKyAxOyBpIDwgdG87IGkrKykge1xuICAgICAgICB2ZWxlbWVudCA9IGFycltpXTtcbiAgICAgICAgaWVsZW1lbnQgPSBpbmRleE1hcFtpXTtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gZnJvbTsgai0tKSB7XG4gICAgICAgICAgICB2dG1wID0gYXJyW2pdO1xuICAgICAgICAgICAgaXRtcCA9IGluZGV4TWFwW2pdO1xuICAgICAgICAgICAgb3JkZXIgPSBjb21wYXJlRm4odnRtcCwgdmVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKG9yZGVyID4gMCkge1xuICAgICAgICAgICAgICAgIGFycltqICsgMV0gPSB2dG1wO1xuICAgICAgICAgICAgICAgIGluZGV4TWFwW2ogKyAxXSA9IGl0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcnJbaiArIDFdID0gdmVsZW1lbnQ7XG4gICAgICAgIGluZGV4TWFwW2ogKyAxXSA9IGllbGVtZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1aWNrU29ydChhcnIsIGluZGV4TWFwLCBmcm9tLCB0bywgY29tcGFyZUZuKSB7XG4gICAgbGV0IHRoaXJkSW5kZXggPSAwLCBpID0gMDtcbiAgICBsZXQgdjAsIHYxLCB2MjtcbiAgICBsZXQgaTAsIGkxLCBpMjtcbiAgICBsZXQgYzAxLCBjMDIsIGMxMjtcbiAgICBsZXQgdnRtcCwgaXRtcDtcbiAgICBsZXQgdnBpdm90LCBpcGl2b3QsIGxvd0VuZCwgaGlnaFN0YXJ0O1xuICAgIGxldCB2ZWxlbWVudCwgaWVsZW1lbnQsIG9yZGVyLCB2dG9wRWxlbWVudDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHRvIC0gZnJvbSA8PSAxMCkge1xuICAgICAgICAgICAgaW5zZXJ0aW9uU29ydChhcnIsIGluZGV4TWFwLCBmcm9tLCB0bywgY29tcGFyZUZuKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlyZEluZGV4ID0gZnJvbSArICgodG8gLSBmcm9tKSA+PiAxKTtcbiAgICAgICAgdjAgPSBhcnJbZnJvbV07XG4gICAgICAgIGkwID0gaW5kZXhNYXBbZnJvbV07XG4gICAgICAgIHYxID0gYXJyW3RvIC0gMV07XG4gICAgICAgIGkxID0gaW5kZXhNYXBbdG8gLSAxXTtcbiAgICAgICAgdjIgPSBhcnJbdGhpcmRJbmRleF07XG4gICAgICAgIGkyID0gaW5kZXhNYXBbdGhpcmRJbmRleF07XG4gICAgICAgIGMwMSA9IGNvbXBhcmVGbih2MCwgdjEpO1xuICAgICAgICBpZiAoYzAxID4gMCkge1xuICAgICAgICAgICAgdnRtcCA9IHYwO1xuICAgICAgICAgICAgaXRtcCA9IGkwO1xuICAgICAgICAgICAgdjAgPSB2MTtcbiAgICAgICAgICAgIGkwID0gaTE7XG4gICAgICAgICAgICB2MSA9IHZ0bXA7XG4gICAgICAgICAgICBpMSA9IGl0bXA7XG4gICAgICAgIH1cbiAgICAgICAgYzAyID0gY29tcGFyZUZuKHYwLCB2Mik7XG4gICAgICAgIGlmIChjMDIgPj0gMCkge1xuICAgICAgICAgICAgdnRtcCA9IHYwO1xuICAgICAgICAgICAgaXRtcCA9IGkwO1xuICAgICAgICAgICAgdjAgPSB2MjtcbiAgICAgICAgICAgIGkwID0gaTI7XG4gICAgICAgICAgICB2MiA9IHYxO1xuICAgICAgICAgICAgaTIgPSBpMTtcbiAgICAgICAgICAgIHYxID0gdnRtcDtcbiAgICAgICAgICAgIGkxID0gaXRtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGMxMiA9IGNvbXBhcmVGbih2MSwgdjIpO1xuICAgICAgICAgICAgaWYgKGMxMiA+IDApIHtcbiAgICAgICAgICAgICAgICB2dG1wID0gdjE7XG4gICAgICAgICAgICAgICAgaXRtcCA9IGkxO1xuICAgICAgICAgICAgICAgIHYxID0gdjI7XG4gICAgICAgICAgICAgICAgaTEgPSBpMjtcbiAgICAgICAgICAgICAgICB2MiA9IHZ0bXA7XG4gICAgICAgICAgICAgICAgaTIgPSBpdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFycltmcm9tXSA9IHYwO1xuICAgICAgICBpbmRleE1hcFtmcm9tXSA9IGkwO1xuICAgICAgICBhcnJbdG8gLSAxXSA9IHYyO1xuICAgICAgICBpbmRleE1hcFt0byAtIDFdID0gaTI7XG4gICAgICAgIHZwaXZvdCA9IHYxO1xuICAgICAgICBpcGl2b3QgPSBpMTtcbiAgICAgICAgbG93RW5kID0gZnJvbSArIDE7XG4gICAgICAgIGhpZ2hTdGFydCA9IHRvIC0gMTtcbiAgICAgICAgYXJyW3RoaXJkSW5kZXhdID0gYXJyW2xvd0VuZF07XG4gICAgICAgIGluZGV4TWFwW3RoaXJkSW5kZXhdID0gaW5kZXhNYXBbbG93RW5kXTtcbiAgICAgICAgYXJyW2xvd0VuZF0gPSB2cGl2b3Q7XG4gICAgICAgIGluZGV4TWFwW2xvd0VuZF0gPSBpcGl2b3Q7XG4gICAgICAgIHBhcnRpdGlvbjogZm9yIChpID0gbG93RW5kICsgMTsgaSA8IGhpZ2hTdGFydDsgaSsrKSB7XG4gICAgICAgICAgICB2ZWxlbWVudCA9IGFycltpXTtcbiAgICAgICAgICAgIGllbGVtZW50ID0gaW5kZXhNYXBbaV07XG4gICAgICAgICAgICBvcmRlciA9IGNvbXBhcmVGbih2ZWxlbWVudCwgdnBpdm90KTtcbiAgICAgICAgICAgIGlmIChvcmRlciA8IDApIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBhcnJbbG93RW5kXTtcbiAgICAgICAgICAgICAgICBpbmRleE1hcFtpXSA9IGluZGV4TWFwW2xvd0VuZF07XG4gICAgICAgICAgICAgICAgYXJyW2xvd0VuZF0gPSB2ZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpbmRleE1hcFtsb3dFbmRdID0gaWVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgbG93RW5kKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcmRlciA+IDApIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hTdGFydC0tO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWdoU3RhcnQgPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcGFydGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZ0b3BFbGVtZW50ID0gYXJyW2hpZ2hTdGFydF07XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID0gY29tcGFyZUZuKHZ0b3BFbGVtZW50LCB2cGl2b3QpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKG9yZGVyID4gMCk7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gYXJyW2hpZ2hTdGFydF07XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBpbmRleE1hcFtoaWdoU3RhcnRdO1xuICAgICAgICAgICAgICAgIGFycltoaWdoU3RhcnRdID0gdmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaGlnaFN0YXJ0XSA9IGllbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcmRlciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmVsZW1lbnQgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgICAgIGllbGVtZW50ID0gaW5kZXhNYXBbaV07XG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IGFycltsb3dFbmRdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcFtpXSA9IGluZGV4TWFwW2xvd0VuZF07XG4gICAgICAgICAgICAgICAgICAgIGFycltsb3dFbmRdID0gdmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwW2xvd0VuZF0gPSBpZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbG93RW5kKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0byAtIGhpZ2hTdGFydCA8IGxvd0VuZCAtIGZyb20pIHtcbiAgICAgICAgICAgIHF1aWNrU29ydChhcnIsIGluZGV4TWFwLCBoaWdoU3RhcnQsIHRvLCBjb21wYXJlRm4pO1xuICAgICAgICAgICAgdG8gPSBsb3dFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWlja1NvcnQoYXJyLCBpbmRleE1hcCwgZnJvbSwgbG93RW5kLCBjb21wYXJlRm4pO1xuICAgICAgICAgICAgZnJvbSA9IGhpZ2hTdGFydDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuY29uc3QgJHB1c2ggPSBwcm90by5wdXNoO1xuY29uc3QgJHVuc2hpZnQgPSBwcm90by51bnNoaWZ0O1xuY29uc3QgJHBvcCA9IHByb3RvLnBvcDtcbmNvbnN0ICRzaGlmdCA9IHByb3RvLnNoaWZ0O1xuY29uc3QgJHNwbGljZSA9IHByb3RvLnNwbGljZTtcbmNvbnN0ICRyZXZlcnNlID0gcHJvdG8ucmV2ZXJzZTtcbmNvbnN0ICRzb3J0ID0gcHJvdG8uc29ydDtcbmNvbnN0IG5hdGl2ZSA9IHsgcHVzaDogJHB1c2gsIHVuc2hpZnQ6ICR1bnNoaWZ0LCBwb3A6ICRwb3AsIHNoaWZ0OiAkc2hpZnQsIHNwbGljZTogJHNwbGljZSwgcmV2ZXJzZTogJHJldmVyc2UsIHNvcnQ6ICRzb3J0IH07XG5jb25zdCBtZXRob2RzID0gWydwdXNoJywgJ3Vuc2hpZnQnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICdyZXZlcnNlJywgJ3NvcnQnXTtcbmNvbnN0IG9ic2VydmUgPSB7XG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnB1c2hcbiAgICBwdXNoOiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJHB1c2guYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCA9IG8uaW5kZXhNYXAubGVuZ3RoID0gbGVuICsgYXJnQ291bnQ7XG4gICAgICAgIGxldCBpID0gbGVuO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gYXJnc1tpIC0gbGVuXTtcbiAgICAgICAgICAgIG8uaW5kZXhNYXBbaV0gPSAtMjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudW5zaGlmdFxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiAkdW5zaGlmdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbnNlcnRzID0gbmV3IEFycmF5KGFyZ0NvdW50KTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGFyZ0NvdW50KSB7XG4gICAgICAgICAgICBpbnNlcnRzW2krK10gPSAtMjtcbiAgICAgICAgfVxuICAgICAgICAkdW5zaGlmdC5hcHBseShvLmluZGV4TWFwLCBpbnNlcnRzKTtcbiAgICAgICAgY29uc3QgbGVuID0gJHVuc2hpZnQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucG9wXG4gICAgcG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiAkcG9wLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gJHBvcC5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBvbmx5IG1hcmsgaW5kaWNlcyBhcyBkZWxldGVkIGlmIHRoZXkgYWN0dWFsbHkgZXhpc3RlZCBpbiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleE1hcC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXhNYXBbaW5kZXhdID4gLTEpIHtcbiAgICAgICAgICAgIGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5wdXNoKGluZGV4TWFwW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgJHBvcC5jYWxsKGluZGV4TWFwKTtcbiAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2hpZnRcbiAgICBzaGlmdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBvID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJHNoaWZ0LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gJHNoaWZ0LmNhbGwodGhpcyk7XG4gICAgICAgIC8vIG9ubHkgbWFyayBpbmRpY2VzIGFzIGRlbGV0ZWQgaWYgdGhleSBhY3R1YWxseSBleGlzdGVkIGluIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgICAgICBpZiAoaW5kZXhNYXBbMF0gPiAtMSkge1xuICAgICAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnB1c2goaW5kZXhNYXBbMF0pO1xuICAgICAgICB9XG4gICAgICAgICRzaGlmdC5jYWxsKGluZGV4TWFwKTtcbiAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4gICAgc3BsaWNlOiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBzdGFydCA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IGRlbGV0ZUNvdW50ID0gYXJnc1sxXTtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuICRzcGxpY2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlU3RhcnQgPSBzdGFydCB8IDA7XG4gICAgICAgIGNvbnN0IGFjdHVhbFN0YXJ0ID0gcmVsYXRpdmVTdGFydCA8IDAgPyBNYXRoLm1heCgobGVuICsgcmVsYXRpdmVTdGFydCksIDApIDogTWF0aC5taW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICBjb25zdCBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBjb25zdCBhY3R1YWxEZWxldGVDb3VudCA9IGFyZ0NvdW50ID09PSAwID8gMCA6IGFyZ0NvdW50ID09PSAxID8gbGVuIC0gYWN0dWFsU3RhcnQgOiBkZWxldGVDb3VudDtcbiAgICAgICAgaWYgKGFjdHVhbERlbGV0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgbGV0IGkgPSBhY3R1YWxTdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gaSArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0bykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5wdXNoKGluZGV4TWFwW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdDb3VudCA+IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Db3VudCA9IGFyZ0NvdW50IC0gMjtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydHMgPSBuZXcgQXJyYXkoaXRlbUNvdW50KTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaXRlbUNvdW50KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0c1tpKytdID0gLTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc3BsaWNlLmNhbGwoaW5kZXhNYXAsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaW5zZXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkc3BsaWNlLmFwcGx5KGluZGV4TWFwLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxldGVkID0gJHNwbGljZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmV2ZXJzZVxuICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgJHJldmVyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBtaWRkbGUgPSAobGVuIC8gMikgfCAwO1xuICAgICAgICBsZXQgbG93ZXIgPSAwO1xuICAgICAgICB3aGlsZSAobG93ZXIgIT09IG1pZGRsZSkge1xuICAgICAgICAgICAgY29uc3QgdXBwZXIgPSBsZW4gLSBsb3dlciAtIDE7XG4gICAgICAgICAgICBjb25zdCBsb3dlclZhbHVlID0gdGhpc1tsb3dlcl07XG4gICAgICAgICAgICBjb25zdCBsb3dlckluZGV4ID0gby5pbmRleE1hcFtsb3dlcl07XG4gICAgICAgICAgICBjb25zdCB1cHBlclZhbHVlID0gdGhpc1t1cHBlcl07XG4gICAgICAgICAgICBjb25zdCB1cHBlckluZGV4ID0gby5pbmRleE1hcFt1cHBlcl07XG4gICAgICAgICAgICB0aGlzW2xvd2VyXSA9IHVwcGVyVmFsdWU7XG4gICAgICAgICAgICBvLmluZGV4TWFwW2xvd2VyXSA9IHVwcGVySW5kZXg7XG4gICAgICAgICAgICB0aGlzW3VwcGVyXSA9IGxvd2VyVmFsdWU7XG4gICAgICAgICAgICBvLmluZGV4TWFwW3VwcGVyXSA9IGxvd2VySW5kZXg7XG4gICAgICAgICAgICBsb3dlcisrO1xuICAgICAgICB9XG4gICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi9tYXN0ZXIvc3JjL2pzL2FycmF5LmpzXG4gICAgc29ydDogZnVuY3Rpb24gKGNvbXBhcmVGbikge1xuICAgICAgICBjb25zdCBvID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAkc29ydC5jYWxsKHRoaXMsIGNvbXBhcmVGbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHF1aWNrU29ydCh0aGlzLCBvLmluZGV4TWFwLCAwLCBsZW4sIHByZVNvcnRDb21wYXJlKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlRm4gPT09IHZvaWQgMCB8fCB0eXBlb2YgY29tcGFyZUZuICE9PSAnZnVuY3Rpb24nIC8qIHNwZWMgc2F5cyB0aHJvdyBhIFR5cGVFcnJvciwgc2hvdWxkIHdlIGRvIHRoYXQgdG9vPyAqLykge1xuICAgICAgICAgICAgY29tcGFyZUZuID0gc29ydENvbXBhcmU7XG4gICAgICAgIH1cbiAgICAgICAgcXVpY2tTb3J0KHRoaXMsIG8uaW5kZXhNYXAsIDAsIGksIGNvbXBhcmVGbik7XG4gICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5mb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgZGVmKG9ic2VydmVbbWV0aG9kXSwgJ29ic2VydmluZycsIHsgdmFsdWU6IHRydWUsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG59XG5sZXQgZW5hYmxlQXJyYXlPYnNlcnZhdGlvbkNhbGxlZCA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUFycmF5T2JzZXJ2YXRpb24oKSB7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICBpZiAocHJvdG9bbWV0aG9kXS5vYnNlcnZpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlZmluZUhpZGRlblByb3AocHJvdG8sIG1ldGhvZCwgb2JzZXJ2ZVttZXRob2RdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQXJyYXlPYnNlcnZhdGlvbigpIHtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgIGlmIChwcm90b1ttZXRob2RdLm9ic2VydmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChwcm90bywgbWV0aG9kLCBuYXRpdmVbbWV0aG9kXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXJyYXlPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICAgICAgdGhpcy50eXBlID0gMTggLyogQXJyYXkgKi87XG4gICAgICAgIGlmICghZW5hYmxlQXJyYXlPYnNlcnZhdGlvbkNhbGxlZCkge1xuICAgICAgICAgICAgZW5hYmxlQXJyYXlPYnNlcnZhdGlvbkNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBlbmFibGVBcnJheU9ic2VydmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleE9ic2VydmVycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBhcnJheTtcbiAgICAgICAgdGhpcy5pbmRleE1hcCA9IGNyZWF0ZUluZGV4TWFwKGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuT2JzID0gdm9pZCAwO1xuICAgICAgICBvYnNlcnZlckxvb2t1cC5zZXQoYXJyYXksIHRoaXMpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gdGhpcy5pbmRleE1hcDtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5jb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgdGhpcy5pbmRleE1hcCA9IGNyZWF0ZUluZGV4TWFwKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3Vicy5ub3RpZnlDb2xsZWN0aW9uKGluZGV4TWFwLCA4IC8qIHVwZGF0ZVRhcmdldCAqLyk7XG4gICAgfVxuICAgIGdldExlbmd0aE9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5PYnMgPz8gKHRoaXMubGVuT2JzID0gbmV3IENvbGxlY3Rpb25MZW5ndGhPYnNlcnZlcih0aGlzKSk7XG4gICAgfVxuICAgIGdldEluZGV4T2JzZXJ2ZXIoaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBJdCdzIHVubmVjZXNzYXJ5IHRvIGRlc3Ryb3kvcmVjcmVhdGUgaW5kZXggb2JzZXJ2ZXIgYWxsIHRoZSB0aW1lLFxuICAgICAgICAvLyBzbyBqdXN0IGNyZWF0ZSBvbmNlLCBhbmQgYWRkL3JlbW92ZSBpbnN0ZWFkXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmluZGV4T2JzZXJ2ZXJzKVtpbmRleF0gPz8gKF9hW2luZGV4XSA9IG5ldyBBcnJheUluZGV4T2JzZXJ2ZXIodGhpcywgaW5kZXgpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXJyYXlJbmRleE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25lci5jb2xsZWN0aW9uW3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB0aGlzLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheU9ic2VydmVyID0gdGhpcy5vd25lcjtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICBjb25zdCBpbmRleE1hcCA9IGFycmF5T2JzZXJ2ZXIuaW5kZXhNYXA7XG4gICAgICAgIGlmIChpbmRleE1hcFtpbmRleF0gPiAtMSkge1xuICAgICAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnB1c2goaW5kZXhNYXBbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleE1hcFtpbmRleF0gPSAtMjtcbiAgICAgICAgLy8gZG8gbm90IG5lZWQgdG8gdXBkYXRlIGN1cnJlbnQgdmFsdWUgaGVyZVxuICAgICAgICAvLyBhcyBpdCB3aWxsIGJlIHVwZGF0ZWQgaW5zaWRlIGhhbmRsZSBjb2xsZWN0aW9uIGNoYW5nZVxuICAgICAgICBhcnJheU9ic2VydmVyLmNvbGxlY3Rpb25baW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgIGFycmF5T2JzZXJ2ZXIubm90aWZ5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZyb20gaW50ZXJmYWNlIGBJQ29sbGVjdGlvblN1YnNjcmliZXJgXG4gICAgICovXG4gICAgaGFuZGxlQ29sbGVjdGlvbkNoYW5nZShpbmRleE1hcCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICBjb25zdCBub0NoYW5nZSA9IGluZGV4TWFwW2luZGV4XSA9PT0gaW5kZXg7XG4gICAgICAgIGlmIChub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IGN1cnJWYWx1ZSA9IHRoaXMudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIC8vIGhtbVxuICAgICAgICBpZiAocHJldlZhbHVlICE9PSBjdXJyVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkoY3VyclZhbHVlLCBwcmV2VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLmFkZChzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oQXJyYXlPYnNlcnZlcik7XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihBcnJheUluZGV4T2JzZXJ2ZXIpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5T2JzZXJ2ZXIoYXJyYXkpIHtcbiAgICBsZXQgb2JzZXJ2ZXIgPSBvYnNlcnZlckxvb2t1cC5nZXQoYXJyYXkpO1xuICAgIGlmIChvYnNlcnZlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9ic2VydmVyID0gbmV3IEFycmF5T2JzZXJ2ZXIoYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG59XG4vKipcbiAqIEFwcGxpZXMgb2Zmc2V0cyB0byB0aGUgbm9uLW5lZ2F0aXZlIGluZGljZXMgaW4gdGhlIEluZGV4TWFwXG4gKiBiYXNlZCBvbiBhZGRlZCBhbmQgZGVsZXRlZCBpdGVtcyByZWxhdGl2ZSB0byB0aG9zZSBpbmRpY2VzLlxuICpcbiAqIGUuZy4gdHVybiBgWy0yLCAwLCAxXWAgaW50byBgWy0yLCAxLCAyXWAsIGFsbG93aW5nIHRoZSB2YWx1ZXMgYXQgdGhlIGluZGljZXMgdG8gYmVcbiAqIHVzZWQgZm9yIHNvcnRpbmcvcmVvcmRlcmluZyBpdGVtcyBpZiBuZWVkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25zVG9JbmRpY2VzKGluZGV4TWFwKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IGxlbiA9IGluZGV4TWFwLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHdoaWxlIChpbmRleE1hcC5kZWxldGVkSXRlbXNbal0gPD0gaSAtIG9mZnNldCkge1xuICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgLS1vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4TWFwW2ldID09PSAtMikge1xuICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleE1hcFtpXSArPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFmdGVyIGBhcHBseU11dGF0aW9uc1RvSW5kaWNlc2AsIHRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcmVvcmRlciBpdGVtcyBpbiBhIGRlcml2ZWRcbiAqIGFycmF5IChlLmcuICB0aGUgaXRlbXMgaW4gdGhlIGB2aWV3c2AgaW4gdGhlIHJlcGVhdGVyIGFyZSBkZXJpdmVkIGZyb20gdGhlIGBpdGVtc2AgcHJvcGVydHkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzeW5jaHJvbml6ZUluZGljZXMoaXRlbXMsIGluZGV4TWFwKSB7XG4gICAgY29uc3QgY29weSA9IGl0ZW1zLnNsaWNlKCk7XG4gICAgY29uc3QgbGVuID0gaW5kZXhNYXAubGVuZ3RoO1xuICAgIGxldCB0byA9IDA7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlICh0byA8IGxlbikge1xuICAgICAgICBmcm9tID0gaW5kZXhNYXBbdG9dO1xuICAgICAgICBpZiAoZnJvbSAhPT0gLTIpIHtcbiAgICAgICAgICAgIGl0ZW1zW3RvXSA9IGNvcHlbZnJvbV07XG4gICAgICAgIH1cbiAgICAgICAgKyt0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1vYnNlcnZlci5qcy5tYXAiLCJjb25zdCBtYXJrZXIgPSBPYmplY3QuZnJlZXplKHt9KTtcbmV4cG9ydCBjbGFzcyBCaW5kaW5nQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3Ioa2V5T3JPYmosIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXlPck9iaiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIGRlZmluZWQgdGhlbiBpdCdzIGp1c3QgYSBwcm9wZXJ0eSBhbmQgYSB2YWx1ZSB0byBpbml0aWFsaXplIHdpdGhcbiAgICAgICAgICAgICAgICB0aGlzW2tleU9yT2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuIGVpdGhlciBiZSBzb21lIHJhbmRvbSBvYmplY3Qgb3IgYW5vdGhlciBiaW5kaW5nQ29udGV4dCB0byBjbG9uZSBmcm9tXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGtleU9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa2V5T3JPYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BdID0ga2V5T3JPYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShrZXlPck9iaiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nQ29udGV4dChrZXlPck9iaiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KHNjb3BlLCBuYW1lLCBhbmNlc3RvciwgZmxhZ3MsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAoc2NvcGUgPT0gbnVsbCAmJiBob3N0U2NvcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY29wZSBpcyAke3Njb3BlfSBhbmQgSG9zdFNjb3BlIGlzICR7aG9zdFNjb3BlfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNPdGhlclNjb3BlID0gaG9zdFNjb3BlICE9PSBzY29wZSAmJiBob3N0U2NvcGUgIT0gbnVsbDtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvY2hlY2staW5kZW50YXRpb24gKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZmFsbGJhY2sgaXMgbmVlZGVkIHRvIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBjYXNlOlxuICAgICAgICAgKiA8ZGl2IGF1LXNsb3Q9XCJzMVwiPlxuICAgICAgICAgKiAgPGxldCBvdXRlci1ob3N0LmJpbmQ9XCIkaG9zdFwiPjwvbGV0PlxuICAgICAgICAgKiAgJHtvdXRlckhvc3QucHJvcH1cbiAgICAgICAgICogPC9kaXY+XG4gICAgICAgICAqIFRvIGVuYWJsZSB0aGUgYGxldGAgYmluZGluZyBmb3IgJ2hvc3RTY29wZScsIHRoZSBwcm9wZXJ0eSBpcyBhZGRlZCB0byBgaG9zdFNjb3BlLm92ZXJyaWRlQ29udGV4dGAuIFRoYXQgZW5hYmxlcyB1cyB0byB1c2Ugc3VjaCBsZXQgYmluZGluZyBhbHNvIGluc2lkZSBhIHJlcGVhdGVyLlxuICAgICAgICAgKiBIb3dldmVyLCBhcyB0aGUgZXhwcmVzc2lvbiBgJHtvdXRlckhvc3QucHJvcH1gIGRvZXMgbm90IHN0YXJ0IHdpdGggYCRob3N0YCwgaXQgaXMgY29uc2lkZXJlZCB0aGF0IHRvIGV2YWx1YXRlIHRoaXMgZXhwcmVzc2lvbiwgd2UgZG9uJ3QgbmVlZCB0aGUgYWNjZXNzIHRvIGhvc3RTY29wZS5cbiAgICAgICAgICogVGhpcyBhcnRpZmFjdCByYWlzZXMgdGhlIG5lZWQgZm9yIHRoaXMgZmFsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGpzZG9jL2NoZWNrLWluZGVudGF0aW9uICovXG4gICAgICAgIGxldCBjb250ZXh0ID0gY2hvb3NlQ29udGV4dChzY29wZSwgbmFtZSwgYW5jZXN0b3IpO1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgKChjb250ZXh0ID09IG51bGwgPyBmYWxzZSA6IG5hbWUgaW4gY29udGV4dClcbiAgICAgICAgICAgICAgICB8fCAhaGFzT3RoZXJTY29wZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPdGhlclNjb3BlKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY2hvb3NlQ29udGV4dChob3N0U2NvcGUsIG5hbWUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RpbGwgbm90aGluZyBmb3VuZC4gcmV0dXJuIHRoZSByb290IGJpbmRpbmcgY29udGV4dCAob3IgbnVsbFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgcGFyZW50IHNjb3BlIHRyYXZlcnNhbCwgdG8gZW5zdXJlIHdlIGZhbGwgYmFjayB0byB0aGVcbiAgICAgICAgLy8gY29ycmVjdCBsZXZlbClcbiAgICAgICAgaWYgKGZsYWdzICYgMjU2IC8qIGlzVHJhdmVyc2luZ1BhcmVudFNjb3BlICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZS5iaW5kaW5nQ29udGV4dCB8fCBzY29wZS5vdmVycmlkZUNvbnRleHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hvb3NlQ29udGV4dChzY29wZSwgbmFtZSwgYW5jZXN0b3IpIHtcbiAgICBsZXQgb3ZlcnJpZGVDb250ZXh0ID0gc2NvcGUub3ZlcnJpZGVDb250ZXh0O1xuICAgIGxldCBjdXJyZW50U2NvcGUgPSBzY29wZTtcbiAgICBpZiAoYW5jZXN0b3IgPiAwKSB7XG4gICAgICAgIC8vIGp1bXAgdXAgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBhbmNlc3RvciBjb250ZXh0cyAoZWcgJHBhcmVudC4kcGFyZW50IHJlcXVpcmVzIHR3byBqdW1wcylcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yID4gMCkge1xuICAgICAgICAgICAgYW5jZXN0b3ItLTtcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IGN1cnJlbnRTY29wZS5wYXJlbnRTY29wZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcGU/Lm92ZXJyaWRlQ29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdmVycmlkZUNvbnRleHQgPSBjdXJyZW50U2NvcGUub3ZlcnJpZGVDb250ZXh0O1xuICAgICAgICByZXR1cm4gbmFtZSBpbiBvdmVycmlkZUNvbnRleHQgPyBvdmVycmlkZUNvbnRleHQgOiBvdmVycmlkZUNvbnRleHQuYmluZGluZ0NvbnRleHQ7XG4gICAgfVxuICAgIC8vIHRyYXZlcnNlIHRoZSBjb250ZXh0IGFuZCBpdCdzIGFuY2VzdG9ycywgc2VhcmNoaW5nIGZvciBhIGNvbnRleHQgdGhhdCBoYXMgdGhlIG5hbWUuXG4gICAgd2hpbGUgKCFjdXJyZW50U2NvcGU/LmlzQ29tcG9uZW50Qm91bmRhcnlcbiAgICAgICAgJiYgb3ZlcnJpZGVDb250ZXh0XG4gICAgICAgICYmICEobmFtZSBpbiBvdmVycmlkZUNvbnRleHQpXG4gICAgICAgICYmICEob3ZlcnJpZGVDb250ZXh0LmJpbmRpbmdDb250ZXh0XG4gICAgICAgICAgICAmJiBuYW1lIGluIG92ZXJyaWRlQ29udGV4dC5iaW5kaW5nQ29udGV4dCkpIHtcbiAgICAgICAgY3VycmVudFNjb3BlID0gY3VycmVudFNjb3BlLnBhcmVudFNjb3BlID8/IG51bGw7XG4gICAgICAgIG92ZXJyaWRlQ29udGV4dCA9IGN1cnJlbnRTY29wZT8ub3ZlcnJpZGVDb250ZXh0ID8/IG51bGw7XG4gICAgfVxuICAgIGlmIChvdmVycmlkZUNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgaW4gb3ZlcnJpZGVDb250ZXh0ID8gb3ZlcnJpZGVDb250ZXh0IDogb3ZlcnJpZGVDb250ZXh0LmJpbmRpbmdDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBjbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50U2NvcGUsIGJpbmRpbmdDb250ZXh0LCBvdmVycmlkZUNvbnRleHQsIGlzQ29tcG9uZW50Qm91bmRhcnkpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgICAgICB0aGlzLmJpbmRpbmdDb250ZXh0ID0gYmluZGluZ0NvbnRleHQ7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVDb250ZXh0ID0gb3ZlcnJpZGVDb250ZXh0O1xuICAgICAgICB0aGlzLmlzQ29tcG9uZW50Qm91bmRhcnkgPSBpc0NvbXBvbmVudEJvdW5kYXJ5O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGJjLCBvYywgaXNDb21wb25lbnRCb3VuZGFyeSkge1xuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKG51bGwsIGJjLCBvYyA9PSBudWxsID8gT3ZlcnJpZGVDb250ZXh0LmNyZWF0ZShiYykgOiBvYywgaXNDb21wb25lbnRCb3VuZGFyeSA/PyBmYWxzZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT3ZlcnJpZGUob2MpIHtcbiAgICAgICAgaWYgKG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT3ZlcnJpZGVDb250ZXh0IGlzICR7b2N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTY29wZShudWxsLCBvYy5iaW5kaW5nQ29udGV4dCwgb2MsIGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21QYXJlbnQocHMsIGJjKSB7XG4gICAgICAgIGlmIChwcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmVudFNjb3BlIGlzICR7cHN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTY29wZShwcywgYmMsIE92ZXJyaWRlQ29udGV4dC5jcmVhdGUoYmMpLCBmYWxzZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE92ZXJyaWRlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nQ29udGV4dCA9IGJpbmRpbmdDb250ZXh0O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGJjKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3ZlcnJpZGVDb250ZXh0KGJjKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nLWNvbnRleHQuanMubWFwIiwiaW1wb3J0IHsgaXNBcnJheUluZGV4IH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgZW5zdXJlUHJvdG8gfSBmcm9tICcuLi91dGlsaXRpZXMtb2JqZWN0cy5qcyc7XG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbkxlbmd0aE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IDE4IC8qIEFycmF5ICovO1xuICAgICAgICB0aGlzLnZhbHVlID0gKHRoaXMub2JqID0gb3duZXIuY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqLmxlbmd0aDtcbiAgICB9XG4gICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIC8vIGlmIGluIHRoZSB0ZW1wbGF0ZSwgbGVuZ3RoIGlzIHR3by13YXkgYm91bmQgZGlyZWN0bHlcbiAgICAgICAgLy8gdGhlbiB0aGVyZSdzIGEgY2hhbmNlIHRoYXQgdGhlIG5ldyB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgICAgIC8vIGFkZCBhIGd1YXJkIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGJyb2FkY2FzdCBpbnZhbGlkIHZhbHVlc1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnRWYWx1ZSAmJiBpc0FycmF5SW5kZXgobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgNDA5NiAvKiBub0ZsdXNoICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqLmxlbmd0aCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShuZXdWYWx1ZSwgY3VycmVudFZhbHVlLCBmbGFncyB8IDggLyogdXBkYXRlVGFyZ2V0ICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKF8sIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm9iai5sZW5ndGg7XG4gICAgICAgIGlmICgodGhpcy52YWx1ZSA9IHZhbHVlKSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkodmFsdWUsIG9sZFZhbHVlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvblNpemVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLnZhbHVlID0gKHRoaXMub2JqID0gb3duZXIuY29sbGVjdGlvbikuc2l6ZTtcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy5vYmogaW5zdGFuY2VvZiBNYXAgPyA2NiAvKiBNYXAgKi8gOiAzNCAvKiBTZXQgKi87XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmouc2l6ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFwL1NldCBcInNpemVcIiBpcyBhIHJlYWRvbmx5IHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoXywgZmxhZ3MpIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMub2JqLnNpemU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeSh2YWx1ZSwgb2xkVmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGltcGxlbWVudExlbmd0aE9ic2VydmVyKGtsYXNzKSB7XG4gICAgY29uc3QgcHJvdG8gPSBrbGFzcy5wcm90b3R5cGU7XG4gICAgZW5zdXJlUHJvdG8ocHJvdG8sICdzdWJzY3JpYmUnLCBzdWJzY3JpYmUsIHRydWUpO1xuICAgIGVuc3VyZVByb3RvKHByb3RvLCAndW5zdWJzY3JpYmUnLCB1bnN1YnNjcmliZSwgdHJ1ZSk7XG4gICAgc3Vic2NyaWJlckNvbGxlY3Rpb24oa2xhc3MpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICBpZiAodGhpcy5zdWJzLmFkZChzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDEpIHtcbiAgICAgICAgdGhpcy5vd25lci5zdWJzY3JpYmUodGhpcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgIGlmICh0aGlzLnN1YnMucmVtb3ZlKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMCkge1xuICAgICAgICB0aGlzLm93bmVyLnN1YnNjcmliZSh0aGlzKTtcbiAgICB9XG59XG5pbXBsZW1lbnRMZW5ndGhPYnNlcnZlcihDb2xsZWN0aW9uTGVuZ3RoT2JzZXJ2ZXIpO1xuaW1wbGVtZW50TGVuZ3RoT2JzZXJ2ZXIoQ29sbGVjdGlvblNpemVPYnNlcnZlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9uLWxlbmd0aC1vYnNlcnZlci5qcy5tYXAiLCJpbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiB9IGZyb20gJy4vc3Vic2NyaWJlci1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGVudGVyQ29ubmVjdGFibGUsIGV4aXRDb25uZWN0YWJsZSB9IGZyb20gJy4vY29ubmVjdGFibGUtc3dpdGNoZXIuanMnO1xuaW1wb3J0IHsgY29ubmVjdGFibGUgfSBmcm9tICcuLi9iaW5kaW5nL2Nvbm5lY3RhYmxlLmpzJztcbmltcG9ydCB7IHdyYXAsIHVud3JhcCB9IGZyb20gJy4vcHJveHktb2JzZXJ2YXRpb24uanMnO1xuaW1wb3J0IHsgZGVmIH0gZnJvbSAnLi4vdXRpbGl0aWVzLW9iamVjdHMuanMnO1xuZXhwb3J0IGNsYXNzIENvbXB1dGVkT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgZ2V0LCBzZXQsIHVzZVByb3h5LCBvYnNlcnZlckxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMuZ2V0ID0gZ2V0O1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy51c2VQcm94eSA9IHVzZVByb3h5O1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvciA9IHRoaXM7XG4gICAgICAgIHRoaXMudHlwZSA9IDEgLyogT2JzZXJ2ZXIgKi87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIC8vIHRvZG86IG1heWJlIHVzZSBhIGNvdW50ZXIgYWxsb3cgcmVjdXJzaXZlIGNhbGwgdG8gYSBjZXJ0YWluIGxldmVsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY29ubmVjdGFibGUuYXNzaWduSWRUbyh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShvYmosIGtleSwgZGVzY3JpcHRvciwgb2JzZXJ2ZXJMb2NhdG9yLCB1c2VQcm94eSkge1xuICAgICAgICBjb25zdCBnZXR0ZXIgPSBkZXNjcmlwdG9yLmdldDtcbiAgICAgICAgY29uc3Qgc2V0dGVyID0gZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IENvbXB1dGVkT2JzZXJ2ZXIob2JqLCBnZXR0ZXIsIHNldHRlciwgdXNlUHJveHksIG9ic2VydmVyTG9jYXRvcik7XG4gICAgICAgIGNvbnN0ICRnZXQgPSAoKCAvKiBDb21wdXRlZCBPYnNlcnZlciAqLykgPT4gb2JzZXJ2ZXIuZ2V0VmFsdWUoKSk7XG4gICAgICAgICRnZXQuZ2V0T2JzZXJ2ZXIgPSAoKSA9PiBvYnNlcnZlcjtcbiAgICAgICAgZGVmKG9iaiwga2V5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICRnZXQsXG4gICAgICAgICAgICBzZXQ6ICgvKiBDb21wdXRlZCBPYnNlcnZlciAqLyB2KSA9PiB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuc2V0VmFsdWUodiwgMCAvKiBub25lICovKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQuY2FsbCh0aGlzLm9iaiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlKCk7XG4gICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzZXRWYWx1ZSh2LCBfZmxhZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHYgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHJ1bm5pbmcgdHJ1ZSBhcyBhIGZvcm0gb2YgYmF0Y2hpbmdcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0LmNhbGwodGhpcy5vYmosIHYpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IGlzIHJlYWRvbmx5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzLmNvdW50ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzLmNvdW50ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICAvLyBpbiB0aGVvcnksIGEgY29sbGVjdGlvbiBzdWJzY3JpYmVyIGNvdWxkIGJlIGFkZGVkIGJlZm9yZSBhIHByb3BlcnR5IHN1YnNjcmliZXJcbiAgICAgICAgLy8gYW5kIGl0IHNob3VsZCBiZSBoYW5kbGVkIHNpbWlsYXJseSBpbiBzdWJzY3JpYmVUb0NvbGxlY3Rpb25cbiAgICAgICAgLy8gdGhvdWdoIG5vdCBoYW5kbGluZyBmb3Igbm93LCBhbmQgd2FpdCB1bnRpbCB0aGUgbWVyZ2Ugb2Ygbm9ybWFsICsgY29sbGVjdGlvbiBzdWJzY3JpcHRpb25cbiAgICAgICAgaWYgKHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vYnMuY2xlYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFPYmplY3QuaXMobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgLy8gc2hvdWxkIG9wdGlvbmFsbHkgcXVldWVcbiAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkobmV3VmFsdWUsIG9sZFZhbHVlLCAwIC8qIG5vbmUgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGUoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzLnZlcnNpb24rKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVudGVyQ29ubmVjdGFibGUodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHVud3JhcCh0aGlzLmdldC5jYWxsKHRoaXMudXNlUHJveHkgPyB3cmFwKHRoaXMub2JqKSA6IHRoaXMub2JqLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLm9icy5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGV4aXRDb25uZWN0YWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbm5lY3RhYmxlKENvbXB1dGVkT2JzZXJ2ZXIpO1xuc3Vic2NyaWJlckNvbGxlY3Rpb24oQ29tcHV0ZWRPYnNlcnZlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wdXRlZC1vYnNlcnZlci5qcy5tYXAiLCIvKipcbiAqIEN1cnJlbnQgc3Vic2NyaXB0aW9uIGNvbGxlY3RvclxuICovXG5sZXQgX2Nvbm5lY3RhYmxlID0gbnVsbDtcbmNvbnN0IGNvbm5lY3RhYmxlcyA9IFtdO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5leHBvcnQgbGV0IGNvbm5lY3RpbmcgPSBmYWxzZTtcbi8vIHRvZG86IGxheWVyIGJhc2VkIGNvbGxlY3Rpb24gcGF1c2UvcmVzdW1lP1xuZXhwb3J0IGZ1bmN0aW9uIHBhdXNlQ29ubmVjdGluZygpIHtcbiAgICBjb25uZWN0aW5nID0gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzdW1lQ29ubmVjdGluZygpIHtcbiAgICBjb25uZWN0aW5nID0gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50Q29ubmVjdGFibGUoKSB7XG4gICAgcmV0dXJuIF9jb25uZWN0YWJsZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnRlckNvbm5lY3RhYmxlKGNvbm5lY3RhYmxlKSB7XG4gICAgaWYgKGNvbm5lY3RhYmxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25uZWN0YWJsZSBjYW5ub3QgYmUgbnVsbC91bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKF9jb25uZWN0YWJsZSA9PSBudWxsKSB7XG4gICAgICAgIF9jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgICAgICBjb25uZWN0YWJsZXNbMF0gPSBfY29ubmVjdGFibGU7XG4gICAgICAgIGNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChfY29ubmVjdGFibGUgPT09IGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBpbiB0aGlzIGNvbm5lY3RhYmxlICR7Y29ubmVjdGFibGUuaWR9YCk7XG4gICAgfVxuICAgIGNvbm5lY3RhYmxlcy5wdXNoKF9jb25uZWN0YWJsZSk7XG4gICAgX2Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgY29ubmVjdGluZyA9IHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZXhpdENvbm5lY3RhYmxlKGNvbm5lY3RhYmxlKSB7XG4gICAgaWYgKGNvbm5lY3RhYmxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0YWJsZSBjYW5ub3QgYmUgbnVsbC91bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKF9jb25uZWN0YWJsZSAhPT0gY29ubmVjdGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Nvbm5lY3RhYmxlLmlkfSBpcyBub3QgY3VycmVudGx5IGNvbGxlY3RpbmdgKTtcbiAgICB9XG4gICAgY29ubmVjdGFibGVzLnBvcCgpO1xuICAgIF9jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlcy5sZW5ndGggPiAwID8gY29ubmVjdGFibGVzW2Nvbm5lY3RhYmxlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgY29ubmVjdGluZyA9IF9jb25uZWN0YWJsZSAhPSBudWxsO1xufVxuZXhwb3J0IGNvbnN0IENvbm5lY3RhYmxlU3dpdGNoZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9jb25uZWN0YWJsZTtcbiAgICB9LFxuICAgIGdldCBjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGluZztcbiAgICB9LFxuICAgIGVudGVyOiBlbnRlckNvbm5lY3RhYmxlLFxuICAgIGV4aXQ6IGV4aXRDb25uZWN0YWJsZSxcbiAgICBwYXVzZTogcGF1c2VDb25uZWN0aW5nLFxuICAgIHJlc3VtZTogcmVzdW1lQ29ubmVjdGluZyxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGFibGUtc3dpdGNoZXIuanMubWFwIiwiaW1wb3J0IHsgREksIElQbGF0Zm9ybSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiB9IGZyb20gJy4vc3Vic2NyaWJlci1jb2xsZWN0aW9uLmpzJztcbmV4cG9ydCBjb25zdCBJRGlydHlDaGVja2VyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJRGlydHlDaGVja2VyJywgeCA9PiB4LnNpbmdsZXRvbihEaXJ0eUNoZWNrZXIpKTtcbmV4cG9ydCBjb25zdCBEaXJ0eUNoZWNrU2V0dGluZ3MgPSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdDogYDZgXG4gICAgICpcbiAgICAgKiBBZGp1c3QgdGhlIGdsb2JhbCBkaXJ0eSBjaGVjayBmcmVxdWVuY3kuXG4gICAgICogTWVhc3VyZXMgaW4gXCJ0aW1lb3V0cyBwZXIgY2hlY2tcIiwgc3VjaCB0aGF0IChnaXZlbiBhIGRlZmF1bHQgb2YgMjUwIHRpbWVvdXRzIHBlciBzZWNvbmQgaW4gbW9kZXJuIGJyb3dzZXJzKTpcbiAgICAgKiAtIEEgdmFsdWUgb2YgMSB3aWxsIHJlc3VsdCBpbiAyNTAgZGlydHkgY2hlY2tzIHBlciBzZWNvbmQgKG9yIDEgZGlydHkgY2hlY2sgcGVyIHNlY29uZCBmb3IgYW4gaW5hY3RpdmUgdGFiKVxuICAgICAqIC0gQSB2YWx1ZSBvZiAyNSB3aWxsIHJlc3VsdCBpbiAxMCBkaXJ0eSBjaGVja3MgcGVyIHNlY29uZCAob3IgMSBkaXJ0eSBjaGVjayBwZXIgMjUgc2Vjb25kcyBmb3IgYW4gaW5hY3RpdmUgdGFiKVxuICAgICAqL1xuICAgIHRpbWVvdXRzUGVyQ2hlY2s6IDI1LFxuICAgIC8qKlxuICAgICAqIERlZmF1bHQ6IGBmYWxzZWBcbiAgICAgKlxuICAgICAqIERpc2FibGUgZGlydHktY2hlY2tpbmcgZW50aXJlbHkuIFByb3BlcnRpZXMgdGhhdCBjYW5ub3QgYmUgb2JzZXJ2ZWQgd2l0aG91dCBkaXJ0eSBjaGVja2luZ1xuICAgICAqIG9yIGFuIGFkYXB0ZXIsIHdpbGwgc2ltcGx5IG5vdCBiZSBvYnNlcnZlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRGVmYXVsdDogYGZhbHNlYFxuICAgICAqXG4gICAgICogVGhyb3cgYW4gZXJyb3IgaWYgYSBwcm9wZXJ0eSBpcyBiZWluZyBkaXJ0eS1jaGVja2VkLlxuICAgICAqL1xuICAgIHRocm93OiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIGRpcnR5IGNoZWNraW5nIHNldHRpbmdzIHRvIHRoZSBmcmFtZXdvcmsncyBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICByZXNldFRvRGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0c1BlckNoZWNrID0gNjtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRocm93ID0gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IHF1ZXVlVGFza09wdHMgPSB7XG4gICAgcGVyc2lzdGVudDogdHJ1ZSxcbn07XG5leHBvcnQgY2xhc3MgRGlydHlDaGVja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMudHJhY2tlZCA9IFtdO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB0aGlzLmVsYXBzZWRGcmFtZXMgPSAwO1xuICAgICAgICB0aGlzLmNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKERpcnR5Q2hlY2tTZXR0aW5ncy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgrK3RoaXMuZWxhcHNlZEZyYW1lcyA8IERpcnR5Q2hlY2tTZXR0aW5ncy50aW1lb3V0c1BlckNoZWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGFwc2VkRnJhbWVzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZWQgPSB0aGlzLnRyYWNrZWQ7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0cmFja2VkLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0cmFja2VkW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmlzRGlydHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmZsdXNoKDAgLyogbm9uZSAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoRGlydHlDaGVja1NldHRpbmdzLnRocm93KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICcke3Byb3BlcnR5TmFtZX0nIGlzIGJlaW5nIGRpcnR5LWNoZWNrZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaXJ0eUNoZWNrUHJvcGVydHkodGhpcywgb2JqLCBwcm9wZXJ0eU5hbWUpO1xuICAgIH1cbiAgICBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLnRyYWNrZWQucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLnBsYXRmb3JtLm1hY3JvVGFza1F1ZXVlLnF1ZXVlVGFzayh0aGlzLmNoZWNrLCBxdWV1ZVRhc2tPcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLnRyYWNrZWQuc3BsaWNlKHRoaXMudHJhY2tlZC5pbmRleE9mKHByb3BlcnR5KSwgMSk7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2suY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuRGlydHlDaGVja2VyLmluamVjdCA9IFtJUGxhdGZvcm1dO1xuZXhwb3J0IGNsYXNzIERpcnR5Q2hlY2tQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IoZGlydHlDaGVja2VyLCBvYmosIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIHRoaXMuZGlydHlDaGVja2VyID0gZGlydHlDaGVja2VyO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgfVxuICAgIHNldFZhbHVlKHYsIGYpIHtcbiAgICAgICAgLy8gdG9kbzogdGhpcyBzaG91bGQgYmUgYWxsb3dlZCwgcHJvYmFibHlcbiAgICAgICAgLy8gYnV0IHRoZSBjb25zdHJ1Y3Rpb24gb2YgZGlydHkgY2hlY2tlciBzaG91bGQgdGhyb3cgaW5zdGVhZFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyeWluZyB0byBzZXQgdmFsdWUgZm9yIHByb3BlcnR5ICR7dGhpcy5wcm9wZXJ0eUtleX0gaW4gZGlydHkgY2hlY2tlcmApO1xuICAgIH1cbiAgICBpc0RpcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbGRWYWx1ZSAhPT0gdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgfVxuICAgIGZsdXNoKGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIHRoaXMuc3Vicy5ub3RpZnkobmV3VmFsdWUsIG9sZFZhbHVlLCBmbGFncyB8IDggLyogdXBkYXRlVGFyZ2V0ICovKTtcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLmFkZChzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlDaGVja2VyLmFkZFByb3BlcnR5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5Q2hlY2tlci5yZW1vdmVQcm9wZXJ0eSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnN1YnNjcmliZXJDb2xsZWN0aW9uKERpcnR5Q2hlY2tQcm9wZXJ0eSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJ0eS1jaGVja2VyLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUluZGV4TWFwIH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24uanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvblNpemVPYnNlcnZlciB9IGZyb20gJy4vY29sbGVjdGlvbi1sZW5ndGgtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24gfSBmcm9tICcuL3N1YnNjcmliZXItY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBkZWYgfSBmcm9tICcuLi91dGlsaXRpZXMtb2JqZWN0cy5qcyc7XG5jb25zdCBvYnNlcnZlckxvb2t1cCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwcm90byA9IE1hcC5wcm90b3R5cGU7XG5jb25zdCAkc2V0ID0gcHJvdG8uc2V0O1xuY29uc3QgJGNsZWFyID0gcHJvdG8uY2xlYXI7XG5jb25zdCAkZGVsZXRlID0gcHJvdG8uZGVsZXRlO1xuY29uc3QgbmF0aXZlID0geyBzZXQ6ICRzZXQsIGNsZWFyOiAkY2xlYXIsIGRlbGV0ZTogJGRlbGV0ZSB9O1xuY29uc3QgbWV0aG9kcyA9IFsnc2V0JywgJ2NsZWFyJywgJ2RlbGV0ZSddO1xuLy8gbm90ZTogd2UgY2FuJ3QgcmVhbGx5IGRvIG11Y2ggd2l0aCBNYXAgZHVlIHRvIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSBub3QgYmVpbmcgYWNjZXNzaWJsZSBzbyB3ZSdyZSBqdXN0IHVzaW5nIHRoZSBuYXRpdmUgY2FsbHNcbi8vIGZvcnR1bmF0ZWx5LCBtYXAvZGVsZXRlL2NsZWFyIGFyZSBlYXN5IHRvIHJlY29uc3RydWN0IGZvciB0aGUgaW5kZXhNYXBcbmNvbnN0IG9ic2VydmUgPSB7XG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5tYXBcbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRzZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgJHNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBjb25zdCBuZXdTaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gb2xkU2l6ZSkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeVsxXSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnB1c2goby5pbmRleE1hcFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmluZGV4TWFwW2ldID0gLTI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvLmluZGV4TWFwW29sZFNpemVdID0gLTI7XG4gICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5jbGVhclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkY2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4TWFwID0gby5pbmRleE1hcDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBmb3IgKGNvbnN0IF8gb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhNYXBbaV0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcC5kZWxldGVkSXRlbXMucHVzaChpbmRleE1hcFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRjbGVhci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaW5kZXhNYXAubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZGVsZXRlXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICRkZWxldGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gby5pbmRleE1hcDtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5wdXNoKGluZGV4TWFwW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhNYXAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3VsdCA9ICRkZWxldGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZVJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuY29uc3QgZGVzY3JpcHRvclByb3BzID0ge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBkZWYob2JzZXJ2ZVttZXRob2RdLCAnb2JzZXJ2aW5nJywgeyB2YWx1ZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbn1cbmxldCBlbmFibGVNYXBPYnNlcnZhdGlvbkNhbGxlZCA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZU1hcE9ic2VydmF0aW9uKCkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKHByb3RvW21ldGhvZF0ub2JzZXJ2aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWYocHJvdG8sIG1ldGhvZCwgeyAuLi5kZXNjcmlwdG9yUHJvcHMsIHZhbHVlOiBvYnNlcnZlW21ldGhvZF0gfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZU1hcE9ic2VydmF0aW9uKCkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKHByb3RvW21ldGhvZF0ub2JzZXJ2aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWYocHJvdG8sIG1ldGhvZCwgeyAuLi5kZXNjcmlwdG9yUHJvcHMsIHZhbHVlOiBuYXRpdmVbbWV0aG9kXSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNYXBPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IobWFwKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IDY2IC8qIE1hcCAqLztcbiAgICAgICAgaWYgKCFlbmFibGVNYXBPYnNlcnZhdGlvbkNhbGxlZCkge1xuICAgICAgICAgICAgZW5hYmxlTWFwT2JzZXJ2YXRpb25DYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5hYmxlTWFwT2JzZXJ2YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBtYXA7XG4gICAgICAgIHRoaXMuaW5kZXhNYXAgPSBjcmVhdGVJbmRleE1hcChtYXAuc2l6ZSk7XG4gICAgICAgIHRoaXMubGVuT2JzID0gdm9pZCAwO1xuICAgICAgICBvYnNlcnZlckxvb2t1cC5zZXQobWFwLCB0aGlzKTtcbiAgICB9XG4gICAgbm90aWZ5KCkge1xuICAgICAgICBjb25zdCBpbmRleE1hcCA9IHRoaXMuaW5kZXhNYXA7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgICAgdGhpcy5pbmRleE1hcCA9IGNyZWF0ZUluZGV4TWFwKHNpemUpO1xuICAgICAgICB0aGlzLnN1YnMubm90aWZ5Q29sbGVjdGlvbihpbmRleE1hcCwgOCAvKiB1cGRhdGVUYXJnZXQgKi8pO1xuICAgIH1cbiAgICBnZXRMZW5ndGhPYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuT2JzID8/ICh0aGlzLmxlbk9icyA9IG5ldyBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyKHRoaXMpKTtcbiAgICB9XG59XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihNYXBPYnNlcnZlcik7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwT2JzZXJ2ZXIobWFwKSB7XG4gICAgbGV0IG9ic2VydmVyID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KG1hcCk7XG4gICAgaWYgKG9ic2VydmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgTWFwT2JzZXJ2ZXIobWFwKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLW9ic2VydmVyLmpzLm1hcCIsImltcG9ydCB7IFNldHRlck5vdGlmaWVyIH0gZnJvbSAnLi9zZXR0ZXItb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgZGVmIH0gZnJvbSAnLi4vdXRpbGl0aWVzLW9iamVjdHMuanMnO1xuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzTG9va3VwKG9iaikge1xuICAgIGlmIChvYmouJG9ic2VydmVycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZihvYmosICckb2JzZXJ2ZXJzJywgeyB2YWx1ZToge30gfSk7XG4gICAgICAgIC8vIHRvZG86IGRlZmluZSBpbiBhIHdlYWttYXBcbiAgICB9XG4gICAgcmV0dXJuIG9iai4kb2JzZXJ2ZXJzO1xufVxuY29uc3Qgbm9WYWx1ZSA9IHt9O1xuLy8gaW1wbCwgd29udCBiZSBzZWVuXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2YWJsZSh0YXJnZXRPckNvbmZpZywga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgLy8gZWl0aGVyIHRoaXMgY2hlY2ssIG9yIGFyZ3VtZW50cy5sZW5ndGggPT09IDNcbiAgICAvLyBvciBjb3VsZCBiZSBib3RoLCBzbyBjYW4gdGhyb3cgYWdhaW5zdCB1c2VyIGVycm9yIGZvciBiZXR0ZXIgRFhcbiAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgLy8gZm9yOlxuICAgICAgICAvLyAgICBAb2JzZXJ2YWJsZSgncHJvcCcpXG4gICAgICAgIC8vICAgIGNsYXNzIHt9XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIEBvYnNlcnZhYmxlKHsgbmFtZTogJ3Byb3AnLCBjYWxsYmFjazogLi4uIH0pXG4gICAgICAgIC8vICAgIGNsYXNzIHt9XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIGNsYXNzIHtcbiAgICAgICAgLy8gICAgICBAb2JzZXJ2YWJsZSgpIHByb3BcbiAgICAgICAgLy8gICAgICBAb2JzZXJ2YWJsZSh7IGNhbGxiYWNrOiAuLi4gfSkgcHJvcDJcbiAgICAgICAgLy8gICAgfVxuICAgICAgICByZXR1cm4gKCh0LCBrLCBkKSA9PiBkZWNvKHQsIGssIGQsIHRhcmdldE9yQ29uZmlnKSk7XG4gICAgfVxuICAgIC8vIGZvcjpcbiAgICAvLyAgICBjbGFzcyB7XG4gICAgLy8gICAgICBAb2JzZXJ2YWJsZSBwcm9wXG4gICAgLy8gICAgfVxuICAgIHJldHVybiBkZWNvKHRhcmdldE9yQ29uZmlnLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIGZ1bmN0aW9uIGRlY28odGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IsIGNvbmZpZykge1xuICAgICAgICAvLyBjbGFzcyBkZWNvcmF0b3I/XG4gICAgICAgIGNvbnN0IGlzQ2xhc3NEZWNvcmF0b3IgPSBrZXkgPT09IHZvaWQgMDtcbiAgICAgICAgY29uZmlnID0gdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgID8geyBuYW1lOiBjb25maWcgfVxuICAgICAgICAgICAgOiAoY29uZmlnIHx8IHt9KTtcbiAgICAgICAgaWYgKGlzQ2xhc3NEZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGtleSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCBrZXkgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNhZ2UsIGNhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkgbmFtZSBmb3IgQG9ic2VydmFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXRlcm1pbmUgY2FsbGJhY2sgbmFtZSBiYXNlZCBvbiBjb25maWcgb3IgY29udmVudGlvbi5cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2sgfHwgYCR7U3RyaW5nKGtleSl9Q2hhbmdlZGA7XG4gICAgICAgIGxldCBpbml0aWFsVmFsdWUgPSBub1ZhbHVlO1xuICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgLy8gd2UncmUgYWRkaW5nIGEgZ2V0dGVyIGFuZCBzZXR0ZXIgd2hpY2ggbWVhbnMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGNhbm5vdCBoYXZlIGEgXCJ2YWx1ZVwiIG9yIFwid3JpdGFibGVcIiBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGRlbGV0ZSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgZGVsZXRlIGRlc2NyaXB0b3Iud3JpdGFibGU7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBkZXNjcmlwdG9yLmluaXRpYWxpemVyPy4oKTtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXNjcmlwdG9yLmluaXRpYWxpemVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHsgY29uZmlndXJhYmxlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSB0aGUgYWNjZXNzb3IgZW51bWVyYWJsZSBieSBkZWZhdWx0LCBhcyBmaWVsZHMgYXJlIGVudW1lcmFibGVcbiAgICAgICAgaWYgKCEoJ2VudW1lcmFibGUnIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG8oYmlnb3Bvbi9mcmVkKTogZGlzY3VzcyBzdHJpbmcgYXBpIGZvciBjb252ZXJ0ZXJcbiAgICAgICAgY29uc3QgJHNldCA9IGNvbmZpZy5zZXQ7XG4gICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gZyggLyogQG9ic2VydmFibGUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXROb3RpZmllcih0aGlzLCBrZXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUsICRzZXQpLmdldFZhbHVlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gZnVuY3Rpb24gcyhuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZ2V0Tm90aWZpZXIodGhpcywga2V5LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlLCAkc2V0KS5zZXRWYWx1ZShuZXdWYWx1ZSwgMCAvKiBub25lICovKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVzY3JpcHRvci5nZXQuZ2V0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBnTygvKiBAb2JzZXJ2YWJsZSAqLyBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBnZXROb3RpZmllcihvYmosIGtleSwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSwgJHNldCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc0NsYXNzRGVjb3JhdG9yKSB7XG4gICAgICAgICAgICBkZWYodGFyZ2V0LnByb3RvdHlwZSwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Tm90aWZpZXIob2JqLCBrZXksIGNhbGxiYWNrS2V5LCBpbml0aWFsVmFsdWUsIHNldCkge1xuICAgIGNvbnN0IGxvb2t1cCA9IGdldE9ic2VydmVyc0xvb2t1cChvYmopO1xuICAgIGxldCBub3RpZmllciA9IGxvb2t1cFtrZXldO1xuICAgIGlmIChub3RpZmllciA9PSBudWxsKSB7XG4gICAgICAgIG5vdGlmaWVyID0gbmV3IFNldHRlck5vdGlmaWVyKG9iaiwgY2FsbGJhY2tLZXksIHNldCwgaW5pdGlhbFZhbHVlID09PSBub1ZhbHVlID8gdm9pZCAwIDogaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgbG9va3VwW2tleV0gPSBub3RpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuIG5vdGlmaWVyO1xufVxuLypcbiAgICAgICAgICB8IHR5cGVzY3JpcHQgICAgICAgfCBiYWJlbFxuLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxucHJvcGVydHkgIHwgY29uZmlnICAgICAgICAgICB8IGNvbmZpZ1xudy9wYXJlbnMgIHwgdGFyZ2V0LCBrZXkgICAgICB8IHRhcmdldCwga2V5LCBkZXNjcmlwdG9yXG4tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5wcm9wZXJ0eSAgfCB0YXJnZXQsIGtleSAgICAgIHwgdGFyZ2V0LCBrZXksIGRlc2NyaXB0b3Jcbm5vIHBhcmVucyB8IG4vYSAgICAgICAgICAgICAgfCBuL2Fcbi0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzICAgICB8IGNvbmZpZyAgICAgICAgICAgfCBjb25maWdcbiAgICAgICAgICB8IHRhcmdldCAgICAgICAgICAgfCB0YXJnZXRcbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsImltcG9ydCB7IERJLCBpc0FycmF5SW5kZXgsIElMb2dnZXIgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgZ2V0QXJyYXlPYnNlcnZlciB9IGZyb20gJy4vYXJyYXktb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgQ29tcHV0ZWRPYnNlcnZlciB9IGZyb20gJy4vY29tcHV0ZWQtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgSURpcnR5Q2hlY2tlciB9IGZyb20gJy4vZGlydHktY2hlY2tlci5qcyc7XG5pbXBvcnQgeyBnZXRNYXBPYnNlcnZlciB9IGZyb20gJy4vbWFwLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IFByaW1pdGl2ZU9ic2VydmVyIH0gZnJvbSAnLi9wcmltaXRpdmUtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlBY2Nlc3NvciB9IGZyb20gJy4vcHJvcGVydHktYWNjZXNzb3IuanMnO1xuaW1wb3J0IHsgZ2V0U2V0T2JzZXJ2ZXIgfSBmcm9tICcuL3NldC1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBTZXR0ZXJPYnNlcnZlciB9IGZyb20gJy4vc2V0dGVyLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IGRlZiB9IGZyb20gJy4uL3V0aWxpdGllcy1vYmplY3RzLmpzJztcbmV4cG9ydCBjb25zdCBwcm9wZXJ0eUFjY2Vzc29yID0gbmV3IFByb3BlcnR5QWNjZXNzb3IoKTtcbmV4cG9ydCBjb25zdCBJT2JzZXJ2ZXJMb2NhdG9yID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJT2JzZXJ2ZXJMb2NhdG9yJywgeCA9PiB4LnNpbmdsZXRvbihPYnNlcnZlckxvY2F0b3IpKTtcbmV4cG9ydCBjb25zdCBJTm9kZU9ic2VydmVyTG9jYXRvciA9IERJXG4gICAgLmNyZWF0ZUludGVyZmFjZSgnSU5vZGVPYnNlcnZlckxvY2F0b3InLCB4ID0+IHguY2FjaGVkQ2FsbGJhY2soaGFuZGxlciA9PiB7XG4gICAgaGFuZGxlci5nZXRBbGwoSUxvZ2dlcikuZm9yRWFjaChsb2dnZXIgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ1VzaW5nIGRlZmF1bHQgSU5vZGVPYnNlcnZlckxvY2F0b3IgaW1wbGVtZW50YXRpb24uIFdpbGwgbm90IGJlIGFibGUgdG8gb2JzZXJ2ZSBub2RlcyAoSFRNTCBldGMuLi4pLicpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRGVmYXVsdE5vZGVPYnNlcnZlckxvY2F0b3IoKTtcbn0pKTtcbmNsYXNzIERlZmF1bHROb2RlT2JzZXJ2ZXJMb2NhdG9yIHtcbiAgICBoYW5kbGVzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldE9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlBY2Nlc3NvcjtcbiAgICB9XG4gICAgZ2V0QWNjZXNzb3IoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUFjY2Vzc29yO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPYnNlcnZlckxvY2F0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGRpcnR5Q2hlY2tlciwgbm9kZU9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICB0aGlzLmRpcnR5Q2hlY2tlciA9IGRpcnR5Q2hlY2tlcjtcbiAgICAgICAgdGhpcy5ub2RlT2JzZXJ2ZXJMb2NhdG9yID0gbm9kZU9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5hZGFwdGVycyA9IFtdO1xuICAgIH1cbiAgICBhZGRBZGFwdGVyKGFkYXB0ZXIpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVycy5wdXNoKGFkYXB0ZXIpO1xuICAgIH1cbiAgICBnZXRPYnNlcnZlcihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gb2JqLiRvYnNlcnZlcnM/LltrZXldXG4gICAgICAgICAgICA/PyB0aGlzLmNhY2hlKG9iaiwga2V5LCB0aGlzLmNyZWF0ZU9ic2VydmVyKG9iaiwga2V5KSk7XG4gICAgfVxuICAgIGdldEFjY2Vzc29yKG9iaiwga2V5KSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IG9iai4kb2JzZXJ2ZXJzPy5ba2V5XTtcbiAgICAgICAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vZGVPYnNlcnZlckxvY2F0b3IuaGFuZGxlcyhvYmosIGtleSwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVPYnNlcnZlckxvY2F0b3IuZ2V0QWNjZXNzb3Iob2JqLCBrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUFjY2Vzc29yO1xuICAgIH1cbiAgICBnZXRBcnJheU9ic2VydmVyKG9ic2VydmVkQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFycmF5T2JzZXJ2ZXIob2JzZXJ2ZWRBcnJheSk7XG4gICAgfVxuICAgIGdldE1hcE9ic2VydmVyKG9ic2VydmVkTWFwKSB7XG4gICAgICAgIHJldHVybiBnZXRNYXBPYnNlcnZlcihvYnNlcnZlZE1hcCk7XG4gICAgfVxuICAgIGdldFNldE9ic2VydmVyKG9ic2VydmVkU2V0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRPYnNlcnZlcihvYnNlcnZlZFNldCk7XG4gICAgfVxuICAgIGNyZWF0ZU9ic2VydmVyKG9iaiwga2V5KSB7XG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJpbWl0aXZlT2JzZXJ2ZXIob2JqLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vZGVPYnNlcnZlckxvY2F0b3IuaGFuZGxlcyhvYmosIGtleSwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVPYnNlcnZlckxvY2F0b3IuZ2V0T2JzZXJ2ZXIob2JqLCBrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdsZW5ndGgnOlxuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXJyYXlPYnNlcnZlcihvYmopLmdldExlbmd0aE9ic2VydmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFwT2JzZXJ2ZXIob2JqKS5nZXRMZW5ndGhPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFNldE9ic2VydmVyKG9iaikuZ2V0TGVuZ3RoT2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBpc0FycmF5SW5kZXgoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXJyYXlPYnNlcnZlcihvYmopLmdldEluZGV4T2JzZXJ2ZXIoTnVtYmVyKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgLy8gT25seSBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdpbGwgeWllbGQgYSBkZXNjcmlwdG9yIGhlcmUsIG90aGVyd2lzZSB3YWxrIHVwIHRoZSBwcm90byBjaGFpblxuICAgICAgICBpZiAocGQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICB3aGlsZSAocHJvdG8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHBkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBkZXNjcmlwdG9yIGRvZXMgbm90IGhhdmUgYSAndmFsdWUnIHByb3AsIGl0IG11c3QgaGF2ZSBhIGdldHRlciBhbmQvb3Igc2V0dGVyXG4gICAgICAgIGlmIChwZCAhPT0gdm9pZCAwICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGQsICd2YWx1ZScpKSB7XG4gICAgICAgICAgICBsZXQgb2JzID0gdGhpcy5nZXRBZGFwdGVyT2JzZXJ2ZXIob2JqLCBrZXksIHBkKTtcbiAgICAgICAgICAgIGlmIChvYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9icyA9IChwZC5nZXQ/LmdldE9ic2VydmVyID8/IHBkLnNldD8uZ2V0T2JzZXJ2ZXIpPy4ob2JqLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYnMgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gcGQuY29uZmlndXJhYmxlXG4gICAgICAgICAgICAgICAgICAgID8gQ29tcHV0ZWRPYnNlcnZlci5jcmVhdGUob2JqLCBrZXksIHBkLCB0aGlzLCAvKiBBT1Q6IG5vdCB0cnVlIGZvciBJRTExICovIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5kaXJ0eUNoZWNrZXIuY3JlYXRlUHJvcGVydHkob2JqLCBrZXkpXG4gICAgICAgICAgICAgICAgOiBvYnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3JkaW5hcnkgZ2V0L3NldCBvYnNlcnZhdGlvbiAodGhlIGNvbW1vbiB1c2UgY2FzZSlcbiAgICAgICAgLy8gVE9ETzogdGhpbmsgYWJvdXQgaG93IHRvIGhhbmRsZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzaXQgb24gdGhlIGluc3RhbmNlIChzaG91bGQgd2UgZG8gYW55dGhpbmcgZGlmZmVyZW50PylcbiAgICAgICAgcmV0dXJuIG5ldyBTZXR0ZXJPYnNlcnZlcihvYmosIGtleSk7XG4gICAgfVxuICAgIGdldEFkYXB0ZXJPYnNlcnZlcihvYmosIHByb3BlcnR5TmFtZSwgcGQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWRhcHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGFwdGVyIG9mIHRoaXMuYWRhcHRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IGFkYXB0ZXIuZ2V0T2JzZXJ2ZXIob2JqLCBwcm9wZXJ0eU5hbWUsIHBkLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYWNoZShvYmosIGtleSwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyLmRvTm90Q2FjaGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLiRvYnNlcnZlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVmKG9iaiwgJyRvYnNlcnZlcnMnLCB7IHZhbHVlOiB7IFtrZXldOiBvYnNlcnZlciB9IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmouJG9ic2VydmVyc1trZXldID0gb2JzZXJ2ZXI7XG4gICAgfVxufVxuT2JzZXJ2ZXJMb2NhdG9yLmluamVjdCA9IFtJRGlydHlDaGVja2VyLCBJTm9kZU9ic2VydmVyTG9jYXRvcl07XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbk9ic2VydmVyKGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgb2JzO1xuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgb2JzID0gZ2V0QXJyYXlPYnNlcnZlcihjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYnMgPSBnZXRNYXBPYnNlcnZlcihjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBvYnMgPSBnZXRTZXRPYnNlcnZlcihjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG9icztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmVyLWxvY2F0b3IuanMubWFwIiwiZXhwb3J0IGNsYXNzIFByaW1pdGl2ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvYmosIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgZ2V0IGRvTm90Q2FjaGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgfVxuICAgIHNldFZhbHVlKCkgeyB9XG4gICAgc3Vic2NyaWJlKCkgeyB9XG4gICAgdW5zdWJzY3JpYmUoKSB7IH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW1pdGl2ZS1vYnNlcnZlci5qcy5tYXAiLCJleHBvcnQgY2xhc3MgUHJvcGVydHlBY2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IHRoaW5nIGNhbiBiZSBndWFyYW50ZWVkIGlzIGl0J3MgYW4gb2JqZWN0XG4gICAgICAgIC8vIGV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSBhY2Nlc3NvciBpcyB1c2VkIHRvIGFjY2VzcyBhbiBlbGVtZW50XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgZ2V0VmFsdWUob2JqLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgZmxhZ3MsIG9iaiwga2V5KSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHktYWNjZXNzb3IuanMubWFwIiwiaW1wb3J0IHsgY29ubmVjdGluZywgY3VycmVudENvbm5lY3RhYmxlIH0gZnJvbSAnLi9jb25uZWN0YWJsZS1zd2l0Y2hlci5qcyc7XG5jb25zdCBSJGdldCA9IFJlZmxlY3QuZ2V0O1xuY29uc3QgdG9TdHJpbmdUYWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgcHJveHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gY2FuV3JhcChvYmopIHtcbiAgICBzd2l0Y2ggKHRvU3RyaW5nVGFnLmNhbGwob2JqKSkge1xuICAgICAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTWFwXSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgU2V0XSc6XG4gICAgICAgICAgICAvLyBpdCdzIHVubGlrZWx5IHRoYXQgbWV0aG9kcyBvbiB0aGUgZm9sbG93aW5nIDIgb2JqZWN0cyBuZWVkIHRvIGJlIG9ic2VydmVkIGZvciBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBzbyB3aGlsZSB0aGV5IGFyZSB2YWxpZC8gd2UgZG9uJ3Qgd3JhcCB0aGVtIGVpdGhlclxuICAgICAgICAgICAgLy8gY2FzZSAnW29iamVjdCBNYXRoXSc6XG4gICAgICAgICAgICAvLyBjYXNlICdbb2JqZWN0IFJlZmxlY3RdJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCByYXdLZXkgPSAnX19yYXdfXyc7XG5leHBvcnQgZnVuY3Rpb24gd3JhcCh2KSB7XG4gICAgcmV0dXJuIGNhbldyYXAodikgPyBnZXRQcm94eSh2KSA6IHY7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJveHkob2JqKSB7XG4gICAgLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXR1cm4gcHJveHlNYXAuZ2V0KG9iaikgPz8gY3JlYXRlUHJveHkob2JqKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXcob2JqKSB7XG4gICAgLy8gdG9kbzogZ2V0IGluIGEgd2Vha21hcCBpZiBudWxsL3VuZGVmXG4gICAgcmV0dXJuIG9ialtyYXdLZXldID8/IG9iajtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAodikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVybiBjYW5XcmFwKHYpICYmIHZbcmF3S2V5XSB8fCB2O1xufVxuZnVuY3Rpb24gZG9Ob3RDb2xsZWN0KGtleSkge1xuICAgIHJldHVybiBrZXkgPT09ICdjb25zdHJ1Y3RvcidcbiAgICAgICAgfHwga2V5ID09PSAnX19wcm90b19fJ1xuICAgICAgICAvLyBwcm9iYWJseSBzaG91bGQgcmV2ZXJ0IHRvIHYxIG5hbWluZyBzdHlsZSBmb3IgY29uc2lzdGVuY3kgd2l0aCBidWlsdGluP1xuICAgICAgICAvLyBfX29fXyBpcyBzaG9ydGVycyAmIGxlc3MgY2hhbmNlIG9mIGNvbmZsaWN0IHdpdGggb3RoZXIgbGlicyBhcyB3ZWxsXG4gICAgICAgIHx8IGtleSA9PT0gJyRvYnNlcnZlcnMnXG4gICAgICAgIHx8IGtleSA9PT0gU3ltYm9sLnRvUHJpbWl0aXZlXG4gICAgICAgIHx8IGtleSA9PT0gU3ltYm9sLnRvU3RyaW5nVGFnO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJveHkob2JqKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG9iaiBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgID8gYXJyYXlIYW5kbGVyXG4gICAgICAgIDogb2JqIGluc3RhbmNlb2YgTWFwIHx8IG9iaiBpbnN0YW5jZW9mIFNldFxuICAgICAgICAgICAgPyBjb2xsZWN0aW9uSGFuZGxlclxuICAgICAgICAgICAgOiBvYmplY3RIYW5kbGVyO1xuICAgIGNvbnN0IHByb3hpZWRPYmogPSBuZXcgUHJveHkob2JqLCBoYW5kbGVyKTtcbiAgICBwcm94eU1hcC5zZXQob2JqLCBwcm94aWVkT2JqKTtcbiAgICByZXR1cm4gcHJveGllZE9iajtcbn1cbmNvbnN0IG9iamVjdEhhbmRsZXIgPSB7XG4gICAgZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgICAgICAvLyBtYXliZSB1c2Ugc3ltYm9sP1xuICAgICAgICBpZiAoa2V5ID09PSByYXdLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGFibGUgPSBjdXJyZW50Q29ubmVjdGFibGUoKTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW5nIHx8IGRvTm90Q29sbGVjdChrZXkpIHx8IGNvbm5lY3RhYmxlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBSJGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IHN0YXRpY1xuICAgICAgICBjb25uZWN0YWJsZS5vYnNlcnZlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgICAgICByZXR1cm4gd3JhcChSJGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKTtcbiAgICB9LFxufTtcbmNvbnN0IGFycmF5SGFuZGxlciA9IHtcbiAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgIC8vIG1heWJlIHVzZSBzeW1ib2w/XG4gICAgICAgIGlmIChrZXkgPT09IHJhd0tleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGN1cnJlbnRDb25uZWN0YWJsZSgpO1xuICAgICAgICBpZiAoIWNvbm5lY3RpbmcgfHwgZG9Ob3RDb2xsZWN0KGtleSkgfHwgY29ubmVjdGFibGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFIkZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGUub2JzZXJ2ZVByb3BlcnR5KHRhcmdldCwgJ2xlbmd0aCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQubGVuZ3RoO1xuICAgICAgICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5TWFwO1xuICAgICAgICAgICAgY2FzZSAnaW5jbHVkZXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlJbmNsdWRlcztcbiAgICAgICAgICAgIGNhc2UgJ2luZGV4T2YnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlJbmRleE9mO1xuICAgICAgICAgICAgY2FzZSAnbGFzdEluZGV4T2YnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlMYXN0SW5kZXhPZjtcbiAgICAgICAgICAgIGNhc2UgJ2V2ZXJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5RXZlcnk7XG4gICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlGaWx0ZXI7XG4gICAgICAgICAgICBjYXNlICdmaW5kSW5kZXgnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlGaW5kSW5kZXg7XG4gICAgICAgICAgICBjYXNlICdmbGF0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5RmxhdDtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXRNYXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlGbGF0TWFwO1xuICAgICAgICAgICAgY2FzZSAnam9pbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheUpvaW47XG4gICAgICAgICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5UHVzaDtcbiAgICAgICAgICAgIGNhc2UgJ3BvcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVBvcDtcbiAgICAgICAgICAgIGNhc2UgJ3JlZHVjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRSZWR1Y2U7XG4gICAgICAgICAgICBjYXNlICdyZWR1Y2VSaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRSZWR1Y2VSaWdodDtcbiAgICAgICAgICAgIGNhc2UgJ3JldmVyc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlSZXZlcnNlO1xuICAgICAgICAgICAgY2FzZSAnc2hpZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlTaGlmdDtcbiAgICAgICAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlVbnNoaWZ0O1xuICAgICAgICAgICAgY2FzZSAnc2xpY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlTbGljZTtcbiAgICAgICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVNwbGljZTtcbiAgICAgICAgICAgIGNhc2UgJ3NvbWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlTb21lO1xuICAgICAgICAgICAgY2FzZSAnc29ydCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVNvcnQ7XG4gICAgICAgICAgICBjYXNlICdrZXlzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEtleXM7XG4gICAgICAgICAgICBjYXNlICd2YWx1ZXMnOlxuICAgICAgICAgICAgY2FzZSBTeW1ib2wuaXRlcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRWYWx1ZXM7XG4gICAgICAgICAgICBjYXNlICdlbnRyaWVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVudHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGFibGUub2JzZXJ2ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICAgICAgcmV0dXJuIHdyYXAoUiRnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSk7XG4gICAgfSxcbiAgICAvLyBmb3IgKGxldCBpIGluIGFycmF5KSAuLi5cbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZVByb3BlcnR5KHRhcmdldCwgJ2xlbmd0aCcpO1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlNYXAoY2IsIHRoaXNBcmcpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3Lm1hcCgodiwgaSkgPT4gXG4gICAgLy8gZG8gd2Ugd3JhcCBgdGhpc0FyZ2A/XG4gICAgdW53cmFwKGNiLmNhbGwodGhpc0FyZywgd3JhcCh2KSwgaSwgdGhpcykpKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gd3JhcChyZXMpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5RXZlcnkoY2IsIHRoaXNBcmcpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3LmV2ZXJ5KCh2LCBpKSA9PiBjYi5jYWxsKHRoaXNBcmcsIHdyYXAodiksIGksIHRoaXMpKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5RmlsdGVyKGNiLCB0aGlzQXJnKSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGNvbnN0IHJlcyA9IHJhdy5maWx0ZXIoKHYsIGkpID0+IFxuICAgIC8vIGRvIHdlIHdyYXAgYHRoaXNBcmdgP1xuICAgIHVud3JhcChjYi5jYWxsKHRoaXNBcmcsIHdyYXAodiksIGksIHRoaXMpKSk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHdyYXAocmVzKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheUluY2x1ZGVzKHYpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3LmluY2x1ZGVzKHVud3JhcCh2KSk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheUluZGV4T2Yodikge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcuaW5kZXhPZih1bndyYXAodikpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlMYXN0SW5kZXhPZih2KSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGNvbnN0IHJlcyA9IHJhdy5sYXN0SW5kZXhPZih1bndyYXAodikpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlGaW5kSW5kZXgoY2IsIHRoaXNBcmcpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3LmZpbmRJbmRleCgodiwgaSkgPT4gdW53cmFwKGNiLmNhbGwodGhpc0FyZywgd3JhcCh2KSwgaSwgdGhpcykpKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5RmxhdCgpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHdyYXAocmF3LmZsYXQoKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlGbGF0TWFwKGNiLCB0aGlzQXJnKSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiBnZXRQcm94eShyYXcuZmxhdE1hcCgodiwgaSkgPT4gd3JhcChjYi5jYWxsKHRoaXNBcmcsIHdyYXAodiksIGksIHRoaXMpKSkpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5Sm9pbihzZXBhcmF0b3IpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHJhdy5qb2luKHNlcGFyYXRvcik7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlQb3AoKSB7XG4gICAgcmV0dXJuIHdyYXAoZ2V0UmF3KHRoaXMpLnBvcCgpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheVB1c2goLi4uYXJncykge1xuICAgIHJldHVybiBnZXRSYXcodGhpcykucHVzaCguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheVNoaWZ0KCkge1xuICAgIHJldHVybiB3cmFwKGdldFJhdyh0aGlzKS5zaGlmdCgpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheVVuc2hpZnQoLi4uYXJncykge1xuICAgIHJldHVybiBnZXRSYXcodGhpcykudW5zaGlmdCguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheVNwbGljZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHdyYXAoZ2V0UmF3KHRoaXMpLnNwbGljZSguLi5hcmdzKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlSZXZlcnNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3LnJldmVyc2UoKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gd3JhcChyZXMpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5U29tZShjYiwgdGhpc0FyZykge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcuc29tZSgodiwgaSkgPT4gdW53cmFwKGNiLmNhbGwodGhpc0FyZywgd3JhcCh2KSwgaSwgdGhpcykpKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5U29ydChjYikge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcuc29ydChjYik7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHdyYXAocmVzKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheVNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIGdldFByb3h5KHJhdy5zbGljZShzdGFydCwgZW5kKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkUmVkdWNlKGNiLCBpbml0VmFsdWUpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3LnJlZHVjZSgoY3VyciwgdiwgaSkgPT4gY2IoY3Vyciwgd3JhcCh2KSwgaSwgdGhpcyksIGluaXRWYWx1ZSk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHdyYXAocmVzKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRSZWR1Y2VSaWdodChjYiwgaW5pdFZhbHVlKSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGNvbnN0IHJlcyA9IHJhdy5yZWR1Y2VSaWdodCgoY3VyciwgdiwgaSkgPT4gY2IoY3Vyciwgd3JhcCh2KSwgaSwgdGhpcyksIGluaXRWYWx1ZSk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHdyYXAocmVzKTtcbn1cbi8vIHRoZSBiZWxvdyBsb2dpYyB0YWtlcyBpbnNwaXJhdGlvbiBmcm9tIFZ1ZSwgTW9ieFxuLy8gbXVjaCB0aGFua3MgdG8gdGhlbSBmb3Igd29ya2luZyBvdXQgdGhpc1xuY29uc3QgY29sbGVjdGlvbkhhbmRsZXIgPSB7XG4gICAgZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgICAgICAvLyBtYXliZSB1c2Ugc3ltYm9sP1xuICAgICAgICBpZiAoa2V5ID09PSByYXdLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGFibGUgPSBjdXJyZW50Q29ubmVjdGFibGUoKTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW5nIHx8IGRvTm90Q29sbGVjdChrZXkpIHx8IGNvbm5lY3RhYmxlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBSJGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZS5vYnNlcnZlUHJvcGVydHkodGFyZ2V0LCAnc2l6ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2l6ZTtcbiAgICAgICAgICAgIGNhc2UgJ2NsZWFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZENsZWFyO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZERlbGV0ZTtcbiAgICAgICAgICAgIGNhc2UgJ2ZvckVhY2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRm9yRWFjaDtcbiAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRHZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkU2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hhcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRIYXM7XG4gICAgICAgICAgICBjYXNlICdrZXlzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEtleXM7XG4gICAgICAgICAgICBjYXNlICd2YWx1ZXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkVmFsdWVzO1xuICAgICAgICAgICAgY2FzZSAnZW50cmllcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbnRyaWVzO1xuICAgICAgICAgICAgY2FzZSBTeW1ib2wuaXRlcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIE1hcCA/IHdyYXBwZWRFbnRyaWVzIDogd3JhcHBlZFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcChSJGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHdyYXBwZWRGb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiByYXcuZm9yRWFjaCgodiwga2V5KSA9PiB7XG4gICAgICAgIGNiLmNhbGwoLyogc2hvdWxkIHdyYXAgb3Igbm90Pz8gKi8gdGhpc0FyZywgd3JhcCh2KSwgd3JhcChrZXkpLCB0aGlzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRIYXModikge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gcmF3Lmhhcyh1bndyYXAodikpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEdldChrKSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiB3cmFwKHJhdy5nZXQodW53cmFwKGspKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkU2V0KGssIHYpIHtcbiAgICByZXR1cm4gd3JhcChnZXRSYXcodGhpcykuc2V0KHVud3JhcChrKSwgdW53cmFwKHYpKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkQWRkKHYpIHtcbiAgICByZXR1cm4gd3JhcChnZXRSYXcodGhpcykuYWRkKHVud3JhcCh2KSkpO1xufVxuZnVuY3Rpb24gd3JhcHBlZENsZWFyKCkge1xuICAgIHJldHVybiB3cmFwKGdldFJhdyh0aGlzKS5jbGVhcigpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWREZWxldGUoaykge1xuICAgIHJldHVybiB3cmFwKGdldFJhdyh0aGlzKS5kZWxldGUodW53cmFwKGspKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkS2V5cygpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgY29uc3QgaXRlcmF0b3IgPSByYXcua2V5cygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZG9uZSA9IG5leHQuZG9uZTtcbiAgICAgICAgICAgIHJldHVybiBkb25lXG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiB2b2lkIDAsIGRvbmUgfVxuICAgICAgICAgICAgICAgIDogeyB2YWx1ZTogd3JhcCh2YWx1ZSksIGRvbmUgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcHBlZFZhbHVlcygpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgY29uc3QgaXRlcmF0b3IgPSByYXcudmFsdWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gbmV4dC5kb25lO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHZvaWQgMCwgZG9uZSB9XG4gICAgICAgICAgICAgICAgOiB7IHZhbHVlOiB3cmFwKHZhbHVlKSwgZG9uZSB9O1xuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwcGVkRW50cmllcygpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgY29uc3QgaXRlcmF0b3IgPSByYXcuZW50cmllcygpO1xuICAgIC8vIHJldHVybiBhIHdyYXBwZWQgaXRlcmF0b3Igd2hpY2ggcmV0dXJucyBvYnNlcnZlZCB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyB2YWx1ZXMgZW1pdHRlZCBmcm9tIHRoZSByZWFsIGl0ZXJhdG9yXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gbmV4dC5kb25lO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHZvaWQgMCwgZG9uZSB9XG4gICAgICAgICAgICAgICAgOiB7IHZhbHVlOiBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSwgZG9uZSB9O1xuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgUHJveHlPYnNlcnZhYmxlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZ2V0UHJveHksXG4gICAgZ2V0UmF3LFxuICAgIHdyYXAsXG4gICAgdW53cmFwLFxuICAgIHJhd0tleSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJveHktb2JzZXJ2YXRpb24uanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlSW5kZXhNYXAgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi5qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyIH0gZnJvbSAnLi9jb2xsZWN0aW9uLWxlbmd0aC1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiB9IGZyb20gJy4vc3Vic2NyaWJlci1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGRlZiB9IGZyb20gJy4uL3V0aWxpdGllcy1vYmplY3RzLmpzJztcbmNvbnN0IG9ic2VydmVyTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHByb3RvID0gU2V0LnByb3RvdHlwZTtcbmNvbnN0ICRhZGQgPSBwcm90by5hZGQ7XG5jb25zdCAkY2xlYXIgPSBwcm90by5jbGVhcjtcbmNvbnN0ICRkZWxldGUgPSBwcm90by5kZWxldGU7XG5jb25zdCBuYXRpdmUgPSB7IGFkZDogJGFkZCwgY2xlYXI6ICRjbGVhciwgZGVsZXRlOiAkZGVsZXRlIH07XG5jb25zdCBtZXRob2RzID0gWydhZGQnLCAnY2xlYXInLCAnZGVsZXRlJ107XG4vLyBub3RlOiB3ZSBjYW4ndCByZWFsbHkgZG8gbXVjaCB3aXRoIFNldCBkdWUgdG8gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlIG5vdCBiZWluZyBhY2Nlc3NpYmxlIHNvIHdlJ3JlIGp1c3QgdXNpbmcgdGhlIG5hdGl2ZSBjYWxsc1xuLy8gZm9ydHVuYXRlbHksIGFkZC9kZWxldGUvY2xlYXIgYXJlIGVhc3kgdG8gcmVjb25zdHJ1Y3QgZm9yIHRoZSBpbmRleE1hcFxuY29uc3Qgb2JzZXJ2ZSA9IHtcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmFkZFxuICAgIGFkZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRhZGQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgICAgICAkYWRkLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICBjb25zdCBuZXdTaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gb2xkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgby5pbmRleE1hcFtvbGRTaXplXSA9IC0yO1xuICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuY2xlYXJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBvID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJGNsZWFyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleE1hcCA9IG8uaW5kZXhNYXA7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgZm9yIChjb25zdCBfIG9mIHRoaXMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwW2ldID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnB1c2goaW5kZXhNYXBbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkY2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGluZGV4TWFwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkZGVsZXRlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCBpbmRleE1hcCA9IG8uaW5kZXhNYXA7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhNYXBbaV0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcC5kZWxldGVkSXRlbXMucHVzaChpbmRleE1hcFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4TWFwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVSZXN1bHQgPSAkZGVsZXRlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVSZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IGRlc2NyaXB0b3JQcm9wcyA9IHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbn07XG5mb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgZGVmKG9ic2VydmVbbWV0aG9kXSwgJ29ic2VydmluZycsIHsgdmFsdWU6IHRydWUsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG59XG5sZXQgZW5hYmxlU2V0T2JzZXJ2YXRpb25DYWxsZWQgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVTZXRPYnNlcnZhdGlvbigpIHtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgIGlmIChwcm90b1ttZXRob2RdLm9ic2VydmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVmKHByb3RvLCBtZXRob2QsIHsgLi4uZGVzY3JpcHRvclByb3BzLCB2YWx1ZTogb2JzZXJ2ZVttZXRob2RdIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTZXRPYnNlcnZhdGlvbigpIHtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgIGlmIChwcm90b1ttZXRob2RdLm9ic2VydmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVmKHByb3RvLCBtZXRob2QsIHsgLi4uZGVzY3JpcHRvclByb3BzLCB2YWx1ZTogbmF0aXZlW21ldGhvZF0gfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2V0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9ic2VydmVkU2V0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IDM0IC8qIFNldCAqLztcbiAgICAgICAgaWYgKCFlbmFibGVTZXRPYnNlcnZhdGlvbkNhbGxlZCkge1xuICAgICAgICAgICAgZW5hYmxlU2V0T2JzZXJ2YXRpb25DYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5hYmxlU2V0T2JzZXJ2YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBvYnNlcnZlZFNldDtcbiAgICAgICAgdGhpcy5pbmRleE1hcCA9IGNyZWF0ZUluZGV4TWFwKG9ic2VydmVkU2V0LnNpemUpO1xuICAgICAgICB0aGlzLmxlbk9icyA9IHZvaWQgMDtcbiAgICAgICAgb2JzZXJ2ZXJMb29rdXAuc2V0KG9ic2VydmVkU2V0LCB0aGlzKTtcbiAgICB9XG4gICAgbm90aWZ5KCkge1xuICAgICAgICBjb25zdCBpbmRleE1hcCA9IHRoaXMuaW5kZXhNYXA7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgICAgdGhpcy5pbmRleE1hcCA9IGNyZWF0ZUluZGV4TWFwKHNpemUpO1xuICAgICAgICB0aGlzLnN1YnMubm90aWZ5Q29sbGVjdGlvbihpbmRleE1hcCwgOCAvKiB1cGRhdGVUYXJnZXQgKi8pO1xuICAgIH1cbiAgICBnZXRMZW5ndGhPYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuT2JzID8/ICh0aGlzLmxlbk9icyA9IG5ldyBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyKHRoaXMpKTtcbiAgICB9XG59XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihTZXRPYnNlcnZlcik7XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2V0T2JzZXJ2ZXIob2JzZXJ2ZWRTZXQpIHtcbiAgICBsZXQgb2JzZXJ2ZXIgPSBvYnNlcnZlckxvb2t1cC5nZXQob2JzZXJ2ZWRTZXQpO1xuICAgIGlmIChvYnNlcnZlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9ic2VydmVyID0gbmV3IFNldE9ic2VydmVyKG9ic2VydmVkU2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0LW9ic2VydmVyLmpzLm1hcCIsImltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgZGVmIH0gZnJvbSAnLi4vdXRpbGl0aWVzLW9iamVjdHMuanMnO1xuLyoqXG4gKiBPYnNlcnZlciBmb3IgdGhlIG11dGF0aW9uIG9mIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZSBlbXBsb3lpbmcgZ2V0dGVyLXNldHRlciBzdHJhdGVneS5cbiAqIFRoaXMgaXMgdXNlZCBmb3Igb2JzZXJ2aW5nIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgaGFzIG5vIGRlY29yYXRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRlck9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvYmosIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmluQmF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gdG9kbyhiaWdvcG9uKTogdHdlYWsgdGhlIGZsYWcgYmFzZWQgb24gdHlwZW9mIG9iaiAoYXJyYXkvc2V0L21hcC9pdGVyYXRvci9wcm94eSBldGMuLi4pXG4gICAgICAgIHRoaXMudHlwZSA9IDEgLyogT2JzZXJ2ZXIgKi87XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkobmV3VmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgc3Vic2NyaWJlKCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdGFyZ2V0IHByb3BlcnR5IGRlc2NyaXB0b3IgaXMgcmVwbGFjZWQgYnkgdGhlc2UgZ2V0dGVyL3NldHRlciBtZXRob2RzLFxuICAgICAgICAgICAgLy8gc28gY2FsbGluZyBvYmpbcHJvcGVydHlLZXldIHdpbGwgYWN0dWFsbHkgcmV0dXJuIHRoaXMuY3VycmVudFZhbHVlLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgaWYgc3Vic2NyaWJlKCkgd2FzIG5vdCB5ZXQgY2FsbGVkIChpbmRpY2F0ZWQgYnkgIXRoaXMub2JzZXJ2aW5nKSwgdGhlIHRhcmdldCBkZXNjcmlwdG9yXG4gICAgICAgICAgICAvLyBpcyB1bm1vZGlmaWVkIGFuZCB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgc2V0IHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gb25lLXRpbWUsIHRvLXZpZXcgYW5kIHR3by13YXkgYmluZGluZ3MgZHVyaW5nICRiaW5kLCBtZWFuaW5nIHRoYXQgdGhlICRiaW5kIHdpbGwgbm90IGFjdHVhbGx5IHVwZGF0ZSB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgICAgICAgICAgLy8gVGhpcyB3YXNuJ3QgdmlzaWJsZSBpbiB2Q3VycmVudCBkdWUgdG8gY29ubmVjdC1xdWV1ZSBhbHdheXMgZG9pbmcgYSBkZWxheWVkIHVwZGF0ZSwgc28gaW4gbWFueSBjYXNlcyBpdCBkaWRuJ3QgbWF0dGVyIHdoZXRoZXIgJGJpbmQgdXBkYXRlZCB0aGUgdGFyZ2V0IG9yIG5vdC5cbiAgICAgICAgICAgIHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcik7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldO1xuICAgICAgICAgICAgZGVmKHRoaXMub2JqLCB0aGlzLnByb3BlcnR5S2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoIC8qIFNldHRlciBPYnNlcnZlciAqLykgPT4gdGhpcy5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgICAgIHNldDogKC8qIFNldHRlciBPYnNlcnZlciAqLyB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlLCAwIC8qIG5vbmUgKi8pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2aW5nKSB7XG4gICAgICAgICAgICBkZWYodGhpcy5vYmosIHRoaXMucHJvcGVydHlLZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50VmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB0b2RvKGJpZ29wb24vZnJlZCk6IGFkZCAucmVtb3ZlQWxsU3Vic2NyaWJlcnMoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXR0ZXJOb3RpZmllciB7XG4gICAgY29uc3RydWN0b3Iob2JqLCBjYWxsYmFja0tleSwgc2V0LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBPYnNlcnZlciAqLztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5zID0gc2V0O1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9ialtjYWxsYmFja0tleV07XG4gICAgICAgIHRoaXMuY2IgPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IHZvaWQgMDtcbiAgICAgICAgdGhpcy52ID0gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudjtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnY7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jYj8uY2FsbCh0aGlzLm9iaiwgdmFsdWUsIG9sZFZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICAvLyB0aGVyZSdzIGEgY2hhbmNlIHRoYXQgY2IuY2FsbCguLi4pXG4gICAgICAgICAgICAvLyBjaGFuZ2VzIHRoZSBsYXRlc3QgdmFsdWUgb2YgdGhpcyBvYnNlcnZlclxuICAgICAgICAgICAgLy8gYW5kIHRodXMgbWFraW5nIGB2YWx1ZWAgc3RhbGVcbiAgICAgICAgICAgIC8vIHNvIGZvciBub3csIGNhbGwgd2l0aCB0aGlzLnZcbiAgICAgICAgICAgIC8vIHRvZG86IHNob3VsZCBvbGRWYWx1ZSBiZSB0cmVhdGVkIHRoZSBzYW1lIHdheT9cbiAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkodGhpcy52LCBvbGRWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oU2V0dGVyT2JzZXJ2ZXIpO1xuc3Vic2NyaWJlckNvbGxlY3Rpb24oU2V0dGVyTm90aWZpZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGVyLW9ic2VydmVyLmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmV4cG9ydCBjb25zdCBJU2lnbmFsZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lTaWduYWxlcicsIHggPT4geC5zaW5nbGV0b24oU2lnbmFsZXIpKTtcbmV4cG9ydCBjbGFzcyBTaWduYWxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2lnbmFscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGRpc3BhdGNoU2lnbmFsKG5hbWUsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuc2lnbmFsc1tuYW1lXTtcbiAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMua2V5cygpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVDaGFuZ2UodW5kZWZpbmVkLCB1bmRlZmluZWQsIGZsYWdzIHwgOCAvKiB1cGRhdGVUYXJnZXQgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFNpZ25hbExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbHMgPSB0aGlzLnNpZ25hbHM7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHNpZ25hbHNbbmFtZV07XG4gICAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2lnbmFsc1tuYW1lXSA9IG5ldyBTZXQoW2xpc3RlbmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVTaWduYWxMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLnNpZ25hbHNbbmFtZV07XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmFsZXIuanMubWFwIiwiaW1wb3J0IHsgZGVmLCBkZWZpbmVIaWRkZW5Qcm9wLCBlbnN1cmVQcm90byB9IGZyb20gJy4uL3V0aWxpdGllcy1vYmplY3RzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmVyQ29sbGVjdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ID09IG51bGwgPyBzdWJzY3JpYmVyQ29sbGVjdGlvbkRlY28gOiBzdWJzY3JpYmVyQ29sbGVjdGlvbkRlY28odGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHN1YnNjcmliZXJDb2xsZWN0aW9uRGVjbyh0YXJnZXQpIHtcbiAgICBjb25zdCBwcm90byA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgLy8gbm90IGNvbmZpZ3VyYWJsZSwgYXMgaW4gZGV2dG9vbCwgdGhlIGdldHRlciBjb3VsZCBiZSBpbnZva2VkIG9uIHRoZSBwcm90b3R5cGUsXG4gICAgLy8gYW5kIGJlY29tZSBwZXJtYW5lbnRseSBicm9rZW5cbiAgICBkZWYocHJvdG8sICdzdWJzJywgeyBnZXQ6IGdldFN1YnNjcmliZXJSZWNvcmQgfSk7XG4gICAgZW5zdXJlUHJvdG8ocHJvdG8sICdzdWJzY3JpYmUnLCBhZGRTdWJzY3JpYmVyKTtcbiAgICBlbnN1cmVQcm90byhwcm90bywgJ3Vuc3Vic2NyaWJlJywgcmVtb3ZlU3Vic2NyaWJlcik7XG59XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXMgKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVyUmVjb3JkIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogc3Vic2NyaWJlciBmbGFnczogYml0cyBpbmRpY2F0aW5nIHRoZSBleGlzdGVuY2Ugc3RhdHVzIG9mIHRoZSBzdWJzY3JpYmVycyBvZiB0aGlzIHJlY29yZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2YgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgfVxuICAgIGFkZChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhzdWJzY3JpYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJGbGFncyA9IHRoaXMuX3NmO1xuICAgICAgICBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDEgLyogU3Vic2NyaWJlcjAgKi8pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zMCA9IHN1YnNjcmliZXI7XG4gICAgICAgICAgICB0aGlzLl9zZiB8PSAxIC8qIFN1YnNjcmliZXIwICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAyIC8qIFN1YnNjcmliZXIxICovKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fczEgPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgdGhpcy5fc2YgfD0gMiAvKiBTdWJzY3JpYmVyMSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoc3Vic2NyaWJlckZsYWdzICYgNCAvKiBTdWJzY3JpYmVyMiAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3MyID0gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NmIHw9IDQgLyogU3Vic2NyaWJlcjIgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDggLyogU3Vic2NyaWJlcnNSZXN0ICovKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3IgPSBbc3Vic2NyaWJlcl07XG4gICAgICAgICAgICB0aGlzLl9zZiB8PSA4IC8qIFN1YnNjcmliZXJzUmVzdCAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NyLnB1c2goc3Vic2NyaWJlcik7IC8vIE5vbi1udWxsIGlzIGltcGxpZWQgYnkgZWxzZSBicmFuY2ggb2YgKHN1YnNjcmliZXJGbGFncyAmIFNGLlN1YnNjcmliZXJzUmVzdCkgPT09IDBcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMuY291bnQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBoYXMoc3Vic2NyaWJlcikge1xuICAgICAgICAvLyBGbGFncyBoZXJlIGlzIGp1c3QgYSBwZXJmIHR3ZWFrXG4gICAgICAgIC8vIENvbXBhcmVkIHRvIG5vdCB1c2luZyBmbGFncywgaXQncyBhIG1vZGVyYXRlIHNwZWVkLXVwIHdoZW4gdGhpcyBjb2xsZWN0aW9uIGRvZXMgbm90IGhhdmUgdGhlIHN1YnNjcmliZXI7XG4gICAgICAgIC8vIGFuZCBtaW5vciBzbG93LWRvd24gd2hlbiBpdCBkb2VzLCBhbmQgdGhlIGZvcm1lciBpcyBtb3JlIGNvbW1vbiB0aGFuIHRoZSBsYXR0ZXIuXG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJGbGFncyA9IHRoaXMuX3NmO1xuICAgICAgICBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDEgLyogU3Vic2NyaWJlcjAgKi8pID4gMCAmJiB0aGlzLl9zMCA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAyIC8qIFN1YnNjcmliZXIxICovKSA+IDAgJiYgdGhpcy5fczEgPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgNCAvKiBTdWJzY3JpYmVyMiAqLykgPiAwICYmIHRoaXMuX3MyID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDggLyogU3Vic2NyaWJlcnNSZXN0ICovKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5fc3I7IC8vIE5vbi1udWxsIGlzIGltcGxpZWQgYnkgKHN1YnNjcmliZXJGbGFncyAmIFNGLlN1YnNjcmliZXJzUmVzdCkgPiAwXG4gICAgICAgICAgICBjb25zdCBpaSA9IHN1YnNjcmliZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyc1tpXSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZiAhPT0gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICByZW1vdmUoc3Vic2NyaWJlcikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyRmxhZ3MgPSB0aGlzLl9zZjtcbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAxIC8qIFN1YnNjcmliZXIwICovKSA+IDAgJiYgdGhpcy5fczAgPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3MwID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5fc2YgPSAodGhpcy5fc2YgfCAxIC8qIFN1YnNjcmliZXIwICovKSBeIDEgLyogU3Vic2NyaWJlcjAgKi87XG4gICAgICAgICAgICAtLXRoaXMuY291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoc3Vic2NyaWJlckZsYWdzICYgMiAvKiBTdWJzY3JpYmVyMSAqLykgPiAwICYmIHRoaXMuX3MxID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zMSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRoaXMuX3NmID0gKHRoaXMuX3NmIHwgMiAvKiBTdWJzY3JpYmVyMSAqLykgXiAyIC8qIFN1YnNjcmliZXIxICovO1xuICAgICAgICAgICAgLS10aGlzLmNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDQgLyogU3Vic2NyaWJlcjIgKi8pID4gMCAmJiB0aGlzLl9zMiA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5fczIgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9zZiA9ICh0aGlzLl9zZiB8IDQgLyogU3Vic2NyaWJlcjIgKi8pIF4gNCAvKiBTdWJzY3JpYmVyMiAqLztcbiAgICAgICAgICAgIC0tdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiA4IC8qIFN1YnNjcmliZXJzUmVzdCAqLykgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMuX3NyOyAvLyBOb24tbnVsbCBpcyBpbXBsaWVkIGJ5IChzdWJzY3JpYmVyRmxhZ3MgJiBTRi5TdWJzY3JpYmVyc1Jlc3QpID4gMFxuICAgICAgICAgICAgY29uc3QgaWkgPSBzdWJzY3JpYmVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnNbaV0gPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NmID0gKHRoaXMuX3NmIHwgOCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi8pIF4gOCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLS10aGlzLmNvdW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBub3RpZnkodmFsLCBvbGRWYWwsIGZsYWdzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RlOiBjaGFuZ2UgaGFuZGxlcnMgbWF5IGhhdmUgdGhlIHNpZGUtZWZmZWN0IG9mIGFkZGluZy9yZW1vdmluZyBzdWJzY3JpYmVycyB0byB0aGlzIGNvbGxlY3Rpb24gZHVyaW5nIHRoaXNcbiAgICAgICAgICogY2FsbFN1YnNjcmliZXJzIGludm9jYXRpb24sIHNvIHdlJ3JlIGNhY2hpbmcgdGhlbSBhbGwgYmVmb3JlIGludm9raW5nIGFueS5cbiAgICAgICAgICogU3Vic2NyaWJlcnMgYWRkZWQgZHVyaW5nIHRoaXMgaW52b2NhdGlvbiBhcmUgbm90IGludm9rZWQgKGFuZCB0aGV5IHNob3VsZG4ndCBiZSkuXG4gICAgICAgICAqIFN1YnNjcmliZXJzIHJlbW92ZWQgZHVyaW5nIHRoaXMgaW52b2NhdGlvbiB3aWxsIHN0aWxsIGJlIGludm9rZWQgKGFuZCB0aGV5IGFsc28gc2hvdWxkbid0IGJlLFxuICAgICAgICAgKiBob3dldmVyIHRoaXMgaXMgYWNjb3VudGVkIGZvciB2aWEgJGlzQm91bmQgYW5kIHNpbWlsYXIgZmxhZ3Mgb24gdGhlIHN1YnNjcmliZXIgb2JqZWN0cylcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG93bmVyID0gdGhpcy5vd25lcjtcbiAgICAgICAgY29uc3Qgc3ViMCA9IHRoaXMuX3MwO1xuICAgICAgICBjb25zdCBzdWIxID0gdGhpcy5fczE7XG4gICAgICAgIGNvbnN0IHN1YjIgPSB0aGlzLl9zMjtcbiAgICAgICAgbGV0IHN1YnMgPSB0aGlzLl9zcjtcbiAgICAgICAgaWYgKHN1YnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3VicyA9IHN1YnMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyA9IChmbGFncyB8IDI0IC8qIHVwZGF0ZSAqLykgXiAyNCAvKiB1cGRhdGUgKi87XG4gICAgICAgIGlmIChzdWIwICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN1YjAuaGFuZGxlQ2hhbmdlKHZhbCwgb2xkVmFsLCBmbGFncyB8IC8qIHN1YiBvd24gZmxhZ3MgKi8gKHN1YjAuaWQgPT09IHZvaWQgMCA/IDAgOiBvd25lcltzdWIwLmlkXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIxICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN1YjEuaGFuZGxlQ2hhbmdlKHZhbCwgb2xkVmFsLCBmbGFncyB8IC8qIHN1YiBvd24gZmxhZ3MgKi8gKHN1YjEuaWQgPT09IHZvaWQgMCA/IDAgOiBvd25lcltzdWIxLmlkXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN1YjIuaGFuZGxlQ2hhbmdlKHZhbCwgb2xkVmFsLCBmbGFncyB8IC8qIHN1YiBvd24gZmxhZ3MgKi8gKHN1YjIuaWQgPT09IHZvaWQgMCA/IDAgOiBvd25lcltzdWIyLmlkXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IGlpID0gc3Vicy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3ViO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3ViID0gc3Vic1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLmhhbmRsZUNoYW5nZSh2YWwsIG9sZFZhbCwgZmxhZ3MgfCAvKiBzdWIgb3duIGZsYWdzICovIChzdWIuaWQgPT09IHZvaWQgMCA/IDAgOiBvd25lcltzdWIuaWRdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeUNvbGxlY3Rpb24oaW5kZXhNYXAsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHN1YjAgPSB0aGlzLl9zMDtcbiAgICAgICAgY29uc3Qgc3ViMSA9IHRoaXMuX3MxO1xuICAgICAgICBjb25zdCBzdWIyID0gdGhpcy5fczI7XG4gICAgICAgIGxldCBzdWJzID0gdGhpcy5fc3I7XG4gICAgICAgIGlmIChzdWJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN1YnMgPSBzdWJzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YjAgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3ViMC5oYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YjEgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3ViMS5oYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YjIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3ViMi5oYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgaWkgPSBzdWJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdWI7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSBzdWJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdWIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuaGFuZGxlQ29sbGVjdGlvbkNoYW5nZShpbmRleE1hcCwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFN1YnNjcmliZXJSZWNvcmQoKSB7XG4gICAgY29uc3QgcmVjb3JkID0gbmV3IFN1YnNjcmliZXJSZWNvcmQodGhpcyk7XG4gICAgZGVmaW5lSGlkZGVuUHJvcCh0aGlzLCAnc3VicycsIHJlY29yZCk7XG4gICAgcmV0dXJuIHJlY29yZDtcbn1cbmZ1bmN0aW9uIGFkZFN1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgIHJldHVybiB0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLWNvbGxlY3Rpb24uanMubWFwIiwiZXhwb3J0IGNvbnN0IGRlZiA9IFJlZmxlY3QuZGVmaW5lUHJvcGVydHk7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lSGlkZGVuUHJvcChvYmosIGtleSwgdmFsdWUpIHtcbiAgICBkZWYob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlUHJvdG8ocHJvdG8sIGtleSwgZGVmYXVsdFZhbHVlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKGZvcmNlIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIGtleSkpIHtcbiAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChwcm90bywga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxpdGllcy1vYmplY3RzLmpzLm1hcCIsImltcG9ydCB7IFJlZ2lzdHJhdGlvbiwgTWV0YWRhdGEsIFByb3RvY29sLCBtZXJnZUFycmF5cywgZmlyc3REZWZpbmVkLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyByZWdpc3RlckFsaWFzZXMgfSBmcm9tICcuL2FsaWFzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZUNvbnZlcnRlcihuYW1lT3JEZWYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gVmFsdWVDb252ZXJ0ZXIuZGVmaW5lKG5hbWVPckRlZiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIFZhbHVlQ29udmVydGVyRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoVHlwZSwgbmFtZSwgYWxpYXNlcywga2V5KSB7XG4gICAgICAgIHRoaXMuVHlwZSA9IFR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXNlcyA9IGFsaWFzZXM7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgbGV0IGRlZjtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JEZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRGVmO1xuICAgICAgICAgICAgZGVmID0geyBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRGVmLm5hbWU7XG4gICAgICAgICAgICBkZWYgPSBuYW1lT3JEZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZUNvbnZlcnRlckRlZmluaXRpb24oVHlwZSwgZmlyc3REZWZpbmVkKFZhbHVlQ29udmVydGVyLmdldEFubm90YXRpb24oVHlwZSwgJ25hbWUnKSwgbmFtZSksIG1lcmdlQXJyYXlzKFZhbHVlQ29udmVydGVyLmdldEFubm90YXRpb24oVHlwZSwgJ2FsaWFzZXMnKSwgZGVmLmFsaWFzZXMsIFR5cGUuYWxpYXNlcyksIFZhbHVlQ29udmVydGVyLmtleUZyb20obmFtZSkpO1xuICAgIH1cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgeyBUeXBlLCBrZXksIGFsaWFzZXMgfSA9IHRoaXM7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oa2V5LCBUeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICBSZWdpc3RyYXRpb24uYWxpYXNUbyhrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIHJlZ2lzdGVyQWxpYXNlcyhhbGlhc2VzLCBWYWx1ZUNvbnZlcnRlciwga2V5LCBjb250YWluZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBWYWx1ZUNvbnZlcnRlciA9IHtcbiAgICBuYW1lOiBQcm90b2NvbC5yZXNvdXJjZS5rZXlGb3IoJ3ZhbHVlLWNvbnZlcnRlcicpLFxuICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7VmFsdWVDb252ZXJ0ZXIubmFtZX06JHtuYW1lfWA7XG4gICAgfSxcbiAgICBpc1R5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBNZXRhZGF0YS5oYXNPd24oVmFsdWVDb252ZXJ0ZXIubmFtZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZGVmaW5lKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gVmFsdWVDb252ZXJ0ZXJEZWZpbml0aW9uLmNyZWF0ZShuYW1lT3JEZWYsIFR5cGUpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoVmFsdWVDb252ZXJ0ZXIubmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbi5UeXBlKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKFZhbHVlQ29udmVydGVyLm5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICBQcm90b2NvbC5yZXNvdXJjZS5hcHBlbmRUbyhUeXBlLCBWYWx1ZUNvbnZlcnRlci5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24uVHlwZTtcbiAgICB9LFxuICAgIGdldERlZmluaXRpb24oVHlwZSkge1xuICAgICAgICBjb25zdCBkZWYgPSBNZXRhZGF0YS5nZXRPd24oVmFsdWVDb252ZXJ0ZXIubmFtZSwgVHlwZSk7XG4gICAgICAgIGlmIChkZWYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZWZpbml0aW9uIGZvdW5kIGZvciB0eXBlICR7VHlwZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfSxcbiAgICBhbm5vdGF0ZShUeXBlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIHZhbHVlLCBUeXBlKTtcbiAgICB9LFxuICAgIGdldEFubm90YXRpb24oVHlwZSwgcHJvcCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKHByb3ApLCBUeXBlKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlLWNvbnZlcnRlci5qcy5tYXAiLCI8dGVtcGxhdGU+XG4gIDxyZXF1aXJlIGZyb209XCIuL3Jlc2V0LmNzc1wiPjwvcmVxdWlyZT5cbiAgPHJlcXVpcmUgZnJvbT1cIi4vYXBwLmNzc1wiPjwvcmVxdWlyZT5cblxuICA8ZGl2IGlkPVwiYXUtZGV2LXJvb3RcIiBjbGFzcz1cIiR7aXNEYXJrVGhlbWUgPyAnZGFyaycgOiAnJ31cIj5cbiAgICA8aDEgY2xhc3M9XCJhcHAtaGVhZGVyXCI+XG4gICAgICA8YXVyZWxpYS1sb2dvPjwvYXVyZWxpYS1sb2dvPlxuICAgICAgPHNwYW4gY2xhc3M9XCJsb2dvLWJhZGdlXCI+SU5TUEVDVE9SPC9zcGFuPlxuICAgIDwvaDE+XG5cbiAgICA8bWFpbj5cbiAgICAgIDxwIGNsYXNzPVwibm90LWZvdW5kXCIgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiAxMHB4XCI+XG4gICAgICAgIFNlbGVjdCBhIG5vZGUgdGhyb3VnaCB0aGUgaW5zcGVjdCB3aW5kb3cgdG8gc2NvcGUgaW50byB0aGF0IG5vZGUuIENsaWNrXG4gICAgICAgIG9uIHRoZSB2YWx1ZSB3aWxsIGFsbG93IG9uZSB0byBlZGl0IHRoZSB2YWx1ZSBhbmQgYmluZCB0byB0aGUgdmlldy5cbiAgICAgIDwvcD5cbiAgICAgIDwhLS0gPGRlYnVnLWdyb3VwIGhlYWRpbmc9XCJCaW5kaW5nIENvbnRleHRcIiBzaG93LmJpbmQ9XCJ0cnVlXCI+XG4gICAgICAgIDx0ZW1wbGF0ZSBpZi5iaW5kPVwiZGVidWdJbmZvLmJpbmRpbmdDb250ZXh0XCI+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgPGxpIHJlcGVhdC5mb3I9XCJwcm9wZXJ0eSBvZiBkZWJ1Z0luZm8uYmluZGluZ0NvbnRleHQucHJvcGVydGllc1wiPlxuICAgICAgICAgICAgICA8cHJvcGVydHktdmlldyBwcm9wZXJ0eS5iaW5kPVwicHJvcGVydHlcIj48L3Byb3BlcnR5LXZpZXc+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDx0ZW1wbGF0ZSBpZi5iaW5kPVwiIWRlYnVnSW5mby5iaW5kaW5nQ29udGV4dFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwibm90LWZvdW5kXCJcbiAgICAgICAgICAgID5ObyBiaW5kaW5nIGNvbnRleHQgZm91bmQgZm9yIHRoZSBzZWxlY3RlZCBub2RlLjwvc3BhblxuICAgICAgICAgID5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgIDwvZGVidWctZ3JvdXA+XG5cbiAgICAgIDxkZWJ1Zy1ncm91cCBoZWFkaW5nPVwiT3ZlcnJpZGUgQ29udGV4dFwiPlxuICAgICAgICA8dGVtcGxhdGVcbiAgICAgICAgICBpZi5iaW5kPVwiZGVidWdJbmZvLm92ZXJyaWRlQ29udGV4dCAmJiBkZWJ1Z0luZm8ub3ZlcnJpZGVDb250ZXh0LnByb3BlcnRpZXMubGVuZ3RoXCJcbiAgICAgICAgPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgIDxsaSByZXBlYXQuZm9yPVwicHJvcGVydHkgb2YgZGVidWdJbmZvLm92ZXJyaWRlQ29udGV4dC5wcm9wZXJ0aWVzXCI+XG4gICAgICAgICAgICAgIDxwcm9wZXJ0eS12aWV3IHByb3BlcnR5LmJpbmQ9XCJwcm9wZXJ0eVwiPjwvcHJvcGVydHktdmlldz5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgPHRlbXBsYXRlXG4gICAgICAgICAgaWYuYmluZD1cIiFkZWJ1Z0luZm8ub3ZlcnJpZGVDb250ZXh0IHx8ICFkZWJ1Z0luZm8ub3ZlcnJpZGVDb250ZXh0LnByb3BlcnRpZXMubGVuZ3RoXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwibm90LWZvdW5kXCJcbiAgICAgICAgICAgID5ObyBvdmVycmlkZSBjb250ZXh0IGZvdW5kIGZvciB0aGUgc2VsZWN0ZWQgbm9kZS48L3NwYW5cbiAgICAgICAgICA+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICA8L2RlYnVnLWdyb3VwPiAtLT5cblxuICAgICAgPGRlYnVnLWdyb3VwIGhlYWRpbmc9XCJDdXN0b20gRWxlbWVudFwiPlxuICAgICAgICA8dGVtcGxhdGUgYXUtc2xvdD5cbiAgICAgICAgICA8c3BhbiBpZi5iaW5kPVwiIXNlbGVjdGVkRWxlbWVudFwiIGNsYXNzPVwibm90LWZvdW5kXCJcbiAgICAgICAgICAgID5UaGUgc2VsZWN0ZWQgbm9kZSBpcyBub3QgYSBjdXN0b20gZWxlbWVudC48L3NwYW5cbiAgICAgICAgICA+XG4gICAgICAgICAgPGNvbnRyb2xsZXItdmlld1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udHJvbGxlci5iaW5kPVwic2VsZWN0ZWRFbGVtZW50XCJcbiAgICAgICAgICA+PC9jb250cm9sbGVyLXZpZXc+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICA8L2RlYnVnLWdyb3VwPlxuXG4gICAgICA8ZGVidWctZ3JvdXAgaGVhZGluZz1cIkN1c3RvbSBBdHRyaWJ1dGVzXCI+XG4gICAgICAgIDx0ZW1wbGF0ZSBhdS1zbG90PlxuICAgICAgICAgIDxzcGFuIGlmLmJpbmQ9XCIhc2VsZWN0ZWRFbGVtZW50QXR0cmlidXRlc1wiIGNsYXNzPVwibm90LWZvdW5kXCJcbiAgICAgICAgICAgID5ObyBjdXN0b20gYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgc2VsZWN0ZWQgbm9kZS48L3NwYW5cbiAgICAgICAgICA+XG4gICAgICAgICAgPHVsIGVsc2U+XG4gICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgcmVwZWF0LmZvcj1cImN1c3RvbUF0dHJpYnV0ZSBvZiBzZWxlY3RlZEVsZW1lbnRBdHRyaWJ1dGVzXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJjdXN0b20tYXR0cmlidXRlXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGgzIGNsYXNzPVwiYXR0cmlidXRlLW5hbWVcIj4ke2N1c3RvbUF0dHJpYnV0ZS5uYW1lfTwvaDM+XG4gICAgICAgICAgICAgICZuYnNwOzxzcGFuIGNsYXNzPVwiYmxvY2stdG9rZW5cIj57PC9zcGFuPlxuICAgICAgICAgICAgICA8Y29udHJvbGxlci12aWV3XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5iaW5kPVwiY3VzdG9tQXR0cmlidXRlXCJcbiAgICAgICAgICAgICAgPjwvY29udHJvbGxlci12aWV3PlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJsb2NrLXRva2VuXCI+fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgIDwvZGVidWctZ3JvdXA+XG4gICAgPC9tYWluPlxuXG4gICAgPCEtLSA8bWFpbj5cbiAgICAgIDxjdXN0b20tZWxlbWVudCBpZi5iaW5kPVwic2VsZWN0ZWRFbGVtZW50XCI+XG4gICAgICAgICR7SlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWRFbGVtZW50KX1cbiAgICAgICAgPGRpdj5OYW1lID0gJHtzZWxlY3RlZEVsZW1lbnQubmFtZX08L2Rpdj5cbiAgICAgICAgPGRpdj5LZXkgPSAke3NlbGVjdGVkRWxlbWVudC5rZXl9PC9kaXY+XG4gICAgICAgIDxkaXY+QWxpYXNlcyA9ICR7c2VsZWN0ZWRFbGVtZW50LmFsaWFzZXMuam9pbignLCAnKX08L2Rpdj5cbiAgICAgICAgPGgzPkJpbmRhYmxlczwvaDM+XG4gICAgICAgIDxkaXYgcmVwZWF0LmZvcj1cInZhbHVlIG9mIHNlbGVjdGVkRWxlbWVudC5iaW5kYWJsZXNcIj5cbiAgICAgICAgICAke3ZhbHVlLm5hbWV9ID1cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHZhbHVlLmJpbmQ9XCJ2YWx1ZS52YWx1ZVwiXG4gICAgICAgICAgICBrZXl1cC5kZWxlZ2F0ZT1cInZhbHVlQ2hhbmdlZChzZWxlY3RlZEVsZW1lbnQpXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGhyIC8+XG4gICAgICA8L2N1c3RvbS1lbGVtZW50PlxuICAgIDwvbWFpbj4gLS0+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbiIsIjxwIGlkPVwiY3VzdG9tLWVsZW1lbnRcIj5cbiAgQ3VzdG9tRWxlbWVudCB3b3JrcyFcbjwvcD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHN2ZyBoZWlnaHQ9XCIyOHB4XCIgdmlld0JveD1cIjMxNSAxOSAxNDAgNDFcIiB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiPlxuICAgIDxkZWZzPlxuICAgICAgPGxpbmVhckdyYWRpZW50IHgxPVwiLTM4OC4xNDc4NTElXCIgeTE9XCItMTQ0LjE3NzQyNSVcIiB4Mj1cIjIzNy42ODM4MDklXCIgeTI9XCI0MzAuNDA1NzU0JVwiIGlkPVwibGluZWFyR3JhZGllbnQtMVwiPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0MwNkZCQlwiIG9mZnNldD1cIjAlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiIzZFNEQ5QlwiIG9mZnNldD1cIjEwMCVcIj48L3N0b3A+XG4gICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgPGxpbmVhckdyYWRpZW50IHgxPVwiNzIuOTQ1NDg1NCVcIiB5MT1cIjg0LjQyNDA3NzclXCIgeDI9XCItOTcuMDUxNzkwNCVcIiB5Mj1cIi0xNDcuNjk2NTkxJVwiIGlkPVwibGluZWFyR3JhZGllbnQtMlwiPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiIzZFNEQ5QlwiIG9mZnNldD1cIjAlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiIzc3MzI3QVwiIG9mZnNldD1cIjE0JVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNCMzE3NzdcIiBvZmZzZXQ9XCIyOSVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjQ0QwRjdFXCIgb2Zmc2V0PVwiODQlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0VEMkM4OVwiIG9mZnNldD1cIjEwMCVcIj48L3N0b3A+XG4gICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgPGxpbmVhckdyYWRpZW50IHgxPVwiLTI4My44ODQwNzklXCIgeTE9XCItNjkzLjU5OTg3MiVcIiB4Mj1cIjI4Ny41Mzc0MTclXCIgeTI9XCIxMDEuNzA5NzYlXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC0zXCI+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjQzA2RkJCXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNkU0RDlCXCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD5cbiAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8bGluZWFyR3JhZGllbnQgeDE9XCItODIxLjE4NjIxNCVcIiB5MT1cIi00NjkuMDQ3ODYyJVwiIHgyPVwiMTAxLjk4NTE0MiVcIiB5Mj1cIjI4OC4yMzU5OCVcIiBpZD1cImxpbmVhckdyYWRpZW50LTRcIj5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNDMDZGQkJcIiBvZmZzZXQ9XCIwJVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM2RTREOUJcIiBvZmZzZXQ9XCIxMDAlXCI+PC9zdG9wPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCB4MT1cIi0xNDAuMzU5MzczJVwiIHkxPVwiLTIzMC45MjU3MTglXCIgeDI9XCI0MTkuMDEyMzE2JVwiIHkyPVwiMjYxLjk3Njc0MiVcIiBpZD1cImxpbmVhckdyYWRpZW50LTVcIj5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNDMDZGQkJcIiBvZmZzZXQ9XCIwJVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM2RTREOUJcIiBvZmZzZXQ9XCIxMDAlXCI+PC9zdG9wPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCB4MT1cIjE5MS4wODM3MTYlXCIgeTE9XCIyNTMuOTUyNTE3JVwiIHgyPVwiMjAuMzU3NzAyMiVcIiB5Mj1cIjIwLjQwMjkyODMlXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC02XCI+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNkU0RDlCXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNzczMjdBXCIgb2Zmc2V0PVwiMTQlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0IzMTc3N1wiIG9mZnNldD1cIjI5JVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNDRDBGN0VcIiBvZmZzZXQ9XCI4NCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjRUQyQzg5XCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD5cbiAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8bGluZWFyR3JhZGllbnQgeDE9XCItMzg4LjA5NDAwNCVcIiB5MT1cIi0xNzMuODUwMDU1JVwiIHgyPVwiMjM3LjY3NDgwMiVcIiB5Mj1cIjUxOC45OTAyMjUlXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC03XCI+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjQzA2RkJCXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNkU0RDlCXCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD5cbiAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8bGluZWFyR3JhZGllbnQgeDE9XCIxMS4xODg0NTYxJVwiIHkxPVwiODkuNjUyNTk5MyVcIiB4Mj1cIjkwLjE0NTEyNSVcIiB5Mj1cIjExLjU3NzM5ODIlXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC04XCI+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNkU0RDlCXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNzczMjdBXCIgb2Zmc2V0PVwiMTQlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0IzMTc3N1wiIG9mZnNldD1cIjUzJVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNDRDBGN0VcIiBvZmZzZXQ9XCI3OSVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjRUQyQzg5XCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD5cbiAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8cmVjdCBpZD1cInBhdGgtOVwiIHg9XCIwLjYyNzQ5ODI1NlwiIHk9XCIwXCIgd2lkdGg9XCIzNFwiIGhlaWdodD1cIjE2XCIgcng9XCIyXCI+PC9yZWN0PlxuICAgICAgPGZpbHRlciB4PVwiLTUwJVwiIHk9XCItNTAlXCIgd2lkdGg9XCIyMDAlXCIgaGVpZ2h0PVwiMjAwJVwiIGZpbHRlclVuaXRzPVwib2JqZWN0Qm91bmRpbmdCb3hcIiBpZD1cImZpbHRlci0xMFwiPlxuICAgICAgICA8ZmVPZmZzZXQgZHg9XCIwXCIgZHk9XCIxXCIgaW49XCJTb3VyY2VBbHBoYVwiIHJlc3VsdD1cInNoYWRvd09mZnNldE91dGVyMVwiPjwvZmVPZmZzZXQ+XG4gICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz1cIjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC4xNSAwXCIgdHlwZT1cIm1hdHJpeFwiIGluPVwic2hhZG93T2Zmc2V0T3V0ZXIxXCI+PC9mZUNvbG9yTWF0cml4PlxuICAgICAgPC9maWx0ZXI+XG4gICAgPC9kZWZzPlxuICAgIDxnIGlkPVwiR3JvdXAtM1wiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDMxNy4wMDAwMDAsIDIxLjAwMDAwMClcIj5cbiAgICAgIDxnIGlkPVwiSWNvblwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxOC44MjE0MzYsIDE4LjgyMTQzNikgcm90YXRlKDExLjI4Mzg2NCkgdHJhbnNsYXRlKC0xOC44MjE0MzYsIC0xOC44MjE0MzYpIHRyYW5zbGF0ZSgyLjgyMTQzNiwgMi44MjE0MzYpXCI+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTYuMDYyMjE3LCA0LjMxNDY0OSkgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMTYuMDYyMjE3LCAtNC4zMTQ2NDkpIHRyYW5zbGF0ZSgxMi45MDkzNTQsIDAuODUyNjgyKVwiXG4gICAgICAgICAgZmlsbD1cInVybCgjbGluZWFyR3JhZGllbnQtMSlcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiNi4yNDUxNDEzNCA0Ljc4MTk2NTY4IDMuMjEzNDQ3MzEgNi44MDUzNjE4IDAuMDkwMjU4NDI3NiAyLjEyNDkwNTk0IDMuMTIxOTUyNDYgMC4xMDE1MDk4MjFcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyNC41NzY2NzEsIDIzLjYwNjA2Mikgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMjQuNTc2NjcxLCAtMjMuNjA2MDYyKSB0cmFuc2xhdGUoMTguMzk0NTg3LCAxNi45Mjk0MTEpXCJcbiAgICAgICAgICBmaWxsPVwidXJsKCNsaW5lYXJHcmFkaWVudC0yKVwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCI3LjE2NDA0NjMyIDEuNDczMTkwNjQgMTIuMzQ0MDE0NiA5LjIzNTQxNTQxIDYuMTczNDI5MTYgMTMuMzUzMzAxNiAwLjk5MzQ2MDkxMiA1LjU5MDk1MzIgMC4wODk3NjM4NjA5IDQuMjM2OTUzMTUgNi4yNjA0NzI5MSAwLjExOTA2NjkzOVwiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDE2LjA2NDAwMSwgMjcuMDY5NjcxKSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC0xNi4wNjQwMDEsIC0yNy4wNjk2NzEpIHRyYW5zbGF0ZSgxMi42MDIwMzQsIDIzLjg1NDk4OClcIlxuICAgICAgICAgIGZpbGw9XCJ1cmwoI2xpbmVhckdyYWRpZW50LTMpXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJTaGFwZVwiIHBvaW50cz1cIjUuNjk3Nzc5NjIgMS40NjY2Mzc2MyA2LjgzODI1MDQ5IDMuMTc1NjEyOTUgMi4xNDE0NzM5MyA2LjMwOTkyOTU4IDAuMDk3MzA2MDAzNSAzLjI0NjgzMDU2IDEuMTIzNDA4MzIgMi41NjIxMDI5MyA0Ljc5NDIwNjIxIDAuMTEyNTEzOTNcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyNy40MTcyODcsIDE1LjcyNjcxMikgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMjcuNDE3Mjg3LCAtMTUuNzI2NzEyKSB0cmFuc2xhdGUoMjQuODIwODEyLCAxMy4xMzAyMzYpXCJcbiAgICAgICAgICBmaWxsPVwidXJsKCNsaW5lYXJHcmFkaWVudC00KVwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMS44MTcwMzgxNSwwLjg5NDY3MTIwOCBMMy4xMzQ0NDAyNywwLjAxNTU3ODg1MTkgTDUuMTc4NDg0NTUsMy4wNzg2Nzc4NyBMMi4xNDY0MTk1OSw1LjEwMjA3Mzk5IEwxLjAwNTk0ODcyLDMuMzkzMDk4NjcgTDIuNzIwNjExNTYsMi4yNDg3OTQ5MSBMMS44MTcwMzgxNSwwLjg5NDY3MTIwOCBMMS44MTcwMzgxNSwwLjg5NDY3MTIwOCBaIE0xLjAwNTk0ODcyLDMuMzkzMDk4NjcgTDAuMTAyMzc1MzEyLDIuMDM4OTc0OTcgTDEuODE3MDM4MTUsMC44OTQ2NzEyMDggTDIuNzIwNjExNTYsMi4yNDg3OTQ5MSBMMS4wMDU5NDg3MiwzLjM5MzA5ODY3IEwxLjAwNTk0ODcyLDMuMzkzMDk4NjcgWlwiXG4gICAgICAgICAgICBpZD1cIlNoYXBlXCI+PC9wYXRoPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNC43MjEwNDEsIDE1LjcxNjM4NSkgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtNC43MjEwNDEsIC0xNS43MTYzODUpIHRyYW5zbGF0ZSgwLjc2NDUwNywgMTEuNzU5ODUxKVwiXG4gICAgICAgICAgZmlsbD1cInVybCgjbGluZWFyR3JhZGllbnQtNSlcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiNC4xNzI0MTIxOSA3LjE0NTAwNTUgMy4xNDY0MzM1MSA3LjgyOTczMzEzIDAuMDIyOTk3MzUyOCAzLjE0OTI3NzI3IDQuNzE5NzczOTEgMC4wMTQ5NjA2NDM1IDYuOTA5MDk3MTcgMy4yOTU3OTI2NyAzLjIzODQyMjkzIDUuNzQ1MzgxNjYgNi45MDkwOTcxNyAzLjI5NTc5MjY3IDcuODQzMjEwMDcgNC42OTU1NDAxNFwiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDguODIyNTYwLCA3LjgzNzYwOSkgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtOC44MjI1NjAsIC03LjgzNzYwOSkgdHJhbnNsYXRlKDIuNjQwNDc2LCAxLjE2MDk1OClcIlxuICAgICAgICAgIGZpbGw9XCJ1cmwoI2xpbmVhckdyYWRpZW50LTYpXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJTaGFwZVwiIHBvaW50cz1cIjExLjM0Mjg4NzkgNy43NTMzMjI1NyAxMi4yNzY4NzcxIDkuMTUzMDcwMDUgNi4xMDYxNjgwOSAxMy4yNzA5NTYzIDUuMTcyMTc4ODMgMTEuODcxMjA4OCAwLjA0MDY3ODExMzMgNC4xODE2ODUzMSA2LjIxMTM4NzE2IDAuMDYzNzk5MTA3N1wiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDE2LjEyMjg1NywgNC4zMDA3MDMpIHJvdGF0ZSgtMTEuMjgzODY0KSB0cmFuc2xhdGUoLTE2LjEyMjg1NywgLTQuMzAwNzAzKSB0cmFuc2xhdGUoMTIuOTY5OTk0LCAwLjkwMDU1NylcIlxuICAgICAgICAgIGZpbGw9XCJ1cmwoI2xpbmVhckdyYWRpZW50LTcpXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJTaGFwZVwiIHBvaW50cz1cIjQuODY2MDQyMDIgNS42MDEzMzkxIDMuMTUxMzc5MTggNi43NDU1MTkyMyAyLjIxNzI2NjI4IDUuMzQ1ODk1MzkgMC4wMjc5NDMwMjAxIDIuMDY1MDYzMzcgMy4wNjAwMDc5OCAwLjA0MTY2NzI0NjcgNi4xODM0NDQxNCA0LjcyMjEyMzExXCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTUuODIyMDcxLCAyNS44NTcxNTUpIHJvdGF0ZSgtMTEuMjgzODY0KSB0cmFuc2xhdGUoLTE1LjgyMjA3MSwgLTI1Ljg1NzE1NSkgdHJhbnNsYXRlKDEzLjQ3Mjg3OSwgMjMuODc4ODg4KVwiXG4gICAgICAgICAgZmlsbD1cIiM3MTQ4OTZcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiMC45MTQzMzAyMzYgMy45MTYyMjY2MiAwLjAxMDYzMzE4NDYgMi41NjIxMDI5MyAzLjY4MTQzMTA3IDAuMTEyNTEzOTMgNC41ODUwMDQ0OCAxLjQ2NjYzNzYzXCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMjYuMTgwNzIxLCAxNS41MzIxNjQpIHJvdGF0ZSgtMTEuMjgzODY0KSB0cmFuc2xhdGUoLTI2LjE4MDcyMSwgLTE1LjUzMjE2NCkgdHJhbnNsYXRlKDI0Ljc1ODg0MiwgMTQuMjMzOTI2KVwiXG4gICAgICAgICAgZmlsbD1cIiM2RjQ3OTVcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiMS4wMDU5NDg3MiAyLjUyNzYwNjkgMC4xMDIzNzUzMTIgMS4xNzM0ODMyIDEuODE3MDM4MTUgMC4wMjkxNzk0MzY5IDIuNzIwNjExNTYgMS4zODMzMDMxM1wiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDYuNTM5MjQyLCAxNi42MTQzOTMpIHJvdGF0ZSgtMTEuMjgzODY0KSB0cmFuc2xhdGUoLTYuNTM5MjQyLCAtMTYuNjE0MzkzKSB0cmFuc2xhdGUoNC4xOTAwNTAsIDE0LjYzNjEyNilcIlxuICAgICAgICAgIGZpbGw9XCIjODg1MTlGXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJTaGFwZVwiIHBvaW50cz1cIjAuOTU3NzI4NDY2IDMuOTMwMzIxNzggMC4wMjM3MzkyMDI5IDIuNTMwNjk3OTQgMy42OTQ0MTM0NSAwLjA4MTEwODk0MzIgNC42Mjg1MjYzNSAxLjQ4MDg1NjQyXCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTYuODg1Nzk1LCA2LjIyODc3Nykgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMTYuODg1Nzk1LCAtNi4yMjg3NzcpIHRyYW5zbGF0ZSgxNS40NjM5MTYsIDQuODY4NzE4KVwiXG4gICAgICAgICAgZmlsbD1cIiM4NTUwOUVcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiMS4wNDk0NzA1OSAyLjY2NTM0MzczIDAuMTE1MzU3Njg5IDEuMjY1NzE5ODkgMS44MzAxNDQxNyAwLjEyMTQxNjEzMSAyLjc2NDEzMzQzIDEuNTIxMTYzNjFcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyMS4yODA0MDQsIDIwLjM1NTMxMykgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMjEuMjgwNDA0LCAtMjAuMzU1MzEzKSB0cmFuc2xhdGUoMTcuNjk0Nzk1LCAxNy41MTE1NTQpXCJcbiAgICAgICAgICBmaWxsPVwiIzhEMTY2QVwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCI3LjE2NDA0NjMyIDEuNDczMTkwNjQgMC45OTM0NjA5MTIgNS41OTA5NTMyIDAuMDg5NzYzODYwOSA0LjIzNjk1MzE1IDYuMjYwNDcyOTEgMC4xMTkwNjY5MzlcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMi4wNTgyMDEsIDExLjEwMDQ1NCkgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMTIuMDU4MjAxLCAtMTEuMTAwNDU0KSB0cmFuc2xhdGUoOC40MTA3NzEsIDguMjU2Njk2KVwiXG4gICAgICAgICAgZmlsbD1cIiNBNzBENkZcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiNi4yNzM1Nzg5MyAwLjA4NzUzODMxMDYgNy4yMDc1NjgxOSAxLjQ4NzI4NTc5IDEuMDM2ODU5MTQgNS42MDUxNzIgMC4xMDI4Njk4NzkgNC4yMDU0MjQ1MlwiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEuODUzNDExLCAxMC42NzgyNjcpIHJvdGF0ZSg0NS4wMDAwMDApIHRyYW5zbGF0ZSgtMS44NTM0MTEsIC0xMC42NzgyNjcpIHRyYW5zbGF0ZSgwLjc5NzkwNiwgOS42MjI3NjIpXCJcbiAgICAgICAgICBmaWxsPVwiIzlFNjFBRFwiPlxuICAgICAgICAgIDxyZWN0IGlkPVwiUmVjdGFuZ2xlLXBhdGhcIiB4PVwiMS42NjY2MjU3MWUtMTVcIiB5PVwiMFwiIHdpZHRoPVwiMi4wOTgyNzE1XCIgaGVpZ2h0PVwiMi4wOTgyNzE1XCI+PC9yZWN0PlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTIuMTE1NjY5LCAyOS45NjYzNjYpIHJvdGF0ZSg0NS4wMDAwMDApIHRyYW5zbGF0ZSgtMTIuMTE1NjY5LCAtMjkuOTY2MzY2KSB0cmFuc2xhdGUoMTEuMDYwMTYzLCAyOC45MTA4NjApXCJcbiAgICAgICAgICBmaWxsPVwiIzgwNTNBM1wiPlxuICAgICAgICAgIDxyZWN0IGlkPVwiUmVjdGFuZ2xlLXBhdGhcIiB4PVwiMS42NjY2MjU3MWUtMTVcIiB5PVwiMFwiIHdpZHRoPVwiMi4wOTgyNzE1XCIgaGVpZ2h0PVwiMi4wOTgyNzE1XCI+PC9yZWN0PlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTYuNjQxOTU0LCAxNi40Mjc0MzcpIHJvdGF0ZSgwLjAwMDAwMCkgdHJhbnNsYXRlKC0xNi42NDE5NTQsIC0xNi40Mjc0MzcpIHRyYW5zbGF0ZSgxLjQyMjQ0MiwgMS4yMDc5MjQpXCJcbiAgICAgICAgICBmaWxsPVwidXJsKCNsaW5lYXJHcmFkaWVudC04KVwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCI2LjUzNDQ2MTU3IDI5Ljg4Nzg5NzggMC4wMTI5ODIzNzQgMjMuMzE3NTgwMSAyMy4yMTg2NjY4IDAuMDYzMDU3MjQ1MSAyOS45NTk2MDk5IDYuNDYzOTg1ODNcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGlkPVwiQXVyZWxpYS0rLVR5cGUtc29tZXRoaW5nXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDM4LjEzMTk2MCwgMy4wMjE0MjcpXCI+XG4gICAgICAgIDxnIGlkPVwiQXVyZWxpYVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLjkyOTUwNSwgMC4yOTAyOTcpXCI+XG4gICAgICAgICAgPGcgaWQ9XCJBXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAuMDc2NjczLCA4LjQxMzQ2NSlcIiBmaWxsPVwiI0VEMkM4OFwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk04Ljc5NTI0NzUyLDE2LjU0MDM1NjQgQzguOTEwODkxMDksMTYuNTM5ODgxMiA5LjAyODExODgxLDE2LjUzNzY2MzQgOS4xNDM3NjIzOCwxNi41MzI1OTQxIEM5LjM4OTMwNjkzLDE2LjUyMTY2MzQgOS42MzMyNjczMywxNi40OTkzMjY3IDkuODc3MjI3NzIsMTYuNDY1MjY3MyBDMTAuNTg1MzQ2NSwxNi4zNjU5NDA2IDExLjI3OTIwNzksMTYuMTY3NjA0IDExLjkzMzQ2NTMsMTUuODc2NTk0MSBDMTIuNzQyOTcwMywxNS41MTY2NzMzIDEzLjQ4OTEwODksMTUuMDE2MjM3NiAxNC4xMzA2OTMxLDE0LjQwNTA2OTMgQzE0LjczNTg0MTYsMTMuODI3MTY4MyAxNS4yNDc1MjQ4LDEzLjE1MTIwNzkgMTUuNjM4ODExOSwxMi40MTA0NTU0IEMxNS45Njk5MDEsMTEuNzgyMTc4MiAxNi4yMTM4NjE0LDExLjEwODQzNTYgMTYuMzYxMTg4MSwxMC40MTMzMDY5IEMxNi41NDAxOTgsOS41NjM1NjQzNiAxNi41NzUwNDk1LDguNjgzMjQ3NTIgMTYuNDY1NzQyNiw3LjgyMTc4MjE4IEMxNi4zNjQzNTY0LDcuMDMyNzEyODcgMTYuMTQyNTc0Myw2LjI2MDQzNTY0IDE1LjgwNTE0ODUsNS41Mzk2NDM1NiBDMTUuNDE4NjEzOSw0LjcwOTU0NDU1IDE0Ljg4MTU4NDIsMy45NTAyNTc0MyAxNC4yMzA0OTUsMy4zMDY0NTU0NSBDMTMuNTQ0NTU0NSwyLjYyOTIyNzcyIDEyLjczMzQ2NTMsMi4wODExMDg5MSAxMS44NDc5MjA4LDEuNzAwMTE4ODEgQzExLjM2NzkyMDgsMS40OTM1NDQ1NSAxMC44NjU3NDI2LDEuMzM2MDc5MjEgMTAuMzU0MDU5NCwxLjIzMTM2NjM0IEM5Ljg3NDA1OTQxLDEuMTMzMTQ4NTEgOS4zODQ1NTQ0NiwxLjA4MTAyOTcgOC44OTUwNDk1LDEuMDc0ODUxNDkgQzguNDE4MjE3ODIsMS4wNjg4MzE2OCA3Ljk0MTM4NjE0LDEuMTA1OTAwOTkgNy40NzI0NzUyNSwxLjE4NjY5MzA3IEM2Ljk0MDE5ODAyLDEuMjc4NDE1ODQgNi40MTc0MjU3NCwxLjQyNjUzNDY1IDUuOTE1MjQ3NTIsMS42Mjc4ODExOSBDNS4wMzQ0NTU0NSwxLjk4MTMwNjkzIDQuMjIxNzgyMTgsMi40OTkxNjgzMiAzLjUyNjMzNjYzLDMuMTQ1ODIxNzggQzIuODQ1MTQ4NTEsMy43ODAxMTg4MSAyLjI3OTYwMzk2LDQuNTM2ODcxMjkgMS44NjQ1NTQ0Niw1LjM3MDYxMzg2IEMxLjUxMjg3MTI5LDYuMDgwNzkyMDggMS4yNzA0OTUwNSw2Ljg0NDk5MDEgMS4xNTAwOTkwMSw3LjYyODk5MDEgQzEuMDE3MDI5Nyw4LjUwNDA3OTIxIDEuMDMyODcxMjksOS40MDIyOTcwMyAxLjIwMDc5MjA4LDEwLjI3MTg0MTYgQzEuMzM3MDI5NywxMC45ODU5ODAyIDEuNTc2MjM3NjIsMTEuNjgwMTU4NCAxLjkwNzMyNjczLDEyLjMyNzQ0NTUgQzIuMjg5MTA4OTEsMTMuMDczMTA4OSAyLjc5Mjg3MTI5LDEzLjc1NTI0NzUgMy4zOTMyNjczMywxNC4zNDA1OTQxIEM0LjAxNDI1NzQzLDE0Ljk0ODI3NzIgNC43MzgyMTc4MiwxNS40NTAyOTcgNS41MjcxMjg3MSwxNS44MTgxMzg2IEM2LjE1OTIwNzkyLDE2LjExMzQyNTcgNi44MzI0NzUyNSwxNi4zMjE5MDEgNy41MiwxNi40MzU5NjA0IEM3Ljc2MDc5MjA4LDE2LjQ3NTg4MTIgOC4wMDQ3NTI0OCwxNi41MDQzOTYgOC4yNDg3MTI4NywxNi41MjEzNDY1IEM4LjM4MDE5ODAyLDE2LjUzMDUzNDcgOC41MTE2ODMxNywxNi41MzU5MjA4IDguNjQ0NzUyNDgsMTYuNTM4OTMwNyBDOC42OTU0NDU1NCwxNi41Mzk3MjI4IDguNzQ0NTU0NDYsMTYuNTQwMTk4IDguNzk1MjQ3NTIsMTYuNTQwMzU2NCBMOC43OTUyNDc1MiwxNi41NDAzNTY0IFogTTE2Ljg1Mzg2MTQsMTIuMTk5NjA0IEMxNi43Njk5MDEsMTIuMzk4ODkxMSAxNi42NzgwMTk4LDEyLjU5NTAwOTkgMTYuNTc5ODAyLDEyLjc4NzQ4NTEgQzE2LjEzMzA2OTMsMTMuNjYxMzA2OSAxNS41Mzc0MjU3LDE0LjQ1Nzk4MDIgMTQuODI2MTM4NiwxNS4xMzUzNjYzIEMxNC4xMjc1MjQ4LDE1LjgwMTgyMTggMTMuMzE4MDE5OCwxNi4zNTE4NDE2IDEyLjQ0MDM5NiwxNi43NTUwMDk5IEMxMS43MDUzNDY1LDE3LjA5MjQzNTYgMTAuOTI0MzU2NCwxNy4zMjY1NzQzIDEwLjEyNTk0MDYsMTcuNDQ4NzEyOSBDOS44NTE4ODExOSwxNy40OTA1MzQ3IDkuNTc2MjM3NjIsMTcuNTE5MzY2MyA5LjI5OTAwOTksMTcuNTM1MDQ5NSBDOS4xNjkxMDg5MSwxNy41NDI0OTUgOS4wMzc2MjM3NiwxNy41NDY2MTM5IDguOTA3NzIyNzcsMTcuNTQ4NjczMyBDOC44Njk3MDI5NywxNy41NDkxNDg1IDguODMxNjgzMTcsMTcuNTQ5MzA2OSA4Ljc5NTI0NzUyLDE3LjU0OTQ2NTMgQzguNjYzNzYyMzgsMTcuNTQ4OTkwMSA4LjUzMjI3NzIzLDE3LjU0NjYxMzkgOC40MDA3OTIwOCwxNy41NDA3NTI1IEM4LjEyMzU2NDM2LDE3LjUyODM5NiA3Ljg0NzkyMDc5LDE3LjUwMzA0OTUgNy41NzIyNzcyMywxNy40NjQ3MTI5IEM2Ljc3MDY5MzA3LDE3LjM1MjM5NiA1Ljk4NDk1MDUsMTcuMTI3NzYyNCA1LjI0NTE0ODUxLDE2Ljc5ODczMjcgQzQuMzQ2OTMwNjksMTYuMzk4ODkxMSAzLjUxNjgzMTY4LDE1Ljg0NjAxOTggMi44MDA3OTIwOCwxNS4xNzE0ODUxIEMyLjA3MzY2MzM3LDE0LjQ4NjE3ODIgMS40NjUzNDY1MywxMy42NzY4MzE3IDEuMDA5MTA4OTEsMTIuNzg3NDg1MSBDMC42NDE1ODQxNTgsMTIuMDcxMjg3MSAwLjM3NTQ0NTU0NSwxMS4zMDQ1NTQ1IDAuMjE4NjEzODYxLDEwLjUxNTE2ODMgQzAuMDMxNjgzMTY4Myw5LjU3MDM3NjI0IDAuMDAzMTY4MzE2ODMsOC41OTQ1MzQ2NSAwLjEyOTkwMDk5LDcuNjM5OTIwNzkgQzAuMjQ3MTI4NzEzLDYuNzY2MjU3NDMgMC40OTU4NDE1ODQsNS45MTEyODcxMyAwLjg2OTcwMjk3LDUuMTEyNzEyODcgQzEuMzE0ODUxNDksNC4xNTg1NzQyNiAxLjkzNDI1NzQzLDMuMjg3NjAzOTYgMi42ODgzMTY4MywyLjU1MTkyMDc5IEMzLjQ2NjEzODYxLDEuNzkwNzMyNjcgNC4zODgxMTg4MSwxLjE3NjcxMjg3IDUuMzkwODkxMDksMC43NTIzMTY4MzIgQzUuOTIsMC41Mjg2MzM2NjMgNi40NzEyODcxMywwLjM1NzcwMjk3IDcuMDMzNjYzMzcsMC4yNDI2OTMwNjkgQzcuNTk0NDU1NDUsMC4xMjggOC4xNjYzMzY2MywwLjA2ODc1MjQ3NTIgOC43MzgyMTc4MiwwLjA2NTI2NzMyNjcgQzkuMzExNjgzMTcsMC4wNjE2MjM3NjI0IDkuODg1MTQ4NTEsMC4xMTM1ODQxNTggMTAuNDQ5MTA4OSwwLjIyMTQ2NTM0NyBDMTEuMDEzMDY5MywwLjMyOTY2MzM2NiAxMS41Njc1MjQ4LDAuNDkzOTQwNTk0IDEyLjA5OTgwMiwwLjcxMTI4NzEyOSBDMTMuMTA4OTEwOSwxLjEyMzY0MzU2IDE0LjAzNzIyNzcsMS43MjY4OTEwOSAxNC44MjYxMzg2LDIuNDc5MDQ5NSBDMTUuNTc1NDQ1NSwzLjE5MzAyOTcgMTYuMTk2NDM1Niw0LjAzOTYwMzk2IDE2LjY1MTA4OTEsNC45NjkxODgxMiBDMTYuNzIyMzc2Miw1LjExNTg4MTE5IDE2Ljc5MDQ5NSw1LjI2NDQ3NTI1IDE2Ljg1Mzg2MTQsNS40MTQ5NzAzIEwxNi44NTM4NjE0LDAuMDk0NDE1ODQxNiBMMTcuODQzOTYwNCwwLjA5NDQxNTg0MTYgTDE3Ljg0Mzk2MDQsMTcuNTIwMTU4NCBMMTYuODUzODYxNCwxNy41MjAxNTg0IEwxNi44NTM4NjE0LDEyLjE5OTYwNCBMMTYuODUzODYxNCwxMi4xOTk2MDQgWlwiXG4gICAgICAgICAgICAgIGlkPVwiU2hhcGVcIj48L3BhdGg+XG4gICAgICAgICAgPC9nPlxuICAgICAgICAgIDxnIGlkPVwiVVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyMC4zNTM5MDEsIDguNDEzNDY1KVwiIGZpbGw9XCIjQ0QwRjdFXCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTE2LjUzNzAyOTcsMTIuODE4ODUxNSBDMTYuMTcxMDg5MSwxMy41MjM0ODUxIDE1LjcxMTY4MzIsMTQuMTc5MDA5OSAxNS4xNzE0ODUxLDE0Ljc2MTUwNSBDMTQuNzEwNDk1LDE1LjI2MDUxNDkgMTQuMTg5MzA2OSwxNS43MDU2NjM0IDEzLjYyNTM0NjUsMTYuMDg0NTk0MSBDMTMuMDEwNjkzMSwxNi40OTY3OTIxIDEyLjM0MjE3ODIsMTYuODI5OTQwNiAxMS42NDM1NjQ0LDE3LjA3MjQ3NTIgQzExLjA2Mzc2MjQsMTcuMjczNjYzNCAxMC40NjE3ODIyLDE3LjQxMjI3NzIgOS44NTE4ODExOSwxNy40ODU5NDA2IEM5LjY0OTEwODkxLDE3LjUxMDQ5NSA5LjQ0NzkyMDc5LDE3LjUyNzc2MjQgOS4yNDM1NjQzNiwxNy41MzgwNTk0IEM5LjEzMTA4OTExLDE3LjU0Mzc2MjQgOS4wMjAxOTgwMiwxNy41NDY5MzA3IDguOTA3NzIyNzcsMTcuNTQ4NjczMyBDOC44Njk3MDI5NywxNy41NDkxNDg1IDguODMxNjgzMTcsMTcuNTQ5MzA2OSA4Ljc5NTI0NzUyLDE3LjU0OTQ2NTMgQzguNjgxMTg4MTIsMTcuNTQ5MTQ4NSA4LjU3MDI5NzAzLDE3LjU0NzI0NzUgOC40NTYyMzc2MiwxNy41NDI5NzAzIEM4LjIxNTQ0NTU0LDE3LjUzMzk0MDYgNy45NzQ2NTM0NywxNy41MTQ5MzA3IDcuNzM1NDQ1NTQsMTcuNDg2MDk5IEM3LjAzMzY2MzM3LDE3LjQwMTUwNSA2LjM0Mjk3MDMsMTcuMjMxODQxNiA1LjY4MDc5MjA4LDE2Ljk4MTcwMyBDNC42ODkxMDg5MSwxNi42MDY1NzQzIDMuNzY3MTI4NzEsMTYuMDUwNTM0NyAyLjk3MTg4MTE5LDE1LjM0OTIyNzcgQzIuNDA3OTIwNzksMTQuODUwNTM0NyAxLjkwNTc0MjU3LDE0LjI3ODgxMTkgMS40ODc1MjQ3NSwxMy42NTE5NjA0IEMxLjAzNDQ1NTQ1LDEyLjk3NDU3NDMgMC42NzgwMTk4MDIsMTIuMjMzMDI5NyAwLjQzNTY0MzU2NCwxMS40NTUzNjYzIEMwLjI1NjYzMzY2MywxMC44ODMwMDk5IDAuMTM5NDA1OTQxLDEwLjI5MTgwMiAwLjA4NTU0NDU1NDUsOS42OTQ3MzI2NyBDMC4wNTg2MTM4NjE0LDkuMzk4NjUzNDcgMC4wNDkxMDg5MTA5LDkuMTAxNjIzNzYgMC4wNTIyNzcyMjc3LDguODA0NDM1NjQgTDAuMDUyMjc3MjI3NywwLjA5NDQxNTg0MTYgTDEuMDYxMzg2MTQsMC4wOTQ0MTU4NDE2IEwxLjA2MTM4NjE0LDguODEwMTM4NjEgTDEuMDYxMzg2MTQsOC45MTQ1MzQ2NSBMMS4wNjEzODYxNCw5LjAxNDAxOTggQzEuMDYyOTcwMyw5LjExMzAyOTcgMS4wNjQ1NTQ0Niw5LjIxMTg4MTE5IDEuMDcwODkxMDksOS4zMTA3MzI2NyBDMS4wODE5ODAyLDkuNTM4MDU5NDEgMS4xMDQxNTg0Miw5Ljc2NDkxMDg5IDEuMTM1ODQxNTgsOS45OTAzMzY2MyBDMS4yMjc3MjI3NywxMC42MzMzNDY1IDEuNDAzNTY0MzYsMTEuMjY0IDEuNjYwMTk4MDIsMTEuODYxMzg2MSBDMi4wMTk4MDE5OCwxMi43MDQ3OTIxIDIuNTM2MjM3NjIsMTMuNDc5Mjg3MSAzLjE2OTkwMDk5LDE0LjE0MTQ2NTMgQzMuNzk1NjQzNTYsMTQuNzkzOTgwMiA0LjUzNTQ0NTU0LDE1LjMzNTc2MjQgNS4zNDQ5NTA1LDE1LjczNjIzNzYgQzYuMDU5NDA1OTQsMTYuMDg5MDI5NyA2LjgyNzcyMjc3LDE2LjMzMTA4OTEgNy42MTUwNDk1LDE2LjQ1MTE2ODMgQzguNDI2MTM4NjEsMTYuNTc0NzMyNyA5LjI1NzgyMTc4LDE2LjU3MDQ1NTQgMTAuMDY3MzI2NywxNi40MzU5NjA0IEMxMC43MDU3NDI2LDE2LjMyOTY2MzQgMTEuMzMxNDg1MSwxNi4xNDE2MjM4IDExLjkyMzk2MDQsMTUuODc2OTEwOSBDMTIuNzcxNDg1MSwxNS40OTc5ODAyIDEzLjU0NzcyMjgsMTQuOTYzMTY4MyAxNC4yMDY3MzI3LDE0LjMwODkxMDkgQzE0LjgzNDA1OTQsMTMuNjg1Mzg2MSAxNS4zNTM2NjM0LDEyLjk1NTI0NzUgMTUuNzQwMTk4LDEyLjE1ODczMjcgQzE2LjA1ODYxMzksMTEuNTAwMzU2NCAxNi4yODM1NjQ0LDEwLjc5NzYyMzggMTYuNDA4NzEyOSwxMC4wNzcxNDg1IEMxNi40NTc4MjE4LDkuODAzMDg5MTEgMTYuNDkxMDg5MSw5LjUyNjY1MzQ3IDE2LjUxMDA5OSw5LjI0OTI2NzMzIEMxNi41MTgwMTk4LDkuMTE2NTE0ODUgMTYuNTI0MzU2NCw4Ljk4Mzc2MjM4IDE2LjUyNzUyNDgsOC44NTA2OTMwNyBMMTYuNTI3NTI0OCw4LjgwMzE2ODMyIEwxNi41MzcwMjk3LDAuMDk0NDE1ODQxNiBMMTcuNTI3MTI4NywwLjA5NDQxNTg0MTYgTDE3LjUyNzEyODcsMTcuNTIwMTU4NCBMMTYuNTM3MDI5NywxNy41MjAxNTg0IEwxNi41MzcwMjk3LDEyLjgxODg1MTUgTDE2LjUzNzAyOTcsMTIuODE4ODUxNSBaXCJcbiAgICAgICAgICAgICAgaWQ9XCJTaGFwZVwiPjwvcGF0aD5cbiAgICAgICAgICA8L2c+XG4gICAgICAgICAgPGcgaWQ9XCJSXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDQwLjMxNDI5NywgOC40MTM0NjUpXCIgZmlsbD1cIiNCMzE3NzZcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMS4wNjQ1NTQ0Niw4LjQxNTUyNDc1IEwxLjA0MjM3NjI0LDE3LjUyMDE1ODQgTDAuMDUyMjc3MjI3NywxNy41MjAxNTg0IEwwLjA1MjI3NzIyNzcsMC4wOTQ0MTU4NDE2IEwxLjA0MjM3NjI0LDAuMDk0NDE1ODQxNiBMMS4wNDIzNzYyNCw0LjU1NTI0NzUyIEMxLjE2NTk0MDU5LDQuMzI5NjYzMzcgMS4zMDA1OTQwNiw0LjEwOTc4MjE4IDEuNDQzMTY4MzIsMy44OTYzOTYwNCBDMS44MzI4NzEyOSwzLjMxNjkxMDg5IDIuMjk1NDQ1NTQsMi43ODYzNzYyNCAyLjgxMzQ2NTM1LDIuMzE4ODkxMDkgQzMuNTcwNjkzMDcsMS42MzYxMTg4MSA0LjQ0ODMxNjgzLDEuMDg5MTA4OTEgNS4zOTQwNTk0MSwwLjcwNjY5MzA2OSBDNi4wODk1MDQ5NSwwLjQyNTE4ODExOSA2LjgyMTM4NjE0LDAuMjMyODcxMjg3IDcuNTY1OTQwNTksMC4xMzMzODYxMzkgQzcuODIyNTc0MjYsMC4wOTkzMjY3MzI3IDguMDc5MjA3OTIsMC4wNzYwMzk2MDQgOC4zMzc0MjU3NCwwLjA2MzUyNDc1MjUgQzguNDg2MzM2NjMsMC4wNTYzOTYwMzk2IDguNjM1MjQ3NTIsMC4wNTMyMjc3MjI4IDguNzg0MTU4NDIsMC4wNTI3NTI0NzUyIEw4Ljc4NzMyNjczLDEuMDg2NDE1ODQgQzguNzUyNDc1MjUsMS4wODY1NzQyNiA4LjcxOTIwNzkyLDEuMDg2NzMyNjcgOC42ODU5NDA1OSwxLjA4NzA0OTUgQzguNjUyNjczMjcsMS4wODc1MjQ3NSA4LjYxOTQwNTk0LDEuMDg4MTU4NDIgOC41ODYxMzg2MSwxLjA4ODk1MDUgQzguNDcwNDk1MDUsMS4wOTE5NjA0IDguMzU0ODUxNDksMS4wOTY4NzEyOSA4LjIzOTIwNzkyLDEuMTA0NjMzNjYgQzcuOTk1MjQ3NTIsMS4xMjA3OTIwOCA3Ljc1Mjg3MTI5LDEuMTQ3ODgxMTkgNy41MTIwNzkyMSwxLjE4NTkwMDk5IEM2Ljg3MzY2MzM3LDEuMjg2ODExODggNi4yNDc5MjA3OSwxLjQ2NTUwNDk1IDUuNjUyMjc3MjMsMS43MTg0OTUwNSBDNC44MjY5MzA2OSwyLjA3MDAxOTggNC4wNjE3ODIxOCwyLjU2NTA2OTMxIDMuNDA1OTQwNTksMy4xNzgxMzg2MSBDMi45NDY1MzQ2NSwzLjYwNzEyODcxIDIuNTQwOTkwMSw0LjA5MzQ2NTM1IDIuMjAzNTY0MzYsNC42MjMyMDc5MiBDMS44NTY2MzM2Niw1LjE2NjczMjY3IDEuNTgwOTkwMSw1Ljc1NjE5ODAyIDEuMzg5MzA2OTMsNi4zNzE4MDE5OCBDMS4yNTMwNjkzMSw2LjgwOTY2MzM3IDEuMTU5NjAzOTYsNy4yNjAzNTY0NCAxLjEwODkxMDg5LDcuNzE2MTE4ODEgQzEuMDgxOTgwMiw3Ljk0ODUxNDg1IDEuMDY5MzA2OTMsOC4xODE4NjEzOSAxLjA2NDU1NDQ2LDguNDE1NTI0NzUgTDEuMDY0NTU0NDYsOC40MTU1MjQ3NSBaXCJcbiAgICAgICAgICAgICAgaWQ9XCJTaGFwZVwiPjwvcGF0aD5cbiAgICAgICAgICA8L2c+XG4gICAgICAgICAgPGcgaWQ9XCJFXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDQ4LjM5MzUwNSwgOC40MTM0NjUpXCIgZmlsbD1cIiM5QjIwNzNcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNOS4zNzUwNDk1LDE3LjU1MTA0OTUgTDguODE1ODQxNTgsMTcuNTQ5MzA2OSBDOC43Nzk0MDU5NCwxNy41NDg4MzE3IDguNzQxMzg2MTQsMTcuNTQ4MzU2NCA4LjcwMzM2NjM0LDE3LjU0Nzg4MTIgQzguNTkwODkxMDksMTcuNTQ1MzQ2NSA4LjQ4LDE3LjU0MTM4NjEgOC4zNjc1MjQ3NSwxNy41MzUwNDk1IEM4LjEyODMxNjgzLDE3LjUyMTQyNTcgNy44ODkxMDg5MSwxNy40OTc5ODAyIDcuNjUxNDg1MTUsMTcuNDY0NzEyOSBDNi45ODkzMDY5MywxNy4zNzIwMzk2IDYuMzM5ODAxOTgsMTcuMjAzMzI2NyA1LjcxNzIyNzcyLDE2Ljk2MjM3NjIgQzQuNjgyNzcyMjgsMTYuNTYyMDU5NCAzLjcyOTEwODkxLDE1Ljk2MjYxMzkgMi45MTgwMTk4LDE1LjIwNzI4NzEgQzIuMTIxMTg4MTIsMTQuNDY2Mzc2MiAxLjQ2NTM0NjUzLDEzLjU3NzM0NjUgMC45OTMyNjczMjcsMTIuNTk3NTQ0NiBDMC42NDMxNjgzMTcsMTEuODcwNzMyNyAwLjM5NDQ1NTQ0NiwxMS4wOTU0NDU1IDAuMjU4MjE3ODIyLDEwLjMwMDM1NjQgQzAuMDkzNDY1MzQ2NSw5LjM1MDgxMTg4IDAuMDg4NzEyODcxMyw4LjM3Mzg2MTM5IDAuMjM5MjA3OTIxLDcuNDIyNDE1ODQgQzAuNDAwNzkyMDc5LDYuNDE0ODkxMDkgMC43Mzk4MDE5OCw1LjQzNzc4MjE4IDEuMjM3MjI3NzIsNC41NDczMjY3MyBDMS43ODM3NjIzOCwzLjU2ODc5MjA4IDIuNTIwMzk2MDQsMi42OTg0NTU0NSAzLjM5MzI2NzMzLDEuOTk1MjQ3NTIgQzMuODU3NDI1NzQsMS42MjA3NTI0OCA0LjM2MTE4ODEyLDEuMjkzOTQwNTkgNC44OTE4ODExOSwxLjAyMTc4MjE4IEM1LjM4Mjk3MDMsMC43NzAyMTc4MjIgNS44OTc4MjE3OCwwLjU2NTU0NDU1NCA2LjQyODUxNDg1LDAuNDExNTY0MzU2IEM3LjE4NTc0MjU3LDAuMTkxNTI0NzUyIDcuOTcxNDg1MTUsMC4wNzU3MjI3NzIzIDguNzYwMzk2MDQsMC4wNjU3NDI1NzQzIEM5LjY0MTE4ODEyLDAuMDU0NjUzNDY1MyAxMC41MjM1NjQ0LDAuMTc1MzY2MzM3IDExLjM2OTUwNSwwLjQyNjc3MjI3NyBDMTIuMzE4NDE1OCwwLjcwOTM4NjEzOSAxMy4yMTgyMTc4LDEuMTU1NjQzNTYgMTQuMDE5ODAyLDEuNzM5NzIyNzcgQzE0Ljg2NzMyNjcsMi4zNTg0OTUwNSAxNS42MDIzNzYyLDMuMTI5NjYzMzcgMTYuMTgwNTk0MSw0LjAwNjY1MzQ3IEMxNi41NTkyMDc5LDQuNTgyMzM2NjMgMTYuODY5NzAzLDUuMjAzMDA5OSAxNy4xMDI1NzQzLDUuODUxNzIyNzcgQzE3LjM0MTc4MjIsNi41MTY3NTI0OCAxNy40OTg2MTM5LDcuMjEwOTMwNjkgMTcuNTY5OTAxLDcuOTE0MTM4NjEgQzE3LjU5MjA3OTIsOC4xMzYwNzkyMSAxNy42MDYzMzY2LDguMzU4ODExODggMTcuNjEyNjczMyw4LjU4MTg2MTM5IEMxNy42MTI2NzMzLDguNjM4MjU3NDMgMTcuNjE0MjU3NCw4LjY5NDQ5NTA1IDE3LjYxNDI1NzQsOC43NTA3MzI2NyBDMTcuNjE1ODQxNiw4Ljc4NzMyNjczIDE3LjYxNTg0MTYsOC44MjU4MjE3OCAxNy42MTI2NzMzLDguODYyMDk5MDEgQzE3LjYwOTUwNSw4Ljg4MDk1MDUgMTcuNjA2MzM2Niw4Ljg5OTY0MzU2IDE3LjYwMzE2ODMsOC45MTgxNzgyMiBDMTcuNTkwNDk1LDguOTczNDY1MzUgMTcuNTY4MzE2OCw5LjAyNjY5MzA3IDE3LjUzODIxNzgsOS4wNzQ2OTMwNyBDMTcuNDc4MDE5OCw5LjE3MTMyNjczIDE3LjM4NDU1NDUsOS4yNDU2MjM3NiAxNy4yNzY4MzE3LDkuMjgzMzI2NzMgQzE3LjI0MTk4MDIsOS4yOTU4NDE1OCAxNy4yMDM5NjA0LDkuMzA0Mzk2MDQgMTcuMTY3NTI0OCw5LjMwODY3MzI3IEMxNy4xNDg1MTQ5LDkuMzEwNzMyNjcgMTcuMTI5NTA1LDkuMzEwNzMyNjcgMTcuMTEwNDk1LDkuMzExODQxNTggTDkuMDgxOTgwMiw5LjMxMTg0MTU4IEw5LjA4MTk4MDIsOC4zMDI3MzI2NyBMMTYuNTg5MzA2OSw4LjMwMjczMjY3IEMxNi41NzE4ODEyLDguMDI4NjczMjcgMTYuNTQwMTk4LDcuNzU1ODgxMTkgMTYuNDkyNjczMyw3LjQ4NTMwNjkzIEMxNi40MDIzNzYyLDYuOTUyNzEyODcgMTYuMjUzNDY1Myw2LjQyOTYyMzc2IDE2LjA1MjI3NzIsNS45MjgwNzkyMSBDMTUuNzYyMzc2Miw1LjIwNTM4NjE0IDE1LjM2MTU4NDIsNC41MjggMTQuODY4OTEwOSwzLjkyNDQzNTY0IEMxNC4zMTEyODcxLDMuMjQwMDc5MjEgMTMuNjM2NDM1NiwyLjY1MTg4MTE5IDEyLjg4MjM3NjIsMi4xOTM0MjU3NCBDMTIuMjY0NTU0NSwxLjgxODQ1NTQ1IDExLjU5NjAzOTYsMS41MzA3NzIyOCAxMC44OTc0MjU3LDEuMzQxOTQwNTkgQzEwLjA2MjU3NDMsMS4xMTU4ODExOSA5LjE4OTcwMjk3LDEuMDMyODcxMjkgOC4zMjYzMzY2MywxLjA5MzIyNzcyIEM3LjkwNjUzNDY1LDEuMTIyNTM0NjUgNy40ODgzMTY4MywxLjE4NTkwMDk5IDcuMDc5NjAzOTYsMS4yODMxNjgzMiBDNi42MzI4NzEyOSwxLjM4OTE0ODUxIDYuMTk3MjI3NzIsMS41MzUyMDc5MiA1Ljc3NTg0MTU4LDEuNzE4OTcwMyBDNC44OTM0NjUzNSwyLjEwNDg3MTI5IDQuMDg1NTQ0NTUsMi42NTc5MDA5OSAzLjQwNDM1NjQ0LDMuMzM5MDg5MTEgQzMuMDg3NTI0NzUsMy42NTY1NTQ0NiAyLjc5NzYyMzc2LDQuMDAxNTg0MTYgMi41Mzk0MDU5NCw0LjM2ODk1MDUgQzIuMjE2MjM3NjIsNC44MjgzNTY0NCAxLjk0Mzc2MjM4LDUuMzIyNjEzODYgMS43MjgzMTY4Myw1Ljg0MDc5MjA4IEMxLjUwMzM2NjM0LDYuMzgzODQxNTggMS4zNDAxOTgwMiw2Ljk1Mjg3MTI5IDEuMjQzNTY0MzYsNy41MzMxNDg1MSBDMS4xNjU5NDA1OSw4LjAwMzMyNjczIDEuMTMyNjczMjcsOC40ODA2MzM2NiAxLjE0MDU5NDA2LDguOTU3MzA2OTMgQzEuMTUxNjgzMTcsOS40OTQ0OTUwNSAxLjIxNjYzMzY2LDEwLjAzMDU3NDMgMS4zMzcwMjk3LDEwLjU1NDEzODYgQzEuNDc2NDM1NjQsMTEuMTUzNTg0MiAxLjY4NzEyODcxLDExLjczNjIzNzYgMS45NjQzNTY0NCwxMi4yODU2MjM4IEMyLjI2NTM0NjUzLDEyLjg4MTc0MjYgMi42NDM5NjA0LDEzLjQzODI1NzQgMy4wODU5NDA1OSwxMy45Mzc1ODQyIEMzLjQ5NzgyMTc4LDE0LjQwMDc5MjEgMy45NjM1NjQzNiwxNC44MTQ1NzQzIDQuNDcyMDc5MjEsMTUuMTY3MzY2MyBDNC44ODIzNzYyNCwxNS40NTE0MDU5IDUuMzE5NjAzOTYsMTUuNjk1ODQxNiA1Ljc3NTg0MTU4LDE1Ljg5NTYwNCBDNi4yNTU4NDE1OCwxNi4xMDUwMjk3IDYuNzU0ODUxNDksMTYuMjY1MzQ2NSA3LjI2NjUzNDY1LDE2LjM3MzM4NjEgQzcuNTk5MjA3OTIsMTYuNDQzNzIyOCA3LjkzODIxNzgyLDE2LjQ5MTg4MTIgOC4yNzcyMjc3MiwxNi41MTc3MDMgQzguNDU5NDA1OTQsMTYuNTMxNDg1MSA4LjY0LDE2LjUzODQ1NTQgOC44MjIxNzgyMiwxNi41NDAxOTggTDkuMzc4MjE3ODIsMTYuNTQxOTQwNiBDOS4zNzgyMTc4MiwxNi44NzgyNTc0IDkuMzc2NjMzNjYsMTcuMjE0NTc0MyA5LjM3NTA0OTUsMTcuNTUxMDQ5NSBMOS4zNzUwNDk1LDE3LjU1MTA0OTUgWlwiXG4gICAgICAgICAgICAgIGlkPVwiU2hhcGVcIj48L3BhdGg+XG4gICAgICAgICAgPC9nPlxuICAgICAgICAgIDxnIGlkPVwiTFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg2OC41MTIzMTcsIDAuMDE3NDI2KVwiIGZpbGw9XCIjOEYyNDc1XCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTUuMTUwMDk5MDEsMjUuOTQ1NTA1IEM0Ljk4ODUxNDg1LDI1Ljk0NTAyOTcgNC44MjY5MzA2OSwyNS45NDAxMTg4IDQuNjY1MzQ2NTMsMjUuOTI5MTg4MSBDNC4zMjQ3NTI0OCwyNS45MDYyMTc4IDMuOTg0MTU4NDIsMjUuODU3NzQyNiAzLjY1MTQ4NTE1LDI1Ljc4MDI3NzIgQzMuMzE4ODExODgsMjUuNzAyNjUzNSAyLjk5MDg5MTA5LDI1LjU5NTcyMjggMi42Nzg4MTE4OCwyNS40NTY2MzM3IEMyLjI5MjI3NzIzLDI1LjI4NDkxMDkgMS45MjYzMzY2MywyNS4wNjQyMzc2IDEuNjAxNTg0MTYsMjQuNzk0NzcyMyBDMS40MzA0OTUwNSwyNC42NTQ4OTExIDEuMjcyMDc5MjEsMjQuNTAyMDE5OCAxLjEyNjMzNjYzLDI0LjMzNzU4NDIgQzAuOTQyNTc0MjU3LDI0LjEzMTQ4NTEgMC43ODA5OTAwOTksMjMuOTA3NDg1MSAwLjY0MTU4NDE1OCwyMy42NjkyMjc3IEMwLjQ2NzMyNjczMywyMy4zNjk5ODAyIDAuMzMxMDg5MTA5LDIzLjA0OTE4ODEgMC4yMzQ0NTU0NDYsMjIuNzE2ODMxNyBDMC4xNjMxNjgzMTcsMjIuNDY5Mzg2MSAwLjExMjQ3NTI0OCwyMi4yMTU3NjI0IDAuMDgzOTYwMzk2LDIxLjk1OTc2MjQgQzAuMDYwMTk4MDE5OCwyMS43NDcwMDk5IDAuMDQ5MTA4OTEwOSwyMS41MzI5OTAxIDAuMDUyMjc3MjI3NywyMS4zMTg5NzAzIEwwLjA1MjI3NzIyNzcsMC4xNDA2NzMyNjcgTDEuMDYxMzg2MTQsMC4xNDA2NzMyNjcgTDEuMDYxMzg2MTQsMjEuMzI1MzA2OSBMMS4wNjEzODYxNCwyMS40MzA0OTUgQzEuMDYyOTcwMywyMS41NjkxMDg5IDEuMDcwODkxMDksMjEuNzA3NzIyOCAxLjA4NjczMjY3LDIxLjg0NTU0NDYgQzEuMTEyMDc5MjEsMjIuMDY3MzI2NyAxLjE1NjQzNTY0LDIyLjI4NzA0OTUgMS4yMjI5NzAzLDIyLjUwMDExODggQzEuMzAyMTc4MjIsMjIuNzUxMDQ5NSAxLjQwOTkwMDk5LDIyLjk5Mjc5MjEgMS41NDc3MjI3NywyMy4yMTcyNjczIEMxLjY1MjI3NzIzLDIzLjM4OTMwNjkgMS43NzQyNTc0MywyMy41NTEwNDk1IDEuOTEwNDk1MDUsMjMuNjk5ODAyIEMyLjAxODIxNzgyLDIzLjgxODYxMzkgMi4xMzU0NDU1NCwyMy45MjkxODgxIDIuMjYwNTk0MDYsMjQuMDMwNTc0MyBDMi4zNjUxNDg1MSwyNC4xMTYxMTg4IDIuNDc2MDM5NiwyNC4xOTUzMjY3IDIuNTkwMDk5MDEsMjQuMjY4MDM5NiBDMi42ODgzMTY4MywyNC4zMzA2MTM5IDIuNzg5NzAyOTcsMjQuMzg4NDM1NiAyLjg5MjY3MzI3LDI0LjQ0MTUwNSBDMy4zODUzNDY1MywyNC42OTMwNjkzIDMuOTI3MTI4NzEsMjQuODM3MDY5MyA0LjQ3NTI0NzUyLDI0Ljg5OTE2ODMgQzQuNzAwMTk4MDIsMjQuOTI0NjczMyA0LjkyNjczMjY3LDI0LjkzNTc2MjQgNS4xNTE2ODMxNywyNC45MzYzOTYgQzUuMTUxNjgzMTcsMjUuMjcyNzEyOSA1LjE1MDA5OTAxLDI1LjYwOTAyOTcgNS4xNTAwOTkwMSwyNS45NDU1MDUgTDUuMTUwMDk5MDEsMjUuOTQ1NTA1IFpcIlxuICAgICAgICAgICAgICBpZD1cIlNoYXBlXCI+PC9wYXRoPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8ZyBpZD1cIklcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNzUuOTU3ODYxLCAwLjAxNzQyNilcIiBmaWxsPVwiIzc4MzI3QVwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0wLjE0ODkxMDg5MSwyNS45MTYxOTggTDAuMTQ4OTEwODkxLDguNDkwNDU1NDUgTDEuMTM5MDA5OSw4LjQ5MDQ1NTQ1IEwxLjEzOTAwOTksMjUuOTE2MTk4IEwwLjE0ODkxMDg5MSwyNS45MTYxOTggTDAuMTQ4OTEwODkxLDI1LjkxNjE5OCBaIE0wLjE1MzY2MzM2NiwyLjQ3MDY1MzQ3IEwwLjE1MzY2MzM2NiwwLjE0MDY3MzI2NyBMMS4xMzU4NDE1OCwwLjE0MDY3MzI2NyBMMS4xMzU4NDE1OCwyLjQ3MDY1MzQ3IEwwLjE1MzY2MzM2NiwyLjQ3MDY1MzQ3IEwwLjE1MzY2MzM2NiwyLjQ3MDY1MzQ3IFpcIlxuICAgICAgICAgICAgICBpZD1cIlNoYXBlXCI+PC9wYXRoPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8ZyBpZD1cIkExXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDc5LjYwMTQyNiwgOC40MTM0NjUpXCIgZmlsbD1cIiM2RTREOUJcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNOC43OTUyNDc1MiwxNi41NDAzNTY0IEM4LjkxMDg5MTA5LDE2LjUzOTg4MTIgOS4wMjgxMTg4MSwxNi41Mzc2NjM0IDkuMTQzNzYyMzgsMTYuNTMyNTk0MSBDOS4zODkzMDY5MywxNi41MjE2NjM0IDkuNjMzMjY3MzMsMTYuNDk5MzI2NyA5Ljg3NzIyNzcyLDE2LjQ2NTI2NzMgQzEwLjU4NTM0NjUsMTYuMzY1OTQwNiAxMS4yNzkyMDc5LDE2LjE2NzYwNCAxMS45MzM0NjUzLDE1Ljg3NjU5NDEgQzEyLjY3MTY4MzIsMTUuNTQ4MDM5NiAxMy4zNTc2MjM4LDE1LjEwMjczMjcgMTMuOTU5NjA0LDE0LjU2MjY5MzEgQzE0LjYyODExODgsMTMuOTYxNjYzNCAxNS4xOTIwNzkyLDEzLjI0NDY3MzMgMTUuNjE2NjMzNywxMi40NTE4MDIgQzE1Ljk1ODgxMTksMTEuODExODAyIDE2LjIxMDY5MzEsMTEuMTIzNjQzNiAxNi4zNjExODgxLDEwLjQxMzMwNjkgQzE2LjU0MzM2NjMsOS41NDc1NjQzNiAxNi41NzY2MzM3LDguNjUwMjk3MDMgMTYuNDU5NDA1OSw3Ljc3MzMwNjkzIEMxNi4zNTQ4NTE1LDYuOTg1NTA0OTUgMTYuMTI2NzMyNyw2LjIxNTI4NzEzIDE1Ljc4NjEzODYsNS40OTcxODgxMiBDMTUuMzkzMjY3Myw0LjY2OTQ2NTM1IDE0Ljg1MTQ4NTEsMy45MTM4MjE3OCAxNC4xOTcyMjc3LDMuMjczODIxNzggQzEzLjUwNjUzNDcsMi42MDA1NTQ0NiAxMi42OTIyNzcyLDIuMDU3MDI5NyAxMS44MDUxNDg1LDEuNjgxNzQyNTcgQzExLjMzNzgyMTgsMS40ODQxOTgwMiAxMC44NDk5MDEsMS4zMzI5MTA4OSAxMC4zNTQwNTk0LDEuMjMxMzY2MzQgQzkuODU2NjMzNjYsMS4xMjk4MjE3OCA5LjM1MTI4NzEzLDEuMDc3NTQ0NTUgOC44NDQzNTY0NCwxLjA3NDM3NjI0IEM4LjMzNzQyNTc0LDEuMDcxMjA3OTIgNy44Mjg5MTA4OSwxLjExNjk5MDEgNy4zMjk5MDA5OSwxLjIxMjUxNDg1IEM2LjgzMDg5MTA5LDEuMzA4MTk4MDIgNi4zNDEzODYxNCwxLjQ1MzQ2NTM1IDUuODcyNDc1MjUsMS42NDU0NjUzNSBDNC45NzkwMDk5LDIuMDEwMjk3MDMgNC4xNTY4MzE2OCwyLjU0NDE1ODQyIDMuNDU5ODAxOTgsMy4yMDk1MDQ5NSBDMi43OTYwMzk2LDMuODQxMjY3MzMgMi4yNDYzMzY2Myw0LjU5MDQxNTg0IDEuODQzOTYwNCw1LjQxMjc1MjQ4IEMxLjQ5NTQ0NTU0LDYuMTI1NDY1MzUgMS4yNTc4MjE3OCw2Ljg5MTg4MTE5IDEuMTQzNzYyMzgsNy42NzY5OTAxIEMxLjAxODYxMzg2LDguNTM2NzEyODcgMS4wMzYwMzk2LDkuNDE4MTM4NjEgMS4yMDA3OTIwOCwxMC4yNzE2ODMyIEMxLjM0MzM2NjM0LDExLjAxNjcxMjkgMS41OTY4MzE2OCwxMS43Mzk1NjQ0IDEuOTUwMDk5MDEsMTIuNDEwNDU1NCBDMi4zNDEzODYxNCwxMy4xNTEyMDc5IDIuODUzMDY5MzEsMTMuODI3MTY4MyAzLjQ1OTgwMTk4LDE0LjQwNTA2OTMgQzQuMDc3NjIzNzYsMTQuOTk0NTM0NyA0Ljc5MzY2MzM3LDE1LjQ4MTM0NjUgNS41Njk5MDA5OSwxNS44Mzc5NDA2IEM2LjIxOTQwNTk0LDE2LjEzNjIzNzYgNi45MTAwOTkwMSwxNi4zNDMyODcxIDcuNjE2NjMzNjYsMTYuNDUxMTY4MyBDNy44NTkwMDk5LDE2LjQ4ODIzNzYgOC4xMDI5NzAzLDE2LjUxMzU4NDIgOC4zNDY5MzA2OSwxNi41Mjc1MjQ4IEM4LjQ2MjU3NDI2LDE2LjUzNDE3ODIgOC41NzgyMTc4MiwxNi41Mzc4MjE4IDguNjkzODYxMzksMTYuNTM5NzIyOCBDOC43Mjg3MTI4NywxNi41NDAwMzk2IDguNzYwMzk2MDQsMTYuNTQwMTk4IDguNzk1MjQ3NTIsMTYuNTQwMzU2NCBMOC43OTUyNDc1MiwxNi41NDAzNTY0IFogTTE2Ljg1Mzg2MTQsMTIuMTk5NjA0IEMxNi43Njk5MDEsMTIuMzk4ODkxMSAxNi42NzgwMTk4LDEyLjU5NTAwOTkgMTYuNTc5ODAyLDEyLjc4NzQ4NTEgQzE2LjEyNTE0ODUsMTMuNjc2ODMxNyAxNS41MTUyNDc1LDE0LjQ4NjE3ODIgMTQuNzg4MTE4OCwxNS4xNzE0ODUxIEMxNC4wNzIwNzkyLDE1Ljg0NjAxOTggMTMuMjQzNTY0NCwxNi4zOTg4OTExIDEyLjM0Mzc2MjQsMTYuNzk4NzMyNyBDMTEuNjAzOTYwNCwxNy4xMjc3NjI0IDEwLjgxODIxNzgsMTcuMzUyMzk2IDEwLjAxNjYzMzcsMTcuNDY0NzEyOSBDOS43NDI1NzQyNiwxNy41MDMwNDk1IDkuNDY1MzQ2NTMsMTcuNTI4Mzk2IDkuMTg4MTE4ODEsMTcuNTQwNzUyNSBDOS4wNTY2MzM2NiwxNy41NDY2MTM5IDguOTI1MTQ4NTEsMTcuNTQ4OTkwMSA4Ljc5NTI0NzUyLDE3LjU0OTQ2NTMgQzguNjYzNzYyMzgsMTcuNTQ4OTkwMSA4LjUzMjI3NzIzLDE3LjU0NjYxMzkgOC40MDA3OTIwOCwxNy41NDA3NTI1IEM4LjEyMzU2NDM2LDE3LjUyODM5NiA3Ljg0NzkyMDc5LDE3LjUwMzA0OTUgNy41NzIyNzcyMywxNy40NjQ3MTI5IEM2Ljc3MDY5MzA3LDE3LjM1MjM5NiA1Ljk4NDk1MDUsMTcuMTI3NzYyNCA1LjI0NTE0ODUxLDE2Ljc5ODczMjcgQzQuMzMxMDg5MTEsMTYuMzkxNzYyNCAzLjQ4NjczMjY3LDE1LjgyNjIxNzggMi43NjI3NzIyOCwxNS4xMzUzNjYzIEMyLjA1MzA2OTMxLDE0LjQ1Nzk4MDIgMS40NTc0MjU3NCwxMy42NjEzMDY5IDEuMDA5MTA4OTEsMTIuNzg3NDg1MSBDMC42MzM2NjMzNjYsMTIuMDU1MTI4NyAwLjM2NDM1NjQzNiwxMS4yNjk3MDMgMC4yMDkxMDg5MTEsMTAuNDYxNjIzOCBDMC4wMzE2ODMxNjgzLDkuNTMzNjIzNzYgMC4wMDQ3NTI0NzUyNSw4LjU3NjMxNjgzIDAuMTI5OTAwOTksNy42Mzk3NjIzOCBDMC4yNDg3MTI4NzEsNi43NDg2NzMyNyAwLjUwNjkzMDY5Myw1Ljg3NzA2OTMxIDAuODkxODgxMTg4LDUuMDY0NzEyODcgQzEuMzQzMzY2MzQsNC4xMTM0MjU3NCAxLjk2NzUyNDc1LDMuMjQ2NDE1ODQgMi43MjQ3NTI0OCwyLjUxNTQ4NTE1IEMzLjUwODkxMDg5LDEuNzU4NzMyNjcgNC40MzQwNTk0MSwxLjE1MDA5OTAxIDUuNDQsMC43MzE3MjI3NzIgQzUuOTg4MTE4ODEsMC41MDQyMzc2MjQgNi41NTg0MTU4NCwwLjMzMjk5MDA5OSA3LjEzOTgwMTk4LDAuMjIxNDY1MzQ3IEM3LjY4NDc1MjQ4LDAuMTE3MDY5MzA3IDguMjM5MjA3OTIsMC4wNjUxMDg5MTA5IDguNzk1MjQ3NTIsMC4wNjUxMDg5MTA5IEM5LjM0OTcwMjk3LDAuMDY1MTA4OTEwOSA5LjkwNDE1ODQyLDAuMTE3MDY5MzA3IDEwLjQ0OTEwODksMC4yMjE0NjUzNDcgQzExLjAzMDQ5NSwwLjMzMjk5MDA5OSAxMS42MDA3OTIxLDAuNTA0MjM3NjI0IDEyLjE0ODkxMDksMC43MzE3MjI3NzIgQzEzLjE1NDg1MTUsMS4xNTAwOTkwMSAxNC4wOCwxLjc1ODczMjY3IDE0Ljg2NDE1ODQsMi41MTUzMjY3MyBDMTUuNjA4NzEyOSwzLjIzMzkwMDk5IDE2LjIyNDk1MDUsNC4wODQ0MzU2NCAxNi42NzQ4NTE1LDUuMDE2ODcxMjkgQzE2LjczODIxNzgsNS4xNDgwMzk2IDE2Ljc5NjgzMTcsNS4yODA3OTIwOCAxNi44NTM4NjE0LDUuNDE0OTcwMyBMMTYuODUzODYxNCwwLjA5NDQxNTg0MTYgTDE3Ljg0Mzk2MDQsMC4wOTQ0MTU4NDE2IEwxNy44NDM5NjA0LDE3LjUyMDE1ODQgQzE3Ljg0MjM3NjIsMTcuNTM5MzI2NyAxNi44NTM4NjE0LDE3LjUyMDE1ODQgMTYuODUzODYxNCwxNy41MjAxNTg0IEwxNi44NTM4NjE0LDEyLjE5OTYwNCBMMTYuODUzODYxNCwxMi4xOTk2MDQgWlwiXG4gICAgICAgICAgICAgIGlkPVwiU2hhcGVcIj48L3BhdGg+XG4gICAgICAgICAgPC9nPlxuICAgICAgICA8L2c+XG4gICAgICA8L2c+XG4gICAgPC9nPlxuICA8L3N2Zz5cbjwvdGVtcGxhdGU+XG4iLCI8dGVtcGxhdGUgYmluZGFibGU9XCJjb250cm9sbGVyXCI+XG4gIDxyZXF1aXJlIGZyb209XCIuL2NvbnRyb2xsZXItdmlldy5jc3NcIj48L3JlcXVpcmU+XG5cbiAgPGRpdiBjbGFzcz1cImNhdGVnb3J5XCIgaWYuYmluZD1cImNvbnRyb2xsZXIuYmluZGFibGVzLmxlbmd0aFwiPlxuICAgIDxoNCBjbGFzcz1cImNhdGVnb3J5LW5hbWVcIj5CaW5kYWJsZXM8L2g0PlxuICAgIDx1bCBjbGFzcz1cInByb3BlcnRpZXNcIj5cbiAgICAgIDxsaSByZXBlYXQuZm9yPVwiYmluZGFibGUgb2YgY29udHJvbGxlci5iaW5kYWJsZXNcIj5cbiAgICAgICAgPHByb3BlcnR5LXZpZXdcbiAgICAgICAgICBjb250cm9sbGVyLmJpbmQ9XCJjb250cm9sbGVyXCJcbiAgICAgICAgICBwcm9wZXJ0eS5iaW5kPVwiYmluZGFibGVcIlxuICAgICAgICA+PC9wcm9wZXJ0eS12aWV3PlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnlcIiBpZi5iaW5kPVwiY29udHJvbGxlci5wcm9wZXJ0aWVzLmxlbmd0aFwiPlxuICAgIDxoNCBjbGFzcz1cImNhdGVnb3J5LW5hbWVcIj5Qcm9wZXJ0aWVzPC9oND5cbiAgICA8dWwgY2xhc3M9XCJwcm9wZXJ0aWVzXCI+XG4gICAgICA8bGkgcmVwZWF0LmZvcj1cInByb3BlcnR5IG9mIGNvbnRyb2xsZXIucHJvcGVydGllc1wiPlxuICAgICAgICA8cHJvcGVydHktdmlld1xuICAgICAgICAgIGNvbnRyb2xsZXIuYmluZD1cImNvbnRyb2xsZXJcIlxuICAgICAgICAgIHByb3BlcnR5LmJpbmQ9XCJwcm9wZXJ0eVwiXG4gICAgICAgID48L3Byb3BlcnR5LXZpZXc+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbiIsIjxpbXBvcnQgZnJvbT1cIi4vZGVidWctZ3JvdXAuY3NzXCI+PC9pbXBvcnQ+XG48c2VjdGlvbj5cbiAgPGgyIGNsYXNzPVwiaGVhZGVyXCI+JHtoZWFkaW5nfTwvaDI+XG4gIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgPGF1LXNsb3Q+PC9hdS1zbG90PlxuICA8L2Rpdj5cbjwvc2VjdGlvbj5cbiIsIjxyZXF1aXJlIGZyb209XCIuL3Byb3BlcnR5LXZpZXcuY3NzXCI+PC9yZXF1aXJlPlxuXG48c3BhbiBjbGFzcz1cInByb3BlcnR5LWxpbmVcIj5cbiAgPHNwYW5cbiAgICBjc3M9XCJvcGFjaXR5OiAke3Byb3BlcnR5LmNhbkV4cGFuZCA/IDEgOiAwfVwiXG4gICAgY2xhc3M9XCJhcnJvd1wiXG4gICAgY2xpY2sudHJpZ2dlcj1cImRlYnVnSG9zdC50b2dnbGVEZWJ1Z1ZhbHVlRXhwYW5zaW9uKHByb3BlcnR5KVwiXG4gID5cbiAgICA8c3BhbiBpZi5iaW5kPVwicHJvcGVydHkuaXNFeHBhbmRlZFwiIGNsYXNzPVwiZG93blwiPuKWvDwvc3Bhbj5cbiAgICA8c3BhbiBpZi5iaW5kPVwiIXByb3BlcnR5LmlzRXhwYW5kZWRcIiBjbGFzcz1cInJpZ2h0XCI+4pa2PC9zcGFuPlxuICA8L3NwYW4+XG4gIDxzcGFuIGNsYXNzPVwicHJvcGVydHktbmFtZVwiPiR7cHJvcGVydHkubmFtZX08L3NwYW5cbiAgPjxzcGFuIGNsYXNzPVwidG9rZW4tY29sb25cIj46PC9zcGFuPiZuYnNwO1xuXG4gIDxzcGFuIGNsYXNzPVwidmFsdWUtY29udGFpbmVyXCI+XG4gICAgPHNwYW5cbiAgICAgIGlmLmJpbmQ9XCJwcm9wZXJ0eS50eXBlID09PSAnc3RyaW5nJyAmJiAhcHJvcGVydHkuaXNFZGl0aW5nXCJcbiAgICAgIGNsYXNzPVwicHJvcGVydHktdmFsdWUgc3RyaW5nXCJcbiAgICAgID5cIjwvc3BhblxuICAgID48c3BhblxuICAgICAgaWYuYmluZD1cIiFwcm9wZXJ0eS5pc0VkaXRpbmdcIlxuICAgICAgY2xhc3M9XCJwcm9wZXJ0eS12YWx1ZSAke3Byb3BlcnR5LnR5cGV9XCJcbiAgICAgIGNsaWNrLnRyaWdnZXI9XCJiZWdpbkVkaXRpbmcoKVwiXG4gICAgICA+JHtwcm9wZXJ0eS52YWx1ZX08L3NwYW5cbiAgICA+PHNwYW5cbiAgICAgIGlmLmJpbmQ9XCJwcm9wZXJ0eS50eXBlID09PSAnc3RyaW5nJyAmJiAhcHJvcGVydHkuaXNFZGl0aW5nXCJcbiAgICAgIGNsYXNzPVwicHJvcGVydHktdmFsdWUgc3RyaW5nXCJcbiAgICAgID5cIjwvc3BhblxuICAgID5cblxuICAgIDwhLS0gPHNlbGVjdFxuICAgICAgaWYuYmluZD1cInByb3BlcnR5LmlzRWRpdGluZyAmJiAgcHJvcGVydHkudHlwZSA9PT0gJ2Jvb2xlYW4nXCJcbiAgICAgIGNsYXNzPVwicHJvcGVydHktZWRpdG9yXCJcbiAgICAgIHZhbHVlLmJpbmQ9XCJmYWxzZVwiXG4gICAgPlxuICAgICAgPG9wdGlvbiBtb2RlbC5iaW5kPVwidHJ1ZVwiPlRydWU8L29wdGlvbj5cbiAgICAgIDxvcHRpb24gbW9kZWwuYmluZD1cImZhbHNlXCI+RmFsc2U8L29wdGlvbj5cbiAgICA8L3NlbGVjdD4gLS0+XG5cbiAgICA8aW5wdXRcbiAgICAgIGlmLmJpbmQ9XCJwcm9wZXJ0eS5pc0VkaXRpbmdcIlxuICAgICAgY2xhc3M9XCJwcm9wZXJ0eS1lZGl0b3JcIlxuICAgICAgcmVmPVwiZWRpdG9yXCJcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIHZhbHVlLmJpbmQ9XCJwcm9wZXJ0eS52YWx1ZVwiXG4gICAgICBrZXl1cC50cmlnZ2VyPVwib25LZXlEb3duKCRldmVudClcIlxuICAgICAgYmx1ci50cmlnZ2VyPVwiZW5kRWRpdGluZygpXCJcbiAgICAvPlxuICA8L3NwYW4+XG48L3NwYW4+XG5cbjx1bCBpZi5iaW5kPVwicHJvcGVydHkuaXNFeHBhbmRlZCAmJiBwcm9wZXJ0eS5leHBhbmRlZFZhbHVlXCIgY2xhc3M9XCJwcm9wZXJ0aWVzXCI+XG4gIDxkaXZcbiAgICBpZi5iaW5kPVwiIXByb3BlcnR5LmV4cGFuZGVkVmFsdWUucHJvcGVydGllcy5sZW5ndGhcIlxuICAgIGNsYXNzPVwibm8tcHJvcGVydGllc1wiXG4gID5cbiAgICBPYmplY3QgaGFzIG5vIHByb3BlcnRpZXMuXG4gIDwvZGl2PlxuICA8bGkgcmVwZWF0LmZvcj1cInAgb2YgcHJvcGVydHkuZXhwYW5kZWRWYWx1ZS5wcm9wZXJ0aWVzXCI+XG4gICAgPHByb3BlcnR5LXZpZXcgcHJvcGVydHkuYmluZD1cInBcIj48L3Byb3BlcnR5LXZpZXc+XG4gIDwvbGk+XG48L3VsPlxuIiwiaW1wb3J0IHsgREksIFJlZ2lzdHJhdGlvbiB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBTdGFuZGFyZENvbmZpZ3VyYXRpb24sIEF1cmVsaWEgYXMgJEF1cmVsaWEsIElQbGF0Zm9ybSwgQ3VzdG9tRWxlbWVudCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG5pbXBvcnQgeyBCcm93c2VyUGxhdGZvcm0gfSBmcm9tICdAYXVyZWxpYS9wbGF0Zm9ybS1icm93c2VyJztcbmV4cG9ydCBjb25zdCBQTEFURk9STSA9IEJyb3dzZXJQbGF0Zm9ybS5nZXRPckNyZWF0ZShnbG9iYWxUaGlzKTtcbmV4cG9ydCB7IElQbGF0Zm9ybSB9O1xuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBESS5jcmVhdGVDb250YWluZXIoKVxuICAgICAgICAucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKElQbGF0Zm9ybSwgUExBVEZPUk0pLCBTdGFuZGFyZENvbmZpZ3VyYXRpb24pO1xufVxuZXhwb3J0IGNsYXNzIEF1cmVsaWEgZXh0ZW5kcyAkQXVyZWxpYSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKCkpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyKTtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXJlbGlhKCkuc3RhcnQocm9vdCk7XG4gICAgfVxuICAgIHN0YXRpYyBhcHAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXVyZWxpYSgpLmFwcChjb25maWcpO1xuICAgIH1cbiAgICBzdGF0aWMgZW5oYW5jZShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXJlbGlhKCkuZW5oYW5jZShjb25maWcpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVnaXN0ZXIoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXVyZWxpYSgpLnJlZ2lzdGVyKC4uLnBhcmFtcyk7XG4gICAgfVxuICAgIGFwcChjb25maWcpIHtcbiAgICAgICAgaWYgKEN1c3RvbUVsZW1lbnQuaXNUeXBlKGNvbmZpZykpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VzdG9tIGVsZW1lbnQgZWxlbWVudCBuYW1lXG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKGNvbmZpZyk7XG4gICAgICAgICAgICBsZXQgaG9zdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGVmaW5pdGlvbi5uYW1lKTtcbiAgICAgICAgICAgIGlmIChob3N0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBubyB0YXJnZXQgaXMgZm91bmQsIGRlZmF1bHQgdG8gYm9keS5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiB1c2VyIGZvcmdvdCB0byB3cml0ZSA8bXktYXBwPjwvbXktYXBwPiBpbiBodG1sLlxuICAgICAgICAgICAgICAgIGhvc3QgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFwcCh7XG4gICAgICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbmZpZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmFwcChjb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEF1cmVsaWE7XG5leHBvcnQgeyBcbi8vIFJldHJ5Q29uZmlndXJhdGlvbixcbi8vIFJldHJ5YWJsZVJlcXVlc3QsXG4vLyBWYWxpZEludGVyY2VwdG9yTWV0aG9kTmFtZSxcbmpzb24sIFxuLy8gcmV0cnlTdHJhdGVneSxcbi8vIFJldHJ5SW50ZXJjZXB0b3IsXG5IdHRwQ2xpZW50Q29uZmlndXJhdGlvbiwgSHR0cENsaWVudCwgSUh0dHBDbGllbnQsIH0gZnJvbSAnQGF1cmVsaWEvZmV0Y2gtY2xpZW50JztcbmV4cG9ydCB7IGFsbCwgREksIElDb250YWluZXIsIFxuLy8gSURlZmF1bHRhYmxlSW50ZXJmYWNlU3ltYm9sLFxuLy8gSUZhY3RvcnksXG5pbmplY3QsIElTZXJ2aWNlTG9jYXRvciwgbGF6eSwgb3B0aW9uYWwsIFxuLy8gUmVnaXN0ZXJTZWxmLFxuUmVnaXN0cmF0aW9uLCBcbi8vIFJlc29sdmVDYWxsYmFjayxcbnNpbmdsZXRvbiwgdHJhbnNpZW50LCBcbi8vIEluamVjdGFibGUsXG4vLyBJbnRlcmZhY2VTeW1ib2wsXG5JbnN0YW5jZVByb3ZpZGVyLCBcbi8vIElQZXJmb3JtYW5jZSxcbi8vIElUaW1lckhhbmRsZXIsXG4vLyBJV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZSxcbi8vIEtub3duS2V5cyxcbi8vIE5vSW5mZXIsXG4vLyBPbWl0LFxuLy8gT3B0aW9uYWxLbm93bktleXMsXG4vLyBPcHRpb25hbFZhbHVlc09mLFxuLy8gT3ZlcndyaXRlLFxuLy8gUGFyYW0wLFxuLy8gUGFyYW0xLFxuLy8gUGFyYW0yLFxuLy8gUGFyYW0zLFxuLy8gUGljazIsXG4vLyBQaWNrMyxcbi8vIFByaW1pdGl2ZSxcbi8vIFB1YmxpYyxcbi8vIFB1cmlmeSxcbi8vIFJlcXVpcmVkS25vd25LZXlzLFxuLy8gUmVxdWlyZWRWYWx1ZXNPZixcbi8vIFN0cmljdFByaW1pdGl2ZSxcbi8vIFVud3JhcCxcbi8vIFZhbHVlc09mLFxuLy8gV3JpdGFibGUsXG4vLyBJZkVxdWFscyxcbi8vIFJlYWRvbmx5S2V5cyxcbi8vIFdyaXRhYmxlS2V5cyxcbi8vIG1ldGFkYXRhLFxuTWV0YWRhdGEsIFxuLy8gSUNvbnNvbGVMaWtlLFxuQ29sb3JPcHRpb25zLCBcbi8vIElMb2dDb25maWcsXG4vLyBJTG9nRXZlbnQsXG4vLyBJTG9nRXZlbnRGYWN0b3J5LFxuLy8gSVNpbmssXG5JTG9nZ2VyLCBcbi8vIExvZ0NvbmZpZyxcbi8vIERlZmF1bHRMb2dFdmVudCxcbi8vIERlZmF1bHRMb2dFdmVudEZhY3RvcnksXG4vLyBEZWZhdWx0TG9nZ2VyLFxuLy8gQ29uc29sZVNpbmssXG5Mb2dnZXJDb25maWd1cmF0aW9uLCBcbi8vIHJlbGF0aXZlVG9GaWxlLFxuLy8gam9pbixcbi8vIHBhcnNlUXVlcnlTdHJpbmcsXG4vLyBJUXVlcnlQYXJhbXMsXG5lbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgbm9vcCwgXG4vLyBJVHJhY2VJbmZvLFxuLy8gSVRyYWNlV3JpdGVyLFxuLy8gSUxpdmVMb2dnaW5nT3B0aW9ucyxcbkxvZ0xldmVsLCBcbi8vIElSZXNvdXJjZURlZmluaXRpb24sXG4vLyBJUmVzb3VyY2VEZXNjcmlwdGlvbnMsXG4vLyBJUmVzb3VyY2VLaW5kLFxuLy8gSVJlc291cmNlVHlwZSxcbi8vIFJlc291cmNlRGVzY3JpcHRpb24sXG4vLyBSZXNvdXJjZVBhcnREZXNjcmlwdGlvbixcbi8vIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0LFxuLy8gZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQsXG4vLyBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCxcbkV2ZW50QWdncmVnYXRvciwgSUV2ZW50QWdncmVnYXRvciwgaXNBcnJheUluZGV4LCBjYW1lbENhc2UsIGtlYmFiQ2FzZSwgcGFzY2FsQ2FzZSwgdG9BcnJheSwgXG4vLyBuZXh0SWQsXG4vLyByZXNldElkLFxuLy8gY29tcGFyZU51bWJlcixcbi8vIG1lcmdlRGlzdGluY3QsXG4vLyBpc051bWJlck9yQmlnSW50LFxuLy8gaXNTdHJpbmdPckRhdGUsXG5ib3VuZCwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IHsgXG4vLyBOYXYsXG5OYXZSb3V0ZSwgXG4vLyBJU3RvcmVkTmF2aWdhdG9yRW50cnksXG4vLyBJTmF2aWdhdG9yRW50cnksXG4vLyBJTmF2aWdhdG9yT3B0aW9ucyxcbi8vIElOYXZpZ2F0b3JGbGFncyxcbi8vIElOYXZpZ2F0b3JTdGF0ZSxcbi8vIElOYXZpZ2F0b3JTdG9yZSxcbi8vIElOYXZpZ2F0b3JWaWV3ZXIsXG4vLyBJTmF2aWdhdG9yVmlld2VyRXZlbnQsXG4vLyBOYXZpZ2F0b3IsXG4vLyBRdWV1ZUl0ZW0sXG4vLyBJUXVldWVPcHRpb25zLFxuLy8gUXVldWUsXG4vLyBSb3V0ZUhhbmRsZXIsXG4vLyBDb25maWd1cmFibGVSb3V0ZSxcbi8vIEhhbmRsZXJFbnRyeSxcbi8vIFJvdXRlR2VuZXJhdG9yLFxuLy8gVHlwZXNSZWNvcmQsXG4vLyBSZWNvZ25pemVSZXN1bHQsXG4vLyBSZWNvZ25pemVSZXN1bHRzLFxuLy8gQ2hhclNwZWMsXG4vLyAvLyBTdGF0ZSBhcyBSb3V0ZXJTdGF0ZSwgLy8gZHVwbGljYXRlZCBpbiBAYXVyZWxpYS9ydW50aW1lXG4vLyBTdGF0aWNTZWdtZW50LFxuLy8gRHluYW1pY1NlZ21lbnQsXG4vLyBTdGFyU2VnbWVudCxcbi8vIEVwc2lsb25TZWdtZW50LFxuLy8gU2VnbWVudCxcbi8vIFJvdXRlUmVjb2duaXplcixcblJvdXRlck9wdGlvbnMsIElSb3V0ZXIsIFJvdXRlciwgXG4vLyBJVmlld3BvcnRPcHRpb25zLFxuLy8gVmlld3BvcnQsXG4vLyBDb250ZW50U3RhdHVzLFxuLy8gVmlld3BvcnRDb250ZW50LFxuVmlld3BvcnRJbnN0cnVjdGlvbiwgUm91dGVyQ29uZmlndXJhdGlvbiwgUm91dGVyUmVnaXN0cmF0aW9uLCB9IGZyb20gJ0BhdXJlbGlhL3JvdXRlcic7XG5leHBvcnQgeyBcbi8vIENhbGxGdW5jdGlvbkV4cHJlc3Npb24sXG4vLyBjb25uZWN0cyxcbi8vIG9ic2VydmVzLFxuLy8gY2FsbHNGdW5jdGlvbixcbi8vIGhhc0FuY2VzdG9yLFxuLy8gaXNBc3NpZ25hYmxlLFxuLy8gaXNMZWZ0SGFuZFNpZGUsXG4vLyBpc1ByaW1hcnksXG4vLyBpc1Jlc291cmNlLFxuLy8gaGFzQmluZCxcbi8vIGhhc1VuYmluZCxcbi8vIGlzTGl0ZXJhbCxcbi8vIGFyZVB1cmVMaXRlcmFscyxcbi8vIGlzUHVyZUxpdGVyYWwsXG4vLyBDdXN0b21FeHByZXNzaW9uLFxuLy8gQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbixcbi8vIFZhbHVlQ29udmVydGVyRXhwcmVzc2lvbixcbi8vIEFzc2lnbkV4cHJlc3Npb24sXG4vLyBDb25kaXRpb25hbEV4cHJlc3Npb24sXG4vLyBBY2Nlc3NUaGlzRXhwcmVzc2lvbixcbi8vIEFjY2Vzc1Njb3BlRXhwcmVzc2lvbixcbi8vIEFjY2Vzc01lbWJlckV4cHJlc3Npb24sXG4vLyBBY2Nlc3NLZXllZEV4cHJlc3Npb24sXG4vLyBDYWxsU2NvcGVFeHByZXNzaW9uLFxuLy8gQ2FsbE1lbWJlckV4cHJlc3Npb24sXG4vLyBCaW5hcnlFeHByZXNzaW9uLFxuLy8gVW5hcnlFeHByZXNzaW9uLFxuLy8gUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24sXG4vLyBIdG1sTGl0ZXJhbEV4cHJlc3Npb24sXG4vLyBBcnJheUxpdGVyYWxFeHByZXNzaW9uLFxuLy8gT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24sXG4vLyBUZW1wbGF0ZUV4cHJlc3Npb24sXG4vLyBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24sXG4vLyBBcnJheUJpbmRpbmdQYXR0ZXJuLFxuLy8gT2JqZWN0QmluZGluZ1BhdHRlcm4sXG4vLyBCaW5kaW5nSWRlbnRpZmllcixcbi8vIEZvck9mU3RhdGVtZW50LFxuLy8gSW50ZXJwb2xhdGlvbixcbi8vIEFueUJpbmRpbmdFeHByZXNzaW9uLFxuLy8gSXNQcmltYXJ5LFxuLy8gSXNMaXRlcmFsLFxuLy8gSXNMZWZ0SGFuZFNpZGUsXG4vLyBJc1VuYXJ5LFxuLy8gSXNCaW5hcnksXG4vLyBJc0NvbmRpdGlvbmFsLFxuLy8gSXNBc3NpZ24sXG4vLyBJc1ZhbHVlQ29udmVydGVyLFxuLy8gSXNCaW5kaW5nQmVoYXZpb3IsXG4vLyBJc0Fzc2lnbmFibGUsXG4vLyBJc0V4cHJlc3Npb24sXG4vLyBJc0V4cHJlc3Npb25PclN0YXRlbWVudCxcbi8vIENvbm5lY3RzLFxuLy8gT2JzZXJ2ZXMsXG4vLyBDYWxsc0Z1bmN0aW9uLFxuLy8gSXNSZXNvdXJjZSxcbi8vIEhhc0JpbmQsXG4vLyBIYXNVbmJpbmQsXG4vLyBIYXNBbmNlc3Rvcixcbi8vIElWaXNpdG9yLFxuLy8gSUV4cHJlc3Npb24sXG4vLyBJQWNjZXNzS2V5ZWRFeHByZXNzaW9uLFxuLy8gSUFjY2Vzc01lbWJlckV4cHJlc3Npb24sXG4vLyBJQWNjZXNzU2NvcGVFeHByZXNzaW9uLFxuLy8gSUFjY2Vzc1RoaXNFeHByZXNzaW9uLFxuLy8gSUFycmF5QmluZGluZ1BhdHRlcm4sXG4vLyBJQXJyYXlMaXRlcmFsRXhwcmVzc2lvbixcbi8vIElBc3NpZ25FeHByZXNzaW9uLFxuLy8gSUJpbmFyeUV4cHJlc3Npb24sXG4vLyBJQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbixcbi8vIElCaW5kaW5nSWRlbnRpZmllcixcbi8vIElDYWxsRnVuY3Rpb25FeHByZXNzaW9uLFxuLy8gSUNhbGxNZW1iZXJFeHByZXNzaW9uLFxuLy8gSUNhbGxTY29wZUV4cHJlc3Npb24sXG4vLyBJQ29uZGl0aW9uYWxFeHByZXNzaW9uLFxuLy8gRm9yT2ZTdGF0ZW1lbnQsXG4vLyBJSHRtbExpdGVyYWxFeHByZXNzaW9uLFxuLy8gSW50ZXJwb2xhdGlvbixcbi8vIElPYmplY3RCaW5kaW5nUGF0dGVybixcbi8vIElPYmplY3RMaXRlcmFsRXhwcmVzc2lvbixcbi8vIElQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbixcbi8vIElUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24sXG4vLyBJVGVtcGxhdGVFeHByZXNzaW9uLFxuLy8gSVVuYXJ5RXhwcmVzc2lvbixcbi8vIElWYWx1ZUNvbnZlcnRlckV4cHJlc3Npb24sXG4vLyBCaW5hcnlPcGVyYXRvcixcbi8vIEJpbmRpbmdJZGVudGlmaWVyT3JQYXR0ZXJuLFxuLy8gVW5hcnlPcGVyYXRvcixcbi8vIFByb3BlcnR5QmluZGluZyxcbi8vIENhbGxCaW5kaW5nLFxuLy8gSVBhcnRpYWxDb25uZWN0YWJsZUJpbmRpbmcsXG4vLyBJQ29ubmVjdGFibGVCaW5kaW5nLFxuLy8gY29ubmVjdGFibGUsXG4vLyBJRXhwcmVzc2lvblBhcnNlcixcbi8vIEJpbmRpbmdUeXBlLFxuLy8gTXVsdGlJbnRlcnBvbGF0aW9uQmluZGluZyxcbi8vIEludGVycG9sYXRpb25CaW5kaW5nLFxuLy8gTGV0QmluZGluZyxcbi8vIFJlZkJpbmRpbmcsXG4vLyBBcnJheU9ic2VydmVyLFxuLy8gZW5hYmxlQXJyYXlPYnNlcnZhdGlvbixcbi8vIGRpc2FibGVBcnJheU9ic2VydmF0aW9uLFxuLy8gYXBwbHlNdXRhdGlvbnNUb0luZGljZXMsXG4vLyBzeW5jaHJvbml6ZUluZGljZXMsXG4vLyBNYXBPYnNlcnZlcixcbi8vIGVuYWJsZU1hcE9ic2VydmF0aW9uLFxuLy8gZGlzYWJsZU1hcE9ic2VydmF0aW9uLFxuLy8gU2V0T2JzZXJ2ZXIsXG4vLyBlbmFibGVTZXRPYnNlcnZhdGlvbixcbi8vIGRpc2FibGVTZXRPYnNlcnZhdGlvbixcbi8vIEJpbmRpbmdDb250ZXh0LFxuLy8gT3ZlcnJpZGVDb250ZXh0LFxuLy8gQ29sbGVjdGlvbkxlbmd0aE9ic2VydmVyLFxuLy8gQ29sbGVjdGlvblNpemVPYnNlcnZlcixcbi8vIElEaXJ0eUNoZWNrZXIsXG4vLyBEaXJ0eUNoZWNrUHJvcGVydHksXG4vLyBEaXJ0eUNoZWNrU2V0dGluZ3MsXG5Db21wdXRlZE9ic2VydmVyLCBDb21wdXRlZFdhdGNoZXIsIEV4cHJlc3Npb25XYXRjaGVyLCBXYXRjaCwgd2F0Y2gsIFxuLy8gSU9iamVjdE9ic2VydmF0aW9uQWRhcHRlcixcbklPYnNlcnZlckxvY2F0b3IsIFxuLy8gSVRhcmdldE9ic2VydmVyTG9jYXRvcixcbi8vIElUYXJnZXRBY2Nlc3NvckxvY2F0b3IsXG4vLyBnZXRDb2xsZWN0aW9uT2JzZXJ2ZXIsXG4vLyBPYnNlcnZlckxvY2F0b3IsXG4vLyBQcmltaXRpdmVPYnNlcnZlcixcbi8vIFByb3BlcnR5QWNjZXNzb3IsXG4vLyBCaW5kYWJsZU9ic2VydmVyLFxuLy8gU2V0dGVyT2JzZXJ2ZXIsXG5JU2lnbmFsZXIsIHN1YnNjcmliZXJDb2xsZWN0aW9uLCBiaW5kaW5nQmVoYXZpb3IsIEJpbmRpbmdCZWhhdmlvciwgXG4vLyBQYXJ0aWFsQmluZGluZ0JlaGF2aW9yRGVmaW5pdGlvbixcbi8vIEJpbmRpbmdCZWhhdmlvcktpbmQsXG4vLyBCaW5kaW5nQmVoYXZpb3JEZWNvcmF0b3IsXG4vLyBCaW5kaW5nQmVoYXZpb3JJbnN0YW5jZSxcbi8vIEJpbmRpbmdCZWhhdmlvclR5cGUsXG4vLyBCaW5kaW5nTW9kZUJlaGF2aW9yLFxuLy8gT25lVGltZUJpbmRpbmdCZWhhdmlvcixcbi8vIFRvVmlld0JpbmRpbmdCZWhhdmlvcixcbi8vIEZyb21WaWV3QmluZGluZ0JlaGF2aW9yLFxuLy8gVHdvV2F5QmluZGluZ0JlaGF2aW9yLFxuLy8gRGVib3VuY2VCaW5kaW5nQmVoYXZpb3IsXG4vLyBTaWduYWxhYmxlQmluZGluZyxcbi8vIFNpZ25hbEJpbmRpbmdCZWhhdmlvcixcbi8vIFRocm90dGxlQmluZGluZ0JlaGF2aW9yLFxuY3VzdG9tQXR0cmlidXRlLCBcbi8vIEN1c3RvbUF0dHJpYnV0ZURlY29yYXRvcixcbkN1c3RvbUF0dHJpYnV0ZSwgXG4vLyBDdXN0b21BdHRyaWJ1dGVEZWZpbml0aW9uXG4vLyBDdXN0b21BdHRyaWJ1dGVLaW5kLFxuLy8gQ3VzdG9tQXR0cmlidXRlVHlwZSxcbi8vIFBhcnRpYWxDdXN0b21BdHRyaWJ1dGVEZWZpbml0aW9uLFxudGVtcGxhdGVDb250cm9sbGVyLCBcbi8vIEZyZXF1ZW50TXV0YXRpb25zLFxuLy8gSW5mcmVxdWVudE11dGF0aW9ucyxcbi8vIE9ic2VydmVTaGFsbG93LFxuLy8gSWYsXG4vLyBFbHNlLFxuLy8gUmVwZWF0LFxuLy8gUmVwbGFjZWFibGUsXG4vLyBXaXRoLFxuY29udGFpbmVybGVzcywgY3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudCwgXG4vLyBDdXN0b21FbGVtZW50RGVjb3JhdG9yLFxuLy8gQ3VzdG9tRWxlbWVudEtpbmQsXG4vLyBDdXN0b21FbGVtZW50VHlwZSxcbi8vIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLFxuLy8gUGFydGlhbEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLFxuLy8gSUVsZW1lbnRQcm9qZWN0b3IsXG4vLyBJUHJvamVjdG9yTG9jYXRvcixcbnVzZVNoYWRvd0RPTSwgVmFsdWVDb252ZXJ0ZXIsIFxuLy8gVmFsdWVDb252ZXJ0ZXJUeXBlLFxudmFsdWVDb252ZXJ0ZXIsIFxuLy8gSVNhbml0aXplcixcbi8vIFNhbml0aXplVmFsdWVDb252ZXJ0ZXIsXG4vLyBWaWV3VmFsdWVDb252ZXJ0ZXIsXG4vLyBDbG9jayxcbi8vIElDbG9jayxcbi8vIElDbG9ja1NldHRpbmdzLFxuLy8gSVRhc2ssXG4vLyBUYXNrUXVldWUsXG4vLyBRdWV1ZVRhc2tPcHRpb25zLFxuLy8gVGFzayxcbi8vIFRhc2tBYm9ydEVycm9yLFxuLy8gVGFza0NhbGxiYWNrLFxuLy8gVGFza1F1ZXVlLFxuQXBwVGFzaywgVGFza1F1ZXVlUHJpb3JpdHksIFxuLy8gVGFza1N0YXR1cyxcbi8vIFF1ZXVlVGFza1RhcmdldE9wdGlvbnMsXG5iaW5kYWJsZSwgXG4vLyBQYXJ0aWFsQmluZGFibGVEZWZpbml0aW9uLFxuLy8gQmluZGFibGVEZWZpbml0aW9uLFxuQmluZGFibGUsIFxuLy8gUGFydGlhbENoaWxkcmVuRGVmaW5pdGlvbixcbi8vIENoaWxkcmVuRGVmaW5pdGlvbixcbi8vIENoaWxkcmVuLFxuY2hpbGRyZW4sIFxuLy8gVGhlc2UgZXhwb3J0cyBhcmUgdGVtcG9yYXJ5IHVudGlsIHdlIGhhdmUgYSBwcm9wZXIgd2F5IHRvIHVuaXQgdGVzdCB0aGVtXG5Db250cm9sbGVyLCBWaWV3RmFjdG9yeSwgXG4vLyBJVmlld0xvY2F0b3IsXG4vLyBWaWV3TG9jYXRvcixcbi8vIHZpZXcsXG4vLyBWaWV3cyxcbi8vIEF1cmVsaWEsIC8vIFJlcGxhY2VkIGJ5IHF1aWNrLXN0YXJ0IHdyYXBwZXJcbi8vIElET01Jbml0aWFsaXplcixcbi8vIElTaW5nbGVQYWdlQXBwLFxuSUFwcFJvb3QsIFxuLy8gSWZSZWdpc3RyYXRpb24sXG4vLyBFbHNlUmVnaXN0cmF0aW9uLFxuLy8gUmVwZWF0UmVnaXN0cmF0aW9uLFxuLy8gUmVwbGFjZWFibGVSZWdpc3RyYXRpb24sXG4vLyBXaXRoUmVnaXN0cmF0aW9uLFxuLy8gU2FuaXRpemVWYWx1ZUNvbnZlcnRlclJlZ2lzdHJhdGlvbixcbi8vIERlYm91bmNlQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuLy8gT25lVGltZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbi8vIFRvVmlld0JpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbi8vIEZyb21WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuLy8gU2lnbmFsQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuLy8gVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4vLyBUd29XYXlCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4vLyBSZWZCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBDYWxsQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gQ3VzdG9tQXR0cmlidXRlUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBDdXN0b21FbGVtZW50UmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gSXRlcmF0b3JCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBMZXRFbGVtZW50UmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIFNldFByb3BlcnR5UmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIERlZmF1bHRSZXNvdXJjZXMgYXMgUnVudGltZURlZmF1bHRSZXNvdXJjZXMsXG4vLyBJT2JzZXJ2ZXJMb2NhdG9yUmVnaXN0cmF0aW9uLFxuLy8gSVJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gUnVudGltZUNvbmZpZ3VyYXRpb24sXG4vLyBBdHRyaWJ1dGVJbnN0cnVjdGlvbixcbi8vIElDYWxsQmluZGluZ0luc3RydWN0aW9uLFxuLy8gSUh5ZHJhdGVBdHRyaWJ1dGVJbnN0cnVjdGlvbixcbi8vIElIeWRyYXRlRWxlbWVudEluc3RydWN0aW9uLFxuLy8gSUh5ZHJhdGVMZXRFbGVtZW50SW5zdHJ1Y3Rpb24sXG4vLyBJSHlkcmF0ZVRlbXBsYXRlQ29udHJvbGxlcixcbi8vIElJbnRlcnBvbGF0aW9uSW5zdHJ1Y3Rpb24sXG4vLyBJSXRlcmF0b3JCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBJTGV0QmluZGluZ0luc3RydWN0aW9uLFxuLy8gSUluc3RydWN0aW9uUm93LFxuLy8gSW5zdHJ1Y3Rpb25UeXBlTmFtZSxcbi8vIElQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbixcbi8vIElSZWZCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBJU2V0UHJvcGVydHlJbnN0cnVjdGlvbixcbi8vIGlzSW5zdHJ1Y3Rpb24sXG4vLyBJSW5zdHJ1Y3Rpb24sXG4vLyBOb2RlSW5zdHJ1Y3Rpb24sXG4vLyBJSW5zdHJ1Y3Rpb24sXG4vLyBJbnN0cnVjdGlvblR5cGUsXG4vLyBQYXJ0aWFsQ3VzdG9tRWxlbWVudERlZmluaXRpb25QYXJ0cyxcbmFsaWFzLCByZWdpc3RlckFsaWFzZXMsIFxuLy8gRE9NLCBzaG91bGQgZXhwb3NlIHRoZSBvbmUgZXhwb3J0ZWQgaW4gcnVudGltZS1odG1sXG5JTm9kZSwgSUV2ZW50VGFyZ2V0LCBJUmVuZGVyTG9jYXRpb24sIFxuLy8gTm9kZVNlcXVlbmNlLFxuLy8gSU5vZGVTZXF1ZW5jZSxcbi8vIElOb2RlU2VxdWVuY2VGYWN0b3J5LFxuQmluZGluZ01vZGUsIFxuLy8gRXhwcmVzc2lvbktpbmQsXG4vLyBIb29rcyxcbkxpZmVjeWNsZUZsYWdzLCBcbi8vIElPYnNlcnZhYmxlLFxuLy8gSU9ic2VydmVkQXJyYXksXG4vLyBJT2JzZXJ2ZWRNYXAsXG4vLyBJT2JzZXJ2ZWRTZXQsXG4vLyBJT3ZlcnJpZGVDb250ZXh0LFxuLy8gU2NvcGUsXG4vLyBJU3Vic2NyaWJhYmxlLFxuLy8gSVN1YnNjcmliZXJDb2xsZWN0aW9uLFxuLy8gT2JzZXJ2ZWRDb2xsZWN0aW9uLFxuLy8gQ29sbGVjdGlvbk9ic2VydmVyLFxuLy8gSUNvbGxlY3Rpb25TdWJzY3JpYmVyQ29sbGVjdGlvbixcbi8vIElDb2xsZWN0aW9uU3Vic2NyaWJhYmxlLFxuLy8gSVN1YnNjcmliZXIsXG4vLyBpc0luZGV4TWFwLFxuLy8gY29weUluZGV4TWFwLFxuLy8gY2xvbmVJbmRleE1hcCxcbi8vIGNyZWF0ZUluZGV4TWFwLFxucmVuZGVyZXIsIFxuLy8gRGVmYXVsdEJpbmRpbmdMYW5ndWFnZSBhcyBKaXREZWZhdWx0QmluZGluZ0xhbmd1YWdlLFxuLy8gSml0Q29uZmlndXJhdGlvbixcbi8vIEFjY2Vzcyxcbi8vIFByZWNlZGVuY2UsXG4vLyBDaGFyLFxuLy8gVGhlc2UgZXhwb3J0cyBhcmUgdGVtcG9yYXJ5IHVudGlsIHdlIGhhdmUgYSBwcm9wZXIgd2F5IHRvIHVuaXQgdGVzdCB0aGVtXG4vLyBwYXJzZUV4cHJlc3Npb24sXG4vLyBwYXJzZSxcbi8vIFBhcnNlclN0YXRlLFxuLy8gQmluZGFibGVJbmZvLFxuLy8gRWxlbWVudEluZm8sXG4vLyBBdHRySW5mbyxcbi8vIEFueVN5bWJvbCxcbi8vIEJpbmRpbmdTeW1ib2wsXG4vLyBDdXN0b21BdHRyaWJ1dGVTeW1ib2wsXG4vLyBDdXN0b21FbGVtZW50U3ltYm9sLFxuLy8gRWxlbWVudFN5bWJvbCxcbi8vIExldEVsZW1lbnRTeW1ib2wsXG4vLyBOb2RlU3ltYm9sLFxuLy8gUGFyZW50Tm9kZVN5bWJvbCxcbi8vIFBsYWluQXR0cmlidXRlU3ltYm9sLFxuLy8gUGxhaW5FbGVtZW50U3ltYm9sLFxuLy8gUmVwbGFjZVBhcnRTeW1ib2wsXG4vLyBSZXNvdXJjZUF0dHJpYnV0ZVN5bWJvbCxcbi8vIFN5bWJvbEZsYWdzLFxuLy8gU3ltYm9sV2l0aEJpbmRpbmdzLFxuLy8gU3ltYm9sV2l0aE1hcmtlcixcbi8vIFN5bWJvbFdpdGhUZW1wbGF0ZSxcbi8vIFRlbXBsYXRlQ29udHJvbGxlclN5bWJvbCxcbi8vIFRleHRTeW1ib2xcbklBdXJlbGlhLCBcbi8vIExpc3RlbmVyLFxuLy8gQXR0cmlidXRlQmluZGluZyxcbi8vIEF0dHJpYnV0ZU5TQWNjZXNzb3IsXG4vLyBJSW5wdXRFbGVtZW50LFxuLy8gQ2hlY2tlZE9ic2VydmVyLFxuLy8gQ2xhc3NBdHRyaWJ1dGVBY2Nlc3Nvcixcbi8vIERhdGFBdHRyaWJ1dGVBY2Nlc3Nvcixcbi8vIEVsZW1lbnRQcm9wZXJ0eUFjY2Vzc29yLFxuLy8gSU1hbmFnZWRFdmVudCxcbi8vIExpc3RlbmVyVHJhY2tlcixcbi8vIERlbGVnYXRlT3JDYXB0dXJlU3Vic2NyaXB0aW9uLFxuLy8gVHJpZ2dlclN1YnNjcmlwdGlvbixcbi8vIElFbGVtZW50Q29uZmlndXJhdGlvbixcbi8vIElFdmVudERlbGVnYXRvcixcbi8vIElFdmVudFN1YnNjcmliZXIsXG4vLyBJRXZlbnRUYXJnZXRXaXRoTG9va3Vwcyxcbi8vIEV2ZW50U3Vic2NyaWJlcixcbi8vIEV2ZW50U3Vic2NyaXB0aW9uLFxuLy8gRXZlbnREZWxlZ2F0b3IsXG5Ob2RlT2JzZXJ2ZXJMb2NhdG9yLCBcbi8vIFRhcmdldEFjY2Vzc29yTG9jYXRvcixcbi8vIFRhcmdldE9ic2VydmVyTG9jYXRvcixcbi8vIElTZWxlY3RFbGVtZW50LFxuLy8gSU9wdGlvbkVsZW1lbnQsXG4vLyBTZWxlY3RWYWx1ZU9ic2VydmVyLFxuLy8gU3R5bGVBdHRyaWJ1dGVBY2Nlc3Nvcixcbi8vIElTVkdBbmFseXplcixcbi8vIFZhbHVlQXR0cmlidXRlT2JzZXJ2ZXIsXG4vLyBBdHRyQmluZGluZ0JlaGF2aW9yLFxuLy8gU2VsZmFibGVCaW5kaW5nLFxuLy8gU2VsZkJpbmRpbmdCZWhhdmlvcixcbi8vIFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3IsXG4vLyBVcGRhdGVUcmlnZ2VyYWJsZUJpbmRpbmcsXG4vLyBVcGRhdGVUcmlnZ2VyYWJsZU9ic2VydmVyLFxuLy8gQmx1cixcbi8vIEJsdXJNYW5hZ2VyLFxuLy8gRm9jdXMsXG4vLyBQb3J0YWwsXG4vLyBQb3J0YWxUYXJnZXQsXG4vLyBQb3J0YWxMaWZlY3ljbGVDYWxsYmFjayxcbi8vIFN1YmplY3QsXG4vLyBDb21wb3NlLFxuLy8gSVByb2plY3RvckxvY2F0b3JSZWdpc3RyYXRpb24sXG4vLyBJVGFyZ2V0QWNjZXNzb3JMb2NhdG9yUmVnaXN0cmF0aW9uLFxuLy8gSVRhcmdldE9ic2VydmVyTG9jYXRvclJlZ2lzdHJhdGlvbixcbi8vIElUZW1wbGF0ZUZhY3RvcnlSZWdpc3RyYXRpb24sXG4vLyBEZWZhdWx0Q29tcG9uZW50cyBhcyBSdW50aW1lSHRtbERlZmF1bHRDb21wb25lbnRzLFxuLy8gQ29tcGlsZWRUZW1wbGF0ZSxcbi8vIENoaWxkcmVuT2JzZXJ2ZXIsXG4vLyBJUmVuZGVyZXIsXG4vLyBJSW5zdHJ1Y3Rpb25UeXBlQ2xhc3NpZmllcixcbi8vIElSZW5kZXJpbmdFbmdpbmUsXG4vLyBJVGVtcGxhdGUsXG4vLyBJVGVtcGxhdGVDb21waWxlcixcbi8vIElUZW1wbGF0ZUZhY3RvcnksXG4vLyBSZW5kZXJDb250ZXh0XG4vLyBBdHRyU3ludGF4LFxuLy8gSUF0dHJpYnV0ZVBhcnNlcixcbmF0dHJpYnV0ZVBhdHRlcm4sIFxuLy8gQXR0cmlidXRlUGF0dGVybkRlZmluaXRpb24sXG5JQXR0cmlidXRlUGF0dGVybiwgXG4vLyBJQXR0cmlidXRlUGF0dGVybkhhbmRsZXIsXG4vLyBJbnRlcnByZXRhdGlvbixcbi8vIElTeW50YXhJbnRlcnByZXRlcixcbklBdHRyU3ludGF4VHJhbnNmb3JtZXIsIFxuLy8gQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuLFxuLy8gQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuLFxuLy8gRG90U2VwYXJhdGVkQXR0cmlidXRlUGF0dGVybixcbi8vIFJlZkF0dHJpYnV0ZVBhdHRlcm4sXG5iaW5kaW5nQ29tbWFuZCwgXG4vLyBCaW5kaW5nQ29tbWFuZERlZmluaXRpb24sXG4vLyBCaW5kaW5nQ29tbWFuZEtpbmQsXG4vLyBCaW5kaW5nQ29tbWFuZFR5cGUsXG5nZXRUYXJnZXQsIFxuLy8gQ2FsbEJpbmRpbmdDb21tYW5kLFxuLy8gRGVmYXVsdEJpbmRpbmdDb21tYW5kLFxuLy8gRm9yQmluZGluZ0NvbW1hbmQsXG4vLyBGcm9tVmlld0JpbmRpbmdDb21tYW5kLFxuLy8gT25lVGltZUJpbmRpbmdDb21tYW5kLFxuLy8gVG9WaWV3QmluZGluZ0NvbW1hbmQsXG4vLyBUd29XYXlCaW5kaW5nQ29tbWFuZCxcbi8vIElFeHByZXNzaW9uUGFyc2VyUmVnaXN0cmF0aW9uLFxuLy8gRGVmYXVsdENvbXBvbmVudHMgYXMgSml0RGVmYXVsdENvbXBvbmVudHMsXG4vLyBSZWZBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLFxuLy8gRG90U2VwYXJhdGVkQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvbixcbi8vIERlZmF1bHRCaW5kaW5nU3ludGF4LFxuLy8gQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLFxuLy8gQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLFxuU2hvcnRIYW5kQmluZGluZ1N5bnRheCwgXG4vLyBDYWxsQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4vLyBEZWZhdWx0QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4vLyBGb3JCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbi8vIEZyb21WaWV3QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4vLyBPbmVUaW1lQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4vLyBUb1ZpZXdCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbi8vIFR3b1dheUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuLy8gQXR0ckJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbi8vIFNlbGZCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4vLyBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuLy8gQ29tcG9zZVJlZ2lzdHJhdGlvbixcbi8vIERlZmF1bHRSZXNvdXJjZXMgYXMgUnVudGltZUh0bWxEZWZhdWx0UmVzb3VyY2VzLFxuLy8gQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBTZXRBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIFNldENsYXNzQXR0cmlidXRlUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIFRleHRCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBEZWZhdWx0UmVuZGVyZXJzLFxuLy8gU3RhbmRhcmRDb25maWd1cmF0aW9uLFxuY3JlYXRlRWxlbWVudCwgXG4vLyBSZW5kZXJQbGFuLFxuLy8gQXR0cmlidXRlSW5zdHJ1Y3Rpb24sXG4vLyBJSW5zdHJ1Y3Rpb25Sb3csXG4vLyBOb2RlSW5zdHJ1Y3Rpb24sXG4vLyBJSW5zdHJ1Y3Rpb24sXG4vLyBJbnN0cnVjdGlvblR5cGUsXG4vLyBJQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uLFxuLy8gSUxpc3RlbmVyQmluZGluZ0luc3RydWN0aW9uLFxuLy8gSVNldEF0dHJpYnV0ZUluc3RydWN0aW9uLFxuLy8gaXNJbnN0cnVjdGlvbixcbi8vIElTdHlsZVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uLFxuLy8gSVRleHRCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBOb2RlU2VxdWVuY2VGYWN0b3J5LFxuLy8gRnJhZ21lbnROb2RlU2VxdWVuY2UsXG4vLyBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBTZXRBdHRyaWJ1dGVJbnN0cnVjdGlvbixcbi8vIFNldENsYXNzQXR0cmlidXRlSW5zdHJ1Y3Rpb24sXG4vLyBTZXRTdHlsZUF0dHJpYnV0ZUluc3RydWN0aW9uLFxuLy8gU3R5bGVQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbixcbi8vIFRleHRCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBDb250YWluZXJsZXNzUHJvamVjdG9yLFxuLy8gSG9zdFByb2plY3Rvcixcbi8vIEhUTUxQcm9qZWN0b3JMb2NhdG9yLFxuLy8gU2hhZG93RE9NUHJvamVjdG9yLFxuU3R5bGVDb25maWd1cmF0aW9uLCBcbi8vIENTU01vZHVsZXNQcm9jZXNzb3JSZWdpc3RyeSxcbmNzc01vZHVsZXMsIFxuLy8gU2hhZG93RE9NUmVnaXN0cnksXG4vLyBJU2hhZG93RE9NU3R5bGVGYWN0b3J5LFxuc2hhZG93Q1NTLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5hcHAtaGVhZGVyIHtcXG4gIGJhY2tncm91bmQ6ICNmNGY0ZjQ7XFxuICBwYWRkaW5nOiAwO1xcbiAgcGFkZGluZzogNXB4IDAgMCAwO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uZGFyayAuYXBwLWhlYWRlciB7XFxuICBiYWNrZ3JvdW5kOiAjMmEyYTJhO1xcbn1cXG5cXG4ubG9nby1iYWRnZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IC03cHg7XFxuICBmb250LXdlaWdodDogMTAwO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgY29sb3I6ICNCQjc5QTg7XFxufVxcblxcbi5ub3QtZm91bmQge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbn1cXG5cXG4uZGFyayAubm90LWZvdW5kIHtcXG4gIGNvbG9yOiAjOTg5ODk4O1xcbn1cXG5cXG4uY3VzdG9tLWF0dHJpYnV0ZSB7XFxuICBtYXJnaW4tYm90dG9tOiA0cHg7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIC5hdHRyaWJ1dGUtbmFtZSB7XFxuICBjb2xvcjogc2FkZGxlYnJvd247XFxufVxcbi5kYXJrIC5jdXN0b20tYXR0cmlidXRlIC5hdHRyaWJ1dGUtbmFtZSB7XFxuICBjb2xvcjogI2VmOTU2NTtcXG59XFxuXFxuLmN1c3RvbS1hdHRyaWJ1dGUgLmJsb2NrLXRva2VuIHtcXG4gIGNvbG9yOiBncmF5O1xcbn1cXG5cXG4uY3VzdG9tLWF0dHJpYnV0ZSAuYXR0cmlidXRlLW5hbWUsIC5jdXN0b20tYXR0cmlidXRlIC5ibG9jay10b2tlbiB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBpbmxpbmU7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbn1cXG5cXG4uY3VzdG9tLWF0dHJpYnV0ZSBjb250cm9sbGVyLXZpZXcge1xcbiAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCB7XFxuICBtYXJnaW4tdG9wOiAycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLmFycm93IHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAuYXJyb3cgLnJpZ2h0IHtcXG4gIG1hcmdpbi1yaWdodDogMXB4O1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktbGluZSB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktbmFtZSB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjb2xvcjogcHVycGxlO1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi1sZWZ0OiAxcHg7XFxufVxcblxcbi5kYXJrIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS1uYW1lIHtcXG4gIGNvbG9yOiAjMzRjN2JiO1xcbn1cXG5jdXN0b20tZWxlbWVudCAudmFsdWUtY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LWVkaXRvciB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGRhcmtncmF5O1xcbiAgYm94LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsMCwwLC41KTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNHB4O1xcbiAgbGVmdDogMnB4O1xcbiAgcGFkZGluZzogMCAwIDAgMnB4O1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUsIGN1c3RvbS1lbGVtZW50IC50b2tlbi1jb2xvbiB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjb2xvcjogZGltZ3JheTtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5udWxsLCBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUudW5kZWZpbmVkIHtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUuYm9vbGVhbiB7XFxuICBjb2xvcjogZGVlcHBpbms7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5zdHJpbmcge1xcbiAgY29sb3I6IHJlZDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcbi5kYXJrIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5zdHJpbmcge1xcbiAgY29sb3I6I2NiY2JjYjtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm51bWJlciB7XFxuICBjb2xvcjogYmx1ZTtcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm51bWJlciB7XFxuICBjb2xvcjogIzU5YTZjYTtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLmFycmF5IHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLmFycmF5IHtcXG4gIGNvbG9yOiAjY2JjYmNiO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUub2JqZWN0LCBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUubm9kZSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbi5kYXJrIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5vYmplY3QsIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5ub2RlIHtcXG4gIGNvbG9yOiAjY2JjYmNiO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCB1bC5wcm9wZXJ0aWVzIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4O1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAubm8tcHJvcGVydGllcyB7XFxuICBtYXJnaW4tdG9wOiA0cHg7XFxuICBmb250LXNpemU6IDEwcHg7XFxufVxcblxcbi5kYXJrIGN1c3RvbS1lbGVtZW50IC5uby1wcm9wZXJ0aWVzIHtcXG4gIGNvbG9yOiAjOTg5ODk4O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvYXBwLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLG1CQUFtQjtFQUNuQixVQUFVO0VBQ1Ysa0JBQWtCO0VBQ2xCLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixTQUFTO0VBQ1QsZ0JBQWdCO0VBQ2hCLGVBQWU7RUFDZixjQUFjO0FBQ2hCOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0Usa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0Usa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsV0FBVztBQUNiOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGVBQWU7RUFDZixzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSxnQkFBZ0I7RUFDaEIsY0FBYztBQUNoQjs7QUFFQTtFQUNFLGVBQWU7RUFDZixjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGNBQWM7RUFDZCxlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGFBQWE7RUFDYixzQkFBc0I7RUFDdEIsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsY0FBYztBQUNoQjtBQUNBO0VBQ0Usa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0Usc0JBQXNCO0VBQ3RCLGVBQWU7RUFDZixTQUFTO0VBQ1QsWUFBWTtFQUNaLGFBQWE7RUFDYiwwQkFBMEI7RUFDMUIsa0NBQWtDO0VBQ2xDLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsU0FBUztFQUNULGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLGVBQWU7RUFDZixjQUFjO0VBQ2Qsc0JBQXNCO0FBQ3hCOztBQUVBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTtFQUNFLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxVQUFVO0VBQ1YsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxXQUFXO0FBQ2I7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsWUFBWTtBQUNkOztBQUVBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTtFQUNFLFlBQVk7QUFDZDs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLGNBQWM7QUFDaEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmFwcC1oZWFkZXIge1xcbiAgYmFja2dyb3VuZDogI2Y0ZjRmNDtcXG4gIHBhZGRpbmc6IDA7XFxuICBwYWRkaW5nOiA1cHggMCAwIDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5kYXJrIC5hcHAtaGVhZGVyIHtcXG4gIGJhY2tncm91bmQ6ICMyYTJhMmE7XFxufVxcblxcbi5sb2dvLWJhZGdlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogLTdweDtcXG4gIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBjb2xvcjogI0JCNzlBODtcXG59XFxuXFxuLm5vdC1mb3VuZCB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICBmb250LXNpemU6IDEwcHg7XFxufVxcblxcbi5kYXJrIC5ub3QtZm91bmQge1xcbiAgY29sb3I6ICM5ODk4OTg7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIHtcXG4gIG1hcmdpbi1ib3R0b206IDRweDtcXG59XFxuXFxuLmN1c3RvbS1hdHRyaWJ1dGUgLmF0dHJpYnV0ZS1uYW1lIHtcXG4gIGNvbG9yOiBzYWRkbGVicm93bjtcXG59XFxuLmRhcmsgLmN1c3RvbS1hdHRyaWJ1dGUgLmF0dHJpYnV0ZS1uYW1lIHtcXG4gIGNvbG9yOiAjZWY5NTY1O1xcbn1cXG5cXG4uY3VzdG9tLWF0dHJpYnV0ZSAuYmxvY2stdG9rZW4ge1xcbiAgY29sb3I6IGdyYXk7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIC5hdHRyaWJ1dGUtbmFtZSwgLmN1c3RvbS1hdHRyaWJ1dGUgLmJsb2NrLXRva2VuIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGlubGluZTtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIGNvbnRyb2xsZXItdmlldyB7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IHtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAuYXJyb3cge1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgY29sb3I6IGRpbWdyYXk7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5hcnJvdyAucmlnaHQge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS1saW5lIHtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiBwdXJwbGU7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLWxlZnQ6IDFweDtcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LW5hbWUge1xcbiAgY29sb3I6ICMzNGM3YmI7XFxufVxcbmN1c3RvbS1lbGVtZW50IC52YWx1ZS1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktZWRpdG9yIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuICBoZWlnaHQ6IDEycHg7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgZGFya2dyYXk7XFxuICBib3gtc2hhZG93OiAwIDAgNXB4IHJnYmEoMCwwLDAsLjUpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA0cHg7XFxuICBsZWZ0OiAycHg7XFxuICBwYWRkaW5nOiAwIDAgMCAycHg7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZSwgY3VzdG9tLWVsZW1lbnQgLnRva2VuLWNvbG9uIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm51bGwsIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS51bmRlZmluZWQge1xcbiAgY29sb3I6IGRpbWdyYXk7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5ib29sZWFuIHtcXG4gIGNvbG9yOiBkZWVwcGluaztcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLnN0cmluZyB7XFxuICBjb2xvcjogcmVkO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLnN0cmluZyB7XFxuICBjb2xvcjojY2JjYmNiO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUubnVtYmVyIHtcXG4gIGNvbG9yOiBibHVlO1xcbn1cXG5cXG4uZGFyayBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUubnVtYmVyIHtcXG4gIGNvbG9yOiAjNTlhNmNhO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUuYXJyYXkge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uZGFyayBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUuYXJyYXkge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5vYmplY3QsIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5ub2RlIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm9iamVjdCwgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm5vZGUge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IHVsLnByb3BlcnRpZXMge1xcbiAgbWFyZ2luLWxlZnQ6IDE2cHg7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5uby1wcm9wZXJ0aWVzIHtcXG4gIG1hcmdpbi10b3A6IDRweDtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLm5vLXByb3BlcnRpZXMge1xcbiAgY29sb3I6ICM5ODk4OTg7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qIGh0dHA6Ly9tZXllcndlYi5jb20vZXJpYy90b29scy9jc3MvcmVzZXQvXFxuICAgdjIuMCB8IDIwMTEwMTI2XFxuICAgTGljZW5zZTogbm9uZSAocHVibGljIGRvbWFpbilcXG4qL1xcblxcbmh0bWwsIGJvZHksIGRpdiwgc3BhbiwgYXBwbGV0LCBvYmplY3QsIGlmcmFtZSxcXG5oMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwLCBibG9ja3F1b3RlLCBwcmUsXFxuYSwgYWJiciwgYWNyb255bSwgYWRkcmVzcywgYmlnLCBjaXRlLCBjb2RlLFxcbmRlbCwgZGZuLCBlbSwgaW1nLCBpbnMsIGtiZCwgcSwgcywgc2FtcCxcXG5zbWFsbCwgc3RyaWtlLCBzdHJvbmcsIHN1Yiwgc3VwLCB0dCwgdmFyLFxcbmIsIHUsIGksIGNlbnRlcixcXG5kbCwgZHQsIGRkLCBvbCwgdWwsIGxpLFxcbmZpZWxkc2V0LCBmb3JtLCBsYWJlbCwgbGVnZW5kLFxcbnRhYmxlLCBjYXB0aW9uLCB0Ym9keSwgdGZvb3QsIHRoZWFkLCB0ciwgdGgsIHRkLFxcbmFydGljbGUsIGFzaWRlLCBjYW52YXMsIGRldGFpbHMsIGVtYmVkLFxcbmZpZ3VyZSwgZmlnY2FwdGlvbiwgZm9vdGVyLCBoZWFkZXIsIGhncm91cCxcXG5tZW51LCBuYXYsIG91dHB1dCwgcnVieSwgc2VjdGlvbiwgc3VtbWFyeSxcXG50aW1lLCBtYXJrLCBhdWRpbywgdmlkZW8ge1xcblxcdG1hcmdpbjogMDtcXG5cXHRwYWRkaW5nOiAwO1xcblxcdGJvcmRlcjogMDtcXG5cXHRmb250LXNpemU6IDEwMCU7XFxuXFx0Zm9udDogaW5oZXJpdDtcXG5cXHR2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcbi8qIEhUTUw1IGRpc3BsYXktcm9sZSByZXNldCBmb3Igb2xkZXIgYnJvd3NlcnMgKi9cXG5hcnRpY2xlLCBhc2lkZSwgZGV0YWlscywgZmlnY2FwdGlvbiwgZmlndXJlLFxcbmZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsIG1lbnUsIG5hdiwgc2VjdGlvbiB7XFxuXFx0ZGlzcGxheTogYmxvY2s7XFxufVxcbmJvZHkge1xcblxcdGxpbmUtaGVpZ2h0OiAxO1xcbn1cXG5vbCwgdWwge1xcblxcdGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcbmJsb2NrcXVvdGUsIHEge1xcblxcdHF1b3Rlczogbm9uZTtcXG59XFxuYmxvY2txdW90ZTpiZWZvcmUsIGJsb2NrcXVvdGU6YWZ0ZXIsXFxucTpiZWZvcmUsIHE6YWZ0ZXIge1xcblxcdGNvbnRlbnQ6ICcnO1xcblxcdGNvbnRlbnQ6IG5vbmU7XFxufVxcbnRhYmxlIHtcXG5cXHRib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcblxcdGJvcmRlci1zcGFjaW5nOiAwO1xcbn1cXG5cXG4vKiEgbm9ybWFsaXplLmNzcyB2NS4wLjAgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovXFxuXFxuLyogRG9jdW1lbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZGVmYXVsdCBmb250IGZhbWlseSBpbiBhbGwgYnJvd3NlcnMgKG9waW5pb25hdGVkKS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuICogMy4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpblxcbiAqICAgIElFIG9uIFdpbmRvd3MgUGhvbmUgYW5kIGluIGlPUy5cXG4gKi9cXG5cXG5odG1sIHtcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMiAqL1xcbiAgLW1zLXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDMgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMyAqL1xcbn1cXG5cXG4vKiBGb3Jtc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMgKG9waW5pb25hdGVkKS5cXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxcbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0IHsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSwgRmlyZWZveCwgYW5kIElFLlxcbiAqIDEuIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b24sXFxuc2VsZWN0IHsgLyogMSAqL1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqIDEuIFByZXZlbnQgYSBXZWJLaXQgYnVnIHdoZXJlICgyKSBkZXN0cm95cyBuYXRpdmUgYGF1ZGlvYCBhbmQgYHZpZGVvYFxcbiAqICAgIGNvbnRyb2xzIGluIEFuZHJvaWQgNC5cXG4gKiAyLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmJ1dHRvbixcXG5odG1sIFt0eXBlPVxcXCJidXR0b25cXFwiXSwgLyogMSAqL1xcblt0eXBlPVxcXCJyZXNldFxcXCJdLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGlubmVyIGJvcmRlciBhbmQgcGFkZGluZyBpbiBGaXJlZm94LlxcbiAqL1xcblxcbmJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOjotbW96LWZvY3VzLWlubmVyIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi8qKlxcbiAqIFJlc3RvcmUgdGhlIGZvY3VzIHN0eWxlcyB1bnNldCBieSB0aGUgcHJldmlvdXMgcnVsZS5cXG4gKi9cXG5cXG5idXR0b246LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTotbW96LWZvY3VzcmluZyB7XFxuICBvdXRsaW5lOiAxcHggZG90dGVkIEJ1dHRvblRleHQ7XFxufVxcblxcbi8qKlxcbiAqIENoYW5nZSB0aGUgYm9yZGVyLCBtYXJnaW4sIGFuZCBwYWRkaW5nIGluIGFsbCBicm93c2VycyAob3BpbmlvbmF0ZWQpLlxcbiAqL1xcblxcbmZpZWxkc2V0IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjMGMwYzA7XFxuICBtYXJnaW46IDAgMnB4O1xcbiAgcGFkZGluZzogMC4zNWVtIDAuNjI1ZW0gMC43NWVtO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDktLlxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRS5cXG4gKi9cXG5cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAtLlxcbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC0uXFxuICovXFxuXFxuW3R5cGU9XFxcImNoZWNrYm94XFxcIl0sXFxuW3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBDaHJvbWUuXFxuICovXFxuXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiAqIDIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiAqL1xcblxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGFuZCBjYW5jZWwgYnV0dG9ucyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuICovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvcmVzZXQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7Q0FHQzs7QUFFRDs7Ozs7Ozs7Ozs7OztDQWFDLFNBQVM7Q0FDVCxVQUFVO0NBQ1YsU0FBUztDQUNULGVBQWU7Q0FDZixhQUFhO0NBQ2Isd0JBQXdCO0FBQ3pCO0FBQ0EsZ0RBQWdEO0FBQ2hEOztDQUVDLGNBQWM7QUFDZjtBQUNBO0NBQ0MsY0FBYztBQUNmO0FBQ0E7Q0FDQyxnQkFBZ0I7QUFDakI7QUFDQTtDQUNDLFlBQVk7QUFDYjtBQUNBOztDQUVDLFdBQVc7Q0FDWCxhQUFhO0FBQ2Q7QUFDQTtDQUNDLHlCQUF5QjtDQUN6QixpQkFBaUI7QUFDbEI7O0FBRUEsMkVBQTJFOztBQUUzRTsrRUFDK0U7O0FBRS9FOzs7OztFQUtFOztBQUVGO0VBQ0UsdUJBQXVCLEVBQUUsTUFBTTtFQUMvQixpQkFBaUIsRUFBRSxNQUFNO0VBQ3pCLDBCQUEwQixFQUFFLE1BQU07RUFDbEMsOEJBQThCLEVBQUUsTUFBTTtBQUN4Qzs7QUFFQTsrRUFDK0U7O0FBRS9FOzs7RUFHRTs7QUFFRjs7Ozs7RUFLRSx1QkFBdUIsRUFBRSxNQUFNO0VBQy9CLGVBQWUsRUFBRSxNQUFNO0VBQ3ZCLGlCQUFpQixFQUFFLE1BQU07RUFDekIsU0FBUyxFQUFFLE1BQU07QUFDbkI7O0FBRUE7OztFQUdFOztBQUVGO1FBQ1EsTUFBTTtFQUNaLGlCQUFpQjtBQUNuQjs7QUFFQTs7O0VBR0U7O0FBRUY7U0FDUyxNQUFNO0VBQ2Isb0JBQW9CO0FBQ3RCOztBQUVBOzs7O0VBSUU7O0FBRUY7Ozs7RUFJRSwwQkFBMEIsRUFBRSxNQUFNO0FBQ3BDOztBQUVBOztFQUVFOztBQUVGOzs7O0VBSUUsa0JBQWtCO0VBQ2xCLFVBQVU7QUFDWjs7QUFFQTs7RUFFRTs7QUFFRjs7OztFQUlFLDhCQUE4QjtBQUNoQzs7QUFFQTs7RUFFRTs7QUFFRjtFQUNFLHlCQUF5QjtFQUN6QixhQUFhO0VBQ2IsOEJBQThCO0FBQ2hDOztBQUVBOzs7OztFQUtFOztBQUVGO0VBQ0Usc0JBQXNCLEVBQUUsTUFBTTtFQUM5QixjQUFjLEVBQUUsTUFBTTtFQUN0QixjQUFjLEVBQUUsTUFBTTtFQUN0QixlQUFlLEVBQUUsTUFBTTtFQUN2QixVQUFVLEVBQUUsTUFBTTtFQUNsQixtQkFBbUIsRUFBRSxNQUFNO0FBQzdCOztBQUVBOzs7RUFHRTs7QUFFRjtFQUNFLHFCQUFxQixFQUFFLE1BQU07RUFDN0Isd0JBQXdCLEVBQUUsTUFBTTtBQUNsQzs7QUFFQTs7RUFFRTs7QUFFRjtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7OztFQUdFOztBQUVGOztFQUVFLHNCQUFzQixFQUFFLE1BQU07RUFDOUIsVUFBVSxFQUFFLE1BQU07QUFDcEI7O0FBRUE7O0VBRUU7O0FBRUY7O0VBRUUsWUFBWTtBQUNkOztBQUVBOzs7RUFHRTs7QUFFRjtFQUNFLDZCQUE2QixFQUFFLE1BQU07RUFDckMsb0JBQW9CLEVBQUUsTUFBTTtBQUM5Qjs7QUFFQTs7RUFFRTs7QUFFRjs7RUFFRSx3QkFBd0I7QUFDMUI7O0FBRUE7OztFQUdFOztBQUVGO0VBQ0UsMEJBQTBCLEVBQUUsTUFBTTtFQUNsQyxhQUFhLEVBQUUsTUFBTTtBQUN2QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBodHRwOi8vbWV5ZXJ3ZWIuY29tL2VyaWMvdG9vbHMvY3NzL3Jlc2V0L1xcbiAgIHYyLjAgfCAyMDExMDEyNlxcbiAgIExpY2Vuc2U6IG5vbmUgKHB1YmxpYyBkb21haW4pXFxuKi9cXG5cXG5odG1sLCBib2R5LCBkaXYsIHNwYW4sIGFwcGxldCwgb2JqZWN0LCBpZnJhbWUsXFxuaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCwgYmxvY2txdW90ZSwgcHJlLFxcbmEsIGFiYnIsIGFjcm9ueW0sIGFkZHJlc3MsIGJpZywgY2l0ZSwgY29kZSxcXG5kZWwsIGRmbiwgZW0sIGltZywgaW5zLCBrYmQsIHEsIHMsIHNhbXAsXFxuc21hbGwsIHN0cmlrZSwgc3Ryb25nLCBzdWIsIHN1cCwgdHQsIHZhcixcXG5iLCB1LCBpLCBjZW50ZXIsXFxuZGwsIGR0LCBkZCwgb2wsIHVsLCBsaSxcXG5maWVsZHNldCwgZm9ybSwgbGFiZWwsIGxlZ2VuZCxcXG50YWJsZSwgY2FwdGlvbiwgdGJvZHksIHRmb290LCB0aGVhZCwgdHIsIHRoLCB0ZCxcXG5hcnRpY2xlLCBhc2lkZSwgY2FudmFzLCBkZXRhaWxzLCBlbWJlZCxcXG5maWd1cmUsIGZpZ2NhcHRpb24sIGZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsXFxubWVudSwgbmF2LCBvdXRwdXQsIHJ1YnksIHNlY3Rpb24sIHN1bW1hcnksXFxudGltZSwgbWFyaywgYXVkaW8sIHZpZGVvIHtcXG5cXHRtYXJnaW46IDA7XFxuXFx0cGFkZGluZzogMDtcXG5cXHRib3JkZXI6IDA7XFxuXFx0Zm9udC1zaXplOiAxMDAlO1xcblxcdGZvbnQ6IGluaGVyaXQ7XFxuXFx0dmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG4vKiBIVE1MNSBkaXNwbGF5LXJvbGUgcmVzZXQgZm9yIG9sZGVyIGJyb3dzZXJzICovXFxuYXJ0aWNsZSwgYXNpZGUsIGRldGFpbHMsIGZpZ2NhcHRpb24sIGZpZ3VyZSxcXG5mb290ZXIsIGhlYWRlciwgaGdyb3VwLCBtZW51LCBuYXYsIHNlY3Rpb24ge1xcblxcdGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5ib2R5IHtcXG5cXHRsaW5lLWhlaWdodDogMTtcXG59XFxub2wsIHVsIHtcXG5cXHRsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5ibG9ja3F1b3RlLCBxIHtcXG5cXHRxdW90ZXM6IG5vbmU7XFxufVxcbmJsb2NrcXVvdGU6YmVmb3JlLCBibG9ja3F1b3RlOmFmdGVyLFxcbnE6YmVmb3JlLCBxOmFmdGVyIHtcXG5cXHRjb250ZW50OiAnJztcXG5cXHRjb250ZW50OiBub25lO1xcbn1cXG50YWJsZSB7XFxuXFx0Ym9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG5cXHRib3JkZXItc3BhY2luZzogMDtcXG59XFxuXFxuLyohIG5vcm1hbGl6ZS5jc3MgdjUuMC4wIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL1xcblxcbi8qIERvY3VtZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiAxLiBDaGFuZ2UgdGhlIGRlZmF1bHQgZm9udCBmYW1pbHkgaW4gYWxsIGJyb3dzZXJzIChvcGluaW9uYXRlZCkuXFxuICogMi4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDMuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW5cXG4gKiAgICBJRSBvbiBXaW5kb3dzIFBob25lIGFuZCBpbiBpT1MuXFxuICovXFxuXFxuaHRtbCB7XFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDIgKi9cXG4gIC1tcy10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAzICovXFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDMgKi9cXG59XFxuXFxuLyogRm9ybXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzIChvcGluaW9uYXRlZCkuXFxuICogMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cXG4gIG1hcmdpbjogMDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBTaG93IHRoZSBvdmVyZmxvdyBpbiBJRS5cXG4gKiAxLiBTaG93IHRoZSBvdmVyZmxvdyBpbiBFZGdlLlxcbiAqL1xcblxcbmJ1dHRvbixcXG5pbnB1dCB7IC8qIDEgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UsIEZpcmVmb3gsIGFuZCBJRS5cXG4gKiAxLiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEZpcmVmb3guXFxuICovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7IC8qIDEgKi9cXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBQcmV2ZW50IGEgV2ViS2l0IGJ1ZyB3aGVyZSAoMikgZGVzdHJveXMgbmF0aXZlIGBhdWRpb2AgYW5kIGB2aWRlb2BcXG4gKiAgICBjb250cm9scyBpbiBBbmRyb2lkIDQuXFxuICogMi4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaHRtbCBbdHlwZT1cXFwiYnV0dG9uXFxcIl0sIC8qIDEgKi9cXG5bdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXFxuICovXFxuXFxuYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0O1xcbn1cXG5cXG4vKipcXG4gKiBDaGFuZ2UgdGhlIGJvcmRlciwgbWFyZ2luLCBhbmQgcGFkZGluZyBpbiBhbGwgYnJvd3NlcnMgKG9waW5pb25hdGVkKS5cXG4gKi9cXG5cXG5maWVsZHNldCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjYzBjMGMwO1xcbiAgbWFyZ2luOiAwIDJweDtcXG4gIHBhZGRpbmc6IDAuMzVlbSAwLjYyNWVtIDAuNzVlbTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgdGV4dCB3cmFwcGluZyBpbiBFZGdlIGFuZCBJRS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBjb2xvciBpbmhlcml0YW5jZSBmcm9tIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gSUUuXFxuICogMy4gUmVtb3ZlIHRoZSBwYWRkaW5nIHNvIGRldmVsb3BlcnMgYXJlIG5vdCBjYXVnaHQgb3V0IHdoZW4gdGhleSB6ZXJvIG91dFxcbiAqICAgIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbmxlZ2VuZCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgZGlzcGxheTogdGFibGU7IC8qIDEgKi9cXG4gIG1heC13aWR0aDogMTAwJTsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDsgLyogMSAqL1xcbn1cXG5cXG4vKipcXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSA5LS5cXG4gKiAyLiBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhLlxcbiAqL1xcblxcbnByb2dyZXNzIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jazsgLyogMSAqL1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgZGVmYXVsdCB2ZXJ0aWNhbCBzY3JvbGxiYXIgaW4gSUUuXFxuICovXFxuXFxudGV4dGFyZWEge1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIElFIDEwLS5cXG4gKiAyLiBSZW1vdmUgdGhlIHBhZGRpbmcgaW4gSUUgMTAtLlxcbiAqL1xcblxcblt0eXBlPVxcXCJjaGVja2JveFxcXCJdLFxcblt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gQ2hyb21lLlxcbiAqL1xcblxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG5bdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBhbmQgY2FuY2VsIGJ1dHRvbnMgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuICovXFxuXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1jYW5jZWwtYnV0dG9uLFxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuICogMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxcbiAqL1xcblxcbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXG4gIGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiY29udHJvbGxlci12aWV3IC5jYXRlZ29yeS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIG1hcmdpbi1ib3R0b206IDJweDtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgY29udHJvbGxlci12aWV3IC5jYXRlZ29yeS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIG1hcmdpbi1ib3R0b206IDJweDtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9jb250cm9sbGVyLXZpZXcuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZUFBZTtFQUNmLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2YsWUFBWTtBQUNkOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2YsWUFBWTtBQUNkXCIsXCJzb3VyY2VzQ29udGVudFwiOltcImNvbnRyb2xsZXItdmlldyAuY2F0ZWdvcnktbmFtZSB7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBtYXJnaW4tYm90dG9tOiAycHg7XFxuICBtYXJnaW4tdG9wOiAycHg7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbi5kYXJrIGNvbnRyb2xsZXItdmlldyAuY2F0ZWdvcnktbmFtZSB7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBtYXJnaW4tYm90dG9tOiAycHg7XFxuICBtYXJnaW4tdG9wOiAycHg7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcImRlYnVnLWdyb3VwIC5oZWFkZXIge1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDRweDtcXG4gIGJhY2tncm91bmQ6ICNmNGY0ZjQ7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbn1cXG5cXG4uZGFyayBkZWJ1Zy1ncm91cCAuaGVhZGVyIHtcXG4gIGNvbG9yOiAjOTg5ODk4O1xcbiAgYmFja2dyb3VuZDogIzJhMmEyYTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjNWM1YzVjO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICMzZDNkM2Q7XFxufVxcblxcbmRlYnVnLWdyb3VwIC5jb250ZW50IHtcXG4gIG1hcmdpbjogNHB4O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2RlYnVnLWdyb3VwLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLG1CQUFtQjtFQUNuQixlQUFlO0VBQ2YsU0FBUztFQUNULFlBQVk7RUFDWixtQkFBbUI7RUFDbkIsNENBQTRDO0VBQzVDLHlDQUF5QztBQUMzQzs7QUFFQTtFQUNFLGNBQWM7RUFDZCxtQkFBbUI7RUFDbkIsZ0NBQWdDO0VBQ2hDLDZCQUE2QjtBQUMvQjs7QUFFQTtFQUNFLFdBQVc7QUFDYlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJkZWJ1Zy1ncm91cCAuaGVhZGVyIHtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiA0cHg7XFxuICBiYWNrZ3JvdW5kOiAjZjRmNGY0O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG59XFxuXFxuLmRhcmsgZGVidWctZ3JvdXAgLmhlYWRlciB7XFxuICBjb2xvcjogIzk4OTg5ODtcXG4gIGJhY2tncm91bmQ6ICMyYTJhMmE7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzVjNWM1YztcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjM2QzZDNkO1xcbn1cXG5cXG5kZWJ1Zy1ncm91cCAuY29udGVudCB7XFxuICBtYXJnaW46IDRweDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwicHJvcGVydHktdmlldyB7XFxuICBwYWRkaW5nLXRvcDogMnB4O1xcbiAgcGFkZGluZy1ib3R0b206IDJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5hcnJvdyB7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBjb2xvcjogZGltZ3JheTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxucHJvcGVydHktdmlldyAuYXJyb3cgLnJpZ2h0IHtcXG4gIG1hcmdpbi1yaWdodDogMXB4O1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS1saW5lIHtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LW5hbWUge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY29sb3I6IHB1cnBsZTtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tbGVmdDogMXB4O1xcbn1cXG5cXG4uZGFyayBwcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS1uYW1lIHtcXG4gIGNvbG9yOiAjMzRjN2JiO1xcbn1cXG5wcm9wZXJ0eS12aWV3IC52YWx1ZS1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS1lZGl0b3Ige1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMDtcXG4gIGhlaWdodDogMTJweDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCBkYXJrZ3JheTtcXG4gIGJveC1zaGFkb3c6IDAgMCA1cHggcmdiYSgwLCAwLCAwLCAwLjUpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMnB4O1xcbiAgcGFkZGluZzogMCAwIDAgMnB4O1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZSxcXG5wcm9wZXJ0eS12aWV3IC50b2tlbi1jb2xvbiB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjb2xvcjogZGltZ3JheTtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm51bGwsXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUudW5kZWZpbmVkIHtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5ib29sZWFuIHtcXG4gIGNvbG9yOiBkZWVwcGluaztcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUuc3RyaW5nIHtcXG4gIGNvbG9yOiByZWQ7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4uZGFyayBwcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5zdHJpbmcge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm51bWJlciB7XFxuICBjb2xvcjogYmx1ZTtcXG59XFxuXFxuLmRhcmsgcHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUubnVtYmVyIHtcXG4gIGNvbG9yOiAjNTlhNmNhO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5hcnJheSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLmFycmF5IHtcXG4gIGNvbG9yOiAjY2JjYmNiO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5vYmplY3QsXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUubm9kZSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm9iamVjdCxcXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5ub2RlIHtcXG4gIGNvbG9yOiAjY2JjYmNiO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IHVsLnByb3BlcnRpZXMge1xcbiAgbWFyZ2luLWxlZnQ6IDE2cHg7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLm5vLXByb3BlcnRpZXMge1xcbiAgbWFyZ2luLXRvcDogNHB4O1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbn1cXG5cXG4uZGFyayBwcm9wZXJ0eS12aWV3IC5uby1wcm9wZXJ0aWVzIHtcXG4gIGNvbG9yOiAjOTg5ODk4O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL3Byb3BlcnR5LXZpZXcuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZ0JBQWdCO0VBQ2hCLG1CQUFtQjtFQUNuQixjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGNBQWM7RUFDZCxlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGFBQWE7RUFDYixzQkFBc0I7RUFDdEIsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsY0FBYztBQUNoQjtBQUNBO0VBQ0Usa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0Usc0JBQXNCO0VBQ3RCLGVBQWU7RUFDZixTQUFTO0VBQ1QsWUFBWTtFQUNaLGFBQWE7RUFDYiwwQkFBMEI7RUFDMUIsc0NBQXNDO0VBQ3RDLGtCQUFrQjtFQUNsQixNQUFNO0VBQ04sU0FBUztFQUNULGtCQUFrQjtBQUNwQjs7QUFFQTs7RUFFRSxlQUFlO0VBQ2YsY0FBYztFQUNkLHNCQUFzQjtBQUN4Qjs7QUFFQTs7RUFFRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLFVBQVU7RUFDVixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxXQUFXO0FBQ2I7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsWUFBWTtBQUNkOztBQUVBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTs7RUFFRSxZQUFZO0FBQ2Q7O0FBRUE7O0VBRUUsY0FBYztBQUNoQjs7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLGVBQWU7RUFDZixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsY0FBYztBQUNoQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJwcm9wZXJ0eS12aWV3IHtcXG4gIHBhZGRpbmctdG9wOiAycHg7XFxuICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLmFycm93IHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5hcnJvdyAucmlnaHQge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LWxpbmUge1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktbmFtZSB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjb2xvcjogcHVycGxlO1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi1sZWZ0OiAxcHg7XFxufVxcblxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLnByb3BlcnR5LW5hbWUge1xcbiAgY29sb3I6ICMzNGM3YmI7XFxufVxcbnByb3BlcnR5LXZpZXcgLnZhbHVlLWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LWVkaXRvciB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGRhcmtncmF5O1xcbiAgYm94LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAycHg7XFxuICBwYWRkaW5nOiAwIDAgMCAycHg7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLFxcbnByb3BlcnR5LXZpZXcgLnRva2VuLWNvbG9uIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUubnVsbCxcXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS51bmRlZmluZWQge1xcbiAgY29sb3I6IGRpbWdyYXk7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLmJvb2xlYW4ge1xcbiAgY29sb3I6IGRlZXBwaW5rO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5zdHJpbmcge1xcbiAgY29sb3I6IHJlZDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLnN0cmluZyB7XFxuICBjb2xvcjogI2NiY2JjYjtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUubnVtYmVyIHtcXG4gIGNvbG9yOiBibHVlO1xcbn1cXG5cXG4uZGFyayBwcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5udW1iZXIge1xcbiAgY29sb3I6ICM1OWE2Y2E7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLmFycmF5IHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgcHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUuYXJyYXkge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm9iamVjdCxcXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5ub2RlIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgcHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUub2JqZWN0LFxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm5vZGUge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgdWwucHJvcGVydGllcyB7XFxuICBtYXJnaW4tbGVmdDogMTZweDtcXG59XFxuXFxucHJvcGVydHktdmlldyAubm8tcHJvcGVydGllcyB7XFxuICBtYXJnaW4tdG9wOiA0cHg7XFxuICBmb250LXNpemU6IDEwcHg7XFxufVxcblxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLm5vLXByb3BlcnRpZXMge1xcbiAgY29sb3I6ICM5ODk4OTg7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSkge1xuICB2YXIgX2l0ZW0gPSBfc2xpY2VkVG9BcnJheShpdGVtLCA0KSxcbiAgICAgIGNvbnRlbnQgPSBfaXRlbVsxXSxcbiAgICAgIGNzc01hcHBpbmcgPSBfaXRlbVszXTtcblxuICBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn07IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9hcHAuY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9yZXNldC5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2NvbnRyb2xsZXItdmlldy5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2RlYnVnLWdyb3VwLmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vcHJvcGVydHktdmlldy5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbmltcG9ydCAqIGFzIF9fYXUyVmlld0RlZiBmcm9tICcuL2FwcC5odG1sJztcclxuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCwgdmFsdWVDb252ZXJ0ZXIgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xyXG5pbXBvcnQgeyBEZWJ1Z0hvc3QgfSBmcm9tIFwiLi9iYWNrZW5kL2RlYnVnLWhvc3RcIjtcclxuaW1wb3J0IHsgaW5qZWN0LCBJUGxhdGZvcm0gfSBmcm9tIFwiYXVyZWxpYVwiO1xyXG5sZXQgU3RyaW5naWZ5VmFsdWVDb252ZXJ0ZXIgPSBjbGFzcyBTdHJpbmdpZnlWYWx1ZUNvbnZlcnRlciB7XHJcbiAgICB0b1ZpZXcodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5TdHJpbmdpZnlWYWx1ZUNvbnZlcnRlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgdmFsdWVDb252ZXJ0ZXIoJ3N0cmluZ2lmeScpXHJcbl0sIFN0cmluZ2lmeVZhbHVlQ29udmVydGVyKTtcclxuZXhwb3J0IHsgU3RyaW5naWZ5VmFsdWVDb252ZXJ0ZXIgfTtcclxubGV0IEFwcCA9IGNsYXNzIEFwcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWJ1Z0hvc3QsIHBsYXQpIHtcclxuICAgICAgICB0aGlzLmRlYnVnSG9zdCA9IGRlYnVnSG9zdDtcclxuICAgICAgICB0aGlzLnBsYXQgPSBwbGF0O1xyXG4gICAgICAgIHRoaXMuaXNEYXJrVGhlbWUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLkpTT04gPSBKU09OO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFbGVtZW50QXR0cmlidXRlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmFsbEF1cmVsaWFPYmplY3RzID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgYXR0YWNoaW5nKCkge1xyXG4gICAgICAgIHRoaXMuZGVidWdIb3N0LmF0dGFjaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmlzRGFya1RoZW1lID0gY2hyb21lPy5kZXZ0b29scz8ucGFuZWxzPy50aGVtZU5hbWUgPT09IFwiZGFya1wiO1xyXG4gICAgICAgIFtdLmpvaW4oKTtcclxuICAgIH1cclxuICAgIGdldCBjdXJyZW50Q29udHJvbGxlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICB2YWx1ZUNoYW5nZWQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMucGxhdC5xdWV1ZU1pY3JvdGFzaygoKSA9PiB0aGlzLmRlYnVnSG9zdC51cGRhdGVWYWx1ZXMoZWxlbWVudCkpO1xyXG4gICAgfVxyXG59O1xyXG5BcHAgPSBfX2RlY29yYXRlKFtcclxuICAgIGN1c3RvbUVsZW1lbnQoeyAuLi5fX2F1MlZpZXdEZWYsIGRlcGVuZGVuY2llczogWy4uLl9fYXUyVmlld0RlZi5kZXBlbmRlbmNpZXMsIFN0cmluZ2lmeVZhbHVlQ29udmVydGVyXSB9KSxcclxuICAgIGluamVjdCgpLFxyXG4gICAgX19wYXJhbSgxLCBJUGxhdGZvcm0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEZWJ1Z0hvc3QsIE9iamVjdF0pXHJcbl0sIEFwcCk7XHJcbmV4cG9ydCB7IEFwcCB9O1xyXG4iLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5pbXBvcnQgeyBpbmplY3QgfSBmcm9tIFwiYXVyZWxpYVwiO1xyXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uQ2hhbmdlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWJ1Z0luZm8pIHtcclxuICAgICAgICB0aGlzLmRlYnVnSW5mbyA9IGRlYnVnSW5mbztcclxuICAgIH1cclxufVxyXG5sZXQgRGVidWdIb3N0ID0gY2xhc3MgRGVidWdIb3N0IHtcclxuICAgIGF0dGFjaChjb25zdW1lcikge1xyXG4gICAgICAgIHRoaXMuY29uc3VtZXIgPSBjb25zdW1lcjtcclxuICAgICAgICBpZiAoY2hyb21lICYmIGNocm9tZS5kZXZ0b29scykge1xyXG4gICAgICAgICAgICBjaHJvbWUuZGV2dG9vbHMubmV0d29yay5vbk5hdmlnYXRlZC5hZGRMaXN0ZW5lcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaHJvbWUuZGV2dG9vbHMuaW5zcGVjdGVkV2luZG93LmV2YWwoYHdpbmRvdy5fX0FVUkVMSUFfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5nZXRBbGxJbmZvKClgLCAoZGVidWdPYmplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVyLmFsbEF1cmVsaWFPYmplY3RzID0gZGVidWdPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNocm9tZS5kZXZ0b29scy5wYW5lbHMuZWxlbWVudHMub25TZWxlY3Rpb25DaGFuZ2VkLmFkZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNocm9tZS5kZXZ0b29scy5pbnNwZWN0ZWRXaW5kb3cuZXZhbChgd2luZG93Ll9fQVVSRUxJQV9ERVZUT09MU19HTE9CQUxfSE9PS19fLmdldEN1c3RvbUVsZW1lbnRJbmZvKCQwLCBmYWxzZSlgLCAoZGVidWdPYmplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVyLnNlbGVjdGVkRWxlbWVudCA9IGRlYnVnT2JqZWN0Py5jdXN0b21FbGVtZW50SW5mbztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVyLnNlbGVjdGVkRWxlbWVudEF0dHJpYnV0ZXMgPSBkZWJ1Z09iamVjdD8uY3VzdG9tQXR0cmlidXRlc0luZm87XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNocm9tZS5kZXZ0b29scy5pbnNwZWN0ZWRXaW5kb3cuZXZhbChgd2luZG93Ll9fQVVSRUxJQV9ERVZUT09MU19HTE9CQUxfSE9PS19fLmdldEFsbEluZm8oKWAsIChkZWJ1Z09iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lci5hbGxBdXJlbGlhT2JqZWN0cyA9IGRlYnVnT2JqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVWYWx1ZXModmFsdWUpIHtcclxuICAgICAgICBjaHJvbWUuZGV2dG9vbHMuaW5zcGVjdGVkV2luZG93LmV2YWwoYHdpbmRvdy5fX0FVUkVMSUFfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy51cGRhdGVWYWx1ZXMoJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9KWAsIChkZWJ1Z09iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB0aGlzLmNvbnN1bWVyLnNlbGVjdGVkRWxlbWVudCA9IGRlYnVnT2JqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRGVidWdWYWx1ZShkZWJ1Z0luZm8pIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBkZWJ1Z0luZm8udmFsdWU7XHJcbiAgICAgICAgaWYgKGRlYnVnSW5mby50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gXCInXCIgKyB2YWx1ZSArIFwiJ1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29kZSA9IGBhdXJlbGlhRGVidWdnZXIudXBkYXRlVmFsdWVGb3JJZCgke2RlYnVnSW5mby5kZWJ1Z0lkfSwgJHt2YWx1ZX0pYDtcclxuICAgICAgICBjaHJvbWUuZGV2dG9vbHMuaW5zcGVjdGVkV2luZG93LmV2YWwoY29kZSk7XHJcbiAgICB9XHJcbiAgICB0b2dnbGVEZWJ1Z1ZhbHVlRXhwYW5zaW9uKGRlYnVnSW5mbykge1xyXG4gICAgICAgIGlmIChkZWJ1Z0luZm8uY2FuRXhwYW5kKSB7XHJcbiAgICAgICAgICAgIGRlYnVnSW5mby5pc0V4cGFuZGVkID0gIWRlYnVnSW5mby5pc0V4cGFuZGVkO1xyXG4gICAgICAgICAgICBpZiAoZGVidWdJbmZvLmlzRXhwYW5kZWQgJiYgIWRlYnVnSW5mby5leHBhbmRlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGBhdXJlbGlhRGVidWdnZXIuZ2V0RXhwYW5kZWREZWJ1Z1ZhbHVlRm9ySWQoJHtkZWJ1Z0luZm8uZGVidWdJZH0pO2A7XHJcbiAgICAgICAgICAgICAgICBjaHJvbWUuZGV2dG9vbHMuaW5zcGVjdGVkV2luZG93LmV2YWwoY29kZSwgKGV4cGFuZGVkVmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8uZXhwYW5kZWRWYWx1ZSA9IGV4cGFuZGVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdJbmZvLmlzRXhwYW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbkRlYnVnSG9zdCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgaW5qZWN0KClcclxuXSwgRGVidWdIb3N0KTtcclxuZXhwb3J0IHsgRGVidWdIb3N0IH07XHJcbiIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG5pbXBvcnQgeyBjdXN0b21FbGVtZW50IH0gZnJvbSAnYXVyZWxpYSc7XHJcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL2N1c3RvbS1lbGVtZW50Lmh0bWwnO1xyXG5sZXQgQ3VzdG9tRWxlbWVudCA9IGNsYXNzIEN1c3RvbUVsZW1lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8geW91IGNhbiBpbmplY3QgdGhlIGVsZW1lbnQgb3IgYW55IERJIGluIHRoZSBjb25zdHJ1Y3RvclxyXG4gICAgfVxyXG59O1xyXG5DdXN0b21FbGVtZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICBjdXN0b21FbGVtZW50KHsgbmFtZTogJ2N1c3RvbS1lbGVtZW50JywgdGVtcGxhdGUgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEN1c3RvbUVsZW1lbnQpO1xyXG5leHBvcnQgeyBDdXN0b21FbGVtZW50IH07XHJcbiIsImV4cG9ydCAqIGZyb20gJy4vY3VzdG9tLWVsZW1lbnQvY3VzdG9tLWVsZW1lbnQnO1xyXG4iLCJpbXBvcnQgQXVyZWxpYSwgeyBESSwgSVBsYXRmb3JtLCBQTEFURk9STSwgUmVnaXN0cmF0aW9uIH0gZnJvbSBcImF1cmVsaWFcIjtcclxuaW1wb3J0IHsgU3RhbmRhcmRDb25maWd1cmF0aW9uIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcclxuaW1wb3J0IHsgQXBwIH0gZnJvbSBcIi4vYXBwXCI7XHJcbmltcG9ydCAqIGFzIGN1c3RvbUVsZW1lbnRzIGZyb20gJy4vY3VzdG9tLWVsZW1lbnRzJztcclxuaW1wb3J0ICogYXMgcmVzb3VyY2VzIGZyb20gJy4vcmVzb3VyY2VzL2luZGV4JztcclxuY29uc3QgYXVyZWxpYSA9IG5ldyBBdXJlbGlhKERJLmNyZWF0ZUNvbnRhaW5lcigpXHJcbiAgICAucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKElQbGF0Zm9ybSwgUExBVEZPUk0pLCBTdGFuZGFyZENvbmZpZ3VyYXRpb24sIGN1c3RvbUVsZW1lbnRzLCByZXNvdXJjZXMpKS5hcHAoQXBwKTtcclxuYXVyZWxpYS5zdGFydCgpO1xyXG4iLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxuaW1wb3J0ICogYXMgX19hdTJWaWV3RGVmIGZyb20gJy4vZGVidWctZ3JvdXAuaHRtbCc7XHJcbmltcG9ydCB7IGN1c3RvbUVsZW1lbnQgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xyXG5pbXBvcnQgeyBiaW5kYWJsZSB9IGZyb20gXCJhdXJlbGlhXCI7XHJcbmxldCBEZWJ1Z0dyb3VwID0gY2xhc3MgRGVidWdHcm91cCB7XHJcbn07XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgYmluZGFibGUsXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBEZWJ1Z0dyb3VwLnByb3RvdHlwZSwgXCJoZWFkaW5nXCIsIHZvaWQgMCk7XHJcbkRlYnVnR3JvdXAgPSBfX2RlY29yYXRlKFtcclxuICAgIGN1c3RvbUVsZW1lbnQoX19hdTJWaWV3RGVmKVxyXG5dLCBEZWJ1Z0dyb3VwKTtcclxuZXhwb3J0IHsgRGVidWdHcm91cCB9O1xyXG4iLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG5pbXBvcnQgKiBhcyBfX2F1MlZpZXdEZWYgZnJvbSAnLi9wcm9wZXJ0eS12aWV3Lmh0bWwnO1xyXG5pbXBvcnQgeyBjdXN0b21FbGVtZW50IH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcclxuaW1wb3J0IHsgaW5qZWN0LCBiaW5kYWJsZSwgSVBsYXRmb3JtIH0gZnJvbSAnYXVyZWxpYSc7XHJcbmltcG9ydCB7IERlYnVnSG9zdCB9IGZyb20gJy4uLy4uL2JhY2tlbmQvZGVidWctaG9zdCc7XHJcbmNvbnN0IGVkaXRhYmxlVHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbicsICdiaWdpbnQnXTtcclxubGV0IFByb3BlcnR5VmlldyA9IGNsYXNzIFByb3BlcnR5VmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWJ1Z0hvc3QsIHBsYXRmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1Z0hvc3QgPSBkZWJ1Z0hvc3Q7XHJcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xyXG4gICAgfVxyXG4gICAgYmVnaW5FZGl0aW5nKCkge1xyXG4gICAgICAgIGlmIChlZGl0YWJsZVR5cGVzLnNvbWUoeCA9PiB4ID09PSB0aGlzLnByb3BlcnR5Py50eXBlIHx8IHRoaXMucHJvcGVydHkudmFsdWUgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS5pc0VkaXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXRmb3JtLnF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZWxlY3QoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAga2V5dXAoZSkge1xyXG4gICAgICAgIGlmIChlLmNvZGUgPT09ICdFbnRlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRFZGl0aW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5LnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkudHlwZSA9ICdzdHJpbmcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBsYXRmb3JtLnF1ZXVlTWljcm90YXNrKCgpID0+IHRoaXMuZGVidWdIb3N0LnVwZGF0ZVZhbHVlcyh0aGlzLmNvbnRyb2xsZXIpKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVuZEVkaXRpbmcoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eS5pc0VkaXRpbmcgPSBmYWxzZTtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBiaW5kYWJsZSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFByb3BlcnR5Vmlldy5wcm90b3R5cGUsIFwicHJvcGVydHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBiaW5kYWJsZSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFByb3BlcnR5Vmlldy5wcm90b3R5cGUsIFwiY29udHJvbGxlclwiLCB2b2lkIDApO1xyXG5Qcm9wZXJ0eVZpZXcgPSBfX2RlY29yYXRlKFtcclxuICAgIGN1c3RvbUVsZW1lbnQoX19hdTJWaWV3RGVmKSxcclxuICAgIGluamVjdCgpLFxyXG4gICAgX19wYXJhbSgxLCBJUGxhdGZvcm0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEZWJ1Z0hvc3QsIE9iamVjdF0pXHJcbl0sIFByb3BlcnR5Vmlldyk7XHJcbmV4cG9ydCB7IFByb3BlcnR5VmlldyB9O1xyXG4iLCJleHBvcnQgKiBmcm9tICcuL2VsZW1lbnRzL2RlYnVnLWdyb3VwJztcclxuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9wcm9wZXJ0eS12aWV3JztcclxuZXhwb3J0ICogYXMgdCBmcm9tICcuL2VsZW1lbnRzL2F1cmVsaWEtbG9nby5odG1sJztcclxuZXhwb3J0ICogYXMgdDIgZnJvbSAnLi9lbGVtZW50cy9jb250cm9sbGVyLXZpZXcuaHRtbCc7XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcblx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gbW9kdWxlWydkZWZhdWx0J10gOlxuXHRcdCgpID0+IG1vZHVsZTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xucmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9tYWluLnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==